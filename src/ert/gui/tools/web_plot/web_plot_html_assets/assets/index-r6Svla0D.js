var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "assets/index-r6Svla0D.js"(exports, module) {
    var _a;
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    function noop$6() {
    }
    function assign(tar, src) {
      for (const k in src)
        tar[k] = src[k];
      return (
        /** @type {T & S} */
        tar
      );
    }
    function is_promise(value2) {
      return !!value2 && (typeof value2 === "object" || typeof value2 === "function") && typeof /** @type {any} */
      value2.then === "function";
    }
    function run$2(fn) {
      return fn();
    }
    function blank_object() {
      return /* @__PURE__ */ Object.create(null);
    }
    function run_all(fns) {
      fns.forEach(run$2);
    }
    function is_function(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
    }
    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }
    function subscribe(store2, ...callbacks) {
      if (store2 == null) {
        for (const callback of callbacks) {
          callback(void 0);
        }
        return noop$6;
      }
      const unsub = store2.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store2) {
      let value2;
      subscribe(store2, (_) => value2 = _)();
      return value2;
    }
    function component_subscribe(component, store2, callback) {
      component.$$.on_destroy.push(subscribe(store2, callback));
    }
    function create_slot(definition2, ctx, $$scope, fn) {
      if (definition2) {
        const slot_ctx = get_slot_context(definition2, ctx, $$scope, fn);
        return definition2[0](slot_ctx);
      }
    }
    function get_slot_context(definition2, ctx, $$scope, fn) {
      return definition2[1] && fn ? assign($$scope.ctx.slice(), definition2[1](fn(ctx))) : $$scope.ctx;
    }
    function get_slot_changes(definition2, $$scope, dirty, fn) {
      if (definition2[2] && fn) {
        const lets = definition2[2](fn(dirty));
        if ($$scope.dirty === void 0) {
          return lets;
        }
        if (typeof lets === "object") {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function get_all_dirty_from_scope($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length2 = $$scope.ctx.length / 32;
        for (let i = 0; i < length2; i++) {
          dirty[i] = -1;
        }
        return dirty;
      }
      return -1;
    }
    function exclude_internal_props(props) {
      const result = {};
      for (const k in props)
        if (k[0] !== "$")
          result[k] = props[k];
      return result;
    }
    function compute_rest_props(props, keys2) {
      const rest = {};
      keys2 = new Set(keys2);
      for (const k in props)
        if (!keys2.has(k) && k[0] !== "$")
          rest[k] = props[k];
      return rest;
    }
    function null_to_empty(value2) {
      return value2 == null ? "" : value2;
    }
    function set_store_value(store2, ret, value2) {
      store2.set(value2);
      return ret;
    }
    function action_destroyer(action_result) {
      return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$6;
    }
    const contenteditable_truthy_values = ["", true, 1, "true", "contenteditable"];
    function append$2(target2, node) {
      target2.appendChild(node);
    }
    function insert$2(target2, node, anchor2) {
      target2.insertBefore(node, anchor2 || null);
    }
    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
    function destroy_each(iterations2, detaching) {
      for (let i = 0; i < iterations2.length; i += 1) {
        if (iterations2[i])
          iterations2[i].d(detaching);
      }
    }
    function element$2(name2) {
      return document.createElement(name2);
    }
    function svg_element(name2) {
      return document.createElementNS("http://www.w3.org/2000/svg", name2);
    }
    function text$3(data2) {
      return document.createTextNode(data2);
    }
    function space() {
      return text$3(" ");
    }
    function empty$1() {
      return text$3("");
    }
    function listen(node, event2, handler, options) {
      node.addEventListener(event2, handler, options);
      return () => node.removeEventListener(event2, handler, options);
    }
    function attr$6(node, attribute, value2) {
      if (value2 == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value2)
        node.setAttribute(attribute, value2);
    }
    const always_set_through_set_attribute = ["width", "height"];
    function set_attributes(node, attributes) {
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key2 in attributes) {
        if (attributes[key2] == null) {
          node.removeAttribute(key2);
        } else if (key2 === "style") {
          node.style.cssText = attributes[key2];
        } else if (key2 === "__value") {
          node.value = node[key2] = attributes[key2];
        } else if (descriptors[key2] && descriptors[key2].set && always_set_through_set_attribute.indexOf(key2) === -1) {
          node[key2] = attributes[key2];
        } else {
          attr$6(node, key2, attributes[key2]);
        }
      }
    }
    function set_svg_attributes(node, attributes) {
      for (const key2 in attributes) {
        attr$6(node, key2, attributes[key2]);
      }
    }
    function children$3(element2) {
      return Array.from(element2.childNodes);
    }
    function set_data(text2, data2) {
      data2 = "" + data2;
      if (text2.data === data2)
        return;
      text2.data = /** @type {string} */
      data2;
    }
    function set_data_contenteditable(text2, data2) {
      data2 = "" + data2;
      if (text2.wholeText === data2)
        return;
      text2.data = /** @type {string} */
      data2;
    }
    function set_data_maybe_contenteditable(text2, data2, attr_value) {
      if (~contenteditable_truthy_values.indexOf(attr_value)) {
        set_data_contenteditable(text2, data2);
      } else {
        set_data(text2, data2);
      }
    }
    function toggle_class(element2, name2, toggle2) {
      element2.classList.toggle(name2, !!toggle2);
    }
    function custom_event(type2, detail, { bubbles = false, cancelable = false } = {}) {
      return new CustomEvent(type2, { detail, bubbles, cancelable });
    }
    function construct_svelte_component(component, props) {
      return new component(props);
    }
    let current_component;
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component)
        throw new Error("Function called outside component initialization");
      return current_component;
    }
    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
      get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
      const component = get_current_component();
      return (type2, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type2];
        if (callbacks) {
          const event2 = custom_event(
            /** @type {string} */
            type2,
            detail,
            { cancelable }
          );
          callbacks.slice().forEach((fn) => {
            fn.call(component, event2);
          });
          return !event2.defaultPrevented;
        }
        return true;
      };
    }
    function bubble(component, event2) {
      const callbacks = component.$$.callbacks[event2.type];
      if (callbacks) {
        callbacks.slice().forEach((fn) => fn.call(this, event2));
      }
    }
    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush$1);
      }
    }
    function tick$1() {
      schedule_update();
      return resolved_promise;
    }
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }
    const seen_callbacks = /* @__PURE__ */ new Set();
    let flushidx = 0;
    function flush$1() {
      if (flushidx !== 0) {
        return;
      }
      const saved_component = current_component;
      do {
        try {
          while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update$8(component.$$);
          }
        } catch (e3) {
          dirty_components.length = 0;
          flushidx = 0;
          throw e3;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
          binding_callbacks.pop()();
        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];
          if (!seen_callbacks.has(callback)) {
            seen_callbacks.add(callback);
            callback();
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
      seen_callbacks.clear();
      set_current_component(saved_component);
    }
    function update$8($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }
    function flush_render_callbacks(fns) {
      const filtered = [];
      const targets = [];
      render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
      targets.forEach((c2) => c2());
      render_callbacks = filtered;
    }
    const outroing = /* @__PURE__ */ new Set();
    let outros;
    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros
        // parent group
      };
    }
    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }
      outros = outros.p;
    }
    function transition_in(block2, local) {
      if (block2 && block2.i) {
        outroing.delete(block2);
        block2.i(local);
      }
    }
    function transition_out(block2, local, detach2, callback) {
      if (block2 && block2.o) {
        if (outroing.has(block2))
          return;
        outroing.add(block2);
        outros.c.push(() => {
          outroing.delete(block2);
          if (callback) {
            if (detach2)
              block2.d(1);
            callback();
          }
        });
        block2.o(local);
      } else if (callback) {
        callback();
      }
    }
    function handle_promise(promise, info2) {
      const token = info2.token = {};
      function update2(type2, index2, key2, value2) {
        if (info2.token !== token)
          return;
        info2.resolved = value2;
        let child_ctx = info2.ctx;
        if (key2 !== void 0) {
          child_ctx = child_ctx.slice();
          child_ctx[key2] = value2;
        }
        const block2 = type2 && (info2.current = type2)(child_ctx);
        let needs_flush = false;
        if (info2.block) {
          if (info2.blocks) {
            info2.blocks.forEach((block3, i) => {
              if (i !== index2 && block3) {
                group_outros();
                transition_out(block3, 1, 1, () => {
                  if (info2.blocks[i] === block3) {
                    info2.blocks[i] = null;
                  }
                });
                check_outros();
              }
            });
          } else {
            info2.block.d(1);
          }
          block2.c();
          transition_in(block2, 1);
          block2.m(info2.mount(), info2.anchor);
          needs_flush = true;
        }
        info2.block = block2;
        if (info2.blocks)
          info2.blocks[index2] = block2;
        if (needs_flush) {
          flush$1();
        }
      }
      if (is_promise(promise)) {
        const current_component2 = get_current_component();
        promise.then(
          (value2) => {
            set_current_component(current_component2);
            update2(info2.then, 1, info2.value, value2);
            set_current_component(null);
          },
          (error2) => {
            set_current_component(current_component2);
            update2(info2.catch, 2, info2.error, error2);
            set_current_component(null);
            if (!info2.hasCatch) {
              throw error2;
            }
          }
        );
        if (info2.current !== info2.pending) {
          update2(info2.pending, 0);
          return true;
        }
      } else {
        if (info2.current !== info2.then) {
          update2(info2.then, 1, info2.value, promise);
          return true;
        }
        info2.resolved = /** @type {T} */
        promise;
      }
    }
    function update_await_block_branch(info2, ctx, dirty) {
      const child_ctx = ctx.slice();
      const { resolved } = info2;
      if (info2.current === info2.then) {
        child_ctx[info2.value] = resolved;
      }
      if (info2.current === info2.catch) {
        child_ctx[info2.error] = resolved;
      }
      info2.block.p(child_ctx, dirty);
    }
    function ensure_array_like(array_like_or_iterator) {
      return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
    }
    function outro_and_destroy_block(block2, lookup2) {
      transition_out(block2, 1, 1, () => {
        lookup2.delete(block2.key);
      });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list2, lookup2, node, destroy, create_each_block2, next2, get_context) {
      let o = old_blocks.length;
      let n = list2.length;
      let i = o;
      const old_indexes = {};
      while (i--)
        old_indexes[old_blocks[i].key] = i;
      const new_blocks = [];
      const new_lookup = /* @__PURE__ */ new Map();
      const deltas = /* @__PURE__ */ new Map();
      const updates = [];
      i = n;
      while (i--) {
        const child_ctx = get_context(ctx, list2, i);
        const key2 = get_key(child_ctx);
        let block2 = lookup2.get(key2);
        if (!block2) {
          block2 = create_each_block2(key2, child_ctx);
          block2.c();
        } else if (dynamic) {
          updates.push(() => block2.p(child_ctx, dirty));
        }
        new_lookup.set(key2, new_blocks[i] = block2);
        if (key2 in old_indexes)
          deltas.set(key2, Math.abs(i - old_indexes[key2]));
      }
      const will_move = /* @__PURE__ */ new Set();
      const did_move = /* @__PURE__ */ new Set();
      function insert2(block2) {
        transition_in(block2, 1);
        block2.m(node, next2);
        lookup2.set(block2.key, block2);
        next2 = block2.first;
        n--;
      }
      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          next2 = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          destroy(old_block, lookup2);
          o--;
        } else if (!lookup2.has(new_key) || will_move.has(new_key)) {
          insert2(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert2(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }
      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
          destroy(old_block, lookup2);
      }
      while (n)
        insert2(new_blocks[n - 1]);
      run_all(updates);
      return new_blocks;
    }
    function get_spread_update(levels2, updates) {
      const update2 = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i = levels2.length;
      while (i--) {
        const o = levels2[i];
        const n = updates[i];
        if (n) {
          for (const key2 in o) {
            if (!(key2 in n))
              to_null_out[key2] = 1;
          }
          for (const key2 in n) {
            if (!accounted_for[key2]) {
              update2[key2] = n[key2];
              accounted_for[key2] = 1;
            }
          }
          levels2[i] = n;
        } else {
          for (const key2 in o) {
            accounted_for[key2] = 1;
          }
        }
      }
      for (const key2 in to_null_out) {
        if (!(key2 in update2))
          update2[key2] = void 0;
      }
      return update2;
    }
    function bind$2(component, name2, callback) {
      const index2 = component.$$.props[name2];
      if (index2 !== void 0) {
        component.$$.bound[index2] = callback;
        callback(component.$$.ctx[index2]);
      }
    }
    function create_component(block2) {
      block2 && block2.c();
    }
    function mount_component(component, target2, anchor2) {
      const { fragment, after_update } = component.$$;
      fragment && fragment.m(target2, anchor2);
      add_render_callback(() => {
        const new_on_destroy = component.$$.on_mount.map(run$2).filter(is_function);
        if (component.$$.on_destroy) {
          component.$$.on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }
    function init$2(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop$6,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
        const value2 = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
          if (!$$.skip_bound && $$.bound[i])
            $$.bound[i](value2);
          if (ready)
            make_dirty(component, i);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          const nodes = children$3(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush$1();
      }
      set_current_component(parent_component);
    }
    class SvelteComponent {
      constructor() {
        /**
         * ### PRIVATE API
         *
         * Do not use, may change at any time
         *
         * @type {any}
         */
        __publicField(this, "$$");
        /**
         * ### PRIVATE API
         *
         * Do not use, may change at any time
         *
         * @type {any}
         */
        __publicField(this, "$$set");
      }
      /** @returns {void} */
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$6;
      }
      /**
       * @template {Extract<keyof Events, string>} K
       * @param {K} type
       * @param {((e: Events[K]) => void) | null | undefined} callback
       * @returns {() => void}
       */
      $on(type2, callback) {
        if (!is_function(callback)) {
          return noop$6;
        }
        const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
        callbacks.push(callback);
        return () => {
          const index2 = callbacks.indexOf(callback);
          if (index2 !== -1)
            callbacks.splice(index2, 1);
        };
      }
      /**
       * @param {Partial<Props>} props
       * @returns {void}
       */
      $set(props) {
        if (this.$$set && !is_empty(props)) {
          this.$$.skip_bound = true;
          this.$$set(props);
          this.$$.skip_bound = false;
        }
      }
    }
    const PUBLIC_VERSION = "4";
    if (typeof window !== "undefined")
      (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
    const subscriber_queue = [];
    function readable(value2, start2) {
      return {
        subscribe: writable(value2, start2).subscribe
      };
    }
    function writable(value2, start2 = noop$6) {
      let stop2;
      const subscribers = /* @__PURE__ */ new Set();
      function set2(new_value) {
        if (safe_not_equal(value2, new_value)) {
          value2 = new_value;
          if (stop2) {
            const run_queue = !subscriber_queue.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value2);
            }
            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }
              subscriber_queue.length = 0;
            }
          }
        }
      }
      function update2(fn) {
        set2(fn(value2));
      }
      function subscribe2(run2, invalidate = noop$6) {
        const subscriber = [run2, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop2 = start2(set2, update2) || noop$6;
        }
        run2(value2);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0 && stop2) {
            stop2();
            stop2 = null;
          }
        };
      }
      return { set: set2, update: update2, subscribe: subscribe2 };
    }
    function derived(stores, fn, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      if (!stores_array.every(Boolean)) {
        throw new Error("derived() expects stores as input, got a falsy value");
      }
      const auto = fn.length < 2;
      return readable(initial_value, (set2, update2) => {
        let started = false;
        const values2 = [];
        let pending = 0;
        let cleanup = noop$6;
        const sync2 = () => {
          if (pending) {
            return;
          }
          cleanup();
          const result = fn(single ? values2[0] : values2, set2, update2);
          if (auto) {
            set2(result);
          } else {
            cleanup = is_function(result) ? result : noop$6;
          }
        };
        const unsubscribers = stores_array.map(
          (store2, i) => subscribe(
            store2,
            (value2) => {
              values2[i] = value2;
              pending &= ~(1 << i);
              if (started) {
                sync2();
              }
            },
            () => {
              pending |= 1 << i;
            }
          )
        );
        started = true;
        sync2();
        return function stop2() {
          run_all(unsubscribers);
          cleanup();
          started = false;
        };
      });
    }
    function readonly(store2) {
      return {
        subscribe: store2.subscribe.bind(store2)
      };
    }
    class ExperimentMetadata {
      constructor(name2, id2, ensembles, responses, parameters) {
        __publicField(this, "name");
        __publicField(this, "id");
        __publicField(this, "ensembles");
        __publicField(this, "responses");
        __publicField(this, "parameters");
        this.name = name2;
        this.id = id2;
        this.ensembles = ensembles;
        this.responses = responses;
        this.parameters = parameters;
      }
      get numEnsembles() {
        return Object.keys(this.ensembles).length;
      }
      static FromObject({
        name: name2,
        id: id2,
        ensembles,
        responses,
        parameters
      }) {
        return new ExperimentMetadata(
          name2,
          id2,
          ensembles,
          responses,
          parameters
        );
      }
      availableKeywords() {
        const summaryKeys = (this.responses.summary || { keys: [] }).keys || [];
        const hasHistoryKeys = new Set(
          summaryKeys.filter((k) => k.endsWith("H")).map((k) => k.slice(0, -1))
        );
        const summaryKeyInfos = summaryKeys.filter((k) => !k.endsWith("H")).map((k) => ({
          key: k,
          kind: "summary",
          hasHistory: hasHistoryKeys.has(k),
          hasObservations: false
          // TODO
        }));
        const paramKeyInfos = Object.values(this.parameters).flatMap(
          (v) => v.transfer_function_definitions.map((n) => ({
            key: n.name,
            kind: "parameter",
            hasHistory: false,
            hasObservations: false
          }))
        );
        const genDataKeyInfos = this.responses.gen_data.map((gd) => ({
          key: gd.name,
          kind: "gendata",
          hasObservations: false,
          hasHistory: false
        }));
        return [
          ...summaryKeyInfos,
          ...paramKeyInfos,
          ...genDataKeyInfos
        ];
      }
      getKeywordInfo(keyword) {
        return this.availableKeywords().find((k) => k.key === keyword);
      }
      ensembleIdToAlias(ensembleId) {
        const { iteration } = this.ensembles[ensembleId];
        return `ensemble:${iteration === 0 ? "first" : iteration === this.numEnsembles - 1 ? "last" : iteration}`;
      }
      ensemblesByAliasOrId() {
        const mapping = {};
        const allEnsembles = Object.values(this.ensembles);
        allEnsembles.forEach((ens, i) => {
          if (i === 0)
            mapping["first"] = ens;
          if (i === allEnsembles.length - 1)
            mapping["last"] = ens;
          mapping[ens.iteration] = ens;
          mapping[ens.id] = ens;
        });
        return mapping;
      }
      ensembleAliasToId(ensembleAlias) {
        return this.ensemblesByAliasOrId()[ensembleAlias].id;
      }
      eachEnsemble(f) {
        Object.keys(this.ensembles).forEach((ensembleId, i) => {
          const ensembleAlias = this.ensembleIdToAlias(ensembleId);
          f(ensembleId, ensembleAlias, i);
        });
      }
      sortedEnsembles() {
        return Object.values(this.ensembles).sort(
          (a2, b2) => a2.iteration - b2.iteration
        );
      }
    }
    const urlParams$1 = new URLSearchParams(window.location.search);
    const serverURL$1 = decodeURIComponent(
      urlParams$1.get("serverURL") || "http://localhost:8001"
    );
    const lag = async (t4) => new Promise((resolve2) => setTimeout(resolve2, t4));
    const minLagMs = 0;
    const createQueryString = (obj) => {
      const urlParams2 = new URLSearchParams();
      Object.entries(obj).forEach(([k, v]) => urlParams2.append(k, v.toString()));
      return urlParams2.toString();
    };
    const _summaryCache = {};
    const fetchSummary = async (query) => {
      await lag(minLagMs);
      const queryString = createQueryString(query);
      if (!(queryString in _summaryCache)) {
        const response = await fetch(
          `${serverURL$1}/api/summary_chart_data?${queryString}`
        );
        const responseJSON = await response.json();
        _summaryCache[queryString] = responseJSON;
      }
      return _summaryCache[queryString];
    };
    const getLoadedSummary = (query) => {
      const queryString = createQueryString(query);
      if (!(queryString in _summaryCache))
        throw new ReferenceError(
          `Expected summary to be loaded for: ${queryString}.Loaded summaries: ${Object.keys(_summaryCache)}`
        );
      return _summaryCache[queryString];
    };
    let _experimentsMetadataCache = void 0;
    const fetchExperiments = async (forceRefresh = false) => {
      await lag(minLagMs);
      if (!_experimentsMetadataCache || forceRefresh) {
        const response = await fetch(`${serverURL$1}/api/experiments`);
        const responseJSON = await response.json();
        const parsedResponseJSON = {};
        Object.entries(responseJSON).forEach(
          ([k, v]) => parsedResponseJSON[k] = ExperimentMetadata.FromObject(v)
        );
        _experimentsMetadataCache = parsedResponseJSON;
      }
      return _experimentsMetadataCache;
    };
    const getLoadedExperiments = () => _experimentsMetadataCache;
    const _parametersCache = {};
    const fetchParameter = async (query) => {
      await lag(minLagMs);
      const queryString = createQueryString(query);
      if (!(queryString in _parametersCache)) {
        const response = await fetch(
          `${serverURL$1}/api/parameter_chart_data?${queryString}`
        );
        const responseJSON = await response.json();
        _parametersCache[queryString] = responseJSON;
      }
      return _parametersCache[queryString];
    };
    const getLoadedParameter = (query) => {
      const queryString = createQueryString(query);
      if (!(queryString in _parametersCache))
        throw new ReferenceError(
          `Expected parameter to be loaded for: ${queryString}.Loaded parameters: ${Object.keys(_parametersCache)}`
        );
      return _parametersCache[createQueryString(query)];
    };
    const _observationsCache = {};
    const fetchObservations = async (query) => {
      await lag(minLagMs);
      const queryString = `experiment=${query.experiment}`;
      if (!(queryString in _observationsCache)) {
        const response = await fetch(
          `${serverURL$1}/api/observations_chart_data?${queryString}`
        );
        const responseJSON = await response.json();
        _observationsCache[queryString] = responseJSON;
      }
      return _observationsCache[queryString];
    };
    const getLoadedObservations = (query) => {
      const queryString = `experiment=${query.experiment}`;
      if (!(queryString in _observationsCache))
        throw new ReferenceError(
          `Expected observation to be loaded for: ${queryString}.Loaded parameters: ${Object.keys(_observationsCache)}`
        );
      return _observationsCache[queryString];
    };
    const _genDataCache = {};
    const fetchGenData = async (query) => {
      await lag(minLagMs);
      const queryString = createQueryString(query);
      if (!(queryString in _observationsCache)) {
        const response = await fetch(`${serverURL$1}/api/gen_data?${queryString}`);
        const responseJSON = await response.json();
        _genDataCache[queryString] = responseJSON;
      }
      return _genDataCache[queryString];
    };
    const getLoadedGenData = (query) => {
      const queryString = createQueryString(query);
      if (!(queryString in _genDataCache))
        throw new ReferenceError(
          `Expected observation to be loaded for: ${queryString}.Loaded parameters: ${Object.keys(_genDataCache)}`
        );
      return _genDataCache[queryString];
    };
    const urlParams = new URLSearchParams(window.location.search);
    const serverURL = decodeURIComponent(urlParams.get("serverURL") || ".");
    const DefaultPlotterState = {
      serverURL,
      style: {
        // Global style
        "ensemble:first": {
          "stroke-width": "2px"
        },
        "ensemble:last": {
          "stroke-width": "2px"
        }
      },
      charts: [
        // {
        //     kind: 'gendata',
        //     chart: 'line matrix',
        //     query: {
        //         ensembles: ['first', 'last'],
        //         keyword: 'POLY_RES',
        //         experiment: 'auto',
        //     },
        // },
        {
          kind: "summary",
          chart: "lines",
          query: {
            ensembles: ["first", "last"],
            keyword: "FOPR",
            experiment: "auto"
          }
        },
        {
          kind: "summary",
          chart: "stackedLines",
          query: {
            ensembles: ["first", "last"],
            keyword: "FOPR",
            experiment: "auto"
          }
        },
        {
          kind: "summary",
          chart: "linePlotly",
          query: {
            ensembles: ["first", "last"],
            keyword: "FOPR",
            experiment: "auto"
          }
        }
        // {
        //     kind: 'parameter',
        //     chart: 'ridgelines',
        //     query: {
        //         ensembles: ['first', 'last'],
        //         keyword: 'OP1_PERSISTENCE',
        //         experiment: 'auto',
        //     },
        //     style: {
        //         // Global style
        //         'ensemble:first': {
        //             stroke: 'none',
        //             'stroke-width': '2px',
        //         },
        //         'ensemble:last': {
        //             stroke: 'none',
        //             'stroke-width': '2px',
        //         },
        //     },
        // },
        // {
        //     kind: 'parameter',
        //     chart: 'area',
        //     query: {
        //         ensembles: ['first', 'last'],
        //         keyword: 'OP1_PERSISTENCE',
        //         experiment: 'auto',
        //     },
        //     style: {
        //         // Global style
        //         'ensemble:first': {
        //             stroke: 'none',
        //             'stroke-width': '2px',
        //         },
        //         'ensemble:last': {
        //             stroke: 'none',
        //             'stroke-width': '2px',
        //         },
        //     },
        // },
      ]
    };
    const serializedState = decodeURIComponent(
      urlParams.get("serializedState") || ""
    );
    let useState;
    if (serializedState !== "") {
      useState = JSON.parse(serializedState);
    } else {
      useState = DefaultPlotterState;
    }
    const ensureStoreIsSyncedWithExperiments = async () => {
      const experimentsMetadata = await fetchExperiments();
      const allExperiments = Object.keys(experimentsMetadata);
      useState.charts.forEach((spec) => {
        if (spec.query.experiment === "auto")
          spec.query.experiment = allExperiments[0];
        const experiment = experimentsMetadata[spec.query.experiment];
        if (spec.kind === "summary" && !!experiment.responses.summary) {
          const availableKeywords = experiment.responses.summary.keys;
          if (!availableKeywords.includes(spec.query.keyword)) {
            spec.query.keyword = availableKeywords[0];
          }
        } else if (spec.kind === "parameter") {
          const paramMeta = experiment.parameters;
          const availableParameters = [
            ...Object.entries(paramMeta).reduce((namesList, entry2) => {
              const [, param2] = entry2;
              const paramNames = param2.transfer_function_definitions.map(
                (d) => d.name
              );
              return namesList.concat(paramNames);
            }, [])
          ];
          if (!availableParameters.includes(spec.query.keyword)) {
            spec.query.keyword = availableParameters[0];
          }
        }
      });
    };
    const plotterStore = writable(useState);
    const watchResize = (element2) => {
      const resizeObserver = new ResizeObserver((entries2) => {
        element2.dispatchEvent(
          new CustomEvent("resized", { detail: { entries: entries2 } })
        );
      });
      resizeObserver.observe(element2);
      return {
        destroy() {
          resizeObserver.disconnect();
        }
      };
    };
    function create_else_block$5(ctx) {
      let button;
      let span2;
      let span_class_value;
      let button_tabindex_value;
      let current2;
      let mounted;
      let dispose;
      const default_slot_template = (
        /*#slots*/
        ctx[9].default
      );
      const default_slot = create_slot(
        default_slot_template,
        ctx,
        /*$$scope*/
        ctx[8],
        null
      );
      let button_levels = [
        { class: (
          /*containerClasses*/
          ctx[3]
        ) },
        { disabled: (
          /*disabled*/
          ctx[1]
        ) },
        {
          tabindex: button_tabindex_value = /*disabled*/
          ctx[1] ? -1 : 0
        },
        /*$$restProps*/
        ctx[4]
      ];
      let button_data = {};
      for (let i = 0; i < button_levels.length; i += 1) {
        button_data = assign(button_data, button_levels[i]);
      }
      return {
        c() {
          button = element$2("button");
          span2 = element$2("span");
          if (default_slot)
            default_slot.c();
          attr$6(span2, "class", span_class_value = null_to_empty(
            /*innerClasses*/
            ctx[2]
          ) + " svelte-8fbdp9");
          set_attributes(button, button_data);
          toggle_class(button, "svelte-8fbdp9", true);
        },
        m(target2, anchor2) {
          insert$2(target2, button, anchor2);
          append$2(button, span2);
          if (default_slot) {
            default_slot.m(span2, null);
          }
          if (button.autofocus)
            button.focus();
          current2 = true;
          if (!mounted) {
            dispose = listen(
              button,
              "click",
              /*click_handler*/
              ctx[10]
            );
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current2 || dirty & /*$$scope*/
            256)) {
              update_slot_base(
                default_slot,
                default_slot_template,
                ctx2,
                /*$$scope*/
                ctx2[8],
                !current2 ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx2[8]
                ) : get_slot_changes(
                  default_slot_template,
                  /*$$scope*/
                  ctx2[8],
                  dirty,
                  null
                ),
                null
              );
            }
          }
          if (!current2 || dirty & /*innerClasses*/
          4 && span_class_value !== (span_class_value = null_to_empty(
            /*innerClasses*/
            ctx2[2]
          ) + " svelte-8fbdp9")) {
            attr$6(span2, "class", span_class_value);
          }
          set_attributes(button, button_data = get_spread_update(button_levels, [
            (!current2 || dirty & /*containerClasses*/
            8) && { class: (
              /*containerClasses*/
              ctx2[3]
            ) },
            (!current2 || dirty & /*disabled*/
            2) && { disabled: (
              /*disabled*/
              ctx2[1]
            ) },
            (!current2 || dirty & /*disabled*/
            2 && button_tabindex_value !== (button_tabindex_value = /*disabled*/
            ctx2[1] ? -1 : 0)) && { tabindex: button_tabindex_value },
            dirty & /*$$restProps*/
            16 && /*$$restProps*/
            ctx2[4]
          ]));
          toggle_class(button, "svelte-8fbdp9", true);
        },
        i(local) {
          if (current2)
            return;
          transition_in(default_slot, local);
          current2 = true;
        },
        o(local) {
          transition_out(default_slot, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          if (default_slot)
            default_slot.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function create_if_block$b(ctx) {
      let a2;
      let span2;
      let span_class_value;
      let a_class_value;
      let a_tabindex_value;
      let current2;
      const default_slot_template = (
        /*#slots*/
        ctx[9].default
      );
      const default_slot = create_slot(
        default_slot_template,
        ctx,
        /*$$scope*/
        ctx[8],
        null
      );
      let a_levels = [
        { href: (
          /*href*/
          ctx[0]
        ) },
        {
          class: a_class_value = "inline-block " + /*containerClasses*/
          ctx[3]
        },
        { "aria-disabled": (
          /*disabled*/
          ctx[1]
        ) },
        {
          tabindex: a_tabindex_value = /*disabled*/
          ctx[1] ? -1 : 0
        },
        /*$$restProps*/
        ctx[4]
      ];
      let a_data = {};
      for (let i = 0; i < a_levels.length; i += 1) {
        a_data = assign(a_data, a_levels[i]);
      }
      return {
        c() {
          a2 = element$2("a");
          span2 = element$2("span");
          if (default_slot)
            default_slot.c();
          attr$6(span2, "class", span_class_value = null_to_empty(
            /*innerClasses*/
            ctx[2]
          ) + " svelte-8fbdp9");
          set_attributes(a2, a_data);
          toggle_class(a2, "svelte-8fbdp9", true);
        },
        m(target2, anchor2) {
          insert$2(target2, a2, anchor2);
          append$2(a2, span2);
          if (default_slot) {
            default_slot.m(span2, null);
          }
          current2 = true;
        },
        p(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current2 || dirty & /*$$scope*/
            256)) {
              update_slot_base(
                default_slot,
                default_slot_template,
                ctx2,
                /*$$scope*/
                ctx2[8],
                !current2 ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx2[8]
                ) : get_slot_changes(
                  default_slot_template,
                  /*$$scope*/
                  ctx2[8],
                  dirty,
                  null
                ),
                null
              );
            }
          }
          if (!current2 || dirty & /*innerClasses*/
          4 && span_class_value !== (span_class_value = null_to_empty(
            /*innerClasses*/
            ctx2[2]
          ) + " svelte-8fbdp9")) {
            attr$6(span2, "class", span_class_value);
          }
          set_attributes(a2, a_data = get_spread_update(a_levels, [
            (!current2 || dirty & /*href*/
            1) && { href: (
              /*href*/
              ctx2[0]
            ) },
            (!current2 || dirty & /*containerClasses*/
            8 && a_class_value !== (a_class_value = "inline-block " + /*containerClasses*/
            ctx2[3])) && { class: a_class_value },
            (!current2 || dirty & /*disabled*/
            2) && { "aria-disabled": (
              /*disabled*/
              ctx2[1]
            ) },
            (!current2 || dirty & /*disabled*/
            2 && a_tabindex_value !== (a_tabindex_value = /*disabled*/
            ctx2[1] ? -1 : 0)) && { tabindex: a_tabindex_value },
            dirty & /*$$restProps*/
            16 && /*$$restProps*/
            ctx2[4]
          ]));
          toggle_class(a2, "svelte-8fbdp9", true);
        },
        i(local) {
          if (current2)
            return;
          transition_in(default_slot, local);
          current2 = true;
        },
        o(local) {
          transition_out(default_slot, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(a2);
          }
          if (default_slot)
            default_slot.d(detaching);
        }
      };
    }
    function create_fragment$m(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current2;
      const if_block_creators = [create_if_block$b, create_else_block$5];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (
          /*href*/
          ctx2[0] && !/*disabled*/
          ctx2[1]
        )
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      return {
        c() {
          if_block.c();
          if_block_anchor = empty$1();
        },
        m(target2, anchor2) {
          if_blocks[current_block_type_index].m(target2, anchor2);
          insert$2(target2, if_block_anchor, anchor2);
          current2 = true;
        },
        p(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block);
          current2 = true;
        },
        o(local) {
          transition_out(if_block);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(if_block_anchor);
          }
          if_blocks[current_block_type_index].d(detaching);
        }
      };
    }
    function instance$l($$self, $$props, $$invalidate) {
      let containerClasses;
      let innerClasses;
      const omit_props_names = ["href", "justify", "color", "variant", "disabled"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let { $$slots: slots = {}, $$scope } = $$props;
      let { href: href2 = "" } = $$props;
      let { justify = "center" } = $$props;
      let { color: color2 = "primary" } = $$props;
      let { variant = "solid" } = $$props;
      let { disabled = false } = $$props;
      function click_handler(event2) {
        bubble.call(this, $$self, event2);
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("href" in $$new_props)
          $$invalidate(0, href2 = $$new_props.href);
        if ("justify" in $$new_props)
          $$invalidate(5, justify = $$new_props.justify);
        if ("color" in $$new_props)
          $$invalidate(6, color2 = $$new_props.color);
        if ("variant" in $$new_props)
          $$invalidate(7, variant = $$new_props.variant);
        if ("disabled" in $$new_props)
          $$invalidate(1, disabled = $$new_props.disabled);
        if ("$$scope" in $$new_props)
          $$invalidate(8, $$scope = $$new_props.$$scope);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*variant, color*/
        192) {
          $$invalidate(3, containerClasses = `inline-block button button--${variant} button--${color2}`);
        }
        if ($$self.$$.dirty & /*justify*/
        32) {
          $$invalidate(2, innerClasses = `flex gap-2 items-center justify-${justify} min-h-10`);
        }
      };
      return [
        href2,
        disabled,
        innerClasses,
        containerClasses,
        $$restProps,
        justify,
        color2,
        variant,
        $$scope,
        slots,
        click_handler
      ];
    }
    class Button extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$l, create_fragment$m, safe_not_equal, {
          href: 0,
          justify: 5,
          color: 6,
          variant: 7,
          disabled: 1
        });
      }
    }
    const portal = (element2, target2) => {
      const update2 = async () => {
        if (!document.querySelector(target2)) {
          await tick$1();
        }
        document.querySelector(target2).appendChild(element2);
      };
      const destroy = async () => {
        if (element2.parentNode) {
          element2.parentNode.removeChild(element2);
        }
      };
      update2();
      return { update: update2, destroy };
    };
    var open_side_sheet = {
      name: "open_side_sheet",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 4H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1Zm-1 14H10V6h10v12Zm-4.84-7H11v2h4.16l-1.59 1.59L14.99 16 19 12.01 14.99 8l-1.41 1.41L15.16 11Z"
    };
    var reduce$1 = {
      name: "reduce",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 4h2v2H3V4ZM7 6V4h2v2H7ZM3 8v2h2V8H3ZM3 13v9h9v-9H3Zm2 7v-5h5v5H5ZM17 22h-2v-2h2v2ZM19 20v2h2v-2h-2ZM21 16v2h-2v-2h2ZM21 10h-4.512l4.25-4.25-1.414-1.415L15 8.66V4h-2v8h8v-2Z"
    };
    var filter_alt_active = {
      name: "filter_alt_active",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.962 13s-3.73-4.8-5.75-7.39A.998.998 0 0 1 5.002 4h13.91c.83 0 1.3.95.79 1.61-2.02 2.59-5.74 7.39-5.74 7.39v6c0 .55-.45 1-1 1h-2c-.55 0-1-.45-1-1v-6Z"
    };
    var layers_off = {
      name: "layers_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3.34 1.895-1.41 1.41 4.22 4.22-3.22 2.51 9 7 2.1-1.63 1.42 1.42-3.53 2.75-7.37-5.73-1.62 1.26 9 7 4.95-3.85 3.78 3.78 1.41-1.41L3.34 1.895Zm14.33 8.14-5.74-4.47-1.17.91-1.42-1.42 2.59-2.02 9 7-3.72 2.89-1.43-1.42 1.89-1.47Zm1.63 3.8 1.63 1.27-.87.68-1.43-1.43.67-.52Zm-13.11-3.8 5.74 4.47.67-.53-5.02-5.02-1.39 1.08Z"
    };
    var layers = {
      name: "layers",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 16.465 7.36-5.73L21 9.465l-9-7-9 7 1.63 1.27 7.37 5.73Zm-.01 2.54-7.37-5.73L3 14.535l9 7 9-7-1.63-1.27-7.38 5.74Zm5.75-9.54L12 4.995l-5.74 4.47 5.74 4.47 5.74-4.47Z"
    };
    var more_horizontal = {
      name: "more_horizontal",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm-8 2c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var more_vertical = {
      name: "more_vertical",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2Zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm-2 8c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var fullscreen_exit = {
      name: "fullscreen_exit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 8h3V5h2v5H5V8Zm3 8H5v-2h5v5H8v-3Zm6 3h2v-3h3v-2h-5v5Zm2-14v3h3v2h-5V5h2Z"
    };
    var vertical_split = {
      name: "vertical_split",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 5H3v2h8V5ZM3 9h8v2H3V9Zm8 4H3v2h8v-2Zm0 4H3v2h8v-2Zm8-10v10h-4V7h4Zm-6-2h8v14h-8V5Z"
    };
    var view_agenda = {
      name: "view_agenda",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.5 3h-17c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1Zm-1 6V5h-15v4h15Zm0 10v-4h-15v4h15Zm-16-6h17c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1h-17c-.55 0-1-.45-1-1v-6c0-.55.45-1 1-1Z"
    };
    var view_array = {
      name: "view_array",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 5.5h3v13h-3v-13Zm13 0h-9v13h9v-13Zm1 0h3v13h-3v-13Zm-3 11v-9h-5v9h5Z"
    };
    var view_carousel = {
      name: "view_carousel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 19.5H7v-15h10v15ZM6 6.5H2v11h4v-11Zm3 0h6v11H9v-11Zm13 0h-4v11h4v-11Z"
    };
    var view_column = {
      name: "view_column",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 18.5v-13h17v13h-17Zm10-2v-9h-3v9h3Zm-8-9h3v9h-3v-9Zm10 9h3v-9h-3v9Z"
    };
    var view_day = {
      name: "view_day",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.5 4h19v2h-19V4Zm18 4h-17c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1Zm-1 6v-4h-15v4h15Zm-17 4h19v2h-19v-2Z"
    };
    var view_list = {
      name: "view_list",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 5v14h17V5h-17Zm4 2v2h-2V7h2Zm-2 4v2h2v-2h-2Zm0 4h2v2h-2v-2Zm4 2h9v-2h-9v2Zm9-4h-9v-2h9v2Zm-9-4h9V7h-9v2Z"
    };
    var view_module = {
      name: "view_module",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 5.5v13h17v-13h-17Zm10 2V11h-3V7.5h3Zm-5 0h-3V11h3V7.5Zm-3 9V13h3v3.5h-3Zm5-3.5v3.5h3V13h-3Zm8 3.5h-3V13h3v3.5Zm-3-9V11h3V7.5h-3Z"
    };
    var view_quilt = {
      name: "view_quilt",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 5.5v13h17v-13h-17Zm2 11v-9h3v9h-3Zm5-3.5v3.5h3V13h-3Zm8 3.5h-3V13h3v3.5Zm-8-9V11h8V7.5h-8Z"
    };
    var view_stream = {
      name: "view_stream",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.5 6v12h17V6h-17Zm15 10h-13v-3h13v3Zm-13-8v3h13V8h-13Z"
    };
    var view_week = {
      name: "view_week",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 4h18c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1H3c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1Zm1 14h4V6H4v12Zm10 0h-4V6h4v12Zm2 0h4V6h-4v12Z"
    };
    var grid_off = {
      name: "grid_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M.564 1.98 1.974.57l21.46 21.45-1.41 1.41-2.01-2.009H4.565c-1.1 0-2-.9-2-1.999V3.978l-2-1.999Zm8 1.449v.89l2 1.998V3.43h4v3.998h-2.89l2 2h.89v.889l2 1.999V9.426h4v3.998h-2.89l2 2h.89v.89l2 1.998V3.43c0-1.1-.9-2-2-2H5.674l2 2h.89Zm8 0h4v3.998h-4V3.429Zm-6 8.546 1.45 1.45h-1.45v-1.45Zm-4.55-4.548-1.45-1.45v1.45h1.45Zm2.55 11.995h-4v-3.998h4v3.998Zm-4-5.998h4V9.976l-.55-.55h-3.45v3.998Zm10 5.998h-4v-3.998h3.45l.55.55v3.448Zm2-1.45v1.45h1.45l-1.45-1.45Z"
    };
    var grid_on = {
      name: "grid_on",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2h16c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 18h4v-4H4v4Zm4-6H4v-4h4v4ZM4 8h4V4H4v4Zm10 12h-4v-4h4v4Zm-4-6h4v-4h-4v4Zm4-6h-4V4h4v4Zm2 12h4v-4h-4v4Zm4-6h-4v-4h4v4Zm-4-6h4V4h-4v4Z"
    };
    var dashboard = {
      name: "dashboard",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h8v10H3V3Zm18 0h-8v6h8V3ZM9 11V5H5v6h4Zm10-4V5h-4v2h4Zm0 6v6h-4v-6h4ZM9 19v-2H5v2h4Zm12-8h-8v10h8V11ZM3 15h8v6H3v-6Z"
    };
    var maximize = {
      name: "maximize",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 11h18v2H3v-2Z"
    };
    var minimize = {
      name: "minimize",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 11h12v2H6v-2Z"
    };
    var reorder = {
      name: "reorder",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 7V5h18v2H3Zm0 4h18V9H3v2Zm18 4H3v-2h18v2Zm0 4H3v-2h18v2Z"
    };
    var toc = {
      name: "toc",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 9H3V7h14v2Zm0 4H3v-2h14v2ZM3 17h14v-2H3v2Zm18 0h-2v-2h2v2ZM19 7v2h2V7h-2Zm2 6h-2v-2h2v2Z"
    };
    var zoom_in = {
      name: "zoom_in",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.756 14.255h-.79l-.28-.27a6.471 6.471 0 0 0 1.57-4.23 6.5 6.5 0 1 0-6.5 6.5c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99 1.49-1.49-4.99-5Zm-6 0c-2.49 0-4.5-2.01-4.5-4.5s2.01-4.5 4.5-4.5 4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5Zm-.5-5v-2h1v2h2v1h-2v2h-1v-2h-2v-1h2Z"
    };
    var zoom_out = {
      name: "zoom_out",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.756 14.255h-.79l-.28-.27a6.471 6.471 0 0 0 1.57-4.23 6.5 6.5 0 1 0-6.5 6.5c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99 1.49-1.49-4.99-5Zm-6 0c-2.49 0-4.5-2.01-4.5-4.5s2.01-4.5 4.5-4.5 4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5Zm2.5-5h-5v1h5v-1Z"
    };
    var all_out = {
      name: "all_out",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 8V4h4L4 8Zm16 0-4-4h4v4Zm0 12v-4l-4 4h4ZM8 20H4v-4l4 4Zm11-8c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7 7-3.13 7-7ZM7 12c0 2.76 2.24 5 5 5s5-2.24 5-5-2.24-5-5-5-5 2.24-5 5Z"
    };
    var pan_tool = {
      name: "pan_tool",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.82 23.995h6.55c2.21 0 4-1.79 4-4V6.145a2.5 2.5 0 0 0-3-2.45v-.28a2.5 2.5 0 0 0-2.5-2.5c-.33 0-.65.06-.94.18a2.48 2.48 0 0 0-2.06-1.09c-1.32 0-2.4 1.03-2.49 2.33a2.5 2.5 0 0 0-3.01 2.45v9.55l-2.41-1.28c-.73-.39-1.64-.28-2.26.27l-2.07 1.83 7.3 7.61c.75.78 1.81 1.23 2.89 1.23Zm-1.45-2.62-5.86-6.1.51-.45 5.35 2.83V4.785c0-.27.22-.5.5-.5s.5.22.5.5v7.21h2v-9.49c0-.28.22-.5.5-.5s.5.22.5.5v9.49h2v-8.58c0-.28.22-.5.5-.5s.5.22.5.5v8.58h2v-5.85c0-.28.22-.5.5-.5s.5.22.5.5v13.85c0 1.1-.9 2-2 2h-6.56c-.54 0-1.06-.23-1.44-.62Z"
    };
    var list = {
      name: "list",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 7h2v2H3V7Zm2 4H3v2h2v-2Zm16 0H7v2h14v-2ZM3 15h2v2H3v-2Zm18 0H7v2h14v-2Zm0-8H7v2h14V7Z"
    };
    var sort_by_alpha = {
      name: "sort_by_alpha",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m10.495 4.66 2.36-2.36 2.36 2.36h-4.72Zm4.69 14.71-2.33 2.33-2.33-2.33h4.66Zm-13.31-1.64 4.5-11.46h1.64l4.49 11.46h-1.84l-.92-2.45h-5.11l-.92 2.45h-1.84Zm3.37-4.09 1.94-5.18 1.94 5.18h-3.88Zm16.88 2.5h-6.12l5.93-8.6V6.28h-8.3v1.6h5.88l-5.92 8.56v1.29h8.53v-1.59Z"
    };
    var tune = {
      name: "tune",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 9h-2V3h2v2h4v2h-4v2ZM3 7V5h10v2H3Zm0 12v-2h6v2H3Zm10 2v-2h8v-2h-8v-2h-2v6h2ZM7 11V9h2v6H7v-2H3v-2h4Zm14 2v-2H11v2h10Z"
    };
    var focus_center = {
      name: "focus_center",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5Zm0 10H3v4c0 1.1.9 2 2 2h4v-2H5v-4ZM15 3h4c1.1 0 2 .9 2 2v4h-2V5h-4V3Zm4 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4ZM9 12c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3Z"
    };
    var compare$a = {
      name: "compare",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h5v2h2V1h-2v2Zm0 15H5l5-6v6Zm4-15h5c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2h-5v-9l5 6V5h-5V3Z"
    };
    var details = {
      name: "details",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 20 3 4h18l-9 16Zm5.63-14H6.38L12 16l5.63-10Z"
    };
    var touch$1 = {
      name: "touch",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.264 12.94-3.24-1.62c1.29-1 2.12-2.56 2.12-4.32 0-3.03-2.47-5.5-5.5-5.5a5.51 5.51 0 0 0-5.5 5.5c0 2.13 1.22 3.98 3 4.89v3.26l-1.84-.39-.1-.02c-.1-.02-.2-.03-.32-.03-.53 0-1.03.21-1.41.59l-1.4 1.42 5.09 5.09c.43.44 1.03.69 1.65.69h6.3c.98 0 1.81-.7 1.97-1.67l.8-4.71c.22-1.3-.43-2.58-1.62-3.18Zm-.35 2.85-.8 4.71h-6.3c-.09 0-.17-.04-.24-.1l-3.68-3.68 4.25.89V7c0-.28.22-.5.5-.5s.5.22.5.5v6h1.76l3.46 1.73c.4.2.62.63.55 1.06ZM11.644 3.5c-1.93 0-3.5 1.57-3.5 3.5 0 .95.38 1.81 1 2.44V7a2.5 2.5 0 0 1 5 0v2.44c.62-.63 1-1.49 1-2.44 0-1.93-1.57-3.5-3.5-3.5Z"
    };
    var change_history = {
      name: "change_history",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 20 12 4l10 16H2Zm16.39-2L12 7.77 5.61 18h12.78Z"
    };
    var track_changes = {
      name: "track_changes",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.07 4.93-1.41 1.41A8.014 8.014 0 0 1 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07Z"
    };
    var work = {
      name: "work",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 6.5h4c1.11 0 2 .89 2 2v11c0 1.11-.89 2-2 2H4c-1.11 0-2-.89-2-2l.01-11c0-1.11.88-2 1.99-2h4v-2c0-1.11.89-2 2-2h4c1.11 0 2 .89 2 2v2Zm-6 0h4v-2h-4v2Z"
    };
    var work_off = {
      name: "work_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.83 1.42 1.42 2.83l2.75 2.75h-.74c-1.11 0-1.99.89-1.99 2l-.01 11c0 1.11.89 2 2 2h15.74l2 2 1.41-1.41L2.83 1.42Zm6.6 2.16h4v2h-3.6l2 2h7.6v7.6l2 2v-9.6c0-1.11-.89-2-2-2h-4v-2c0-1.11-.89-2-2-2h-4c-.99 0-1.8.7-1.96 1.64l1.96 1.96v-1.6Zm-6 4v11h13.74l-11-11H3.43Z"
    };
    var work_outline = {
      name: "work_outline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 8.5c0-1.11-.89-2-2-2h-4v-2c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19.5c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2v-11Zm-8-2v-2h-4v2h4Zm-10 2v11h16v-11H4Z"
    };
    var sort$1 = {
      name: "sort",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6v2h18V6H3Zm0 12h6v-2H3v2Zm12-5H3v-2h12v2Z"
    };
    var filter_list = {
      name: "filter_list",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6v2h18V6H3Zm7 12h4v-2h-4v2Zm8-5H6v-2h12v2Z"
    };
    var filter_alt = {
      name: "filter_alt",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 6h10l-5.01 6.3L7 6Zm-2.75-.39C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39A.998.998 0 0 0 18.95 4H5.04c-.83 0-1.3.95-.79 1.61Z"
    };
    var boundaries = {
      name: "boundaries",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7.05 14.121-1.415 1.415L2.1 12l3.535-3.535L7.05 9.879 4.928 12l2.121 2.121Zm1.414 4.243 1.414-1.414 2.121 2.121 2.121-2.121 1.415 1.414-3.536 3.536-3.535-3.536ZM19.07 12l-2.121 2.121 1.414 1.415L21.9 12l-3.536-3.535-1.414 1.414L19.07 12ZM9.878 7.05 8.464 5.636l3.535-3.535 3.536 3.535L14.12 7.05 12 4.93 9.877 7.05Z"
    };
    var invert$1 = {
      name: "invert",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.553 2.106a1 1 0 0 1 .894 0l8 4A1 1 0 0 1 21 7v10a1 1 0 0 1-.553.894l-8 4a1 1 0 0 1-.894 0l-8-4A1 1 0 0 1 3 17V7a1 1 0 0 1 .553-.894l8-4ZM5 8.618 12 12v7.882l-7-3.5V8.618Zm7 1.264L6.236 7 12 4.118v5.764Z"
    };
    var inspect_rotation = {
      name: "inspect_rotation",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 5a8 8 0 1 0 5.646 2.333l1.412-1.417A9.972 9.972 0 0 1 22 13c0 5.523-4.477 10-10 10S2 18.523 2 13 6.477 3 12 3v2Z"
    };
    var inspect_3d = {
      name: "inspect_3d",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.261 6.035c-.482.012-.758.148-.919.308-.3.3-.505 1.064-.018 2.5.457 1.346 1.436 2.969 2.865 4.553L10.585 12v4.243H6.342l1.431-1.43-.033-.037C6.16 13.034 5 11.165 4.43 9.486c-.542-1.6-.658-3.4.498-4.557.62-.62 1.445-.873 2.284-.893.831-.021 1.736.18 2.646.53.692.267 1.413.629 2.141 1.076.859-.527 1.708-.937 2.514-1.21 1.6-.543 3.4-.66 4.557.497.62.62.873 1.445.894 2.283.02.832-.182 1.737-.531 2.647A13.19 13.19 0 0 1 18.358 12c.447.728.808 1.45 1.075 2.141.35.91.551 1.815.53 2.647-.02.839-.272 1.663-.893 2.283-.666.667-1.564.907-2.467.895-.898-.013-1.88-.272-2.865-.697l.791-1.836c.834.359 1.549.525 2.101.533.548.007.855-.138 1.026-.309.16-.16.296-.437.308-.919.012-.489-.108-1.125-.398-1.879-.13-.338-.291-.691-.481-1.054a20.865 20.865 0 0 1-1.55 1.73c-1.833 1.833-3.855 3.198-5.677 3.898-.91.35-1.815.552-2.647.532-.838-.021-1.662-.273-2.283-.894-.666-.666-.907-1.565-.894-2.467.012-.898.271-1.88.696-2.865l1.837.791c-.36.834-.526 1.549-.534 2.101-.007.548.138.855.31 1.026.16.16.436.296.918.308.49.012 1.125-.108 1.88-.398 1.504-.58 3.297-1.764 4.98-3.446a18.438 18.438 0 0 0 1.827-2.12 18.448 18.448 0 0 0-1.828-2.122A18.436 18.436 0 0 0 12 8.05c-.464.34-.932.72-1.397 1.139L12 10.586H7.757V6.343l1.43 1.43.037-.032c.32-.29.644-.566.97-.827-.363-.19-.716-.35-1.054-.48-.754-.29-1.39-.411-1.879-.399Zm6.543.88c.587.468 1.168.987 1.73 1.55a20.852 20.852 0 0 1 1.55 1.73c.191-.363.352-.716.482-1.054.29-.754.41-1.39.398-1.879-.012-.482-.148-.758-.308-.919-.3-.3-1.063-.505-2.5-.018a9.57 9.57 0 0 0-1.352.59Z"
    };
    var fault = {
      name: "fault",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.752 10.1-2.107 3.65-2.126 3.715 4.729-2.172-1.562-.926 1.054-1.825 1.053-1.825-1.041-.617ZM4.602 13.9l2.107-3.65 2.126-3.715-4.73 2.172 1.563.926-1.054 1.825-1.054 1.825 1.042.617ZM11.618 5H3V3h10.353a1 1 0 0 1 .865 1.501l-7.53 13a1 1 0 0 1-.864.499H3v-2h2.247l6.371-11ZM11.735 19h8.619v2H10a1 1 0 0 1-.866-1.501l7.53-13A1 1 0 0 1 17.53 6h2.823v2h-2.247l-6.37 11Z"
    };
    var grid_layer = {
      name: "grid_layer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.412 13.451 12.001 20l-8.423-6.549L1.715 12 12 4l10.285 8-1.874 1.451Zm-6.14-4.791L12 6.89 9.583 8.774l2.421 1.775 2.268-1.89Zm1.845 1.437L18.561 12l-2.22 1.729-2.438-1.787 2.214-1.845Zm-5.922 1.96-2.486-1.823L5.44 12l2.493 1.941 2.261-1.884Zm-.416 3.322 2.315-1.93 2.372 1.74L12 17.109l-2.222-1.73Z"
    };
    var grid_layers = {
      name: "grid_layers",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 16.465 7.36-5.73L21 9.465l-9-7-9 7 1.63 1.27 7.37 5.73Zm-.01 2.54-7.37-5.73L3 14.535l9 7 9-7-1.63-1.27-7.38 5.74Zm1.997-12.463L12 4.995 9.885 6.642l2.118 1.553 1.984-1.653ZM15.602 7.8l2.138 1.665-1.943 1.513-2.132-1.564L15.602 7.8ZM10.42 9.515 8.245 7.919 6.26 9.465l2.181 1.699 1.98-1.65Zm-.364 2.906 2.026-1.688 2.075 1.522L12 13.935l-1.944-1.514Z"
    };
    var hill_shading = {
      name: "hill_shading",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3 9.78 8.63l1.25 1.67L14 6.33 19 13h-8.46L6.53 7.63 1 15h22L14 3ZM5 13l1.52-2.03L8.04 13H5Zm-2 6.5L2 17h2l1 2.5H3ZM8 21l-2-4h2l2 4H8Zm2-4 1 2.5h2L12 17h-2Zm4 0h2l2.5 5h-2L14 17Zm4 0 2 4h2l-2-4h-2Z"
    };
    var well = {
      name: "well",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.3 3h5.4v.9h1.8v1.8h-.9v1.717L17.784 19.2H19.2V21H4.8v-1.8h1.418L8.4 7.417V5.7h-.9V3.9h1.8V3Zm4.5 2.7v1.8l.005.023-1.804 1.11-1.804-1.11.004-.023V5.7h3.6Zm-3.778 2.772-.286 1.555 1.406-.865-1.12-.69Zm1.979 1.218-2.484 1.529-.298 1.62L12 14.386l2.782-1.545-.298-1.621L12 9.689Zm2.265.337-.286-1.555-1.12.69 1.406.865ZM11.074 14.9l-2.027-1.126-.462 2.509 2.49-1.383Zm.927.515 3.626 2.015.326 1.77H8.049l.325-1.77 3.627-2.015Zm3.415.868L12.927 14.9l2.028-1.126.461 2.509Z"
    };
    var surface_layer = {
      name: "surface_layer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 20 8.412-6.549L22.286 12 12.001 4 1.715 12l1.863 1.451L12 20Zm0-13.109 5.212 4.06c-2.646 1.81-4.676 1.762-6.144 1.15-1.284-.535-2.215-1.532-2.781-2.317L12 6.89ZM18.56 12l-.522-.407c-2.996 2.148-5.467 2.218-7.355 1.431-1.49-.621-2.548-1.749-3.186-2.625L5.441 12l2.412 1.879c.84-.213 1.928-.348 3.028-.112 1.064.23 2.113.802 2.934 1.928L18.562 12Zm-5.534 4.31c-.678-.942-1.52-1.385-2.356-1.565a5.243 5.243 0 0 0-1.77-.051l3.1 2.415 1.026-.8Zm.224-6.292c-.002.054-.036.154-.193.258a1.196 1.196 0 0 1-.681.168 1.197 1.197 0 0 1-.67-.208c-.151-.113-.18-.214-.178-.27.002-.054.036-.154.194-.257.155-.103.395-.177.68-.169.286.008.521.097.67.209.151.112.18.214.178.269Zm-.904 1.426a2.19 2.19 0 0 0 1.26-.332c.345-.227.63-.594.643-1.065.014-.47-.248-.854-.58-1.1a2.191 2.191 0 0 0-1.237-.407 2.19 2.19 0 0 0-1.26.333c-.345.226-.63.593-.643 1.064-.014.47.248.854.58 1.1a2.19 2.19 0 0 0 1.237.407Z"
    };
    var miniplayer = {
      name: "miniplayer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2Zm0 2v12H3V4h18Zm-8 5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-6Z"
    };
    var miniplayer_fullscreen = {
      name: "miniplayer_fullscreen",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 2h18c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2h-7v2h2v2H8v-2h2v-2H3c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 2v12h18V4H3Zm16 9h1v2h-2v-1h1v-1Zm-7 0h1v1h1v1h-2v-2Zm8-4v2h-1v-1h-1V9h2Zm-8 2V9h2v1h-1v1h-1Z"
    };
    var fullscreen = {
      name: "fullscreen",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 10H5V5h5v2H7v3Zm-2 4h2v3h3v2H5v-5Zm12 3h-3v2h5v-5h-2v3ZM14 7V5h5v5h-2V7h-3Z",
      sizes: {
        small: {
          name: "fullscreen_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M5 7H3V3h4v2H5v2Zm-2 4h2v2h2v2H3v-4Zm10 2h-2v2h4v-4h-2v2Zm-2-8V3h4v4h-2V5h-2Z"
        }
      }
    };
    var expand_screen = {
      name: "expand_screen",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 5a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v5a1 1 0 1 1-2 0V7.414l-3.793 3.793a1 1 0 0 1-1.414-1.414L16.586 6H14a1 1 0 0 1-1-1ZM11.207 14.207a1 1 0 0 0-1.414-1.414L6 16.586V14a1 1 0 1 0-2 0v5a1 1 0 0 0 1 1h5a1 1 0 1 0 0-2H7.414l3.793-3.793Z"
    };
    var collapse_screen = {
      name: "collapse_screen",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.207 4.293a1 1 0 0 1 0 1.414L16.414 9.5H19a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1v-5a1 1 0 1 1 2 0v2.586l3.793-3.793a1 1 0 0 1 1.414 0ZM4.5 14a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v5a1 1 0 1 1-2 0v-2.586l-3.793 3.793a1 1 0 0 1-1.414-1.414L8.086 15H5.5a1 1 0 0 1-1-1Z"
    };
    var filter_alt_off = {
      name: "filter_alt_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3.414 2 17.352 17.352-1.414 1.414L14 15.414V19c0 .583-.424 1-1 1h-1.907C10.518 20 10 19.583 10 19v-6S6.768 8.865 4.41 5.825L2 3.415 3.414 2ZM19.74 5.61c-1.219 1.563-3.057 3.932-4.323 5.564l-1.41-1.41L17 6h-6.757l-2-2H18.95c.83 0 1.3.95.79 1.61Z"
    };
    var in_progress = {
      name: "in_progress",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 19.5v-15a7.5 7.5 0 1 0 0 15ZM12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2Z"
    };
    var sheet_bottom_position = {
      name: "sheet_bottom_position",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 4h18c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1H3c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1Zm1 10h16V6H4v8Z"
    };
    var sheet_topposition = {
      name: "sheet_topposition",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 20h18c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1Zm1-10h16v8H4v-8Z"
    };
    var sheet_leftposition = {
      name: "sheet_leftposition",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 20h18c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1Zm7-14h10v12H10V6Z"
    };
    var sheet_rightposition = {
      name: "sheet_rightposition",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 4h18c.55 0 1 .45 1 1v14c0 .55-.45 1-1 1H3c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1Zm1 14h10V6H4v12Z"
    };
    var enlarge = {
      name: "enlarge",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 3H3v18h18v-6h-2v4H5V5h4V3ZM10 12h2v2h-2v-2ZM6.375 14v-2h2.25v2h-2.25ZM10 15.375h2v2.25h-2v-2.25ZM17.512 5H13V3h8v8h-2V6.34l-4.324 4.325L13.26 9.25 17.512 5Z"
    };
    var signature = {
      name: "signature",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m17.37 2.29 2.34 2.34c.39.39.39 1.02 0 1.41l-1.83 1.83-3.75-3.75 1.83-1.83c.19-.19.44-.29.7-.29.26 0 .51.09.71.29ZM2 16.25V20h3.75L16.81 8.94l-3.75-3.75L2 16.25ZM4.92 18H4v-.92l9.06-9.06.92.92L4.92 18ZM10 18h9v2H8l2-2Z"
    };
    var select_all = {
      name: "select_all",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 5H3c0-1.1.9-2 2-2v2Zm0 8H3v-2h2v2Zm2 8h2v-2H7v2ZM5 9H3V7h2v2Zm8-6h-2v2h2V3Zm6 2V3c1.1 0 2 .9 2 2h-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm0-4H3v-2h2v2ZM9 3H7v2h2V3Zm4 18h-2v-2h2v2Zm6-8h2v-2h-2v2Zm2 6c0 1.1-.9 2-2 2v-2h2ZM19 9h2V7h-2v2Zm2 8h-2v-2h2v2Zm-6 4h2v-2h-2v2Zm2-16h-2V3h2v2ZM7 17h10V7H7v10Zm8-8H9v6h6V9Z"
    };
    var unarchive = {
      name: "unarchive",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.15 3.55 1.39 1.68c.29.34.46.79.46 1.27V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V6.5c0-.48.17-.93.46-1.27l1.38-1.68C5.12 3.21 5.53 3 6 3h12c.47 0 .88.21 1.15.55ZM17.76 5H6.24l-.82 1h13.17l-.83-1ZM5 19V8h14v11H5Zm5.55-5H8l4-4 4 4h-2.55v3h-2.9v-3Z"
    };
    var send = {
      name: "send",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m1.5 10 .01-7 20.99 9-20.99 9-.01-7 15-2-15-2Zm2.01-3.97 7.51 3.22-7.52-1 .01-2.22Zm7.5 8.72L3.5 17.97v-2.22l7.51-1Z"
    };
    var move_to_inbox = {
      name: "move_to_inbox",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.99 3H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H4.99C3.88 21 3 20.1 3 19V5c0-1.1.88-2 1.99-2Zm8.46 6H16l-4 4-4-4h2.55V6h2.9v3ZM5 19v-3h3.56c.69 1.19 1.97 2 3.45 2 1.48 0 2.75-.81 3.45-2H19v3H5Zm9.01-5H19V5H4.99L5 14h5.01c0 1.1.9 2 2 2s2-.9 2-2Z"
    };
    var priority_low = {
      name: "priority_low",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.5 17.5C4.92 17.5 2 14.58 2 11s2.92-6.5 6.5-6.5H12v2H8.5C6.02 6.5 4 8.52 4 11s2.02 4.5 4.5 4.5H9V13l4 3.5L9 20v-2.5h-.5ZM22 4.5h-8v2h8v-2Zm0 5.5h-8v2h8v-2Zm-8 5.5h8v2h-8v-2Z"
    };
    var priority_high = {
      name: "priority_high",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.5 6.5C4.92 6.5 2 9.42 2 13s2.92 6.5 6.5 6.5H12v-2H8.5C6.02 17.5 4 15.48 4 13s2.02-4.5 4.5-4.5H9V11l4-3.5L9 4v2.5h-.5Zm13.5 0h-8v2h8v-2Zm0 5.5h-8v2h8v-2Zm-8 5.5h8v2h-8v-2Z"
    };
    var inbox = {
      name: "inbox",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 16H5v-3h3.56c.69 1.19 1.97 2 3.45 2 1.48 0 2.75-.81 3.45-2H19v3Zm-4.99-5H19V5H5v9h5.01c0 1.1.9 2 2 2s2-.9 2-2Z"
    };
    var paste = {
      name: "paste",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1ZM5 5v16h14V5h-2v3H7V5H5Z"
    };
    var file_copy = {
      name: "file_copy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.5 1h-12c-1.1 0-2 .9-2 2v14h2V3h12V1Zm-1 4h-7c-1.1 0-1.99.9-1.99 2L6.5 21c0 1.1.89 2 1.99 2H19.5c1.1 0 2-.9 2-2V11l-6-6Zm-7 2v14h11v-9h-5V7h-6Z"
    };
    var delete_multiple = {
      name: "delete_multiple",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 4h4l1 1h3v2H2V5h3l1-1ZM5 20c-1.1 0-2-.9-2-2V8h10v10c0 1.1-.9 2-2 2H5ZM22 8h-7v2h7V8Zm-3 8h-4v2h4v-2Zm-4-4h6v2h-6v-2ZM5 10h6v8H5v-8Z"
    };
    var cut = {
      name: "cut",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64ZM6 8a2 2 0 1 1-.001-3.999A2 2 0 0 1 6 8ZM4 18a2 2 0 1 0 3.999.001A2 2 0 0 0 4 18Zm8-5.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5ZM13 9l6-6h3v1l-7 7-2-2Z"
    };
    var edit = {
      name: "edit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.368 3.29 2.34 2.34c.39.39.39 1.02 0 1.41l-1.83 1.83-3.75-3.75 1.83-1.83c.19-.19.44-.29.7-.29.26 0 .51.09.71.29ZM2.998 17.25V21h3.75l11.06-11.06-3.75-3.75-11.06 11.06ZM5.918 19h-.92v-.92l9.06-9.06.92.92L5.918 19Z"
    };
    var copy$3 = {
      name: "copy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.5 1h-12c-1.1 0-2 .9-2 2v14h2V3h12V1Zm3 4h-11c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2Zm-11 16h11V7h-11v14Z"
    };
    var block = {
      name: "block",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2ZM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9A7.902 7.902 0 0 1 4 12Zm3.1 6.31A7.902 7.902 0 0 0 12 20c4.42 0 8-3.58 8-8 0-1.85-.63-3.55-1.69-4.9L7.1 18.31Z"
    };
    var clear$1 = {
      name: "clear",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"
    };
    var archive = {
      name: "archive",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.15 3.55 1.39 1.68c.29.34.46.79.46 1.27V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V6.5c0-.48.17-.93.46-1.27l1.38-1.68C5.12 3.21 5.53 3 6 3h12c.47 0 .88.21 1.15.55ZM17.76 5H6.24l-.8.97h13.13L17.76 5ZM5 19V8h14v11H5Zm5.55-9h2.9v3H16l-4 4-4-4h2.55v-3Z"
    };
    var add_circle_outlined = {
      name: "add_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-1 5v4H7v2h4v4h2v-4h4v-2h-4V7h-2Zm-7 5c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Z"
    };
    var add_circle_filled = {
      name: "add_circle_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm11 1h4v-2h-4V7h-2v4H7v2h4v4h2v-4Z"
    };
    var add_box = {
      name: "add_box",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 16H5V5h14v14Zm-6-2h-2v-4H7v-2h4V7h2v4h4v2h-4v4Z"
    };
    var add$5 = {
      name: "add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2Z"
    };
    var save = {
      name: "save",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h12l4 4v12c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Zm14 16V7.83L16.17 5H5v14h14Zm-7-7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3Zm3-6H6v4h9V6Z"
    };
    var report_off = {
      name: "report_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.7 1.29 1.29 2.7l3.64 3.64-1.64 1.64v7.46l5.27 5.27h7.46l1.64-1.64 3.64 3.64 1.41-1.41L2.7 1.29Zm6.69 3.42h5.8l4.1 4.1v5.8l-.22.22 1.42 1.41.8-.8V7.98l-5.27-5.27H8.56l-.8.8 1.41 1.42.22-.22Zm2.9 10a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm1-8v2.33l-2-2v-.33h2Zm-3.9 12h5.8l1.05-1.05-9.9-9.9-1.05 1.05v5.8l4.1 4.1Z"
    };
    var remove_outlined = {
      name: "remove_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2ZM4 12c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm3-1v2h10v-2H7Z"
    };
    var remove$2 = {
      name: "remove",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm5 1h10v-2H7v2Z"
    };
    var report = {
      name: "report",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.27 3h7.46L21 8.27v7.46L15.73 21H8.27L3 15.73V8.27L8.27 3Zm6.63 16 4.1-4.1V9.1L14.9 5H9.1L5 9.1v5.8L9.1 19h5.8ZM12 15a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm1-8h-2v7h2V7Z"
    };
    var reply_all = {
      name: "reply_all",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 4.5v3l-4 4 4 4v3l-7-7 7-7Zm6 0v4c7 1 10 6 11 11-2.5-3.5-6-5.1-11-5.1v4.1l-7-7 7-7Z"
    };
    var reply = {
      name: "reply",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 8.5v-4l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11Z"
    };
    var undo = {
      name: "undo",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.266 8.5c-2.65 0-5.05.99-6.9 2.6l-3.6-3.6v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78c-1.39-4.19-5.32-7.22-9.97-7.22Z"
    };
    var redo = {
      name: "redo",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.63 11.1c-1.85-1.61-4.25-2.6-6.9-2.6-4.65 0-8.58 3.03-9.96 7.22l2.36.78a8.002 8.002 0 0 1 7.6-5.5c1.95 0 3.73.72 5.12 1.88l-3.62 3.62h9v-9l-3.6 3.6Z"
    };
    var refresh = {
      name: "refresh",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.646 6.35A7.958 7.958 0 0 0 11.996 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08a5.99 5.99 0 0 1-5.65 4c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L12.996 11h7V4l-2.35 2.35Z"
    };
    var loop = {
      name: "loop",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 1v3c4.42 0 8 3.58 8 8 0 1.57-.46 3.03-1.24 4.26L17.3 14.8c.45-.83.7-1.79.7-2.8 0-3.31-2.69-6-6-6v3L8 5l4-4ZM6 12c0 3.31 2.69 6 6 6v-3l4 4-4 4v-3c-4.42 0-8-3.58-8-8 0-1.57.46-3.03 1.24-4.26L6.7 9.2c-.45.83-.7 1.79-.7 2.8Z"
    };
    var autorenew = {
      name: "autorenew",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 9V6c-3.31 0-6 2.69-6 6 0 1.01.25 1.97.7 2.8l-1.46 1.46A7.93 7.93 0 0 1 4 12c0-4.42 3.58-8 8-8V1l4 4-4 4Zm5.3.2 1.46-1.46A7.93 7.93 0 0 1 20 12c0 4.42-3.58 8-8 8v3l-4-4 4-4v3c3.31 0 6-2.69 6-6 0-1.01-.26-1.96-.7-2.8Z"
    };
    var search_in_page = {
      name: "search_in_page",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6ZM6 4h7l5 5v8.58l-1.84-1.84a4.992 4.992 0 0 0-.64-6.28A4.96 4.96 0 0 0 12 8a5 5 0 0 0-3.53 1.46 4.98 4.98 0 0 0 0 7.05 4.982 4.982 0 0 0 6.28.63L17.6 20H6V4Zm6 11.98c.8 0 1.55-.32 2.11-.88.57-.56.88-1.31.88-2.11 0-.8-.32-1.55-.88-2.11-.56-.57-1.31-.88-2.11-.88-.8 0-1.55.31-2.11.88-.57.56-.88 1.31-.88 2.11 0 .8.32 1.55.88 2.11.56.57 1.31.88 2.11.88Z"
    };
    var search_find_replace = {
      name: "search_find_replace",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.796 6.715c-.91-.9-2.16-1.46-3.54-1.46a5 5 0 0 0-4.9 4h-2.02c.49-3.39 3.39-6 6.92-6 1.93 0 3.68.78 4.95 2.05l2.05-2.05v6h-6l2.54-2.54Zm3.38 4.54a6.89 6.89 0 0 1-1.28 3.14l4.85 4.86-1.49 1.49-4.86-4.85a6.984 6.984 0 0 1-4.14 1.36c-1.93 0-3.68-.78-4.95-2.05l-2.05 2.05v-6h6l-2.54 2.54c.91.9 2.16 1.46 3.54 1.46a5 5 0 0 0 4.9-4h2.02Z"
    };
    var history = {
      name: "history",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 12a9 9 0 1 1 9 9c-2.49 0-4.73-1.01-6.36-2.64l1.42-1.42A6.944 6.944 0 0 0 13.5 19c3.87 0 7-3.13 7-7s-3.13-7-7-7-7 3.13-7 7h3l-4.04 4.03-.07-.14L1.5 12h3Zm8 1V8H14v4.15l3.52 2.09-.77 1.28L12.5 13Z"
    };
    var update$7 = {
      name: "update",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 3v7h-7l2.95-2.95A7.018 7.018 0 0 0 12 5c-3.86 0-7 3.14-7 7s3.14 7 7 7 7-3.14 7-7h2a9 9 0 1 1-9-9c2.49 0 4.74 1.01 6.36 2.64L21 3ZM11 13V8h1.5v4.15l3.52 2.09-.77 1.28L11 13Z"
    };
    var restore = {
      name: "restore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 12a9 9 0 1 1 9 9c-2.49 0-4.73-1.01-6.36-2.64l1.42-1.42A6.944 6.944 0 0 0 13.5 19c3.87 0 7-3.13 7-7s-3.13-7-7-7-7 3.13-7 7h3l-4 3.99-4-3.99h3Zm8 1V8H14v4.15l3.52 2.09-.77 1.28L12.5 13Z"
    };
    var restore_page = {
      name: "restore_page",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6Zm4 18H6V4h7.17L18 8.83V20ZM7.28 9.4l1.17 1.17c.8-1.24 2.18-2.07 3.77-2.07 2.48 0 4.5 2.02 4.5 4.5s-2.02 4.5-4.5 4.5a4.51 4.51 0 0 1-4.12-2.7h1.55a3.14 3.14 0 0 0 2.58 1.35 3.15 3.15 0 1 0 0-6.3c-1.21 0-2.27.7-2.79 1.71L10.88 13h-3.6V9.4Z"
    };
    var setting_backup_restore = {
      name: "setting_backup_restore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 12a9 9 0 1 1 3.52 7.14l1.42-1.44A6.995 6.995 0 0 0 20.5 12c0-3.87-3.13-7-7-7s-7 3.13-7 7h3l-4 4-4-4h3Zm9-2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2Z"
    };
    var searched_history = {
      name: "searched_history",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.01 14.26h-.8l-.27-.27a6.452 6.452 0 0 0 1.57-4.23 6.5 6.5 0 0 0-6.5-6.5c-3.59 0-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51a4.5 4.5 0 0 1 9 0 4.507 4.507 0 0 1-6.32 4.12l-1.48 1.48a6.474 6.474 0 0 0 7.52-.67l.27.27v.79l5.01 4.99L22 19.26l-4.99-5Z"
    };
    var favorite_filled = {
      name: "favorite_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 21.175-1.45-1.32C5.4 15.185 2 12.105 2 8.325c0-3.08 2.42-5.5 5.5-5.5 1.74 0 3.41.81 4.5 2.09 1.09-1.28 2.76-2.09 4.5-2.09 3.08 0 5.5 2.42 5.5 5.5 0 3.78-3.4 6.86-8.55 11.54L12 21.175Z"
    };
    var favorite_outlined = {
      name: "favorite_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 4.915c1.09-1.28 2.76-2.09 4.5-2.09 3.08 0 5.5 2.42 5.5 5.5 0 3.777-3.394 6.855-8.537 11.519l-.013.011-1.45 1.32-1.45-1.31-.04-.036C5.384 15.17 2 12.095 2 8.325c0-3.08 2.42-5.5 5.5-5.5 1.74 0 3.41.81 4.5 2.09Zm0 13.56.1-.1c4.76-4.31 7.9-7.16 7.9-10.05 0-2-1.5-3.5-3.5-3.5-1.54 0-3.04.99-3.56 2.36h-1.87c-.53-1.37-2.03-2.36-3.57-2.36-2 0-3.5 1.5-3.5 3.5 0 2.89 3.14 5.74 7.9 10.05l.1.1Z"
    };
    var star_filled = {
      name: "star_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 16.067 4.947 3.6-1.894-5.814L20 10.334h-6.067l-1.933-6-1.933 6H4l4.947 3.52-1.894 5.814 4.947-3.6Z"
    };
    var star_half = {
      name: "star_half",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22 9.24-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24ZM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4Z"
    };
    var star_circle = {
      name: "star_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2Zm7.48 7.16-5.01-.43-2-4.71c3.21.19 5.91 2.27 7.01 5.14Zm-5.07 6.26L12 13.98l-2.39 1.44.63-2.72-2.11-1.83 2.78-.24L12 8.06l1.09 2.56 2.78.24-2.11 1.83.64 2.73Zm-2.86-11.4-2 4.72-5.02.43c1.1-2.88 3.8-4.97 7.02-5.15ZM4 12c0-.64.08-1.26.23-1.86l3.79 3.28-1.11 4.75A7.982 7.982 0 0 1 4 12Zm3.84 6.82L12 16.31l4.16 2.5A7.924 7.924 0 0 1 11.99 20c-1.52 0-2.94-.44-4.15-1.18Zm9.25-.65-1.11-4.75 3.79-3.28c.14.59.23 1.22.23 1.86 0 2.48-1.14 4.7-2.91 6.17Z"
    };
    var star_outlined = {
      name: "star_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22 9.24-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24ZM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4Z"
    };
    var bookmarks = {
      name: "bookmarks",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2ZM9 4h2v5l-1-.75L9 9V4ZM6 20h12V4h-5v9l-3-2.25L7 13V4H6v16Z"
    };
    var bookmark_filled = {
      name: "bookmark_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2Z"
    };
    var bookmark_outlined = {
      name: "bookmark_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 3h10c1.1 0 2 .9 2 2v16l-7-3-7 3V5c0-1.1.9-2 2-2Zm5 12.82L17 18V5H7v13l5-2.18Z"
    };
    var bookmark_collection = {
      name: "bookmark_collection",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 1H8.99C7.89 1 7 1.9 7 3h10c1.1 0 2 .9 2 2v13l2 1V3c0-1.1-.9-2-2-2Zm-4 6v12.97l-4.21-1.81-.79-.34-.79.34L5 19.97V7h10ZM5 5h10c1.1 0 2 .9 2 2v16l-7-3-7 3V7c0-1.1.9-2 2-2Z"
    };
    var delete_to_trash = {
      name: "delete_to_trash",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.5 3h-5l-1 1H5v2h14V4h-3.5l-1-1ZM16 9v10H8V9h8ZM6 7h12v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V7Z"
    };
    var delete_forever = {
      name: "delete_forever",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m14.5 3 1 1H19v2H5V4h3.5l1-1h5ZM12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12 1.41-1.41L12 12.59ZM6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12ZM16 9H8v10h8V9Z"
    };
    var done = {
      name: "done",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m8.8 15.9-4.2-4.2-1.4 1.4 5.6 5.6 12-12-1.4-1.4L8.8 15.9Z"
    };
    var done_all = {
      name: "done_all",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22.205 5.295-10.58 10.58-4.18-4.17-1.41 1.41 5.59 5.59 12-12-1.42-1.41Zm-4.24 1.41-1.41-1.41-6.34 6.34 1.41 1.41 6.34-6.34Zm-12 12-5.59-5.59 1.42-1.41 5.58 5.59-1.41 1.41Z"
    };
    var restore_from_trash = {
      name: "restore_from_trash",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m14.5 3 1 1H19v2H5V4h3.5l1-1h5ZM8 21c-1.1 0-2-.9-2-2V7h12v12c0 1.1-.9 2-2 2H8Zm0-7V9h8v5l-4-4-4 4Zm0 0v5h8v-5h-2v4h-4v-4H8Z"
    };
    var close_circle_outlined = {
      name: "close_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm0-9.41L15.59 7 17 8.41 13.41 12 17 15.59 15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59Z"
    };
    var check = {
      name: "check",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m8.795 15.875-4.17-4.17-1.42 1.41 5.59 5.59 12-12-1.41-1.41-10.59 10.58Z"
    };
    var radio_button_selected = {
      name: "radio_button_selected",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Zm-5-8a5 5 0 1 1 10 0 5 5 0 0 1-10 0Z"
    };
    var radio_button_unselected = {
      name: "radio_button_unselected",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm2 0c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8-8 3.58-8 8Z"
    };
    var switch_off = {
      name: "switch_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 7h10c2.76 0 5 2.24 5 5s-2.24 5-5 5H7c-2.76 0-5-2.24-5-5s2.24-5 5-5Zm-3 5c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3Z"
    };
    var switch_on = {
      name: "switch_on",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 7h10c2.76 0 5 2.24 5 5s-2.24 5-5 5H7c-2.76 0-5-2.24-5-5s2.24-5 5-5Zm7 5c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3Z"
    };
    var log_out = {
      name: "log_out",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.988 20h7.95v2h-7.95A2 2 0 0 1 4 20V4a2 2 0 0 1 1.988-2h7.95v2h-7.95v16Zm8.745-2.7-1.49-1.4 2.955-2.9h-6.83v-2h6.856l-2.982-3 1.391-1.4L20 12l-5.267 5.3Z"
    };
    var log_in = {
      name: "log_in",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.95 4H10V2h7.95a2 2 0 0 1 1.988 2v16a2 2 0 0 1-1.988 2H10v-2h7.95V4ZM9.366 17.3l-1.491-1.4 2.956-2.9H4v-2h6.857L7.875 8l1.391-1.4 5.367 5.4-5.267 5.3Z"
    };
    var check_circle_outlined = {
      name: "check_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm-2-5.83 6.59-6.59L18 9l-8 8-4-4 1.41-1.41L10 14.17Z",
      sizes: {
        small: {
          name: "check_circle_outlined_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M9 1C4.584 1 1 4.584 1 9s3.584 8 8 8 8-3.584 8-8-3.584-8-8-8Zm0 14c-3.308 0-6-2.693-6-6 0-3.308 2.692-6 6-6 3.307 0 6 2.692 6 6 0 3.307-2.693 6-6 6Zm-1.599-4.264 5.272-5.272L13.801 6.6l-6.4 6.4-3.2-3.2L5.33 8.672l2.072 2.064Z"
        }
      }
    };
    var close = {
      name: "close",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z",
      sizes: {
        small: {
          name: "close_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M14 5.007 12.993 4 9 7.993 5.007 4 4 5.007 7.993 9 4 12.993 5.007 14 9 10.007 12.993 14 14 12.993 10.007 9 14 5.007Z"
        }
      }
    };
    var search = {
      name: "search",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.966 14.255h.79l4.99 5-1.49 1.49-5-4.99v-.79l-.27-.28a6.471 6.471 0 0 1-4.23 1.57 6.5 6.5 0 1 1 6.5-6.5c0 1.61-.59 3.09-1.57 4.23l.28.27Zm-9.71-4.5c0 2.49 2.01 4.5 4.5 4.5s4.5-2.01 4.5-4.5-2.01-4.5-4.5-4.5-4.5 2.01-4.5 4.5Z",
      sizes: {
        small: {
          name: "search_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M11.224 10.691h.592l3.743 3.75-1.118 1.118-3.75-3.743v-.592l-.202-.21a4.853 4.853 0 0 1-3.173 1.177 4.875 4.875 0 1 1 4.875-4.875 4.853 4.853 0 0 1-1.177 3.173l.21.202ZM3.94 7.316a3.37 3.37 0 0 0 3.375 3.375 3.37 3.37 0 0 0 3.375-3.375 3.37 3.37 0 0 0-3.375-3.375 3.37 3.37 0 0 0-3.375 3.375Z"
        }
      }
    };
    var checkbox$1 = {
      name: "checkbox",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2Zm4.3 13.29c.39.39 1.02.39 1.41 0l7.58-7.59a.996.996 0 1 0-1.41-1.41L10 14.17l-2.88-2.88a.996.996 0 1 0-1.41 1.41l3.59 3.59Z",
      sizes: {
        small: {
          name: "checkbox_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M3.75 2h10.5c.825 0 1.75.925 1.75 1.75v10.5c0 .825-.925 1.75-1.75 1.75H3.75c-.825 0-1.662-.925-1.662-1.75V3.75c0-.825.837-1.75 1.662-1.75Zm3.225 10.217a.747.747 0 0 0 1.057 0l5.685-5.692a.747.747 0 1 0-1.057-1.058l-5.16 5.16-2.16-2.16a.747.747 0 1 0-1.058 1.058l2.693 2.692Z"
        }
      }
    };
    var checkbox_outline = {
      name: "checkbox_outline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2Zm1 16h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1Z",
      sizes: {
        small: {
          name: "checkbox_outline_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M3.5 2H14c.825 0 2 .925 2 1.75v10.5c0 .825-1.175 1.75-2 1.75H3.5c-.825 0-1.5-.925-1.5-1.75V3.75C2 2.925 2.675 2 3.5 2Zm1.214 12h8.572a.716.716 0 0 0 .714-.714V4.714A.716.716 0 0 0 13.286 4H4.714A.716.716 0 0 0 4 4.714v8.572c0 .393.321.714.714.714Z"
        }
      }
    };
    var checkbox_indeterminate = {
      name: "checkbox_indeterminate",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2Zm3 10h8c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1Z",
      sizes: {
        small: {
          name: "checkbox_indeterminate_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M3.5 2H14c.825 0 2 .925 2 1.75V14c0 .825-1.175 2-2 2H4c-.825 0-2-1.175-2-2V3.75C2 2.925 2.675 2 3.5 2Zm2.3 8h6.4c.44 0 .8-.45.8-1s-.36-1-.8-1H5.8c-.44 0-.8.45-.8 1s.36 1 .8 1Z"
        }
      }
    };
    var zip_file = {
      name: "zip_file",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2Zm-.83 2 2 2H13v2h2v2h-2v2h2v2h-2v2H4V6h5.17ZM15 16h2v-2h-2v-2h2v-2h-2V8h5v10h-5v-2Z"
    };
    var approve = {
      name: "approve",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m15.33 1.781 2.137 2.968 3.72.852-.377 3.58 2.541 2.826-2.54 2.765.374 3.56-3.705.91-2.082 2.976-3.393-1.33-3.301 1.33-2.167-2.966-3.722-.854.375-3.625-2.542-2.766L3.19 9.18 2.813 5.6l3.712-.85 2.076-2.97 3.395 1.33 3.334-1.33ZM9.338 4.218l-1.615 2.31-2.735.627.284 2.702-1.92 2.135 1.92 2.09-.285 2.762 2.724.625 1.69 2.312 2.594-1.045 2.667 1.045 1.61-2.302 2.741-.673-.286-2.723 1.921-2.09-1.92-2.136.284-2.702-2.727-.626-1.665-2.311-2.617 1.045-2.665-1.045ZM16.59 7.58 10 14.17l-2.59-2.58L6 13l4 4 8-8-1.41-1.42Z"
    };
    var calendar_event = {
      name: "calendar_event",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2Zm0 16H5V10h14v10ZM5 6v2h14V6H5Zm2 6h10v2H7v-2Zm7 4H7v2h7v-2Z"
    };
    var calendar_accept = {
      name: "calendar_accept",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 4h1c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2h1V2h2v2h8V2h2v2ZM5 20h14V10H5v10ZM5 8V6h14v2H5Zm11.49 4.53-5.93 5.93-3.17-3.17 1.06-1.06 2.11 2.11 4.87-4.87 1.06 1.06Z"
    };
    var calendar_reject = {
      name: "calendar_reject",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 4h1c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2h1V2h2v2h8V2h2v2ZM5 20h14V10H5v10ZM5 8V6h14v2H5Zm4.29 10.47-1.06-1.06 2.44-2.44-2.44-2.44 1.06-1.06 2.44 2.44 2.44-2.44 1.06 1.06-2.44 2.44 2.44 2.44-1.06 1.06-2.44-2.44-2.44 2.44Z"
    };
    var timer$2 = {
      name: "timer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 1.505h6v2H9v-2Zm2 13v-6h2v6h-2Zm8.03-6.62 1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42A8.962 8.962 0 0 0 12 4.495a9 9 0 0 0-9 9c0 4.97 4.02 9 9 9s9-4.03 9-9c0-2.11-.74-4.06-1.97-5.61ZM5 13.505c0 3.87 3.13 7 7 7s7-3.13 7-7-3.13-7-7-7-7 3.13-7 7Z"
    };
    var timer_off = {
      name: "timer_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.625 1h6v2h-6V1Zm2 7v.86l2 2V8h-2Zm8 5c0-3.87-3.13-7-7-7-1.12 0-2.18.27-3.12.74l-1.47-1.47c1.34-.8 2.91-1.27 4.59-1.27 2.12 0 4.07.74 5.62 1.98l1.42-1.42c.51.42.98.9 1.41 1.41l-1.42 1.42a8.963 8.963 0 0 1 1.97 5.61c0 1.68-.47 3.25-1.27 4.59l-1.47-1.47c.47-.94.74-2 .74-3.12ZM3.785 3.86l-1.41 1.41 2.75 2.75a9.043 9.043 0 0 0-1.5 4.98c0 4.97 4.02 9 9 9 1.84 0 3.55-.55 4.98-1.5l2.5 2.5 1.41-1.41L3.785 3.86ZM5.625 13c0 3.87 3.13 7 7 7 1.29 0 2.49-.35 3.53-.95l-9.57-9.57a6.876 6.876 0 0 0-.96 3.52Z"
    };
    var calendar_today = {
      name: "calendar_today",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 4h1c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1V2h2v2h8V2h2v2ZM5 10v10h14V10H5Zm14-2H5V6h14v2Zm-7 4H7v5h5v-5Z"
    };
    var calendar_date_range = {
      name: "calendar_date_range",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 11h2v2H7v-2Zm14-5v14c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2l.01-14c0-1.1.88-2 1.99-2h1V2h2v2h8V2h2v2h1c1.1 0 2 .9 2 2ZM5 8h14V6H5v2Zm14 12V10H5v10h14Zm-4-7h2v-2h-2v2Zm-4 0h2v-2h-2v2Z"
    };
    var alarm = {
      name: "alarm",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.945 3.441 6.664 1.905 2.057 5.75l1.28 1.536L7.946 3.44Zm9.392-1.535 4.608 3.843-1.282 1.536-4.607-3.843 1.281-1.536Zm-4.836 6.189H11v6l4.75 2.85.75-1.23-4-2.37v-5.25Zm-.5-4a9 9 0 1 0 .001 18.001 9 9 0 0 0-.001-18.001Zm-7 9c0 3.86 3.14 7 7 7s7-3.14 7-7-3.14-7-7-7-7 3.14-7 7Z"
    };
    var alarm_add = {
      name: "alarm_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6.664 1.905 1.281 1.536-4.607 3.844-1.281-1.536 4.607-3.844Zm10.673 0 4.608 3.844-1.282 1.536-4.607-3.843 1.281-1.536ZM3.001 13.096a9 9 0 1 1 18.001.001 9 9 0 0 1-18.001-.001Zm9 7c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7Zm-1-8v-3h2v3h3v2h-3v3h-2v-3H8v-2h3Z"
    };
    var alarm_off = {
      name: "alarm_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m8.164 3.445-.46.38-1.42-1.42.6-.5 1.28 1.54Zm9.397-1.54 4.607 3.844-1.281 1.536-4.608-3.843 1.282-1.536Zm-7.297 4.48c.62-.18 1.28-.29 1.96-.29 3.86 0 7 3.14 7 7 0 .68-.11 1.34-.29 1.96l1.56 1.56c.47-1.08.73-2.27.73-3.52a9 9 0 0 0-12.53-8.28l1.57 1.57Zm-8.43-2.78 1.41-1.41 18.38 18.39-1.41 1.41-2.1-2.1a8.964 8.964 0 0 1-5.89 2.2 9 9 0 0 1-9-9c0-2.25.83-4.31 2.2-5.89l-.8-.8-1.06.88-1.28-1.54.92-.77-1.37-1.37Zm10.39 16.49c-3.86 0-7-3.14-7-7 0-1.7.61-3.26 1.62-4.47l9.85 9.85a6.956 6.956 0 0 1-4.47 1.62Z"
    };
    var alarm_on = {
      name: "alarm_on",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.945 3.441 6.664 1.905 2.057 5.75l1.28 1.536L7.946 3.44Zm9.392-1.535 4.608 3.843-1.282 1.536-4.607-3.843 1.281-1.536Zm-6.796 12.719-2.13-2.13-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95ZM12 4.095a9 9 0 1 0 .001 18.001 9 9 0 0 0-.001-18.001Zm-7 9c0 3.86 3.14 7 7 7s7-3.14 7-7-3.14-7-7-7-7 3.14-7 7Z"
    };
    var infinity = {
      name: "infinity",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.6 6.62c-1.44 0-2.8.56-3.77 1.53L7.8 14.39c-.64.64-1.49.99-2.4.99-1.87 0-3.39-1.51-3.39-3.38 0-1.87 1.52-3.38 3.39-3.38.91 0 1.76.35 2.44 1.03l1.13 1 1.51-1.34L9.22 8.2A5.37 5.37 0 0 0 5.4 6.62C2.42 6.62 0 9.04 0 12s2.42 5.38 5.4 5.38c1.44 0 2.8-.56 3.77-1.53l7.03-6.24c.64-.64 1.49-.99 2.4-.99 1.87 0 3.39 1.51 3.39 3.38 0 1.87-1.52 3.38-3.39 3.38-.9 0-1.76-.35-2.44-1.03l-1.14-1.01-1.51 1.34 1.27 1.12a5.386 5.386 0 0 0 3.82 1.57c2.98 0 5.4-2.41 5.4-5.38 0-2.97-2.42-5.37-5.4-5.37Z"
    };
    var hourglass_empty = {
      name: "hourglass_empty",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6Zm10 14.5V20H8v-3.5l4-4 4 4ZM8 4v3.5l4 4 4-4V4H8Z"
    };
    var hourglass_full = {
      name: "hourglass_full",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6Z"
    };
    var calendar$1 = {
      name: "calendar",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2Zm0 16H5V10h14v10ZM5 6v2h14V6H5Z",
      sizes: {
        small: {
          name: "calendar_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M13.5 3H13V2h-1v1H6V2H5v1h-.5C3.5 3 3 3.5 3 4.6v9.1c0 .715.6 1.3 1.333 1.3h9.334C14.4 15 15 14.415 15 13.7V4.6c0-1.1-.5-1.6-1.5-1.6ZM13 13H5V8h8v5ZM5 5v1h8V5H5Z"
        }
      }
    };
    var time$2 = {
      name: "time",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8ZM11 7h1.5v5.2l4.5 2.7-.8 1.3L11 13V7Z",
      sizes: {
        small: {
          name: "time_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M9 2C5.15 2 2 5.15 2 9s3.15 7 7 7 7-3.15 7-7-3.15-7-7-7Zm-.002 12.6a5.607 5.607 0 0 1-5.6-5.6c0-3.087 2.513-5.6 5.6-5.6 3.087 0 5.6 2.513 5.6 5.6 0 3.087-2.513 5.6-5.6 5.6ZM8 6h1v3.391l3 1.761-.533.848L8 9.913V6Z"
        }
      }
    };
    var no_craning = {
      name: "no_craning",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 4.5 4.5 3 21 19.5 19.5 21 3 4.5ZM13.915 11H14a1 1 0 0 0 .832-.445l4-6A1 1 0 0 0 18 3H6c-.027 0-.055.001-.082.003L7.915 5h8.217l-2.667 4h-1.55l2 2Zm.976 6.805 1.531 1.531A5 5 0 0 1 7 17a1 1 0 1 1 2 0 3 3 0 0 0 5.891.805ZM13 7a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
    };
    var craning = {
      name: "craning",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.118 3.528A1 1 0 0 1 6 3h12a1 1 0 0 1 .832 1.555l-4 6A1 1 0 0 1 14 11h-1v1.1a5.002 5.002 0 0 1-1 9.9 5 5 0 0 1-5-5 1 1 0 1 1 2 0 3 3 0 1 0 3-3h-1v-3h-1a1 1 0 0 1-.832-.445l-4-6a1 1 0 0 1-.05-1.027ZM13.465 9H10.535L7.87 5h8.262l-2.666 4ZM12 8a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
    };
    var toolbox = {
      name: "toolbox",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 4a2 2 0 0 0-2 2v2H5a2 2 0 0 0-2 2v10h18V10a2 2 0 0 0-2-2h-2V6a2 2 0 0 0-2-2H9Zm10 9v-3H5v3h2v-1h2v1h6v-1h2v1h2Zm-4 2v1h2v-1h2v3H5v-3h2v1h2v-1h6Zm0-7V6H9v2h6Z"
    };
    var cable = {
      name: "cable",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 4.5a1 1 0 0 0-2 0v4a1 1 0 1 0 2 0v-4Zm10.25-.75A4.75 4.75 0 0 0 12.5 8.5v6.75a2.75 2.75 0 1 1-5.5 0V11.5a1 1 0 1 0-2 0v3.75a4.75 4.75 0 1 0 9.5 0V8.5a2.75 2.75 0 0 1 5.5 0V19a1 1 0 0 0 2 0V8.5a4.75 4.75 0 0 0-4.75-4.75ZM1.293 7.793a1 1 0 0 1 1.414 0l1.414 1.414a1 1 0 1 1-1.414 1.414L1.293 9.207a1 1 0 0 1 0-1.414Zm8 0a1 1 0 0 1 1.414 1.414l-1.414 1.414a1 1 0 0 1-1.415-1.414l1.415-1.414Z"
    };
    var beat = {
      name: "beat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.5 4a1 1 0 0 0-.97.757l-1.845 7.378-.79-1.582a1 1 0 0 0-1.79 0L4.383 14H2a1 1 0 1 0 0 2h3a1 1 0 0 0 .894-.553L7 13.237l1.106 2.21a1 1 0 0 0 1.864-.204l1.53-6.12 2.53 10.12a1 1 0 0 0 1.94 0l1.03-4.12.03.12A1 1 0 0 0 18 16h4a1 1 0 1 0 0-2h-3.22l-.81-3.242a1 1 0 0 0-1.94 0L15 14.877l-2.53-10.12A1 1 0 0 0 11.5 4Z"
    };
    var gas = {
      name: "gas",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.205 13.636c.985 1.83 1.238 4.036 1.127 5.806-.093 1.49-.444 2.67-.832 3.058.75-.346 1.758-1.11 2.757-2.149C18.146 18.387 20 15.444 20 12.5c0-4.216-3.82-7.257-6.73-9.573-.186-.15-.37-.295-.548-.438C12.056 1.954 11.46 1.46 11 1c0 .645-.324 1.29-.832 1.96C9.672 3.615 9 4.292 8.284 5.016 6.316 7 4 9.336 4 12.5c0 3.012 1.942 5.8 3.876 7.765.955.97 1.908 1.74 2.624 2.235-.294-.765-.599-1.893-.727-3.175-.178-1.79-.013-3.882 1.004-5.707A7.33 7.33 0 0 1 12 12l.001.001a6.984 6.984 0 0 1 1.204 1.635ZM7.75 17.044c.17-2.146.909-4.532 2.835-6.458L12 9.172l1.414 1.414c1.875 1.875 2.641 4.4 2.866 6.583C17.325 15.65 18 13.996 18 12.5c0-1.919-1.131-3.674-2.953-5.438-.892-.863-1.87-1.652-2.832-2.42l-.217-.172-.29-.23c-.089.114-.178.224-.264.328-.518.623-1.186 1.297-1.811 1.927-.242.244-.477.482-.694.707C7.186 9.018 6 10.624 6 12.5c0 1.5.68 3.065 1.751 4.544Z"
    };
    var gear = {
      name: "gear",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.424 2a.5.5 0 0 0-.493.418l-.224 1.345a.52.52 0 0 1-.408.418 7.955 7.955 0 0 0-2.646 1.102.52.52 0 0 1-.586-.006L5.952 4.48a.5.5 0 0 0-.644.053l-.816.816a.5.5 0 0 0-.053.644l.804 1.126a.52.52 0 0 1 .01.582 7.953 7.953 0 0 0-1.079 2.63.52.52 0 0 1-.419.41l-1.378.23a.5.5 0 0 0-.418.494v1.153a.5.5 0 0 0 .418.493l1.397.233a.52.52 0 0 1 .418.405c.209.936.581 1.81 1.086 2.59a.52.52 0 0 1-.007.586L4.44 18.09a.5.5 0 0 0 .053.644l.816.815a.5.5 0 0 0 .644.053l1.176-.84a.52.52 0 0 1 .582-.009c.777.495 1.646.86 2.575 1.063a.52.52 0 0 1 .407.418l.239 1.43a.5.5 0 0 0 .493.419h1.153a.5.5 0 0 0 .493-.418l.238-1.43a.52.52 0 0 1 .407-.42 7.952 7.952 0 0 0 2.576-1.062.52.52 0 0 1 .582.01l1.176.84a.5.5 0 0 0 .644-.054l.815-.815a.5.5 0 0 0 .053-.644l-.832-1.165a.52.52 0 0 1-.007-.585 7.955 7.955 0 0 0 1.087-2.591.52.52 0 0 1 .418-.405l1.397-.233a.5.5 0 0 0 .418-.493v-1.153a.5.5 0 0 0-.418-.493l-1.379-.23a.52.52 0 0 1-.419-.41 7.954 7.954 0 0 0-1.078-2.63.52.52 0 0 1 .01-.583l.803-1.126a.5.5 0 0 0-.053-.644l-.815-.816a.5.5 0 0 0-.644-.053l-1.116.797a.52.52 0 0 1-.585.006 7.956 7.956 0 0 0-2.646-1.102.52.52 0 0 1-.408-.418l-.224-1.345A.5.5 0 0 0 12.577 2h-1.153ZM18 12a6 6 0 1 1-12 0 6 6 0 0 1 12 0Zm-4 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm2 0a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"
    };
    var bearing = {
      name: "bearing",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm0-4a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm0-2a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm1-8a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm4 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm0 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-8 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm0-8a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm10 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM7 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm6 6a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
    };
    var pressure = {
      name: "pressure",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.046 2.867c.101.045.144.164.097.264l-.68 1.448a.204.204 0 0 1-.268.098 8 8 0 0 0-6.448.003.204.204 0 0 1-.268-.098l-.681-1.448a.197.197 0 0 1 .096-.264 10 10 0 0 1 8.152-.003Zm5.85 7.894a.197.197 0 0 1-.176.22l-1.591.166a.204.204 0 0 1-.223-.178 8 8 0 0 0-3.337-5.517.204.204 0 0 1-.055-.28L17.4 3.84a.197.197 0 0 1 .276-.054 9.999 9.999 0 0 1 4.22 6.975Zm-19.67.215a.197.197 0 0 1-.175-.22 10 10 0 0 1 4.223-6.973.197.197 0 0 1 .276.054l.885 1.333a.204.204 0 0 1-.054.28 8 8 0 0 0-3.34 5.515.204.204 0 0 1-.223.178l-1.591-.167ZM6 20h-.027a10.001 10.001 0 0 1-3.972-7.26.197.197 0 0 1 .186-.21l1.598-.087a.204.204 0 0 1 .213.19A8 8 0 0 0 8.1 19h7.746a8 8 0 0 0 4.102-6.368.204.204 0 0 1 .213-.189l1.598.087c.11.006.195.1.187.21A10.001 10.001 0 0 1 17.973 20h-.027a.197.197 0 0 1-.053.06c-.478.35-.986.659-1.52.92a.198.198 0 0 1-.087.02H7.66a.198.198 0 0 1-.087-.02 9.998 9.998 0 0 1-1.52-.92A.195.195 0 0 1 6 20Zm5.811-12.964a.5.5 0 0 0-.388.416l-.693 4.776a2 2 0 1 0 2.486 0l-.693-4.776a.5.5 0 0 0-.388-.416l-.055-.012a.5.5 0 0 0-.214 0l-.055.012Z"
    };
    var platform$1 = {
      name: "platform",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 8h2v5H7V8Zm1-5v3H6a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1Zm12 15v-2H4v2h3v4h2v-4h6v4h2v-4h3Zm-6-5h3v-1.955l-3-1.143V13Zm-2 1V8.451a1 1 0 0 1 1.356-.934l5 1.904a1 1 0 0 1 .644.935V14a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1Z"
    };
    var circuit = {
      name: "circuit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V3a1 1 0 0 0-1-1ZM4.707 5.707a1 1 0 0 0 0 1.414l3.847 3.847a4.002 4.002 0 0 0 2.454 5.908A.998.998 0 0 0 11 17v4a1 1 0 0 0 2 0v-4a.998.998 0 0 0-.008-.124 4.002 4.002 0 1 0-3.024-7.322L6.12 5.707a1 1 0 0 0-1.414 0ZM14 13a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"
    };
    var engineering = {
      name: "engineering",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.045 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4Zm-6 4c.22-.72 3.31-2 6-2 2.7 0 5.8 1.29 6 2h-12ZM4.785 9h.26c0 2.21 1.79 4 4 4s4-1.79 4-4h.26c.27 0 .49-.22.49-.49v-.02a.49.49 0 0 0-.49-.49h-.26c0-1.48-.81-2.75-2-3.45v.95c0 .28-.22.5-.5.5s-.5-.22-.5-.5V4.14a4.09 4.09 0 0 0-1-.14c-.35 0-.68.06-1 .14V5.5c0 .28-.22.5-.5.5s-.5-.22-.5-.5v-.95c-1.19.7-2 1.97-2 3.45h-.26a.49.49 0 0 0-.49.49v.03c0 .26.22.48.49.48Zm6.26 0c0 1.1-.9 2-2 2s-2-.9-2-2h4ZM22.025 6.23l.93-.83-.75-1.3-1.19.39c-.14-.11-.3-.2-.47-.27L20.295 3h-1.5l-.25 1.22c-.17.07-.33.16-.48.27l-1.18-.39-.75 1.3.93.83c-.02.17-.02.35 0 .52l-.93.85.75 1.3 1.2-.38c.13.1.28.18.43.25l.28 1.23h1.5l.27-1.22c.16-.07.3-.15.44-.25l1.19.38.75-1.3-.93-.85c.03-.19.02-.36.01-.53Zm-2.48 1.52a1.25 1.25 0 1 1 0-2.5 1.25 1.25 0 0 1 0 2.5ZM19.445 10.79l-.85.28c-.1-.08-.21-.14-.33-.19l-.18-.88h-1.07l-.18.87c-.12.05-.24.12-.34.19l-.84-.28-.54.93.66.59c-.01.13-.01.25 0 .37l-.66.61.54.93.86-.27c.1.07.2.13.31.18l.18.88h1.07l.19-.87c.11-.05.22-.11.32-.18l.85.27.54-.93-.66-.61c.01-.13.01-.25 0-.37l.66-.59-.53-.93Zm-1.9 2.6c-.49 0-.89-.4-.89-.89s.4-.89.89-.89.89.4.89.89-.4.89-.89.89Z"
    };
    var ducting = {
      name: "ducting",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 17c-.6 0-1-.5-1-1V4c0-.5.4-1 1-1s1 .5 1 1v1.1h9c2.2 0 4 1.8 4 4v9.007c.465.06.9.526.9.993 0 .566-.356.954-.9.996v.004h-9.1c-.5 0-1-.4-1-1s.4-1 1-1h.1v-3H9v.9c0 .5-.5 1-1 1Zm12 1.1h-5v-3c0-1.1-.9-2-2-2H9v-6h9c1.1 0 2 .9 2 2v9ZM2.9 6.7c.4-.4.9-.6 1.4-.6.938 0 1.613.705 1.775.874L6.1 7 4.6 8.3c-.1-.1-.2-.2-.3-.2-.4.5-.9.6-1.3.6h-.2c-1-.1-1.7-1-1.8-1.2l1.7-1.1c0 .1.1.2.2.3Zm0 2.9c.4-.4.9-.6 1.4-.6.938 0 1.613.705 1.775.874L6.1 9.9l-1.5 1.3c-.1-.1-.2-.2-.3-.2-.4.5-.9.6-1.3.6h-.2c-1-.1-1.7-1-1.8-1.2l1.7-1.2c0 .1.1.3.2.4Zm1.4 2.2c-.5 0-1 .2-1.4.6-.1-.1-.2-.2-.2-.3L1 13.2c.1.2.8 1.1 1.8 1.2H3c.4 0 .9-.1 1.3-.6.1 0 .2.1.3.2l1.5-1.3-.025-.026c-.162-.17-.837-.874-1.775-.874Z"
    };
    var formula = {
      name: "formula",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 2C5.9 2 4.3 3.6 4.3 6.6v1.7H2v2.2h2.3V22h3V10.5h3.3V8.3H7.3V7c0-1.7.7-2.6 2.3-2.6.5 0 1 0 1.7.2V2.3C10.6 2.1 9.8 2 9 2Zm9.7 18.4-1.5-2.9 1.2-2.4h-1.9l-.6 1.2-.5-1.2h-2.3l1.4 2.7-1.5 2.6h2l.7-1.4.7 1.4h2.3ZM12 22.8c-3.9-4.8-1.7-9.6 0-11.5l1.5 1.3-.7-.6.7.7c-.2.2-3.7 4.2 0 8.9L12 22.8Zm6.3-1.2 1.5 1.3c1.7-1.9 3.9-6.7.1-11.5l-1.6 1.3c3.7 4.7.2 8.7 0 8.9Z"
    };
    var manual_valve = {
      name: "manual_valve",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 4h2c.5 0 1-.4 1-1s-.4-1-1-1H9c-.6 0-1 .4-1 1s.5 1 1 1h2v7.464L2 4.1v18l10.061-8.232L22 22V4l-9 7.364V4Zm7 13.9V8.3L14.1 13l5.9 4.9ZM9.8 13.1 4 8.3v9.5l5.8-4.7Z"
    };
    var pipe_support = {
      name: "pipe_support",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.4 4.8c-.2-.2-.4-.5-.4-.8a1 1 0 0 1 1.6-.8c2.1 1.7 3.4 4.2 3.4 7.1a9.012 9.012 0 0 1-4 7.509V20.2c0 .6-.4 1-1 1H8c-.6 0-1-.4-1-1v-2.56C4.58 15.92 2.936 13.062 3 10c.1-2.7 1.3-5.1 3.3-6.7.6-.5 1.6 0 1.6.8 0 .3-.2.6-.4.8C6 6.2 5 8.1 5 10.3c0 4.3 3.9 7.7 8.4 6.8 2.8-.5 5-2.7 5.5-5.5.5-2.7-.6-5.3-2.5-6.8Z"
    };
    var heat_trace = {
      name: "heat_trace",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.34 22.061c-2.01 0-3.3-1.38-3.3-3.5 0-1.03-.03-10.66-.04-13.5 0-.55.44-1 1-1 .55 0 1 .44 1 .99.01 2.84.04 12.47.04 13.5 0 1.5.95 1.5 1.3 1.5 1.08 0 1.17-1.42 1.17-1.43v-1.15c0-3.04-.01-11.11 0-11.92.02-.78.32-1.88 1.13-2.66.63-.6 1.43-.9 2.35-.88 2.17.05 2.99 2.16 3.01 3.57v3.68c-.01 3.33-.01 8.92 0 9.29.07 1.31.7 1.5 1.3 1.5h.02c.64 0 1.1-.26 1.25-1.47l.01-.11c.03-.5 0-8.74-.01-11.44v-1.45c0-1.41.86-3.53 3.23-3.58.79-.02 1.51.26 2.06.8.9.88 1.14 2.22 1.14 2.8v13.47c0 .55-.45 1-1 1s-1-.45-1-1V5.601c0-.19-.13-.97-.53-1.36-.17-.16-.34-.25-.62-.23-1.23.03-1.27 1.42-1.27 1.58v1.44c.04 10.56.02 11.55-.02 11.75-.37 2.99-2.41 3.29-3.28 3.28-1.94-.02-3.17-1.29-3.28-3.4-.02-.35-.01-4.29 0-9.4v-3.64c0-.02-.05-1.59-1.06-1.61-.38-.02-.67.1-.91.32-.34.33-.51.89-.52 1.26-.02.79-.01 8.85 0 11.88v1.16c0 1.43-.98 3.43-3.17 3.43Z"
    };
    var instrument = {
      name: "instrument",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 11c0-3.9-3.1-7-7-7s-7 3.1-7 7c0 1.818.673 3.461 1.787 4.699a9.117 9.117 0 0 1 4.355-1.65L15 7.2c.3-.5.9-.7 1.4-.4.5.3.7.9.4 1.4l-3.33 5.912a9.22 9.22 0 0 1 3.777 1.548A6.985 6.985 0 0 0 19 11Zm-3.36 5.997C14.618 16.352 13.36 16 12.1 16c-1.344 0-2.577.39-3.657 1.047A7.025 7.025 0 0 0 12 18a7.02 7.02 0 0 0 3.64-1.003ZM3 11c0-5 4-9 9-9s9 4 9 9a8.958 8.958 0 0 1-8 8.946V21c0 .6-.4 1-1 1s-1-.4-1-1v-1.054A8.958 8.958 0 0 1 3 11Z"
    };
    var junction_box = {
      name: "junction_box",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.023 3.695A2 2 0 0 1 5 2h14a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2h-2v3h-2v-3h-2v3h-2v-3H9v3H7v-3H5a2 2 0 0 1-2-2V4c0-.104.008-.205.023-.305ZM5 4v13h14V4H5Z"
    };
    var line$3 = {
      name: "line",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2h10a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2H7a2 2 0 0 0-2-2H3Zm4 4v4h10v-4H7ZM5 8H3v8h2V8Zm16 8h-2V8h2v8Z"
    };
    var telecom = {
      name: "telecom",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m13.168 1-.648 1.794c.057.019 5.96 2.203 8.716 8.939L23 11.008C19.92 3.5 13.435 1.095 13.168 1Zm-.82 5.104.495-1.841c.182.047 4.454 1.23 6.876 6.716l-1.745.773c-2.04-4.608-5.483-5.61-5.626-5.648Zm4.11 5.505-1.802.63c-.85-2.424-2.546-2.738-2.623-2.748l.277-1.889c.135.02 2.901.446 4.148 4.007Zm-3.49 2.614c0 .391-.086.754-.22 1.097l4.244 4.16a1.181 1.181 0 0 1-.153 1.793c-1.583 1.126-3.585 1.718-5.645 1.718-2.556 0-5.197-.916-7.19-2.872C.408 16.6.16 10.903 2.62 7.316c.229-.334.6-.515.972-.515.296 0 .582.105.811.334l4.253 4.178a3.024 3.024 0 0 1 1.173-.229 3.14 3.14 0 0 1 3.138 3.14Zm-7.63 4.541c1.526 1.498 3.605 2.328 5.856 2.328 1.363 0 2.68-.324 3.776-.906l-3.414-3.349-1.459-1.44c.544-.134.954-.601.954-1.183 0-.678-.553-1.231-1.23-1.231-.592 0-1.059.43-1.183.983l-.858-.85-4.034-3.959c-1.364 2.729-1.182 6.888 1.593 9.607Z"
    };
    var toolbox_wheel = {
      name: "toolbox_wheel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 3a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2h2a2 2 0 0 1 2 2v10H3V7a2 2 0 0 1 2-2h2V3Zm12 4v3h-2V9h-2v1H9V9H7v1H5V7h14Zm-4 6v-1H9v1H7v-1H5v3h14v-3h-2v1h-2Zm0-10v2H9V3h6ZM2 18h20v2H2v-2Zm5.5 2a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3Zm9 0a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3Z"
    };
    var toolbox_rope = {
      name: "toolbox_rope",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 1h20v2h-9l3 3h-2l-2-2-2 2H8l3-3H2V1Zm5 8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2h2a2 2 0 0 1 2 2v10H3V13a2 2 0 0 1 2-2h2V9Zm12 4v3h-2v-1h-2v1H9v-1H7v1H5v-3h14Zm-4 6v-1H9v1H7v-1H5v3h14v-3h-2v1h-2Zm0-10v2H9V9h6Z"
    };
    var oil = {
      name: "oil",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.201 19.117C15.016 20.404 13.654 21 12 21c-1.654 0-3.016-.596-4.201-1.883C6.606 17.82 6 16.264 6 14.328c0-1.566.397-2.784 1.108-3.76.805-1.105 2.427-3.209 4.883-6.328 2.464 3.162 4.098 5.286 4.913 6.383.699.942 1.096 2.138 1.096 3.706 0 1.935-.606 3.49-1.799 4.788ZM5.491 9.39c.861-1.183 2.606-3.442 5.233-6.775L12 1l1.267 1.623C15.899 6 17.646 8.27 18.509 9.43 19.503 10.769 20 12.4 20 14.329c0 2.408-.776 4.456-2.327 6.142C16.12 22.157 14.23 23 12 23s-4.121-.843-5.673-2.53C4.776 18.786 4 16.738 4 14.33c0-1.928.497-3.574 1.49-4.938ZM8.5 13a.5.5 0 0 0-1 0c0 1.233.127 2.437.604 3.54.482 1.114 1.306 2.09 2.639 2.889a.5.5 0 1 0 .514-.858c-1.167-.7-1.843-1.52-2.236-2.429-.398-.92-.521-1.967-.521-3.142Z"
    };
    var oil_barrel = {
      name: "oil_barrel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 3a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2h-2v7h1a1 1 0 1 1 0 2h-1v7h2a1 1 0 1 1 0 2H3a1 1 0 1 1 0-2h2v-7H4a1 1 0 1 1 0-2h1V4H3a1 1 0 0 1-1-1Zm15 10v7H7v-7a1 1 0 1 0 0-2V4h10v7a1 1 0 1 0 0 2Zm-5 3c.836 0 1.546-.307 2.127-.92.582-.613.873-1.357.873-2.233 0-.701-.186-1.295-.56-1.781A206.829 206.829 0 0 0 12 8c-1.255 1.538-2.068 2.555-2.44 3.051-.374.496-.56 1.095-.56 1.796 0 .876.29 1.62.873 2.233.582.613 1.29.92 2.127.92Z"
    };
    var wellbore = {
      name: "wellbore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 3h-2v10.083c0 .507.448.917 1 .917s1-.41 1-.917V3ZM7 8H3V6h6v15H7V8Zm10 0h4V6h-6v15h2V8Z"
    };
    var share = {
      name: "share",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.04 16.89c.52-.47 1.2-.77 1.96-.77 1.61 0 2.92 1.31 2.92 2.92 0 1.61-1.31 2.92-2.92 2.92-1.61 0-2.92-1.31-2.92-2.92 0-.22.03-.44.08-.65l-7.12-4.16c-.54.5-1.25.81-2.04.81-1.66 0-3-1.34-3-3s1.34-3 3-3c.79 0 1.5.31 2.04.81l7.05-4.11c-.05-.23-.09-.46-.09-.7 0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3c-.79 0-1.5-.31-2.04-.81l-7.05 4.11c.05.23.09.46.09.7 0 .24-.04.47-.09.7l7.13 4.15ZM19 5.04c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm-13 8c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1Zm11 6.02c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Z"
    };
    var skype = {
      name: "skype",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.5 2A5.5 5.5 0 0 0 2 7.5c0 1.231.409 2.362 1.092 3.28-.054.4-.092.805-.092 1.22a9 9 0 0 0 9 9c.415 0 .82-.038 1.22-.092A5.468 5.468 0 0 0 16.5 22a5.5 5.5 0 0 0 5.5-5.5 5.468 5.468 0 0 0-1.092-3.28c.054-.4.092-.805.092-1.22a9 9 0 0 0-9-9c-.415 0-.82.038-1.22.092A5.468 5.468 0 0 0 7.5 2Zm0 2c.753 0 1.475.24 2.086.695l.652.489.809-.11C11.42 5.024 11.724 5 12 5c3.86 0 7 3.14 7 7 0 .276-.023.578-.074.953l-.11.809.489.652A3.47 3.47 0 0 1 20 16.5c0 1.93-1.57 3.5-3.5 3.5a3.47 3.47 0 0 1-2.086-.695l-.652-.489-.809.11c-.375.05-.677.074-.953.074-3.86 0-7-3.14-7-7 0-.276.023-.578.074-.953l.11-.809-.489-.652A3.471 3.471 0 0 1 4 7.5C4 5.57 5.57 4 7.5 4Zm4.35 3C8.09 7 7.813 9.209 7.813 9.754c0 1.084.621 1.926 1.683 2.334 1.13.434 2.5.694 3.277.906 1.217.333 1.063 1.004 1.063 1.102 0 1.03-1.41 1.295-2.012 1.238-.68-.064-1.369.13-2.086-1.346-.128-.264-.363-.841-1.07-.841-.306 0-1.07.232-1.07.962 0 1.432 1.599 2.891 4.38 2.891 1.454 0 4.167-.503 4.168-3.111 0-2.271-2.29-2.67-3.974-3.104-.461-.119-2.18-.309-2.18-1.209 0-.267.374-.908 1.72-.908 1.388 0 1.69.65 1.874.986.154.267.28.474.435.573a1.091 1.091 0 0 0 1.375-.116c.2-.207.3-.435.3-.695C15.695 8.285 14.357 7 11.85 7Z"
    };
    var whats_app = {
      name: "whats_app",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.012 2c-5.506 0-9.989 4.478-9.99 9.984a9.964 9.964 0 0 0 1.333 4.993L2 22l5.232-1.236a9.981 9.981 0 0 0 4.774 1.215h.004c5.505 0 9.985-4.48 9.988-9.985a9.922 9.922 0 0 0-2.922-7.066A9.923 9.923 0 0 0 12.012 2Zm-.002 2a7.95 7.95 0 0 1 5.652 2.342 7.929 7.929 0 0 1 2.336 5.65c-.002 4.404-3.584 7.986-7.99 7.986a7.999 7.999 0 0 1-3.817-.97l-.673-.367-.745.175-1.968.465.48-1.785.217-.8-.414-.72a7.98 7.98 0 0 1-1.067-3.992C4.023 7.582 7.607 4 12.01 4ZM8.477 7.375a.917.917 0 0 0-.666.313c-.23.248-.875.852-.875 2.08 0 1.228.894 2.415 1.02 2.582.123.166 1.726 2.765 4.263 3.765 2.108.831 2.536.667 2.994.625.458-.04 1.477-.602 1.685-1.185.208-.583.209-1.085.147-1.188-.062-.104-.229-.166-.479-.29-.249-.126-1.476-.728-1.705-.811-.229-.083-.396-.125-.562.125-.166.25-.643.81-.79.976-.145.167-.29.19-.54.065-.25-.126-1.054-.39-2.008-1.24-.742-.662-1.243-1.477-1.389-1.727-.145-.25-.013-.386.112-.51.112-.112.248-.291.373-.437.124-.146.167-.25.25-.416.083-.166.04-.313-.022-.438s-.547-1.357-.77-1.851c-.186-.415-.384-.425-.562-.432-.145-.006-.31-.006-.476-.006Z"
    };
    var facebook_messenger = {
      name: "facebook_messenger",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.486 2 2 6.262 2 11.5c0 2.545 1.088 4.988 3 6.771v4.346l4.08-2.039c.96.28 1.94.422 2.92.422 5.514 0 10-4.262 10-9.5S17.514 2 12 2Zm0 2c4.411 0 8 3.365 8 7.5S16.411 19 12 19a8.461 8.461 0 0 1-2.361-.342l-.752-.219-.701.35L7 19.383V17.402l-.637-.591C4.861 15.409 4 13.472 4 11.5 4 7.365 7.589 4 12 4Zm-1 5-5 5 4.5-2 2.5 2 5-5-4.5 2L11 9Z"
    };
    var microsoft_excel = {
      name: "microsoft_excel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3 2 5v14l12 2v-2h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-7V3Zm-2 2.361V18.64l-8-1.332V6.693l8-1.332ZM14 7h2v2h-2V7Zm4 0h2v2h-2V7ZM5.176 8.297l1.885 3.697L5 15.704h1.736l1.123-2.395c.075-.23.126-.4.15-.514h.016c.041.238.091.407.133.492l1.113 2.414H11l-1.994-3.734 1.937-3.67h-1.62l-1.03 2.197c-.1.285-.167.505-.201.647h-.026a4.519 4.519 0 0 0-.19-.63l-.923-2.214H5.176ZM14 11h2v2h-2v-2Zm4 0h2v2h-2v-2Zm-4 4h2v2h-2v-2Zm4 0h2v2h-2v-2Z"
    };
    var microsoft_word = {
      name: "microsoft_word",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3 2 5v14l12 2v-2h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-7V3Zm-2 2.361V18.64l-8-1.332V6.693l8-1.332ZM14 7h6v2h-6V7ZM4.5 8.5l1.299 7h1.293l.847-3.742a5.68 5.68 0 0 0 .09-.783h.018c.008.288.031.549.072.783l.83 3.742h1.242l1.309-7h-1.365l-.451 3.223c-.033.27-.059.53-.067.783h-.015a7.206 7.206 0 0 0-.082-.748L8.967 8.5H7.2l-.594 3.268a5.285 5.285 0 0 0-.1.82h-.025a5.965 5.965 0 0 0-.064-.803L5.951 8.5H4.5ZM14 11h6v2h-6v-2Zm0 4h6v2h-6v-2Z"
    };
    var microsoft_powerpoint = {
      name: "microsoft_powerpoint",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3 2 5v14l12 2v-2h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-7V3Zm-2 2.361V18.64l-8-1.332V6.693l8-1.332ZM14 7h6v10h-6v-2h4v-2h-4V7Zm0 3a2 2 0 1 0 4 0h-2V8a2 2 0 0 0-2 2ZM4.988 8v8H6.5v-2.969h1.545c.93 0 1.653-.216 2.17-.652.517-.437.773-1.047.773-1.832 0-.766-.263-1.384-.79-1.85C9.668 8.232 8.957 8 8.06 8H4.988ZM6.5 9.188h1.506c.436.005.777.128 1.025.365.25.236.375.55.375.945 0 .401-.123.708-.369.92-.246.212-.601.318-1.068.318H6.5V9.187Z"
    };
    var github = {
      name: "github",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.9 2.1c-4.6.5-8.3 4.2-8.8 8.7-.5 4.7 2.2 8.9 6.3 10.5.3.1.6-.1.6-.5v-1.6s-.4.1-.9.1c-1.4 0-2-1.2-2.1-1.9-.1-.4-.3-.7-.6-1-.3-.1-.4-.1-.4-.2 0-.2.3-.2.4-.2.6 0 1.1.7 1.3 1 .5.8 1.1 1 1.4 1 .4 0 .7-.1.9-.2.1-.7.4-1.4 1-1.8-2.3-.5-4-1.8-4-4 0-1.1.5-2.2 1.2-3-.1-.2-.2-.7-.2-1.4 0-.4 0-1 .3-1.6 0 0 1.4 0 2.8 1.3.5-.2 1.2-.3 1.9-.3s1.4.1 2 .3C15.3 6 16.8 6 16.8 6c.2.6.2 1.2.2 1.6 0 .8-.1 1.2-.2 1.4.7.8 1.2 1.8 1.2 3 0 2.2-1.7 3.5-4 4 .6.5 1 1.4 1 2.3v2.6c0 .3.3.6.7.5 3.7-1.5 6.3-5.1 6.3-9.3 0-6-5.1-10.7-11.1-10Z"
    };
    var spotify = {
      name: "spotify",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.489 2 2 6.489 2 12s4.489 10 10 10 10-4.489 10-10S17.511 2 12 2Zm0 2c4.43 0 8 3.57 8 8s-3.57 8-8 8-8-3.57-8-8 3.57-8 8-8Zm-1.31 4c-1.54 0-2.994.172-4.362.516-.342.085-.6.34-.6.853 0 .513.343.942.856.856.256 0 .343-.086.514-.086a16.488 16.488 0 0 1 3.592-.428c2.395 0 4.874.598 6.585 1.539.256.085.341.172.512.172.514 0 .857-.343.942-.856 0-.427-.255-.684-.512-.855C16.079 8.599 13.34 8 10.69 8Zm-.17 2.994c-1.454 0-2.48.257-3.506.514-.428.17-.6.341-.6.77 0 .341.256.683.684.683.17 0 .256 0 .427-.086.77-.171 1.797-.342 2.909-.342 2.223 0 4.276.512 5.73 1.453.171.085.343.172.514.172.427 0 .682-.342.77-.77 0-.255-.172-.512-.428-.683-1.883-1.112-4.105-1.71-6.5-1.71Zm.255 3.014c-1.197 0-2.31.17-3.421.428-.342 0-.512.255-.512.597 0 .342.255.6.597.6.086 0 .257-.086.428-.086.855-.171 1.881-.342 2.823-.342 1.71 0 3.336.427 4.619 1.197.17.085.256.17.427.17.256 0 .513-.17.684-.597 0-.342-.17-.429-.342-.6a10.864 10.864 0 0 0-5.303-1.367Z"
    };
    var youtube = {
      name: "youtube",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m5.68 2 1.478 5.344v2.562H8.44V7.344L9.937 2h-1.29l-.538 2.432c-.15.71-.247 1.214-.29 1.515h-.04c-.063-.42-.159-.93-.29-1.525L6.97 2H5.68Zm5.752 2.018c-.434 0-.784.084-1.051.257-.267.172-.464.448-.59.825-.125.377-.187.876-.187 1.498v.84c0 .615.054 1.107.164 1.478.11.371.295.644.556.82.261.176.62.264 1.078.264.446 0 .8-.087 1.06-.26.26-.173.45-.444.565-.818.116-.374.174-.869.174-1.485v-.84c0-.62-.059-1.118-.178-1.492-.119-.373-.308-.648-.566-.824-.258-.176-.598-.263-1.025-.263Zm2.447.113v4.314c0 .534.09.927.271 1.178.182.251.465.377.848.377.552 0 .968-.267 1.244-.8h.027l.114.706H17.4V4.131h-1.298v4.588a.635.635 0 0 1-.23.263.569.569 0 0 1-.325.104c-.132 0-.226-.054-.283-.164-.057-.11-.086-.295-.086-.553V4.131h-1.3Zm-2.477.781c.182 0 .311.095.383.287.072.191.108.495.108.91v1.8c0 .426-.036.735-.108.923-.072.188-.2.282-.38.283-.183 0-.309-.095-.378-.283-.07-.188-.103-.497-.103-.924V6.11c0-.414.035-.718.107-.91.072-.19.195-.287.371-.287ZM5 11c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7c0-1.1-.9-2-2-2H5Zm7.049 2h1.056v2.568h.008c.095-.186.232-.335.407-.449.175-.114.364-.17.566-.17.26 0 .463.07.611.207.148.138.257.361.323.668.066.308.097.736.097 1.281v.772h.002c0 .727-.088 1.26-.264 1.602-.175.341-.447.513-.818.513-.207 0-.394-.047-.564-.142a.93.93 0 0 1-.383-.391h-.024l-.11.46h-.907V13Zm-6.563.246h3.252v.885h-1.09v5.789H6.576v-5.79h-1.09v-.884Zm11.612 1.705c.376 0 .665.07.867.207.2.138.343.354.426.645.082.292.123.695.123 1.209v.836h-1.836v.248c0 .313.008.547.027.703.02.156.057.27.115.342.058.072.148.107.27.107.164 0 .277-.064.338-.191.06-.127.094-.338.1-.635l.947.055c.005.042.007.101.007.175 0 .451-.124.788-.37 1.01-.248.223-.595.334-1.046.334-.54 0-.92-.17-1.138-.51-.218-.339-.326-.863-.326-1.574v-.851c0-.733.112-1.267.338-1.604.225-.337.612-.506 1.158-.506Zm-8.688.094h1.1v3.58c0 .217.024.373.072.465.048.093.126.139.238.139a.486.486 0 0 0 .276-.088.538.538 0 0 0 .193-.223v-3.873h1.1v4.875h-.862l-.093-.598h-.026c-.234.452-.584.678-1.05.678-.325 0-.561-.106-.715-.318-.154-.212-.233-.544-.233-.994v-3.643Zm8.664.648c-.117 0-.204.036-.26.104-.055.069-.093.182-.11.338a6.506 6.506 0 0 0-.028.71v.35h.803v-.35c0-.312-.01-.548-.032-.71-.02-.162-.059-.276-.115-.342-.056-.066-.14-.1-.258-.1Zm-3.482.036a.418.418 0 0 0-.293.127.698.698 0 0 0-.192.326v2.767a.487.487 0 0 0 .438.256.337.337 0 0 0 .277-.127c.07-.085.12-.228.149-.43.029-.2.043-.48.043-.835v-.627c0-.383-.011-.676-.035-.883-.024-.207-.067-.357-.127-.444a.3.3 0 0 0-.26-.13Z"
    };
    var youtube_alt = {
      name: "youtube_alt",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 4s-6.254 0-7.814.418a2.503 2.503 0 0 0-1.768 1.768C2 7.746 2 12 2 12s0 4.255.418 5.814c.23.861.908 1.538 1.768 1.768C5.746 20 12 20 12 20s6.255 0 7.814-.418a2.505 2.505 0 0 0 1.768-1.768C22 16.255 22 12 22 12s0-4.254-.418-5.814a2.505 2.505 0 0 0-1.768-1.768C18.255 4 12 4 12 4Zm0 2c2.882 0 6.49.134 7.297.35a.508.508 0 0 1 .353.353c.241.898.35 3.639.35 5.297s-.109 4.398-.35 5.297a.508.508 0 0 1-.353.353c-.805.216-4.415.35-7.297.35-2.881 0-6.49-.134-7.297-.35a.508.508 0 0 1-.353-.353C4.109 16.399 4 13.658 4 12s.109-4.399.35-5.299a.505.505 0 0 1 .353-.351C5.508 6.134 9.118 6 12 6Zm-2 2.535v6.93L16 12l-6-3.465Z"
    };
    var apple_app_store = {
      name: "apple_app_store",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.489 2 2 6.489 2 12s4.489 10 10 10 10-4.489 10-10S17.511 2 12 2Zm0 2c4.43 0 8 3.57 8 8s-3.57 8-8 8-8-3.57-8-8 3.57-8 8-8Zm-.611 1.64-1.748.971 1.214 2.19L9.079 12h2.287L12 10.86l1.145-2.06 1.214-2.189-1.748-.97L12 6.74l-.611-1.1Zm2.328 4.19-1.145 2.059.36.646 1.353 2.438-.015.017-.006.012h.037l1.31 2.357 1.748-.97L16.588 15H18v-2h-2.523l-1.76-3.17ZM6 13v2h1.412l-.771 1.389 1.748.97L9.699 15h3.457l-1.11-2H7c-.014 0-.025.007-.04.008L6.948 13H6Z"
    };
    var twitter = {
      name: "twitter",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2H5Zm0 2h14l.002 14H5V5Zm9.566 2.113A2.488 2.488 0 0 0 12.08 9.6c0 .257.086.428.086.6-2.057-.086-3.857-1.114-5.057-2.571-.257.343-.343.77-.343 1.2 0 .856.429 1.544 1.115 2.144-.428-.086-.772-.173-1.115-.344 0 1.2.856 2.143 1.97 2.4-.257.086-.428.086-.685.086-.086 0-.259-.086-.43-.086.343.943 1.2 1.713 2.315 1.713-.857.6-1.972 1.03-3.086 1.03h-.6c1.114.684 2.4 1.115 3.771 1.115 4.543 0 7.03-3.773 7.03-7.03v-.343a5.786 5.786 0 0 0 1.201-1.287c-.514.258-.943.343-1.457.43.514-.343.942-.772 1.113-1.372-.429.257-.943.514-1.543.6-.429-.514-1.113-.772-1.799-.772Z"
    };
    var apple_logo = {
      name: "apple_logo",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 1c-1.135 0-2.231.48-2.957 1.268-.656.717-1.055 1.99-1.055 3.013 1.172 0 2.424-.6 3.12-1.402C15.754 3.128 16 2.209 16 1ZM8.275 5.514C6.181 5.514 3 7.48 3 12.11 3 16.324 6.767 21 8.893 21h.029c1.269 0 1.712-.823 3.451-.832 1.739.009 2.183.832 3.451.832h.03c1.541 0 3.941-2.464 5.146-5.424A3.99 3.99 0 0 1 18.785 12c0-1.539.867-2.86 2.125-3.53-1.087-2.043-3.014-2.956-4.44-2.956-1.538 0-2.825 1.04-4.097 1.04-1.272 0-2.559-1.04-4.098-1.04Zm0 2c.432 0 .963.204 1.524.422.748.29 1.594.619 2.574.619.98 0 1.828-.33 2.576-.62.56-.216 1.09-.421 1.522-.421.418 0 1.068.196 1.677.683A5.977 5.977 0 0 0 16.788 12c0 1.597.62 3.08 1.69 4.18-.99 1.685-2.216 2.706-2.668 2.82-.152-.002-.261-.042-.636-.203-.577-.248-1.45-.622-2.813-.629-1.34.007-2.212.38-2.789.629-.358.154-.474.196-.64.201C7.942 18.757 5 15.438 5 12.111c0-3.473 2.207-4.596 3.275-4.597Z"
    };
    var instagram = {
      name: "instagram",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 3C5.243 3 3 5.243 3 8v8c0 2.757 2.243 5 5 5h8c2.757 0 5-2.243 5-5V8c0-2.757-2.243-5-5-5H8Zm0 2h8c1.654 0 3 1.346 3 3v8c0 1.654-1.346 3-3 3H8c-1.654 0-3-1.346-3-3V8c0-1.654 1.346-3 3-3Zm9 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-5 1c-2.757 0-5 2.243-5 5s2.243 5 5 5 5-2.243 5-5-2.243-5-5-5Zm0 2c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3Z"
    };
    var facebook = {
      name: "facebook",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2H19c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2H5Zm0 2h14l.002 14h-4.588v-3.965h2.365l.352-2.725H14.43v-1.736c0-.788.22-1.32 1.35-1.32h1.427V6.822a20.013 20.013 0 0 0-2.092-.103c-2.074 0-3.494 1.266-3.494 3.59v2.006H9.277v2.724h2.344V19H5V5Z"
    };
    var chrome = {
      name: "chrome",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C8.728 2 5.832 3.579 4.008 6.008A9.942 9.942 0 0 0 2 12c0 5.197 3.964 9.465 9.033 9.951.318.03.64.049.967.049 5.523 0 10-4.477 10-10S17.523 2 12 2Zm0 2c2.953 0 5.532 1.613 6.918 4h-3.945C14.14 7.38 13.118 7 12 7c-1.897 0-3.526 1.07-4.373 2.627l-2.19-2.19A7.993 7.993 0 0 1 12 4ZM5.037 8.074 7 12a5 5 0 0 0 5 5c.236 0 .461-.038.69-.07l-1.018 3.054C7.414 19.81 4 16.3 4 12c0-1.427.38-2.765 1.037-3.926Zm14.238.615C19.737 9.7 20 10.82 20 12c0 4.294-3.404 7.8-7.654 7.982L15 16h-.027C16.196 15.089 17 13.643 17 12c0-.789-.2-1.525-.525-2.19l2.8-1.12ZM12 9a3 3 0 1 1 0 6 3 3 0 0 1 0-6Z"
    };
    var ios_logo = {
      name: "ios_logo",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.533 2.977a4.567 4.567 0 0 0-4.556 4.556v8.889a4.567 4.567 0 0 0 4.556 4.556h8.889a4.567 4.567 0 0 0 4.556-4.556V7.533a4.567 4.567 0 0 0-4.556-4.556H7.533Zm0 2h8.889a2.522 2.522 0 0 1 2.556 2.556v8.889a2.522 2.522 0 0 1-2.556 2.556H7.533a2.522 2.522 0 0 1-2.556-2.556V7.533a2.522 2.522 0 0 1 2.556-2.556ZM6.5 9a.5.5 0 1 0 0 1 .5.5 0 0 0 0-1Zm4 0C8.961 9 8 10.152 8 12c0 1.844.943 3 2.5 3 1.553 0 2.5-1.16 2.5-3 0-1.844-.954-3-2.5-3ZM16 9c-.558 0-1.07.18-1.435.53-.366.348-.565.853-.565 1.398 0 .53.354.96.727 1.164.372.204.774.29 1.142.39.386.105.735.2.924.303.189.104.207.107.207.287 0 .317-.097.527-.254.676-.157.15-.396.252-.746.252-.324 0-.566-.093-.727-.242-.16-.15-.273-.367-.273-.758h-1c0 .61.216 1.141.594 1.492S15.479 15 16 15c.558 0 1.07-.179 1.436-.527.366-.349.564-.855.564-1.4 0-.531-.354-.96-.727-1.165-.372-.204-.774-.29-1.142-.39-.385-.105-.735-.2-.924-.303-.189-.104-.207-.108-.207-.287 0-.316.097-.526.254-.676.157-.15.396-.252.746-.252.324 0 .566.093.727.242.16.15.273.367.273.758h1c0-.61-.216-1.141-.594-1.492S16.521 9 16 9Zm-5.5 1c1.305 0 1.5 1.253 1.5 2 0 .747-.195 2-1.5 2C9.26 14 9 12.912 9 12c0-.747.195-2 1.5-2ZM6 11v4h1v-4H6Z"
    };
    var linkedin = {
      name: "linkedin",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5Zm0 2h14v14H5V5Zm2.78 1.316c-.858 0-1.372.516-1.372 1.202 0 .686.514 1.199 1.285 1.199.857 0 1.371-.513 1.371-1.2 0-.685-.514-1.2-1.285-1.2ZM6.476 10v7H9v-7H6.477Zm4.605 0v7h2.523v-3.826c0-1.14.813-1.303 1.057-1.303s.897.245.897 1.303V17H18v-3.826C18 10.977 17.024 10 15.803 10s-1.873.407-2.198.977V10h-2.523Z"
    };
    var microsoft_edge = {
      name: "microsoft_edge",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.644 8.586c-.17-.711-.441-1.448-.774-2.021-.771-1.329-1.464-2.237-3.177-3.32C14.98 2.162 13.076 2 12.17 2c-2.415 0-4.211.86-5.525 1.887C3.344 6.47 3 11 3 11s1.221-2.045 3.54-3.526C7.943 6.579 9.941 6 11.568 6 15.885 6 16 10 16 10H9c0-2 1-3 1-3s-5 2-5 7.044c0 .487-.003 1.372.248 2.283.232.843.7 1.705 1.132 2.353 1.221 1.832 3.045 2.614 3.916 2.904.996.332 2.029.416 3.01.416 2.72 0 4.877-.886 5.694-1.275v-4.172c-.758.454-2.679 1.447-5 1.447-5 0-5-4-5-4h12v-2.49s-.039-1.593-.356-2.924Z"
    };
    var microsoft_onedrive = {
      name: "microsoft_onedrive",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 5c-1.811 0-3.382.972-4.26 2.414A3.958 3.958 0 0 0 7 7a4 4 0 0 0-4 4c0 .36.063.703.152 1.035A2.493 2.493 0 0 0 3.5 17h.55c-.018-.166-.05-.329-.05-.5a4.509 4.509 0 0 1 3.287-4.334A6.01 6.01 0 0 1 13 8c1.322 0 2.57.426 3.594 1.203.42-.125.86-.186 1.304-.195A5 5 0 0 0 13 5Zm0 5a4 4 0 0 0-4 4c0 .018.006.034.006.05A2.5 2.5 0 1 0 8.5 19H21a2 2 0 1 0 0-4c-.065 0-.125.014-.19.02.117-.32.19-.66.19-1.02a3 3 0 0 0-3-3c-.68 0-1.302.235-1.805.617A3.981 3.981 0 0 0 13 10Z"
    };
    var google_play = {
      name: "google_play",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.602 2.01a1.45 1.45 0 0 0-.344.002c-.019.002-.036 0-.055.004a1 1 0 0 0-.59.26A1.601 1.601 0 0 0 3 3.503v17.088c0 .432.206.984.701 1.252s1.056.146 1.424-.076l.002-.002c-.06.036.276-.16.701-.4l1.715-.973c1.4-.793 3.238-1.832 5.08-2.873 1.842-1.042 3.687-2.083 5.096-2.881l1.732-.983c.432-.245.645-.366.776-.445.388-.235.78-.69.773-1.275-.008-.586-.402-1.014-.775-1.225A21953.353 21953.353 0 0 1 7.713 3.635L6 2.662c-.426-.242-.747-.428-.715-.408h-.002a1.764 1.764 0 0 0-.681-.244ZM5 5.35l5.756 6.607L5 18.567V5.35Zm3.596 1.084 3.177 1.797 1.493.843-1.184 1.36-3.486-4Zm6.445 3.642 3.338 1.887c-.426.242-.976.556-1.647.936l-1.683.953a.999.999 0 0 0-.063-.084l-1.578-1.81 1.578-1.813a.999.999 0 0 0 .055-.069Zm-2.959 3.404 1.195 1.372-1.638.927-3.073 1.739 3.516-4.038Z"
    };
    var google_maps = {
      name: "google_maps",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.5 2A3.5 3.5 0 0 0 15 5.5c0 2.625 3.063 3.927 3.063 7 0 .241.196.453.437.453s.473-.178.473-.418C18.972 9.461 22 8 22 5.5A3.5 3.5 0 0 0 18.5 2ZM5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7s-.125 2.375-2 3v2.586L13.414 12l1.73-1.73-1.226-1.602L5 17.586V5h8c.125-1.25.625-2 .625-2H5Zm13.533 1.299a1.167 1.167 0 1 1 .002 2.334 1.167 1.167 0 0 1-.002-2.334ZM8.502 6a2.5 2.5 0 1 0 0 5c2.099 0 2.56-1.963 2.355-2.938l-2.355-.001v.955h1.36c-.179.579-.66.992-1.36.992A1.51 1.51 0 0 1 6.992 8.5 1.51 1.51 0 0 1 9.48 7.355l.705-.703A2.493 2.493 0 0 0 8.502 6ZM12 13.414 17.586 19H6.414L12 13.414Z"
    };
    var microsoft_outlook = {
      name: "microsoft_outlook",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2 2 4v16l12 2V2Zm1 5v2.25l2 1.156 4-2.312v1.594L17 12l-2-1.156V15h1.344c.562-1.18 1.761-2 3.156-2 .977 0 1.863.387 2.5 1.031V8c0-.602-.398-1-1-1h-6ZM7.594 8c1.02 0 1.832.371 2.468 1.094.63.722.938 1.664.938 2.844 0 1.21-.309 2.226-.969 2.968C9.383 15.648 8.52 16 7.47 16c-1.028 0-1.864-.371-2.5-1.094C4.32 14.184 4 13.254 4 12.094c0-1.223.309-2.215.969-2.969C5.629 8.371 6.512 8 7.594 8ZM7.53 9.5a1.57 1.57 0 0 0-1.343.688c-.329.457-.5 1.058-.5 1.812 0 .773.171 1.395.5 1.844.328.449.765.656 1.312.656.555 0 .992-.23 1.313-.656.328-.438.5-1.04.5-1.813 0-.793-.16-1.406-.47-1.844A1.544 1.544 0 0 0 7.532 9.5ZM19.5 14a2.497 2.497 0 0 0-2.5 2.5c0 1.383 1.117 2.5 2.5 2.5s2.5-1.117 2.5-2.5-1.117-2.5-2.5-2.5Zm-.5 1h1v1h1v1h-2v-2Z"
    };
    var power_bi = {
      name: "power_bi",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h2v-2H4V6h16v12h-1v2h1c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2ZM7 15h2v5H7v-5ZM10 13h2v7h-2v-7ZM13 14h2v6h-2v-6ZM16 11h2v9h-2v-9Z"
    };
    var slack = {
      name: "slack",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.362 14.11a1.682 1.682 0 0 1-3.362 0 1.688 1.688 0 0 1 1.681-1.682h1.681v1.681Zm.847 0a1.688 1.688 0 0 1 1.682-1.682 1.688 1.688 0 0 1 1.68 1.681v4.21A1.688 1.688 0 0 1 9.892 20a1.684 1.684 0 0 1-1.682-1.681v-4.21Zm1.682-6.747A1.684 1.684 0 0 1 8.209 5.68 1.688 1.688 0 0 1 9.891 4a1.688 1.688 0 0 1 1.68 1.681v1.681h-1.68Zm0 .846a1.686 1.686 0 0 1 1.68 1.682 1.686 1.686 0 0 1-1.68 1.68H5.68A1.688 1.688 0 0 1 4 9.892a1.684 1.684 0 0 1 1.681-1.682h4.21Zm6.746 1.682a1.682 1.682 0 0 1 1.682-1.682A1.688 1.688 0 0 1 20 9.891a1.688 1.688 0 0 1-1.681 1.68h-1.681v-1.68Zm-.846 0a1.688 1.688 0 0 1-1.682 1.68 1.686 1.686 0 0 1-1.68-1.68V5.68A1.688 1.688 0 0 1 14.108 4a1.682 1.682 0 0 1 1.682 1.681v4.21Zm-1.682 6.746a1.68 1.68 0 0 1 1.682 1.682A1.686 1.686 0 0 1 14.109 20a1.688 1.688 0 0 1-1.68-1.681v-1.681h1.68Zm0-.846a1.688 1.688 0 0 1-1.68-1.682 1.686 1.686 0 0 1 1.68-1.68h4.21A1.688 1.688 0 0 1 20 14.108a1.682 1.682 0 0 1-1.681 1.682h-4.21Z"
    };
    var blocked_off = {
      name: "blocked_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.5 11.5c0-4.41-3.59-8-8-8-1.41 0-2.73.37-3.87 1.01L7.17 3.05A9.9 9.9 0 0 1 12.5 1.5c5.52 0 10 4.48 10 10 0 1.96-.57 3.79-1.55 5.34l-1.46-1.46a7.95 7.95 0 0 0 1.01-3.88Zm-5.88-1h2.88v2h-.88l-2-2ZM2.91 1.63 1.5 3.04l2.78 2.78A9.92 9.92 0 0 0 2.5 11.5c0 5.52 4.48 10 10 10 2.11 0 4.07-.66 5.68-1.78l2.78 2.78 1.41-1.41L2.91 1.63ZM4.5 11.5c0 4.41 3.59 8 8 8 1.56 0 3-.45 4.23-1.23l-5.77-5.77H7.5v-2h1.46L5.73 7.27A7.846 7.846 0 0 0 4.5 11.5Z"
    };
    var blocked = {
      name: "blocked",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm5-9H7v2h10v-2Z"
    };
    var security = {
      name: "security",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3 5 9-4 9 4v6c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5Zm16 6.99h-7v-8.8L5 6.3V12h7v8.93c3.72-1.15 6.47-4.82 7-8.94Z"
    };
    var flagged_off = {
      name: "flagged_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 3.5h9l.4 2h5.6v10h-7l-.4-2H6.5v7h-2v-17Zm7.44 2.39-.08-.39H6.5v6h7.24l.32 1.61.08.39h3.36v-6h-5.24l-.32-1.61Z"
    };
    var lock_add = {
      name: "lock_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 8.5h1c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2v-10c0-1.1.9-2 2-2h1v-2c0-2.76 2.24-5 5-5s5 2.24 5 5v2Zm-5-5.1c-1.71 0-3.1 1.39-3.1 3.1v2h6.2v-2c0-1.71-1.39-3.1-3.1-3.1ZM6 20.5v-10h12v10H6Zm5-6v-3h2v3h3v2h-3v3h-2v-3H8v-2h3Z"
    };
    var lock_off = {
      name: "lock_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.805 6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2h-4.66l2 2h5.56v5.56l2 2V10c0-1.1-.9-2-2-2h-1V6c0-2.76-2.24-5-5-5-2.32 0-4.26 1.59-4.82 3.74l1.72 1.72V6Zm-4.49-1.19-1.41 1.41 2.04 2.04c-.62.34-1.04.99-1.04 1.74v10c0 1.1.9 2 2 2h12.78l1 1 1.41-1.41L4.315 4.81ZM5.905 10v10h10.78l-10-10h-.78Z"
    };
    var lock = {
      name: "lock",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 8.5h1c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2v-10c0-1.1.9-2 2-2h1v-2c0-2.76 2.24-5 5-5s5 2.24 5 5v2Zm-5-5c-1.66 0-3 1.34-3 3v2h6v-2c0-1.66-1.34-3-3-3Zm-6 17v-10h12v10H6Zm8-5c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2Z"
    };
    var lock_open = {
      name: "lock_open",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 8.5h-1v-2c0-2.76-2.24-5-5-5s-5 2.24-5 5h2c0-1.66 1.34-3 3-3s3 1.34 3 3v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-10c0-1.1-.9-2-2-2Zm-12 12v-10h12v10H6Zm8-5c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2Z"
    };
    var verified = {
      name: "verified",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 1H5c-1.1 0-1.99.9-1.99 2L3 15.93c0 .69.35 1.3.88 1.66L12 23l8.11-5.41c.53-.36.88-.97.88-1.66L21 3c0-1.1-.9-2-2-2Zm-7 19.6-7-4.66V3h14v12.93l-7 4.67ZM7.41 10.59l2.58 2.59 6.59-6.6L18 8l-8 8-4-4 1.41-1.41Z"
    };
    var verified_user = {
      name: "verified_user",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4Zm7 10c0 4.52-2.98 8.69-7 9.93-4.02-1.24-7-5.41-7-9.93V6.3l7-3.11 7 3.11V11ZM6 13l1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8-4-4Z"
    };
    var flagged = {
      name: "flagged",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.4 6 14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6Z"
    };
    var visibility = {
      name: "visibility",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6a9.77 9.77 0 0 1 8.82 5.5A9.77 9.77 0 0 1 12 17a9.77 9.77 0 0 1-8.82-5.5A9.77 9.77 0 0 1 12 6Zm0-2C7 4 2.73 7.11 1 11.5 2.73 15.89 7 19 12 19s9.27-3.11 11-7.5C21.27 7.11 17 4 12 4Zm0 5a2.5 2.5 0 0 1 0 5 2.5 2.5 0 0 1 0-5Zm0-2c-2.48 0-4.5 2.02-4.5 4.5S9.52 16 12 16s4.5-2.02 4.5-4.5S14.48 7 12 7Z"
    };
    var key$1 = {
      name: "key",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 19h-6v-4h-2.68c-1.14 2.42-3.6 4-6.32 4-3.86 0-7-3.14-7-7s3.14-7 7-7c2.72 0 5.17 1.58 6.32 4H24v6h-2v4Zm-4-2h2v-4h2v-2H11.94l-.23-.67C11.01 8.34 9.11 7 7 7c-2.76 0-5 2.24-5 5s2.24 5 5 5c2.11 0 4.01-1.34 4.71-3.33l.23-.67H18v4ZM7 15c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3Zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1Z"
    };
    var visibility_off = {
      name: "visibility_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6a9.77 9.77 0 0 1 8.82 5.5 9.647 9.647 0 0 1-2.41 3.12l1.41 1.41c1.39-1.23 2.49-2.77 3.18-4.53C21.27 7.11 17 4 12 4c-1.27 0-2.49.2-3.64.57l1.65 1.65C10.66 6.09 11.32 6 12 6Zm-1.07 1.14L13 9.21c.57.25 1.03.71 1.28 1.28l2.07 2.07c.08-.34.14-.7.14-1.07C16.5 9.01 14.48 7 12 7c-.37 0-.72.05-1.07.14ZM2.01 3.87l2.68 2.68A11.738 11.738 0 0 0 1 11.5C2.73 15.89 7 19 12 19c1.52 0 2.98-.29 4.32-.82l3.42 3.42 1.41-1.41L3.42 2.45 2.01 3.87Zm7.5 7.5 2.61 2.61c-.04.01-.08.02-.12.02a2.5 2.5 0 0 1-2.5-2.5c0-.05.01-.08.01-.13Zm-3.4-3.4 1.75 1.75a4.6 4.6 0 0 0-.36 1.78 4.507 4.507 0 0 0 6.27 4.14l.98.98c-.88.24-1.8.38-2.75.38a9.77 9.77 0 0 1-8.82-5.5c.7-1.43 1.72-2.61 2.93-3.53Z"
    };
    var business = {
      name: "business",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 7h10v14H2V3h10v4ZM4 19h2v-2H4v2Zm2-4H4v-2h2v2Zm-2-4h2V9H4v2Zm2-4H4V5h2v2Zm2 12h2v-2H8v2Zm2-4H8v-2h2v2Zm-2-4h2V9H8v2Zm2-4H8V5h2v2Zm10 12V9h-8v2h2v2h-2v2h2v2h-2v2h8Zm-2-8h-2v2h2v-2Zm-2 4h2v2h-2v-2Z"
    };
    var meeting_room = {
      name: "meeting_room",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 19V4h-4V3H5v16H3v2h12V6h2v15h4v-2h-2Zm-6 0H7V5h6v14Zm-1-8h-2v2h2v-2Z"
    };
    var meeting_room_off = {
      name: "meeting_room_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m2.975 1.565-1.41 1.41 4 4v11.46h-2v2h11v-4.46l6.46 6.46 1.41-1.41-19.46-19.46Zm9.59 2.87v3.88l2 2v-4.88h3v7.88l2 2V3.435h-5v-1h-7.88l2 2h3.88Zm-5 14h5v-4.46l-5-5v9.46Z"
    };
    var pool = {
      name: "pool",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m10 8-3.25 3.25c.28.108.51.241.707.354l.063.036c.37.23.59.36 1.15.36.56 0 .78-.13 1.15-.36l.013-.007c.458-.27 1.077-.633 2.177-.633 1.11 0 1.73.37 2.18.64l.01.007c.365.216.595.353 1.14.353.55 0 .78-.13 1.15-.36.12-.07.26-.15.41-.23L10.48 5C8.93 3.45 7.5 2.99 5 3v2.5c1.82-.01 2.89.39 4 1.5l1 1Zm-3.51 7.854c-.365-.217-.595-.354-1.14-.354-.55 0-.78.13-1.15.36l-.03.017c-.466.268-1.083.623-2.17.623v-2c.56 0 .78-.13 1.15-.36.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64l.01.007c.365.216.595.353 1.14.353.56 0 .78-.13 1.15-.36.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64l.01.007c.364.216.595.353 1.14.353.55 0 .78-.13 1.15-.36.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64l.01.007c.364.216.595.353 1.14.353v2c-1.1-.01-1.71-.37-2.16-.64l-.01-.006c-.364-.217-.595-.354-1.14-.354-.56 0-.78.13-1.15.36-.45.27-1.07.64-2.18.64s-1.73-.37-2.18-.64l-.01-.006c-.364-.217-.595-.354-1.14-.354-.56 0-.78.13-1.15.36-.45.27-1.07.64-2.18.64s-1.73-.37-2.18-.64l-.01-.006ZM18.67 18c-1.11 0-1.73.37-2.18.64-.37.23-.6.36-1.15.36-.545 0-.775-.137-1.14-.353l-.01-.007c-.45-.27-1.07-.64-2.18-.64-1.1 0-1.719.363-2.177.633l-.013.007c-.37.23-.59.36-1.15.36-.56 0-.78-.13-1.15-.36-.45-.27-1.07-.64-2.18-.64-1.1 0-1.719.363-2.177.633l-.013.007c-.37.23-.59.36-1.15.36v2c1.1 0 1.719-.363 2.177-.632l.013-.008c.37-.23.6-.36 1.15-.36.55 0 .78.13 1.15.36.45.27 1.07.64 2.18.64 1.1 0 1.719-.363 2.177-.632l.013-.008c.37-.23.59-.36 1.15-.36.545 0 .776.137 1.14.354l.01.006c.45.27 1.07.64 2.18.64 1.09 0 1.698-.357 2.156-.625l.024-.015c.37-.23.59-.36 1.15-.36.545 0 .775.137 1.14.354l.01.006c.45.27 1.07.64 2.18.64v-2c-.56 0-.78-.13-1.15-.36-.45-.27-1.07-.64-2.18-.64ZM14 5.5a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z"
    };
    var cafe = {
      name: "cafe",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h16c1.11 0 2 .89 2 2v3a2 2 0 0 1-2 2h-2v3c0 2.21-1.79 4-4 4H7c-2.21 0-4-1.79-4-4V3Zm16 16H3v2h16v-2Zm-4-6c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V5h10v8Zm2-5h2V5h-2v3Z"
    };
    var gym = {
      name: "gym",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.57 14.86 22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29l-1.43-1.43Z"
    };
    var beach = {
      name: "beach",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.115 3.001c-2.58 0-5.16.98-7.14 2.95l-.01.01c-3.95 3.95-3.95 10.36 0 14.31l14.3-14.31a10.086 10.086 0 0 0-7.15-2.96Zm7.882 16.57-1.429 1.428-6.441-6.442 1.428-1.428 6.442 6.441ZM4.995 13.12c0 1.49.4 2.91 1.14 4.15l1.39-1.38a11.285 11.285 0 0 1-2.07-5.44c-.3.85-.46 1.74-.46 2.67Zm3.98 1.31c-1.35-2.05-1.86-4.5-1.38-6.83.58-.12 1.16-.18 1.75-.18 1.8 0 3.55.55 5.08 1.56l-5.45 5.45Zm4.14-9.43c-.93 0-1.82.16-2.67.46 1.91.19 3.78.89 5.43 2.07l1.39-1.39a8.063 8.063 0 0 0-4.15-1.14Z"
    };
    var world = {
      name: "world",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2ZM4 12c0-.61.08-1.21.21-1.78L8.99 15v1c0 1.1.9 2 2 2v1.93C7.06 19.43 4 16.07 4 12Zm11.99 4c.9 0 1.64.59 1.9 1.4A7.991 7.991 0 0 0 20 12c0-3.35-2.08-6.23-5.01-7.41V5c0 1.1-.9 2-2 2h-2v2c0 .55-.45 1-1 1h-2v2h6c.55 0 1 .45 1 1v3h1Z"
    };
    var school = {
      name: "school",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 3 1 9l4 2.18v6L12 21l7-3.82v-6l2-1.09V17h2V9L12 3Zm6.82 6L12 12.72 5.18 9 12 5.28 18.82 9ZM12 18.72l5-2.73v-3.72L12 15l-5-2.73v3.72l5 2.73Z"
    };
    var city = {
      name: "city",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 5.5v6h6v10H3v-14h6v-2l3-3 3 3Zm-10 14h2v-2H5v2Zm2-4H5v-2h2v2Zm-2-4h2v-2H5v2Zm6 8v-2h2v2h-2Zm0-6v2h2v-2h-2Zm0-2v-2h2v2h-2Zm0-6v2h2v-2h-2Zm8 14h-2v-2h2v2Zm-2-4h2v-2h-2v2Z"
    };
    var account_circle = {
      name: "account_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2ZM7.07 18.28c.43-.9 3.05-1.78 4.93-1.78s4.51.88 4.93 1.78A7.893 7.893 0 0 1 12 20c-1.86 0-3.57-.64-4.93-1.72ZM12 14.5c1.46 0 4.93.59 6.36 2.33A7.95 7.95 0 0 0 20 12c0-4.41-3.59-8-8-8s-8 3.59-8 8c0 1.82.62 3.49 1.64 4.83 1.43-1.74 4.9-2.33 6.36-2.33ZM12 6c-1.94 0-3.5 1.56-3.5 3.5S10.06 13 12 13s3.5-1.56 3.5-3.5S13.94 6 12 6Zm-1.5 3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5S12.83 8 12 8s-1.5.67-1.5 1.5Z"
    };
    var users_circle = {
      name: "users_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm.51 7.99c0-1.65-1.35-3-3-3s-3 1.35-3 3 1.35 3 3 3 3-1.35 3-3Zm-3 1c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1Zm8.5 0c0 1.11-.89 2-2 2-1.11 0-2-.89-2-2-.01-1.11.89-2 2-2 1.11 0 2 .89 2 2ZM9.51 16c-1.39 0-2.98.57-3.66 1.11a7.935 7.935 0 0 0 5.66 2.86v-2.78c0-1.89 2.98-2.7 4.5-2.7.88 0 2.24.28 3.24.87.48-1.03.75-2.17.75-3.37 0-4.41-3.59-8-8-8s-8 3.59-8 8c0 1.23.28 2.39.78 3.43 1.34-.98 3.43-1.43 4.73-1.43.44 0 .97.06 1.53.16-.63.57-1.06 1.22-1.3 1.86-.041 0-.083-.003-.123-.005A1.646 1.646 0 0 0 9.51 16Z"
    };
    var face = {
      name: "face",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 12c0 5.52-4.48 10-10 10S2 17.52 2 12 6.48 2 12 2s10 4.48 10 10ZM9 14.25a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5ZM13.75 13a1.25 1.25 0 1 1 2.5 0 1.25 1.25 0 0 1-2.5 0Zm3.75-5c-2.9 0-5.44-1.56-6.84-3.88.43-.07.88-.12 1.34-.12 2.9 0 5.44 1.56 6.84 3.88-.43.07-.88.12-1.34.12ZM4.42 9.47a8.046 8.046 0 0 0 3.66-4.44 8.046 8.046 0 0 0-3.66 4.44Zm15.25.29c.21.71.33 1.46.33 2.24 0 4.41-3.59 8-8 8s-8-3.59-8-8l.002-.05c.002-.033.005-.064-.002-.09 2.6-.98 4.69-2.99 5.74-5.55A10 10 0 0 0 17.5 10c.75 0 1.47-.09 2.17-.24Z"
    };
    var group$1 = {
      name: "group",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 12c1.93 0 3.5-1.57 3.5-3.5S10.93 5 9 5 5.5 6.57 5.5 8.5 7.07 12 9 12Zm-7 5.25c0-2.33 4.66-3.5 7-3.5s7 1.17 7 3.5V19H2v-1.75Zm7-1.5c-1.79 0-3.82.67-4.66 1.25h9.32c-.84-.58-2.87-1.25-4.66-1.25Zm1.5-7.25C10.5 7.67 9.83 7 9 7s-1.5.67-1.5 1.5S8.17 10 9 10s1.5-.67 1.5-1.5Zm5.54 5.31c1.16.84 1.96 1.96 1.96 3.44V19h4v-1.75c0-2.02-3.5-3.17-5.96-3.44ZM18.5 8.5c0 1.93-1.57 3.5-3.5 3.5-.54 0-1.04-.13-1.5-.35.63-.89 1-1.98 1-3.15s-.37-2.26-1-3.15c.46-.22.96-.35 1.5-.35 1.93 0 3.5 1.57 3.5 3.5Z"
    };
    var group_add = {
      name: "group_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 12c1.93 0 3.5-1.57 3.5-3.5S13.93 5 12 5 8.5 6.57 8.5 8.5 10.07 12 12 12Zm-7 3v-3h3v-2H5V7H3v3H0v2h3v3h2Zm7-1.25c-2.34 0-7 1.17-7 3.5V19h14v-1.75c0-2.33-4.66-3.5-7-3.5Zm0 2c-1.79 0-3.82.67-4.66 1.25h9.32c-.84-.58-2.87-1.25-4.66-1.25Zm1.5-7.25c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5.67 1.5 1.5 1.5 1.5-.67 1.5-1.5ZM17 12c1.93 0 3.5-1.57 3.5-3.5S18.93 5 17 5c-.24 0-.48.02-.71.07a5.416 5.416 0 0 1-.02 6.85c.24.05.48.08.73.08Zm4 5.25c0-1.36-.68-2.42-1.68-3.23 2.24.47 4.68 1.54 4.68 3.23V19h-3v-1.75Z"
    };
    var person = {
      name: "person",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4Zm2 4c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2Zm4 10c-.2-.71-3.3-2-6-2-2.69 0-5.77 1.28-6 2h12ZM4 18c0-2.66 5.33-4 8-4s8 1.34 8 4v2H4v-2Z"
    };
    var person_add = {
      name: "person_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4Zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2ZM7 18c0-2.66 5.33-4 8-4s8 1.34 8 4v2H7v-2Zm2 0c.22-.72 3.31-2 6-2 2.7 0 5.8 1.29 6 2H9Zm-3-6v3H4v-3H1v-2h3V7h2v3h3v2H6Z"
    };
    var baby = {
      name: "baby",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.13 8.17c1.45.43 2.56 1.66 2.81 3.17.04.21.06.43.06.66 0 .23-.02.45-.06.66a3.998 3.998 0 0 1-2.8 3.17 9.086 9.086 0 0 1-2.17 2.89A8.93 8.93 0 0 1 12 21c-2.29 0-4.38-.86-5.96-2.28-.9-.8-1.65-1.78-2.17-2.89a4.008 4.008 0 0 1-2.81-3.17C1.02 12.45 1 12.23 1 12c0-.23.02-.45.06-.66a3.994 3.994 0 0 1 2.81-3.17c.52-1.11 1.27-2.1 2.19-2.91A8.885 8.885 0 0 1 12 3c2.28 0 4.36.85 5.94 2.26.91.81 1.66 1.79 2.19 2.91ZM9.5 9.25a1.25 1.25 0 1 0 0 2.5 1.25 1.25 0 0 0 0-2.5Zm5 0a1.25 1.25 0 1 0 0 2.5 1.25 1.25 0 0 0 0-2.5ZM19 14a1.34 1.34 0 0 1-.189-.017c-.033-.005-.066-.01-.101-.013-.2.67-.49 1.29-.86 1.86A6.976 6.976 0 0 1 12 19c-2.45 0-4.6-1.26-5.85-3.17-.37-.57-.66-1.19-.86-1.86-.035.003-.068.008-.101.013A1.339 1.339 0 0 1 5 14c-1.1 0-2-.9-2-2s.9-2 2-2c.065 0 .126.008.189.017.033.005.066.01.101.013.2-.67.49-1.29.86-1.86A6.976 6.976 0 0 1 12 5c2.45 0 4.6 1.26 5.85 3.17.37.57.66 1.19.86 1.86.035-.003.068-.008.101-.013A1.34 1.34 0 0 1 19 10c1.1 0 2 .9 2 2s-.9 2-2 2Zm-2.5 0c-.76 1.77-2.49 3-4.5 3s-3.74-1.23-4.5-3h9Z"
    };
    var badge = {
      name: "badge",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 2a2 2 0 0 0-2 2v3H4a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-5V4a2 2 0 0 0-2-2h-2Zm3.732 7A2 2 0 0 1 13 10h-2a2 2 0 0 1-1.732-1H4v11h16V9h-5.268ZM11 4h2v4h-2V4ZM8.5 11a1.75 1.75 0 1 0-.001 3.499A1.75 1.75 0 0 0 8.5 11Zm.875 1.75a.878.878 0 0 0-.875-.875.878.878 0 0 0-.875.875c0 .481.394.875.875.875a.878.878 0 0 0 .875-.875Zm1.75 4.375c-.088-.31-1.444-.875-2.625-.875-1.177 0-2.524.56-2.625.875h5.25Zm-6.125 0c0-1.164 2.332-1.75 3.5-1.75 1.168 0 3.5.586 3.5 1.75V18H5v-.875ZM14 11h4v1h-4zM14 14h4v1h-4zM14 17h4v1h-4z"
    };
    var shopping_cart_add = {
      name: "shopping_cart_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.92 9.5h-2v-3h-3v-2h3v-3h2v3h3v2h-3v3Zm-7.99 11c0-1.1.89-2 1.99-2s2 .9 2 2-.9 2-2 2-1.99-.9-1.99-2Zm11.99-2c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2Zm-1.45-5H9.02l-1.1 2h12v2h-12c-1.52 0-2.48-1.63-1.75-2.97l1.35-2.44-3.6-7.59h-2v-2h3.27l4.26 9h7.02l3.87-7 1.74.96-3.86 7.01c-.34.62-1 1.03-1.75 1.03Z"
    };
    var shopping_basket = {
      name: "shopping_basket",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.21 9.49H22c.55 0 1 .45 1 1l-.03.27-2.54 9.27a2.01 2.01 0 0 1-1.93 1.46h-13c-.92 0-1.69-.62-1.92-1.46l-2.54-9.27a.842.842 0 0 1-.04-.27c0-.55.45-1 1-1h4.79l4.38-6.55c.19-.29.51-.43.83-.43.32 0 .64.14.83.42l4.38 6.56Zm-2.41 0L12 5.29l-2.8 4.2h5.6Zm3.7 10-12.99.01-2.2-8.01H20.7l-2.2 8Zm-8.5-4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var shopping_card = {
      name: "shopping_card",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.296 11.97c-.34.62-1 1.03-1.75 1.03h-7.45l-1.1 2h12v2h-12c-1.52 0-2.48-1.63-1.75-2.97l1.35-2.44L3.996 4h-2V2h3.27l.94 2h14.8c.76 0 1.24.82.87 1.48l-3.58 6.49ZM19.306 6H7.156l2.37 5h7.02l2.76-5ZM7.996 18c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2Zm8.01 2c0-1.1.89-2 1.99-2s2 .9 2 2-.9 2-2 2-1.99-.9-1.99-2Z"
    };
    var shopping_cart_off = {
      name: "shopping_cart_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m.565 1.975 1.41-1.41 21.46 21.46-1.41 1.41-2.84-2.84c-.36.51-.95.84-1.62.84a1.997 1.997 0 0 1-1.16-3.62l-1.38-1.38h-7.46c-1.1 0-2-.9-2-2 0-.35.09-.68.25-.96l1.35-2.45-2.21-4.66-4.39-4.39Zm8.1 10.46-1.1 2h5.46l-2-2h-2.36Zm11.9-9H7.685l2 2h9.19l-2.76 5h-1.44l1.94 1.94c.54-.14.99-.49 1.25-.97l3.58-6.49c.37-.66-.12-1.48-.88-1.48Zm-14.99 16c0-1.1.89-2 1.99-2s2 .9 2 2-.9 2-2 2-1.99-.9-1.99-2Z"
    };
    var credit_card = {
      name: "credit_card",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2Zm0 14H4v-6h16v6ZM4 8h16V6H4v2Z"
    };
    var receipt = {
      name: "receipt",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.5 3.5 18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5ZM5 19.09V4.91h14v14.18H5ZM18 17v-2H6v2h12Zm0-6v2H6v-2h12Zm0-2V7H6v2h12Z"
    };
    var notifications_important = {
      name: "notifications_important",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.5 2.75c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v1.17c3.14.68 5.5 3.48 5.5 6.83v6l2 2v1H3v-1l2-2v-6C5 7.4 7.36 4.6 10.5 3.92V2.75Zm1.5 3c2.76 0 5 2.24 5 5v7H7v-7c0-2.76 2.24-5 5-5Zm-1.99 15.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98ZM13 7.75v4h-2v-4h2Zm0 8v-2h-2v2h2Z"
    };
    var notifications_add = {
      name: "notifications_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 1.25c-.83 0-1.5.67-1.5 1.5v1.17C7.36 4.6 5 7.4 5 10.75v6l-2 2v1h18v-1l-2-2v-6c0-3.35-2.36-6.15-5.5-6.83V2.75c0-.83-.67-1.5-1.5-1.5Zm5 9.5c0-2.76-2.24-5-5-5s-5 2.24-5 5v7h10v-7Zm-5 12c-1.1 0-1.99-.89-1.99-1.99h3.98c0 1.1-.89 1.99-1.99 1.99Zm-1-15h2v3h3v2h-3v3h-2v-3H8v-2h3v-3Z"
    };
    var do_not_disturb = {
      name: "do_not_disturb",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31A7.902 7.902 0 0 1 12 20ZM7.1 5.69 18.31 16.9A7.902 7.902 0 0 0 20 12c0-4.42-3.58-8-8-8-1.85 0-3.55.63-4.9 1.69Z"
    };
    var notifications_paused = {
      name: "notifications_paused",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 10.75v5l2 2v1H4v-1l2-2v-5c0-3.08 1.64-5.64 4.5-6.32v-.68c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v.68c2.87.68 4.5 3.25 4.5 6.32Zm-5.7-1.2H9.5v-1.8h5v1.8l-2.8 3.4h2.8v1.8h-5v-1.8l2.8-3.4Zm3.7 7.2H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6Zm-2 3c0 1.1-.9 2-2 2s-2-.9-2-2h4Z"
    };
    var warning_outlined = {
      name: "warning_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m1 21.5 11-19 11 19H1Zm18.53-2L12 6.49 4.47 19.5h15.06Zm-8.53-3v2h2v-2h-2Zm0-6h2v4h-2v-4Z"
    };
    var error_outlined = {
      name: "error_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM13 13V7h-2v6h2Zm0 4v-2h-2v2h2Zm-9-5c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8-8 3.58-8 8Z"
    };
    var sync = {
      name: "sync",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 1v3c4.42 0 8 3.58 8 8 0 1.57-.46 3.03-1.24 4.26L17.3 14.8c.45-.83.7-1.79.7-2.8 0-3.31-2.69-6-6-6v3L8 5l4-4ZM6 12c0 3.31 2.69 6 6 6v-3l4 4-4 4v-3c-4.42 0-8-3.58-8-8 0-1.57.46-3.03 1.24-4.26L6.7 9.2c-.45.83-.7 1.79-.7 2.8Z"
    };
    var sync_off = {
      name: "sync_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3.32 4.73 1.41-1.41 15.95 15.95-1.41 1.41-2.58-2.58c-.68.42-1.43.75-2.23.96v-2.09c.26-.1.51-.21.76-.34L7.14 8.55c-.43.83-.68 1.77-.68 2.77 0 1.66.68 3.15 1.76 4.24l2.24-2.24v6h-6l2.36-2.36a7.925 7.925 0 0 1-1.14-9.87L3.32 4.73Zm17.14 6.59c0-2.21-.91-4.2-2.36-5.64l2.36-2.36h-6v6l2.24-2.24a6.003 6.003 0 0 1 1.76 4.24c0 .85-.19 1.65-.51 2.38l1.5 1.5a7.921 7.921 0 0 0 1.01-3.88Zm-10-5.65V3.58c-.66.17-1.29.43-1.88.75l1.5 1.5c.065-.025.128-.053.19-.08.063-.028.125-.055.19-.08Z"
    };
    var sync_problem = {
      name: "sync_problem",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 4h-6v6l2.24-2.24A6.003 6.003 0 0 1 19 12a5.99 5.99 0 0 1-4 5.65v2.09c3.45-.89 6-4.01 6-7.74 0-2.21-.91-4.2-2.36-5.64L21 4ZM5.36 17.64A7.925 7.925 0 0 1 3 12c0-3.73 2.55-6.85 6-7.74v2.09C6.67 7.17 5 9.39 5 12c0 1.66.68 3.15 1.76 4.24L9 14v6H3l2.36-2.36ZM13 17h-2v-2h2v2Zm0-4h-2V7h2v6Z"
    };
    var notifications = {
      name: "notifications",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 15.75v-5c0-3.07-1.63-5.64-4.5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.11 6 7.67 6 10.75v5l-2 2v1h16v-1l-2-2Zm-6 6c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2Zm-4-5h8v-6c0-2.48-1.51-4.5-4-4.5s-4 2.02-4 4.5v6Z",
      sizes: {
        small: {
          name: "notifications_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M13.5 11.911v-3.67c0-2.254-1.223-4.141-3.375-4.64v-.5C10.125 2.491 9.623 2 9 2s-1.125.492-1.125 1.101v.5C5.73 4.1 4.5 5.979 4.5 8.24v3.67L3 13.38v.673h12v-.673l-1.5-1.469ZM9 16.001c.825 0 1.5-.49 1.5-1.47h-3c0 .98.675 1.47 1.5 1.47Zm-3-3.356h6V8.24c0-1.82-1.133-3.303-3-3.303S6 6.42 6 8.24v4.405Z"
        }
      }
    };
    var notifications_active = {
      name: "notifications_active",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 15.75v-5c0-3.07-1.63-5.64-4.5-6.32v-.68c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.11 6 7.67 6 10.75v5l-2 2v1h16v-1l-2-2Zm-6 6c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2Zm-4-5h8v-6c0-2.48-1.51-4.5-4-4.5s-4 2.02-4 4.5v6ZM7.58 3.83 6.15 2.4c-2.4 1.83-3.98 4.65-4.12 7.85h2a8.445 8.445 0 0 1 3.55-6.42Zm14.39 6.42h-2a8.495 8.495 0 0 0-3.54-6.42l1.42-1.43c2.39 1.83 3.97 4.65 4.12 7.85Z",
      sizes: {
        small: {
          name: "notifications_active_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M13.5 11.813v-3.75c0-2.303-1.223-4.23-3.375-4.74v-.51c0-.623-.503-1.126-1.125-1.126-.623 0-1.125.503-1.125 1.125v.51C5.73 3.832 4.5 5.752 4.5 8.063v3.75l-1.5 1.5V14h12v-.688l-1.5-1.5ZM9 16c1 0 1.5-.871 1.5-1.5h-3c0 .629.5 1.5 1.5 1.5Zm-3-3.438h6v-4.5c0-1.86-1.133-3.374-3-3.374-1.868 0-3 1.514-3 3.375v4.5Zm-.315-9.69L4.612 1.8a7.819 7.819 0 0 0-3.09 5.888h1.5a6.334 6.334 0 0 1 2.663-4.815Zm10.793 4.816h-1.5a6.371 6.371 0 0 0-2.655-4.815L13.386 1.8a7.866 7.866 0 0 1 3.09 5.888Z"
        }
      }
    };
    var notifications_off = {
      name: "notifications_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.305 10.75c0-2.48-1.51-4.5-4-4.5-.144 0-.282.017-.42.034l-.13.016-1.64-1.64.105-.038c.188-.07.383-.141.585-.192v-.68c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v.68c2.87.68 4.5 3.25 4.5 6.32v2.1l-2-2v-.1Zm-2 9c0 1.1-.9 2-2 2s-2-.9-2-2h4ZM4.715 3.1l-1.41 1.41 2.81 2.81c-.52 1-.81 2.17-.81 3.43v5l-2 2v1h14.24l1.74 1.74 1.41-1.41L4.715 3.1Zm2.59 13.65h8v-.24l-7.66-7.66c-.22.58-.34 1.22-.34 1.9v6Z",
      sizes: {
        small: {
          name: "notifications_off_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M11.47 8.236c0-1.82-1.129-3.302-2.99-3.302-.108 0-.21.013-.313.026l-.098.011-1.226-1.203.078-.028c.14-.051.287-.104.438-.14v-.5c0-.608.5-1.1 1.121-1.1.62 0 1.121.492 1.121 1.1v.5c2.146.498 3.364 2.384 3.364 4.636v1.54L11.47 8.31v-.073Zm-1.473 6.297c0 .978-.673 1.467-1.495 1.467-.822 0-1.495-.49-1.495-1.467h2.99ZM3.554 2.623 2.5 3.659l2.1 2.061a5.36 5.36 0 0 0-.605 2.517v3.668L2.5 13.37v.672h10.487l1.459 1.338 1.054-1.034L3.554 2.624ZM5.49 12.639h5.98v-.176l-5.726-5.62a3.856 3.856 0 0 0-.254 1.394v4.402Z"
        }
      }
    };
    var error_filled = {
      name: "error_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-1 15v-2h2v2h-2Zm0-10v6h2V7h-2Z",
      sizes: {
        small: {
          name: "error_filled_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M9 2C5.136 2 2 5.136 2 9s3.136 7 7 7 7-3.136 7-7-3.136-7-7-7ZM8 13v-2h2v2H8Zm0-8v5h2V5H8Z"
        }
      }
    };
    var warning_filled = {
      name: "warning_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m23 21.5-11-19-11 19h22Zm-12-3v-2h2v2h-2Zm0-4h2v-4h-2v4Z",
      sizes: {
        small: {
          name: "warning_filled_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M17.5 16 9 2 .5 16h17ZM8 14v-2h2v2H8Zm0-4h2V6H8v4Z"
        }
      }
    };
    var menu = {
      name: "menu",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 8V6h18v2H3Zm0 5h18v-2H3v2Zm0 5h18v-2H3v2Z"
    };
    var apps = {
      name: "apps",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 8h4V4H4v4Zm6 12h4v-4h-4v4Zm-2 0H4v-4h4v4Zm-4-6h4v-4H4v4Zm10 0h-4v-4h4v4Zm2-10v4h4V4h-4Zm-2 4h-4V4h4v4Zm2 6h4v-4h-4v4Zm4 6h-4v-4h4v4Z"
    };
    var home = {
      name: "home",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 12.5H2l10-9 10 9h-3v8h-6v-6h-2v6H5v-8Zm12-1.81-5-4.5-5 4.5v7.81h2v-6h6v6h2v-7.81Z"
    };
    var exit_to_app = {
      name: "exit_to_app",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2v-4h2v4h14V5H5v4H3V5a2 2 0 0 1 2-2Zm6.5 14-1.41-1.41L12.67 13H3v-2h9.67l-2.58-2.59L11.5 7l5 5-5 5Z"
    };
    var open_in_browser = {
      name: "open_in_browser",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 4h14a2 2 0 0 1 2 2v12c0 1.1-.9 2-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 10 4-4 4 4h-3v6h-2v-6H8Z"
    };
    var external_link = {
      name: "external_link",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3c-1.093 0-2 .907-2 2v14c0 1.093.907 2 2 2h14c1.093 0 2-.907 2-2v-7h-2v7H5V5h7V3H5Zm9 0v2h3.586l-9.293 9.293 1.414 1.414L19 6.414V10h2V3h-7Z"
    };
    var category = {
      name: "category",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6 11 5.5-9 5.5 9H6Zm7.43-2L11.5 5.84 9.56 9h3.87ZM17 13c-2.49 0-4.5 2.01-4.5 4.5S14.51 22 17 22s4.5-2.01 4.5-4.5S19.49 13 17 13Zm-2.5 4.5a2.5 2.5 0 0 0 5 0 2.5 2.5 0 0 0-5 0Zm-12 4h8v-8h-8v8Zm6-6h-4v4h4v-4Z"
    };
    var settings = {
      name: "settings",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.502 12c0 .34-.03.66-.07.98l2.11 1.65c.19.15.24.42.12.64l-2 3.46c-.09.16-.26.25-.43.25-.06 0-.12-.01-.18-.03l-2.49-1c-.52.39-1.08.73-1.69.98l-.38 2.65c-.03.24-.24.42-.49.42h-4c-.25 0-.46-.18-.49-.42l-.38-2.65c-.61-.25-1.17-.58-1.69-.98l-2.49 1a.5.5 0 0 1-.61-.22l-2-3.46a.505.505 0 0 1 .12-.64l2.11-1.65a7.93 7.93 0 0 1-.07-.98c0-.33.03-.66.07-.98l-2.11-1.65a.493.493 0 0 1-.12-.64l2-3.46c.09-.16.26-.25.43-.25.06 0 .12.01.18.03l2.49 1c.52-.39 1.08-.73 1.69-.98l.38-2.65c.03-.24.24-.42.49-.42h4c.25 0 .46.18.49.42l.38 2.65c.61.25 1.17.58 1.69.98l2.49-1a.5.5 0 0 1 .61.22l2 3.46c.12.22.07.49-.12.64l-2.11 1.65c.04.32.07.64.07.98Zm-2 0c0-.21-.01-.42-.05-.73l-.14-1.13.89-.7 1.07-.85-.7-1.21-1.27.51-1.06.43-.91-.7c-.4-.3-.8-.53-1.23-.71l-1.06-.43-.16-1.13-.19-1.35h-1.39l-.2 1.35-.16 1.13-1.06.43c-.41.17-.82.41-1.25.73l-.9.68-1.04-.42-1.27-.51-.7 1.21 1.08.84.89.7-.14 1.13c-.03.3-.05.53-.05.73 0 .2.02.43.05.74l.14 1.13-.89.7-1.08.84.7 1.21 1.27-.51 1.06-.43.91.7c.4.3.8.53 1.23.71l1.06.43.16 1.13.19 1.35h1.4l.2-1.35.16-1.13 1.06-.43c.41-.17.82-.41 1.25-.73l.9-.68 1.04.42 1.27.51.7-1.21-1.08-.84-.89-.7.14-1.13c.03-.3.05-.52.05-.73Zm-5.5-4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4Zm-2 4c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2Z"
    };
    var launch = {
      name: "launch",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 15c-.83 0-1.58.34-2.12.88C2.7 17.06 2 22 2 22s4.94-.7 6.12-1.88A2.996 2.996 0 0 0 6 15Zm.71 3.71c-.28.28-2.17.76-2.17.76s.47-1.88.76-2.17c.17-.19.42-.3.7-.3a1.003 1.003 0 0 1 .71 1.71Zm10.71-5.06c6.36-6.36 4.24-11.31 4.24-11.31S16.71.22 10.35 6.58l-2.49-.5a2.03 2.03 0 0 0-1.81.55L2 10.69l5 2.14L11.17 17l2.14 5 4.05-4.05c.47-.47.68-1.15.55-1.81l-.49-2.49ZM7.41 10.83l-1.91-.82 1.97-1.97 1.44.29c-.57.83-1.08 1.7-1.5 2.5Zm6.58 7.67-.82-1.91c.8-.42 1.67-.93 2.49-1.5l.29 1.44-1.96 1.97ZM16 12.24c-1.32 1.32-3.38 2.4-4.04 2.73l-2.93-2.93c.32-.65 1.4-2.71 2.73-4.04 4.68-4.68 8.23-3.99 8.23-3.99s.69 3.55-3.99 8.23ZM15 11c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2Z"
    };
    var go_to = {
      name: "go_to",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm.8-9.143V8l4.2 4-4.2 4v-2.857H7v-2.286h5.8Z"
    };
    var subsea_drone = {
      name: "subsea_drone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.9 4.18a.893.893 0 0 1 1.31 0l.064.068a2.979 2.979 0 0 0 4.179.19l.216-.194a1 1 0 1 0-1.338-1.487l-.216.195a.979.979 0 0 1-1.374-.063l-.063-.068a2.893 2.893 0 0 0-4.245 0 .893.893 0 0 1-1.31 0 2.893 2.893 0 0 0-4.246 0 .893.893 0 0 1-1.31 0 2.893 2.893 0 0 0-4.245 0l-.063.068a.979.979 0 0 1-1.374.063l-.216-.195a1 1 0 1 0-1.338 1.487l.216.194a2.979 2.979 0 0 0 4.18-.19l.062-.068a.893.893 0 0 1 1.31 0 2.893 2.893 0 0 0 4.246 0 .893.893 0 0 1 1.31 0 2.893 2.893 0 0 0 4.245 0ZM4 11h17V9H4a1 1 0 1 0 0 2Zm0 2h5.091l-2.777 4.011A1.5 1.5 0 1 0 7.618 19.5H14l2.06 2.06a1.5 1.5 0 0 0 1.061.44h1.258a1.5 1.5 0 0 0 1.06-.44L20.5 20.5 19 19l-1 1h-.5L16 18.5l1.5-1.5h.5l1 1 1.5-1.5-1.06-1.06a1.5 1.5 0 0 0-1.061-.44H17.12a1.5 1.5 0 0 0-1.06.44L14 17.5H8.409l3.115-4.5H21a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2H4a3 3 0 0 0 0 6Z"
    };
    var onshore_drone = {
      name: "onshore_drone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.5 6 4 7.5l1.06 1.06A1.5 1.5 0 0 0 6.122 9H7.38a1.5 1.5 0 0 0 1.06-.44L10.5 6.5h8.326L16.403 11H4a3 3 0 1 0 0 6h17a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2.326l2.176-4.041A1.5 1.5 0 1 0 19.382 4.5H10.5L8.44 2.44A1.5 1.5 0 0 0 7.378 2H6.12a1.5 1.5 0 0 0-1.06.44L4 3.5 5.5 5l1-1H7l1.5 1.5L7 7h-.5l-1-1ZM21 15H4a1 1 0 1 1 0-2h17v2ZM5 22a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm5-2a2 2 0 1 0 4 0 2 2 0 0 0-4 0Zm9 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z"
    };
    var van = {
      name: "van",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 5H3a2 2 0 0 0-2 2v9h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-6-6Zm-2 2h1l3 3h-4V7Zm-2 0H9v3h4V7ZM3 7h4v3H3V7Zm1.75 9a1.25 1.25 0 1 0 2.5 0 1.25 1.25 0 0 0-2.5 0ZM18 17.25a1.25 1.25 0 1 1 0-2.5 1.25 1.25 0 0 1 0 2.5ZM20.22 14H21v-2H3v2h.78c.55-.61 1.33-1 2.22-1 .89 0 1.67.39 2.22 1h7.56c.55-.61 1.34-1 2.22-1 .88 0 1.67.39 2.22 1Z"
    };
    var motorcycle = {
      name: "motorcycle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 5h4.41l4.03 4.03C22.03 9.23 24 11.35 24 14c0 2.8-2.2 5-5 5s-5-2.2-5-5c0-.63.11-1.23.32-1.77L11.55 15H9.9c-.45 2.31-2.44 4-4.9 4-2.8 0-5-2.2-5-5s2.2-5 5-5h11.59l-2-2H11V5Zm-.28 8 2-2H8.98c.3.39.54.83.72 1.31l.25.69h.77ZM19 17c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3ZM2 14c0 1.63 1.37 3 3 3 1.28 0 2.4-.85 2.82-2H5v-2h2.82C7.4 11.85 6.28 11 5 11c-1.63 0-3 1.37-3 3Z"
    };
    var transit_enter_exit = {
      name: "transit_enter_exit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 18H6V8h3v4.77L15.98 6 18 8.03 11.15 15H16v3Z"
    };
    var trip_origin = {
      name: "trip_origin",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm6 10c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6Z"
    };
    var satellite = {
      name: "satellite",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2ZM5 19V5h14v14H5ZM6 6h2.57c0 1.42-1.15 2.58-2.57 2.58V6Zm6 0h-1.71c0 2.36-1.92 4.29-4.29 4.29V12c3.32 0 6-2.69 6-6Zm-.86 9.73 3-3.87L18 17H6l3-3.85 2.14 2.58Z"
    };
    var traffic_light = {
      name: "traffic_light",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 10h-3V8.86c1.72-.45 3-2 3-3.86h-3V4c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v1H4c0 1.86 1.28 3.41 3 3.86V10H4c0 1.86 1.28 3.41 3 3.86V15H4c0 1.86 1.28 3.41 3 3.86V20c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-1.14c1.72-.45 3-2 3-3.86h-3v-1.14c1.72-.45 3-2 3-3.86Zm-5-5v14H9V5h6Zm-1.5 11.5c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5.67-1.5 1.5-1.5 1.5.67 1.5 1.5Zm-1.5-3c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5Zm1.5-6c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5S11.17 6 12 6s1.5.67 1.5 1.5Z"
    };
    var hospital = {
      name: "hospital",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 16H5V5h14v14Zm-5.5-2h-3v-3.5H7v-3h3.5V7h3v3.5H17v3h-3.5V17Z"
    };
    var map$2 = {
      name: "map",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.34 3.03 20.5 3c.28 0 .5.22.5.5v15.12c0 .23-.15.41-.36.48L15 21l-6-2.1-5.34 2.07-.16.03c-.28 0-.5-.22-.5-.5V5.38c0-.23.15-.41.36-.48L9 3l6 2.1 5.34-2.07ZM14 6.87l-4-1.4v11.66l4 1.4V6.87Zm-9-.41 3-1.01v11.7l-3 1.16V6.46Zm11 12.09 3-1.01V5.7l-3 1.16v11.69Z"
    };
    var parking = {
      name: "parking",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.5 3h7c3.31 0 6 2.69 6 6s-2.69 6-6 6h-3v6h-4V3Zm4 8h3.2c1.1 0 2-.9 2-2s-.9-2-2-2H9.5v4Z"
    };
    var directions = {
      name: "directions",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22.427 10.593-9.01-9.01c-.75-.75-2.07-.76-2.83 0l-9 9c-.78.78-.78 2.04 0 2.82l9 9c.39.39.9.58 1.41.58.51 0 1.02-.19 1.41-.58l8.99-8.99c.79-.76.8-2.02.03-2.82Zm-10.42 10.4-9-9 9-9 9 9-9 9Zm-4.01-5.99v-4c0-.55.45-1 1-1h5v-2.5l3.5 3.5-3.5 3.5v-2.5h-4v3h-2Z"
    };
    var transfer = {
      name: "transfer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.5 5.25c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2Zm6.99 8.25v1.75H22v1.5h-5.51v1.75L14 16l2.49-2.5Zm-2.49 6h5.51v-1.75l2.49 2.5-2.49 2.5V21H14v-1.5ZM3 22.75l2.75-14.1L4 9.4v3.35H2v-4.7L7.25 5.9c.25-.1.5-.15.75-.15.7 0 1.35.35 1.7.95l.95 1.6c.9 1.45 2.5 2.45 4.35 2.45v2c-2.2 0-4.15-1-5.45-2.6l-.6 3L11 15.2v7.55H9v-6l-2.15-2-1.75 8H3Z"
    };
    var terrain = {
      name: "terrain",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.78 11.63 14 6l9 12H1l5.53-7.37L10.54 16H19l-5-6.67-2.97 3.97-1.25-1.67Zm-3.26 2.34L5 16h3.04l-1.52-2.03Z"
    };
    var mall = {
      name: "mall",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 6.5h2c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-12c0-1.1.9-2 2-2h2c0-2.76 2.24-5 5-5s5 2.24 5 5Zm-2 0c0-1.66-1.34-3-3-3s-3 1.34-3 3h6Zm-10 14v-12h14v12H5Zm4-11c0 1.66 1.34 3 3 3s3-1.34 3-3h2c0 2.76-2.24 5-5 5s-5-2.24-5-5h2Z"
    };
    var ticket = {
      name: "ticket",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 10V6c0-1.1-.9-2-2-2H4c-1.1 0-1.99.9-1.99 2v4c1.1 0 1.99.9 1.99 2a2 2 0 0 1-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2s.9-2 2-2Zm-2-1.46c-1.19.69-2 1.99-2 3.46s.81 2.77 2 3.46V18H4v-2.54c1.19-.69 2-1.99 2-3.46 0-1.48-.8-2.77-1.99-3.46L4 6h16v2.54Zm-8 5.58L9.07 16l.88-3.37-2.69-2.2 3.47-.21L12 7l1.26 3.23 3.47.21-2.69 2.2.89 3.36L12 14.12Z"
    };
    var pharmacy = {
      name: "pharmacy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 6h-2.64l1.14-3.14L17.15 2l-1.46 4H3v2l2 6-2 6v2h18v-2l-2-6 2-6V6Zm-3.9 8.63L18.89 20H5.11l1.79-5.37.21-.63-.21-.63L5.11 8h13.78l-1.79 5.37-.21.63.21.63ZM11 10h2v3h3v2h-3v3h-2v-3H8v-2h3v-3Z"
    };
    var cinema = {
      name: "cinema",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 3h2v18h-2v-2h-2v2H8v-2H6v2H4V3h2v2h2V3h8v2h2V3Zm-4 16V5h-4v14h4Zm2-10V7h2v2h-2ZM6 7v2h2V7H6Zm10 6v-2h2v2h-2ZM6 11v2h2v-2H6Zm10 6v-2h2v2h-2ZM6 15v2h2v-2H6Z"
    };
    var convenience_store = {
      name: "convenience_store",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 4v3h3v13h-8v-4h-4v4H2V7h3V4h14Zm-3 14h4V9h-3V6H7v3H4v9h4v-4h8v4ZM8 8h2v1H8v3h3v-1H9v-1h2V7H8v1Zm6 1h1V7h1v5h-1v-2h-2V7h1v2Z"
    };
    var car_wash = {
      name: "car_wash",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 5.1c.83 0 1.5-.67 1.5-1.5C8.5 2.6 7 .9 7 .9S5.5 2.6 5.5 3.6c0 .83.67 1.5 1.5 1.5Zm6.5-1.5c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5c0-1 1.5-2.7 1.5-2.7s1.5 1.7 1.5 2.7Zm5 0c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5c0-1 1.5-2.7 1.5-2.7s1.5 1.7 1.5 2.7Zm-1 3.5c.66 0 1.22.42 1.42 1.01L21 14.1v8c0 .55-.45 1-1 1h-1c-.55 0-1-.45-1-1v-1H6v1c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1v-8l2.08-5.99c.21-.59.76-1.01 1.42-1.01h11Zm-10.65 2h10.29l1.04 3H5.81l1.04-3ZM5 14.44v4.66h14v-4.66l-.11-.34H5.12l-.12.34Zm2.5.66a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7.5 1.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var library = {
      name: "library",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 5.225c0 2.21-1.79 4-4 4s-4-1.79-4-4 1.79-4 4-4 4 1.79 4 4Zm-2 0c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2Zm-2 6.55c-2.36-2.2-5.52-3.55-9-3.55v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55v-11c-3.48 0-6.64 1.35-9 3.55Zm0 8.4c2.07-1.52 4.47-2.48 7-2.82v-6.95c-2.1.38-4.05 1.35-5.64 2.83L12 14.505l-1.36-1.28A11.18 11.18 0 0 0 5 10.395v6.95a15.2 15.2 0 0 1 7 2.83Z"
    };
    var store = {
      name: "store",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 4h16v2H4V4Zm14.96 8-.6-3H5.64l-.6 3h13.92ZM20 7H4l-1 5v2h1v6h10v-6h4v6h2v-6h1v-2l-1-5ZM6 14v4h6v-4H6Z"
    };
    var hotel = {
      name: "hotel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 6.5h-8v8H3v-10H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4Zm-9 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3Zm-2 0c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm5 4h8v-4c0-1.1-.9-2-2-2h-6v6Z"
    };
    var grocery_store = {
      name: "grocery_store",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.546 13c.75 0 1.41-.41 1.75-1.03l3.58-6.49a.996.996 0 0 0-.87-1.48h-14.8l-.94-2h-3.27v2h2l3.6 7.59-1.35 2.44c-.73 1.34.23 2.97 1.75 2.97h12v-2h-12l1.1-2h7.45Zm-10.54 7c0-1.1.89-2 1.99-2s2 .9 2 2-.9 2-2 2-1.99-.9-1.99-2Zm10 0c0-1.1.89-2 1.99-2s2 .9 2 2-.9 2-2 2-1.99-.9-1.99-2Zm3.3-14H7.156l2.37 5h7.02l2.76-5Z"
    };
    var walk = {
      name: "walk",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 3.25c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2Zm-8.5 19.5 2.8-14.1-1.8.7v3.4h-2v-4.7l5.05-2.14c.97-.41 2.09-.05 2.65.84l1 1.6c.8 1.4 2.4 2.4 4.3 2.4v2c-2.2 0-4.2-1-5.5-2.5l-.6 3 2.1 2v7.5h-2v-6l-2.1-2-1.8 8H6.5Z"
    };
    var run$1 = {
      name: "run",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.55 3.25c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2Zm-4.6 11.5-1 4.4-7-1.4.4-2 4.9 1 1.6-8.1-1.8.7v3.4h-2v-4.7l5.2-2.2c.15 0 .275-.025.4-.05s.25-.05.4-.05c.7 0 1.3.4 1.7 1l1 1.6c.8 1.4 2.4 2.4 4.3 2.4v2c-2.2 0-4.2-1-5.5-2.5l-.6 3 2.1 2v7.5h-2v-6l-2.1-2Z"
    };
    var bike = {
      name: "bike",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.5 3.75c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2ZM0 17.25c0-2.8 2.2-5 5-5s5 2.2 5 5-2.2 5-5 5-5-2.2-5-5Zm5 3.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5Zm14.1-9.5c-2.1 0-3.8-.8-5.1-2.1l-.8-.8-2.4 2.4 2.2 2.3v6.2h-2v-5l-3.2-2.8c-.4-.3-.6-.8-.6-1.4 0-.5.2-1 .6-1.4l2.8-2.8c.3-.4.8-.6 1.4-.6.6 0 1.1.2 1.6.6l1.9 1.9c.9.9 2.1 1.5 3.6 1.5v2Zm-.1 1c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5Zm-3.5 5c0 1.9 1.6 3.5 3.5 3.5s3.5-1.6 3.5-3.5-1.6-3.5-3.5-3.5-3.5 1.6-3.5 3.5Z"
    };
    var boat = {
      name: "boat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.001 1h6v3h3c1.1 0 2 .9 2 2v4.62l1.28.42c.26.08.48.26.6.5s.14.52.06.78L20.051 19h-.05c-1.6 0-3.02-.88-4-2-.98 1.12-2.4 2-4 2s-3.02-.88-4-2c-.98 1.12-2.4 2-4 2h-.05l-1.9-6.68a1.007 1.007 0 0 1 .66-1.28l1.29-.42V6c0-1.1.9-2 2-2h3V1Zm4 2v1h-2V3h2Zm-1 7.11 5.38 1.77 2.39.78-1.12 3.97c-.54-.3-.94-.71-1.14-.94l-1.51-1.73-1.51 1.72c-.34.4-1.28 1.32-2.49 1.32-1.21 0-2.15-.92-2.49-1.32l-1.51-1.72-1.51 1.72c-.2.23-.6.63-1.14.93l-1.13-3.96 2.4-.79 5.38-1.75Zm-6-.14V6h12v3.97l-6-1.97-6 1.97Zm6 10.99c1.39 0 2.78-.43 4-1.28 1.22.85 2.61 1.32 4 1.32h2v2h-2c-1.38 0-2.74-.34-4-.99a8.71 8.71 0 0 1-4 .97c-1.37 0-2.74-.33-4-.97-1.26.64-2.62.99-4 .99h-2v-2h2c1.39 0 2.78-.47 4-1.32 1.22.85 2.61 1.28 4 1.28Z"
    };
    var place_unknown = {
      name: "place_unknown",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 8.755c0-4.41 3.59-8 8-8s8 3.59 8 8c0 5.57-6.96 13.34-7.26 13.67l-.74.82-.74-.82c-.3-.33-7.26-8.1-7.26-13.67Zm2 0c0 3.54 3.82 8.86 6 11.47 1.75-2.11 6-7.64 6-11.47 0-3.31-2.69-6-6-6s-6 2.69-6 6Zm5.13 5h1.75v1.75h-1.75v-1.75Zm-2.63-5.5c0-1.93 1.57-3.5 3.5-3.5s3.5 1.57 3.5 3.5c0 1.124-.69 1.729-1.362 2.318-.637.559-1.258 1.103-1.258 2.062h-1.75c0-1.59.82-2.22 1.543-2.776.569-.438 1.077-.829 1.077-1.604 0-.96-.79-1.75-1.75-1.75s-1.75.79-1.75 1.75H8.5Z"
    };
    var flight = {
      name: "flight",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21.5 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5l-2-1.5v-5.5l8 2.5Z"
    };
    var subway_tunnel = {
      name: "subway_tunnel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2c1.86 0 4 .09 5.8.8C20.47 3.84 22 6.05 22 8.86V22H2V8.86C2 6.05 3.53 3.84 6.2 2.8 8 2.09 10.14 2 12 2Zm-1.33 16.5L9.17 20h5.66l-1.5-1.5h-2.66ZM7.01 14V9h10v5h-10Zm8.49 3c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1Zm-7-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1Zm8 5H20V8.86c0-2-1.01-3.45-2.93-4.2C15.59 4.08 13.68 4 12 4c-1.68 0-3.59.08-5.07.66C5.01 5.41 4 6.86 4 8.86V20h3.5v-.38l1.15-1.16A2.979 2.979 0 0 1 6 15.5V9c0-2.63 3-3 6-3s6 .37 6 3v6.5c0 1.54-1.16 2.79-2.65 2.96l1.15 1.16V20Z"
    };
    var tram = {
      name: "tram",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m13 5 .75-1.5H17V2H7v1.5h4.75L11 5c-3.13.09-6 .73-6 3.5V17c0 1.5 1.11 2.73 2.55 2.95L6 21.5v.5h2l2-2h4l2 2h2v-.5l-1.55-1.55C17.89 19.73 19 18.5 19 17V8.5c0-2.77-2.87-3.41-6-3.5Zm-1.97 2h1.94c2.75.08 3.62.58 3.9 1H7.13c.28-.42 1.15-.92 3.9-1ZM7.74 17.95h3.11c-.22-.26-.35-.59-.35-.95 0-.39.15-.73.39-1H7v1c0 .45.3.84.74.95ZM17 17c0 .45-.3.84-.74.95h-3.11c.22-.26.35-.59.35-.95 0-.39-.15-.73-.39-1H17v1ZM7 14h10v-4H7v4Z"
    };
    var train = {
      name: "train",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 6.5c0-3.5 4-4 8-4s8 .5 8 4V16c0 1.93-1.57 3.5-3.5 3.5L18 21v.5h-2l-2-2h-4l-2 2H6V21l1.5-1.5C5.57 19.5 4 17.93 4 16V6.5Zm4.5 7a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7 0a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm-3.5-9c3.51 0 4.96.48 5.57 1H6.43c.61-.52 2.06-1 5.57-1Zm-1 3H6v3h5v-3Zm7 8.5c0 .83-.67 1.5-1.5 1.5h-9c-.83 0-1.5-.67-1.5-1.5v-3.5h12V16Zm-5-5.5h5v-3h-5v3Z"
    };
    var shipping = {
      name: "shipping",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-3-4Zm-.5 1.5 1.96 2.5H17V9.5h2.5ZM5 17c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Zm3.22-2c-.55-.61-1.33-1-2.22-1-.89 0-1.67.39-2.22 1H3V6h12v9H8.22ZM17 17c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Z"
    };
    var taxi = {
      name: "taxi",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.92 6.01C18.72 5.42 18.16 5 17.5 5H15V3H9v2H6.5c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99ZM6.85 7h10.29l1.04 3H5.81l1.04-3ZM5 17h14v-4.66l-.11-.34H5.12l-.12.34V17Zm2.5-4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7.5 1.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var transit = {
      name: "transit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2.5c-4 0-8 .5-8 4V16c0 1.93 1.57 3.5 3.5 3.5L6 21v.5h12V21l-1.5-1.5c1.93 0 3.5-1.57 3.5-3.5V6.5c0-3.5-3.58-4-8-4Zm5.66 3H6.43c.61-.52 2.06-1 5.57-1 3.71 0 5.12.46 5.66 1Zm-6.66 5v-3H6v3h5Zm2-3h5v3h-5v-3ZM6 16c0 .83.67 1.5 1.5 1.5h9c.83 0 1.5-.67 1.5-1.5v-3.5H6V16Zm2.5-2.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM14 15a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var subway = {
      name: "subway",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2.5c-4 0-8 .5-8 4V16c0 1.93 1.57 3.5 3.5 3.5L6 21v.5h12V21l-1.5-1.5c1.93 0 3.5-1.57 3.5-3.5V6.5c0-3.5-3.58-4-8-4Zm5.66 3H6.43c.61-.52 2.06-1 5.57-1 3.71 0 5.12.46 5.66 1Zm-6.66 5v-3H6v3h5Zm2-3h5v3h-5v-3ZM6 16c0 .83.67 1.5 1.5 1.5h9c.83 0 1.5-.67 1.5-1.5v-3.5H6V16Zm2.5-2.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM14 15a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var car = {
      name: "car",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.92 5.01C18.72 4.42 18.16 4 17.5 4h-11c-.66 0-1.21.42-1.42 1.01L3 11v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99ZM6.85 6h10.29l1.08 3.11H5.77L6.85 6ZM5 16h14v-5H5v5Zm2.5-4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7.5 1.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var railway = {
      name: "railway",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2c-4.42 0-8 .5-8 4v10.5C4 18.43 5.57 20 7.5 20L6 21.5v.5h12v-.5L16.5 20c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4Zm0 2c6 0 6 1.2 6 2H6c0-.8 0-2 6-2Zm6 7V8H6v3h12ZM7.5 18c-.83 0-1.5-.67-1.5-1.5V13h12v3.5c0 .83-.67 1.5-1.5 1.5h-9Zm2.5-2.5c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var bus = {
      name: "bus",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 6.5c0-3.5 3.58-4 8-4s8 .5 8 4v10c0 .88-.39 1.67-1 2.22v1.78c0 .55-.45 1-1 1h-1c-.55 0-1-.45-1-1v-1H8v1c0 .55-.45 1-1 1H6c-.55 0-1-.45-1-1v-1.78c-.61-.55-1-1.34-1-2.22v-10Zm8-2c-3.69 0-5.11.46-5.66.99h11.32c-.55-.53-1.97-.99-5.66-.99Zm6 2.99v3.01H6V7.49h12Zm-.63 10.01.29-.27c.13-.11.34-.36.34-.73v-4H6v4c0 .37.21.62.34.73l.29.27h10.74Zm-8.87-4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM14 15a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var departure_board = {
      name: "departure_board",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 1a6.98 6.98 0 0 0-5.75 3.02C9.84 4.01 9.43 4 9 4c-4.42 0-8 .5-8 4v10c0 .88.39 1.67 1 2.22V22c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.61-.55 1-1.34 1-2.22v-3.08c3.39-.49 6-3.39 6-6.92 0-3.87-3.13-7-7-7ZM4 16.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm7 0a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM9.29 6H9c-3.69 0-5.11.46-5.66.99h5.74c.05-.33.12-.67.21-.99ZM3 8.99h6.08c.16 1.11.57 2.13 1.18 3.01H3V8.99Zm11.66 9.74c.13-.11.34-.36.34-.73v-3.08c-.94-.13-1.81-.45-2.59-.92H3v4c0 .37.21.62.34.73l.29.27h10.74l.29-.27ZM16 13c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5Zm-1-9h1.5v4.25l2.87 1.68-.75 1.23L15 9V4Z"
    };
    var place_edit = {
      name: "place_edit",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 8.755c0-4.41 3.59-8 8-8s8 3.59 8 8c0 5.57-6.96 13.34-7.26 13.67l-.74.82-.74-.82c-.3-.33-7.26-8.1-7.26-13.67Zm2 0c0 3.54 3.82 8.86 6 11.47 1.75-2.11 6-7.64 6-11.47 0-3.31-2.69-6-6-6s-6 2.69-6 6Zm2.51 2.05v1.44h1.44l3.92-3.93-1.43-1.43-3.93 3.92Zm5.34-5.34a.38.38 0 0 1 .54 0l.9.9c.15.15.15.39 0 .54l-.7.7-1.44-1.44.7-.7Z"
    };
    var place_add = {
      name: "place_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7ZM7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 2.88-2.88 7.19-5 9.88C9.92 16.21 7 11.85 7 9Zm4-1V6h2v2h2v2h-2v2h-2v-2H9V8h2Z"
    };
    var place_person = {
      name: "place_person",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 8.755c0-4.41 3.59-8 8-8s8 3.59 8 8c0 5.57-6.96 13.34-7.26 13.67l-.74.82-.74-.82c-.3-.33-7.26-8.1-7.26-13.67Zm2 0c0 3.54 3.82 8.86 6 11.47 1.75-2.11 6-7.64 6-11.47 0-3.31-2.69-6-6-6s-6 2.69-6 6Zm6 0c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.68-1.5 1.5c0 .83.67 1.5 1.5 1.5Zm-3 2.5c0-1 2-1.5 3-1.5s3 .5 3 1.5v.12c-.73.84-1.8 1.38-3 1.38s-2.27-.54-3-1.38v-.12Z"
    };
    var pin_drop = {
      name: "pin_drop",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2c3.31 0 6 2.69 6 6 0 4.5-6 11-6 11S6 12.5 6 8c0-3.31 2.69-6 6-6Zm7 20v-2H5v2h14ZM8 8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 2.13-2.08 5.46-4 7.91-1.92-2.44-4-5.78-4-7.91Zm2 0c0-1.1.9-2 2-2s2 .9 2 2a2 2 0 1 1-4 0Z"
    };
    var place$1 = {
      name: "place",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7ZM7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 2.88-2.88 7.19-5 9.88C9.92 16.21 7 11.85 7 9Zm2.5 0a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z"
    };
    var view_360 = {
      name: "view_360",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 5.5c-5.52 0-10 2.24-10 5 0 2.24 2.94 4.13 7 4.77v3.23l4-4-4-4v2.73c-3.15-.56-5-1.9-5-2.73 0-1.06 3.04-3 8-3s8 1.94 8 3c0 .73-1.46 1.89-4 2.53v2.05c3.53-.77 6-2.53 6-4.58 0-2.76-4.48-5-10-5Z"
    };
    var gps_fixed = {
      name: "gps_fixed",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.94 11A8.994 8.994 0 0 0 13 3.06V1h-2v2.06A8.994 8.994 0 0 0 3.06 11H1v2h2.06A8.994 8.994 0 0 0 11 20.94V23h2v-2.06A8.994 8.994 0 0 0 20.94 13H23v-2h-2.06ZM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4Zm-7 4c0 3.87 3.13 7 7 7s7-3.13 7-7-3.13-7-7-7-7 3.13-7 7Z"
    };
    var gps_not_fixed = {
      name: "gps_not_fixed",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 3.06c4.17.46 7.48 3.77 7.94 7.94H23v2h-2.06A8.994 8.994 0 0 1 13 20.94V23h-2v-2.06A8.994 8.994 0 0 1 3.06 13H1v-2h2.06A8.994 8.994 0 0 1 11 3.06V1h2v2.06ZM5 12c0 3.87 3.13 7 7 7s7-3.13 7-7-3.13-7-7-7-7 3.13-7 7Z"
    };
    var gps_off = {
      name: "gps_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.94 11A8.994 8.994 0 0 0 13 3.06V1h-2v2.06c-.98.11-1.91.38-2.77.78l1.53 1.53a6.995 6.995 0 0 1 8.87 8.87l1.53 1.53c.4-.86.67-1.79.78-2.77H23v-2h-2.06ZM3 4.27l2.04 2.04A8.994 8.994 0 0 0 3.06 11H1v2h2.06A8.994 8.994 0 0 0 11 20.94V23h2v-2.06c1.77-.2 3.38-.91 4.69-1.98L19.73 21l1.41-1.41L4.41 2.86 3 4.27ZM12 19c1.61 0 3.09-.55 4.27-1.46L6.46 7.73A6.995 6.995 0 0 0 12 19Z"
    };
    var near_me = {
      name: "near_me",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 10.53 21 3l-7.54 18h-.98l-2.64-6.84L3 11.51v-.98Zm10.03 6.33 4.24-10.13-10.13 4.23 3.43 1.33.82.32.32.83 1.32 3.42Z"
    };
    var navigation = {
      name: "navigation",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 20.79 12 2.5l7.5 18.29-.71.71-6.79-3-6.79 3-.71-.71Zm11.78-2.59L12 7.77 7.72 18.2l3.47-1.53.81-.36.81.36 3.47 1.53Z"
    };
    var compass_calibration = {
      name: "compass_calibration",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2.5c-3.9 0-7.44 1.59-10 4.15l5 5a7.06 7.06 0 0 1 10-.01l5-5C19.44 4.09 15.9 2.5 12 2.5Zm-5 14c0-2.76 2.24-5 5-5s5 2.24 5 5-2.24 5-5 5-5-2.24-5-5Zm2 0c0 1.65 1.35 3 3 3s3-1.35 3-3-1.35-3-3-3-3 1.35-3 3Zm3-8.93c1.74 0 3.4.49 4.84 1.4l2.21-2.21A12.037 12.037 0 0 0 12 4.5c-2.56 0-5.01.79-7.06 2.26l2.21 2.22A8.973 8.973 0 0 1 12 7.57Z"
    };
    var flight_land = {
      name: "flight_land",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21.18 15.29c-.22.8-1.04 1.27-1.84 1.06L2.77 11.91V6.74l1.45.39.93 2.32 4.97 1.33V2.5l1.93.51 2.76 9.02 5.31 1.42c.8.22 1.27 1.04 1.06 1.84Zm.32 4.21h-19v2h19v-2Z"
    };
    var flight_takeoff = {
      name: "flight_takeoff",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.25 8.295c.8-.22 1.63.26 1.84 1.06.21.8-.26 1.62-1.07 1.85l-16.57 4.43-2.59-4.49 1.45-.39 1.97 1.54 4.97-1.33-4.14-7.17 1.93-.51 6.9 6.43 5.31-1.42Zm1.27 10.42h-19v2h19v-2Z"
    };
    var commute = {
      name: "commute",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 4h7c1.66 0 3 1.34 3 3v1h-2V6H4v7h5v5H7l-2 2H4v-1l1-1c-1.66 0-3-1.34-3-3V7c0-1.66 1.34-3 3-3Zm1 11c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm14.57-5.34c-.14-.4-.52-.66-.97-.66h-7.19c-.46 0-.83.26-.98.66l-1.42 4.11v5.51c0 .38.31.72.69.72h.62c.38 0 .68-.38.68-.76V18h8v1.24c0 .38.31.76.69.76h.61c.38 0 .69-.34.69-.72l.01-1.37v-4.14l-1.43-4.11Zm-.97.34h-7.19l-1.03 3h9.25l-1.03-3ZM12 16c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1Zm7-1c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Z"
    };
    var explore = {
      name: "explore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm2 0c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm2.5 5.5 7.51-3.49L17.5 6.5 9.99 9.99 6.5 17.5Zm6.6-5.5c0-.61-.49-1.1-1.1-1.1-.61 0-1.1.49-1.1 1.1 0 .61.49 1.1 1.1 1.1.61 0 1.1-.49 1.1-1.1Z"
    };
    var explore_off = {
      name: "explore_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 12c0-4.41-3.59-8-8-8-1.48 0-2.86.41-4.05 1.12L6.49 3.66A9.91 9.91 0 0 1 12 2c5.52 0 10 4.48 10 10 0 2.04-.61 3.93-1.66 5.52l-1.46-1.46C19.59 14.86 20 13.48 20 12Zm-2.5-5.5-2.59 5.58-2.99-2.99L17.5 6.5ZM2.1 4.93l1.56 1.56A9.91 9.91 0 0 0 2 12c0 5.52 4.48 10 10 10 2.04 0 3.93-.61 5.51-1.66l1.56 1.56 1.41-1.41L3.51 3.51 2.1 4.93Zm7 6.99L5.12 7.94A7.932 7.932 0 0 0 4 12c0 4.41 3.59 8 8 8 1.48 0 2.86-.41 4.06-1.11l-3.98-3.98L6.5 17.5l2.6-5.58Z"
    };
    var toll = {
      name: "toll",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8Zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6ZM7 6.35a5.99 5.99 0 0 0 0 11.3v2.09c-3.45-.89-6-4.01-6-7.74 0-3.73 2.55-6.85 6-7.74v2.09Z"
    };
    var thumb_pin = {
      name: "thumb_pin",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m20.212 10.216-6.37-6.441-1.394 1.189 1.294 1.288-1.493 1.388-1.096 1.09-.497.495-.697.1-4.38.396H5.18l-.2.198 9.06 9.018.198-.198V18.44l.3-4.459.099-.793.597-.495 1.095-1.09 1.394-1.289 1.194 1.19 1.294-1.289Zm-9.258-6.342L13.841 1 23 10.117l-2.887 2.874a1.84 1.84 0 0 1-1.195.495 1.84 1.84 0 0 1-1.194-.495l-1.095 1.09-.299 4.46c0 .594-.2 1.189-.597 1.585l-1.693 1.685-5.226-5.203-6.122 6.095c-.199.198-.398.297-.697.297-.298 0-.497-.099-.696-.297a.955.955 0 0 1 0-1.388l6.122-6.094-5.326-5.302 1.692-1.685a1.97 1.97 0 0 1 1.394-.594h.199l4.48-.298 1.094-1.09c-.696-.594-.696-1.684 0-2.378Z"
    };
    var anchor = {
      name: "anchor",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.909 9.158A3.638 3.638 0 0 0 11.999 2a3.636 3.636 0 0 0-.908 7.158v1.024H8.363V12h2.728v8.106a5.456 5.456 0 0 1-4.546-5.379H4.727a7.273 7.273 0 0 0 14.546 0h-1.819a5.456 5.456 0 0 1-4.545 5.38V12h2.727v-1.818H12.91V9.158Zm.909-3.522a1.818 1.818 0 1 1-3.636 0 1.818 1.818 0 0 1 3.636 0Z"
    };
    var aerial_drone = {
      name: "aerial_drone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 5a1 1 0 1 0 2 0h1a1 1 0 1 0 0-2h-1a1 1 0 1 0-2 0H5a1 1 0 0 0-2 0H2a1 1 0 0 0 0 2h1a1 1 0 0 0 2 0h2.204L9.03 8.032A2 2 0 0 0 10.743 9h2.836a2 2 0 0 0 1.761-1.053L16.925 5H19ZM9.539 5h5.115l-1.075 2h-2.836L9.54 5Zm6.42 4.96c-2.234 2.234-5.684 2.234-7.918 0l-1.415 1.414c3.016 3.016 7.732 3.016 10.748 0L15.96 9.96ZM5.375 12.626c3.734 3.734 9.518 3.734 13.252 0l1.414 1.414c-4.515 4.516-11.565 4.516-16.08 0l1.414-1.414Zm15.919 2.667c-5.235 5.234-13.351 5.234-18.586 0l-1.414 1.414c6.015 6.016 15.399 6.016 21.414 0l-1.414-1.414Z"
    };
    var hand_radio = {
      name: "hand_radio",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 1a1 1 0 0 0-1 1v4H8a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2v7a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-7a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-1V4a1 1 0 1 0-2 0v2h-2V2a1 1 0 0 0-1-1Zm0 13h4v7h-4v-7Zm6-6H8v4h8V8Zm-3 7h-2v1h2v-1Zm0 2h-2v1h2v-1Zm-2 2h2v1h-2v-1Z"
    };
    var camera = {
      name: "camera",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.83 5H20c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V7c0-1.1.9-2 2-2h3.17L9 3h6l1.83 2ZM4 19h16V7h-4.05l-.59-.65L14.12 5H9.88L8.64 6.35 8.05 7H4v12Zm8-11c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5Zm-3.2 5c0 1.77 1.43 3.2 3.2 3.2 1.77 0 3.2-1.43 3.2-3.2 0-1.77-1.43-3.2-3.2-3.2-1.77 0-3.2 1.43-3.2 3.2Z"
    };
    var phone = {
      name: "phone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 3h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.2-.19.45-.29.71-.29.1 0 .21.01.31.05 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1Zm2.54 2c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51Zm9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19Z"
    };
    var wifi = {
      name: "wifi",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m1 8.776 2 2c4.97-4.97 13.03-4.97 18 0l2-2c-6.07-6.07-15.92-6.07-22 0Zm8 8 3 3 3-3a4.237 4.237 0 0 0-6 0Zm-2-2-2-2c3.87-3.86 10.14-3.86 14 0l-2 2a7.074 7.074 0 0 0-10 0Z"
    };
    var wifi_off = {
      name: "wifi_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m2 4.22 1.41-1.41 16.97 16.97-1.41 1.41-7.08-7.08c-1.78.02-3.54.71-4.89 2.06l-2-2a9.823 9.823 0 0 1 4.41-2.54L7.17 9.39A12.65 12.65 0 0 0 3 12.17l-2-2C2.22 8.96 3.59 8 5.05 7.27L2 4.22Zm21 5.95-2 2a12.747 12.747 0 0 0-9.12-3.73L9.3 5.86c4.83-.84 9.97.58 13.7 4.31Zm-7.72 1.67c1.36.48 2.64 1.25 3.72 2.33l-.7.69-3.02-3.02ZM9 18.17l3 3 3-3a4.237 4.237 0 0 0-6 0Z"
    };
    var usb = {
      name: "usb",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.1 7.4v4h1v2h-3v-8h2l-3-4-3 4h2v8h-3v-2.07c.7-.37 1.2-1.08 1.2-1.93 0-1.21-.99-2.2-2.2-2.2-1.21 0-2.2.99-2.2 2.2 0 .85.5 1.56 1.2 1.93v2.07c0 1.11.89 2 2 2h3v3.05c-.71.37-1.2 1.1-1.2 1.95a2.2 2.2 0 0 0 4.4 0c0-.85-.49-1.58-1.2-1.95V15.4h3c1.11 0 2-.89 2-2v-2h1v-4h-4Z"
    };
    var bluetooth = {
      name: "bluetooth",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.355 7.71 12.645 2h-1v7.59L7.055 5l-1.41 1.41 5.59 5.59-5.59 5.59L7.055 19l4.59-4.59V22h1l5.71-5.71-4.3-4.29 4.3-4.29Zm-4.71-1.88 1.88 1.88-1.88 1.88V5.83Zm0 12.34 1.88-1.88-1.88-1.88v3.76Z"
    };
    var bluetooth_connected = {
      name: "bluetooth_connected",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.71 7.71 12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29ZM7 12l-2-2-2 2 2 2 2-2Zm7.88-4.29L13 5.83v3.76l1.88-1.88Zm0 8.58L13 18.17v-3.76l1.88 1.88ZM17 12l2-2 2 2-2 2-2-2Z"
    };
    var bluetooth_disabled = {
      name: "bluetooth_disabled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m13 5.83 1.88 1.88-1.6 1.6 1.41 1.41 3.02-3.02L12 2h-1v5.03l2 2v-3.2ZM5.41 4 4 5.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l4.29-4.29 2.3 2.29L20 18.59 5.41 4Zm9.47 12.29L13 14.41v3.76l1.88-1.88Z"
    };
    var bluetooth_searching = {
      name: "bluetooth_searching",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m9.995 2 5.71 5.71-4.3 4.29 4.3 4.29L9.995 22h-1v-7.59L4.405 19l-1.41-1.41L8.585 12l-5.59-5.59L4.405 5l4.59 4.59V2h1Zm9.53 4.71-1.26 1.26c.63 1.21.98 2.57.98 4.02 0 1.45-.36 2.82-.98 4.02l1.2 1.2a9.936 9.936 0 0 0 1.54-5.31c-.01-1.89-.55-3.67-1.48-5.19Zm-5.29 5.3 2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32Zm-3.24-6.18 1.88 1.88-1.88 1.88V5.83Zm0 12.34 1.88-1.88-1.88-1.88v3.76Z"
    };
    var apple_airplay = {
      name: "apple_airplay",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 2.5h18c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2h-4v-2h4v-12H3v12h4v2H3c-1.1 0-2-.9-2-2v-12c0-1.1.9-2 2-2Zm9 13 6 6H6l6-6Z"
    };
    var sim_card = {
      name: "sim_card",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 2h8c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V8l6-6Zm8 18V4h-7.17L6 8.83V20h12ZM7 17h2v2H7v-2Zm10 0h-2v2h2v-2ZM7 11h2v4H7v-4Zm6 4h-2v4h2v-4Zm-2-4h2v2h-2v-2Zm6 0h-2v4h2v-4Z"
    };
    var scanner = {
      name: "scanner",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m4.2 4.5 15.6 5.7c.7.2 1.2 1 1.2 1.8v5.5c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-4c0-1.1.9-2 2-2h12.6L3.5 6.4l.7-1.9Zm.8 13h14v-4H5v4Zm1-3h2v2H6v-2Zm12 0h-8v2h8v-2Z"
    };
    var router = {
      name: "router",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 4.2c1.5 0 3 .6 4.2 1.7l.8-.8C19.6 3.7 17.8 3 16 3c-1.8 0-3.6.7-5 2.1l.8.8C13 4.8 14.5 4.2 16 4.2Zm-3.3 2.5.8.8c.7-.7 1.6-1 2.5-1 .9 0 1.8.3 2.5 1l.8-.8c-.9-.9-2.1-1.4-3.3-1.4-1.2 0-2.4.5-3.3 1.4ZM17 13h2c1.1 0 2 .9 2 2v4c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-4c0-1.1.9-2 2-2h10V9h2v4Zm2 6H5v-4h14v4ZM8 16H6v2h2v-2Zm1.5 0h2v2h-2v-2Zm5.5 0h-2v2h2v-2Z"
    };
    var memory = {
      name: "memory",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 11V9h-2V7c0-1.1-.9-2-2-2h-2V3h-2v2h-2V3H9v2H7c-1.1 0-2 .9-2 2v2H3v2h2v2H3v2h2v2c0 1.1.9 2 2 2h2v2h2v-2h2v2h2v-2h2c1.1 0 2-.9 2-2v-2h2v-2h-2v-2h2ZM9 9h6v6H9V9Zm2 4h2v-2h-2v2Zm-4 4h10V7H7v10Z"
    };
    var headset_mic = {
      name: "headset_mic",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 10a9 9 0 0 1 18 0v10c0 1.66-1.34 3-3 3h-6v-2h7v-1h-4v-8h4v-2c0-3.87-3.13-7-7-7s-7 3.13-7 7v2h4v8H6c-1.66 0-3-1.34-3-3v-7Zm4 4v4H6c-.55 0-1-.45-1-1v-3h2Zm12 0v4h-2v-4h2Z"
    };
    var headset = {
      name: "headset",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 11.5a9 9 0 0 1 18 0v7c0 1.66-1.34 3-3 3h-3v-8h4v-2c0-3.87-3.13-7-7-7s-7 3.13-7 7v2h4v8H6c-1.66 0-3-1.34-3-3v-7Zm4 4v4H6c-.55 0-1-.45-1-1v-3h2Zm12 0v3c0 .55-.45 1-1 1h-1v-4h2Z"
    };
    var gamepad = {
      name: "gamepad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 2H9v5.5l3 3 3-3V2Zm-2 4.67V4h-2v2.67l1 1 1-1ZM17.33 13H20v-2h-2.67l-1 1 1 1ZM6.67 11l1 1-1 1H4v-2h2.67ZM13 17.33l-1-1-1 1V20h2v-2.67ZM16.5 9H22v6h-5.5l-3-3 3-3Zm-9 0H2v6h5.5l3-3-3-3ZM9 16.5l3-3 3 3V22H9v-5.5Z"
    };
    var speaker_group = {
      name: "speaker_group",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.8 1h8.4c.99 0 1.8.81 1.8 1.8v14.4c0 .99-.81 1.8-1.8 1.8l-8.4-.01c-.99 0-1.8-.8-1.8-1.79V2.8C8 1.81 8.81 1 9.8 1ZM18 17V3h-8v13.99l8 .01Zm-4-9a2 2 0 1 0 .001-3.999A2 2 0 0 0 14 8Zm3.5 4.5c0 1.93-1.57 3.5-3.5 3.5s-3.5-1.57-3.5-3.5S12.07 9 14 9s3.5 1.57 3.5 3.5ZM14 11c.83 0 1.5.67 1.5 1.5S14.83 14 14 14s-1.5-.67-1.5-1.5.67-1.5 1.5-1.5ZM4 5h2v16h10v2H6a2 2 0 0 1-2-2V5Z"
    };
    var speaker = {
      name: "speaker",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 2H7c-1.1 0-2 .9-2 2v16c0 1.1.9 1.99 2 1.99L17 22c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2ZM7 20V4h10v16H7Zm7-13a2 2 0 1 1-4.001.001A2 2 0 0 1 14 7Zm-2 4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4Zm-2 4c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2Z"
    };
    var mouse = {
      name: "mouse",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 1.035c4.4 0 7.96 3.54 8 7.93v6c0 4.42-3.58 8-8 8s-8-3.58-8-8v-6c.04-4.39 3.6-7.93 8-7.93Zm1 7.93h5a6.005 6.005 0 0 0-5-5.84v5.84Zm-2-5.84v5.84H6a6.005 6.005 0 0 1 5-5.84Zm1 17.84c3.31 0 6-2.69 6-6v-4H6v4c0 3.31 2.69 6 6 6Z"
    };
    var keyboard_hide = {
      name: "keyboard_hide",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2h16c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2l.01-10c0-1.1.89-2 1.99-2Zm0 12h16V4H4v10Zm7-9h2v2h-2V5Zm2 3h-2v2h2V8ZM8 5h2v2H8V5Zm2 3H8v2h2V8ZM5 8h2v2H5V8Zm2-3H5v2h2V5Zm1 6h8v2H8v-2Zm8-3h-2v2h2V8Zm-2-3h2v2h-2V5Zm5 3h-2v2h2V8Zm-2-3h2v2h-2V5Zm-5 17-4-4h8l-4 4Z"
    };
    var keyboard = {
      name: "keyboard",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2Zm0 2v10H4V7h16Zm-7 1h-2v2h2V8Zm-2 3h2v2h-2v-2Zm-1-3H8v2h2V8Zm-2 3h2v2H8v-2Zm-1 0H5v2h2v-2ZM5 8h2v2H5V8Zm11 6H8v2h8v-2Zm-2-3h2v2h-2v-2Zm2-3h-2v2h2V8Zm1 3h2v2h-2v-2Zm2-3h-2v2h2V8Z"
    };
    var keyboard_voice = {
      name: "keyboard_voice",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 14.5c1.66 0 2.99-1.34 2.99-3l.01-6c0-1.66-1.34-3-3-3s-3 1.34-3 3v6c0 1.66 1.34 3 3 3Zm-1.2-9.1c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2-.66 0-1.2-.54-1.2-1.2V5.4ZM12 16.6c2.76 0 5.3-2.1 5.3-5.1H19c0 3.42-2.72 6.24-6 6.72v3.28h-2v-3.28c-3.28-.49-6-3.31-6-6.72h1.7c0 3 2.54 5.1 5.3 5.1Z"
    };
    var smartwatch = {
      name: "smartwatch",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 0H8l-.95 5.73A7.94 7.94 0 0 0 4 12a7.94 7.94 0 0 0 3.05 6.27L8 24h8l.96-5.73A7.976 7.976 0 0 0 20 12c0-2.54-1.19-4.81-3.04-6.27L16 0Zm-1.28 4.48L14.31 2H9.7l-.41 2.47C10.13 4.17 11.05 4 12 4c.96 0 1.87.17 2.72.48ZM14.31 22l.41-2.48c-.85.31-1.76.48-2.72.48-.95 0-1.87-.17-2.71-.47L9.7 22h4.61ZM6 12c0 3.31 2.69 6 6 6s6-2.69 6-6-2.69-6-6-6-6 2.69-6 6Z"
    };
    var tv = {
      name: "tv",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h18c1.1 0 2 .9 2 2l-.01 12c0 1.1-.89 2-1.99 2h-5v2H8v-2H3c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2Zm0 14h18V5H3v12Z"
    };
    var tablet_ipad = {
      name: "tablet_ipad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 0H5a2.5 2.5 0 0 0-2.5 2.5v19A2.5 2.5 0 0 0 5 24h14a2.5 2.5 0 0 0 2.5-2.5v-19A2.5 2.5 0 0 0 19 0Zm-7 23c-.83 0-1.5-.67-1.5-1.5S11.17 20 12 20s1.5.67 1.5 1.5S12.83 23 12 23Zm-7.5-4h15V3h-15v16Z"
    };
    var tablet_android = {
      name: "tablet_android",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 0H6C4.34 0 3 1.34 3 3v18c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V3c0-1.66-1.34-3-3-3Zm-4 22h-4v-1h4v1Zm-9.25-3h14.5V3H4.75v16Z"
    };
    var iphone = {
      name: "iphone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 1H8a2.5 2.5 0 0 0-2.5 2.5v17A2.5 2.5 0 0 0 8 23h8a2.5 2.5 0 0 0 2.5-2.5v-17A2.5 2.5 0 0 0 16 1Zm-4 21c-.83 0-1.5-.67-1.5-1.5S11.17 19 12 19s1.5.67 1.5 1.5S12.83 22 12 22Zm-4.5-4h9V4h-9v14Z"
    };
    var android = {
      name: "android",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 1H8C6.34 1 5 2.34 5 4v16c0 1.66 1.34 3 3 3h8c1.66 0 3-1.34 3-3V4c0-1.66-1.34-3-3-3Zm1 17H7V4h10v14Zm-7 3h4v-1h-4v1Z"
    };
    var dock = {
      name: "dock",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 1.01 8 1c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99ZM8 23h8v-2H8v2Zm0-8h8V5H8v10Z"
    };
    var device_unknown = {
      name: "device_unknown",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h10c1.1 0 2 .9 2 2v18c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2Zm10 18V5H7v14h10ZM12 6.72c-1.96 0-3.5 1.52-3.5 3.47h1.75c0-.93.82-1.75 1.75-1.75s1.75.82 1.75 1.75c0 .767-.505 1.163-1.072 1.608-.728.572-1.558 1.224-1.558 2.842h1.76c0-.945.61-1.488 1.24-2.05.678-.604 1.38-1.23 1.38-2.4 0-1.96-1.54-3.47-3.5-3.47ZM13 18v-2h-2v2h2Z"
    };
    var desktop_windows = {
      name: "desktop_windows",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 2h18c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2h-7v2h2v2H8v-2h2v-2H3c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 14h18V4H3v12Z"
    };
    var desktop_mac = {
      name: "desktop_mac",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 2h18c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2h-7l2 3v1H8v-1l2-3H3c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 12h18V4H3v10Z"
    };
    var computer = {
      name: "computer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21.99 16c0 1.1-.89 2-1.99 2h4v2H0v-2h4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2l-.01 10ZM20 6H4v10h16V6Z"
    };
    var google_cast_connected = {
      name: "google_cast_connected",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2ZM1 12v-2c6.07 0 11 4.92 11 11h-2a9 9 0 0 0-9-9Zm0 2v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7Zm0 4v3h3c0-1.66-1.34-3-3-3Zm16-9H5V7h14v10h-5v-2h3V9Z"
    };
    var google_cast = {
      name: "google_cast",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h18c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2h-7v-2h7V5H3v3H1V5c0-1.1.9-2 2-2ZM1 21v-3c1.66 0 3 1.34 3 3H1Zm0-7v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7Zm0-2v-2c6.07 0 11 4.92 11 11h-2a9 9 0 0 0-9-9Z"
    };
    var dns = {
      name: "dns",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1ZM5 9h14V5H5v4Zm-1 4h16c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1v-6c0-.55.45-1 1-1Zm15 2H5v4h14v-4ZM7 18.5c-.82 0-1.5-.67-1.5-1.5s.68-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5ZM5.5 7c0 .83.68 1.5 1.5 1.5.83 0 1.5-.68 1.5-1.5S7.82 5.5 7 5.5 5.5 6.17 5.5 7Z"
    };
    var fingerprint_scanner = {
      name: "fingerprint_scanner",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.815 4.47c-.08 0-.16-.02-.23-.06-1.92-.99-3.58-1.41-5.57-1.41-1.98 0-3.86.47-5.57 1.41-.24.13-.54.04-.68-.2a.506.506 0 0 1 .2-.68C7.825 2.52 9.865 2 12.015 2c2.13 0 3.99.47 6.03 1.52.25.13.34.43.21.67a.49.49 0 0 1-.44.28ZM3.505 9.72a.499.499 0 0 1-.41-.79c.99-1.4 2.25-2.5 3.75-3.27 3.14-1.62 7.16-1.63 10.31-.01 1.5.77 2.76 1.86 3.75 3.25a.5.5 0 0 1-.12.7c-.23.16-.54.11-.7-.12a9.388 9.388 0 0 0-3.39-2.94c-2.87-1.47-6.54-1.47-9.4.01-1.36.7-2.5 1.7-3.4 2.96-.08.14-.23.21-.39.21Zm5.9 11.92c.09.1.22.15.35.15.13 0 .26-.05.37-.15.19-.2.19-.51 0-.71-.77-.78-1.21-1.27-1.85-2.42-.61-1.08-.93-2.41-.93-3.85 0-2.42 2.09-4.39 4.66-4.39 2.57 0 4.66 1.97 4.66 4.39 0 .28.22.5.5.5s.5-.22.5-.5c0-2.97-2.54-5.39-5.66-5.39s-5.66 2.42-5.66 5.39c0 1.61.36 3.11 1.05 4.34.67 1.21 1.14 1.77 2.01 2.64Zm7.52-1.7c-1.19 0-2.24-.3-3.1-.89-1.49-1.01-2.38-2.65-2.38-4.39 0-.28.22-.5.5-.5s.5.22.5.5c0 1.41.72 2.74 1.94 3.56.71.48 1.54.71 2.54.71.24 0 .64-.03 1.04-.1.27-.05.53.13.58.41.05.27-.13.53-.41.58-.57.11-1.07.12-1.21.12Zm-2.14 2.04c.04.01.09.02.13.02.21 0 .42-.15.47-.38a.496.496 0 0 0-.35-.61c-1.41-.39-2.32-.91-3.27-1.85a6.297 6.297 0 0 1-1.87-4.51c0-1.07.93-1.94 2.08-1.94s2.08.87 2.08 1.94c0 1.62 1.38 2.94 3.08 2.94 1.7 0 3.08-1.32 3.08-2.94 0-4.32-3.7-7.83-8.25-7.83-3.23 0-6.18 1.81-7.51 4.6-.45.95-.68 2.04-.68 3.24 0 1.35.24 2.65.73 3.96.09.25.38.39.64.29.26-.09.39-.38.29-.64-.6-1.6-.67-2.83-.67-3.61 0-1.04.2-1.99.59-2.8 1.17-2.45 3.77-4.03 6.61-4.03 4 0 7.25 3.06 7.25 6.83 0 1.07-.93 1.94-2.08 1.94s-2.08-.87-2.08-1.94c0-1.62-1.38-2.94-3.08-2.94-1.7 0-3.08 1.32-3.08 2.94 0 1.98.77 3.83 2.17 5.22 1.09 1.07 2.13 1.66 3.72 2.1Z"
    };
    var print_off = {
      name: "print_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.23.82.82 2.23l5 4.99c-1.66 0-3 1.34-3 3v6h4v4h12l2.95 2.96 1.41-1.41L2.23.82Zm2.59 13.4v-4c0-.55.45-1 1-1h2l3 3h-4v2h-2Zm12 4-4-4h-4v4h8Zm-8-14h8v3h-5.34l2 2h6.34c.55 0 1 .45 1 1v4l-2 .01v-2.01h-2.34l4 4h2.34v-6c0-1.66-1.34-3-3-3h-1v-5h-12v.36l2 2v-.36Zm9 6.51a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z"
    };
    var print = {
      name: "print",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 8h-1V3H6v5H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3ZM8 5h8v3H8V5Zm8 14v-4H8v4h8Zm2-4v-2H6v2H4v-4c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v4h-2Zm-1-3.5a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z"
    };
    var flash_off = {
      name: "flash_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18.43 2h-10v1.61l6.13 6.13L18.43 2Zm0 8h-3.61l2.28 2.28L18.43 10Zm-15-5.73 1.41-1.41 15.73 15.73L19.16 20l-4.15-4.15L11.43 22v-9h-3V9.27l-5-5Z"
    };
    var flash_on = {
      name: "flash_on",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 2v11h3v9l7-12h-4l3-8H7Z"
    };
    var style$2 = {
      name: "style",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22.292 15.7-4.96-11.97a2.013 2.013 0 0 0-1.81-1.23c-.26 0-.53.04-.79.15L7.362 5.7a1.999 1.999 0 0 0-1.08 2.6l4.96 11.97a1.998 1.998 0 0 0 2.6 1.08l7.36-3.05a1.994 1.994 0 0 0 1.09-2.6Zm-19.5 3.7 1.34.56v-9.03l-2.43 5.86c-.41 1.02.08 2.19 1.09 2.61Zm5.34-11.86 4.96 11.96 7.35-3.05-4.95-11.95h-.01l-7.35 3.04Zm3.13.21a1 1 0 1 0 0 2 1 1 0 0 0 0-2ZM8.142 21.5c-1.1 0-2-.9-2-2v-6.34l3.45 8.34h-1.45Z"
    };
    var color_palette = {
      name: "color_palette",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12c0 5.51 4.49 10 10 10a2.5 2.5 0 0 0 2.5-2.5c0-.61-.23-1.2-.64-1.67a.528.528 0 0 1-.13-.33c0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9S2 6.49 2 12Zm2 0c0-4.41 3.59-8 8-8s8 3.14 8 7c0 2.21-1.79 4-4 4h-1.77a2.5 2.5 0 0 0-2.5 2.5c0 .6.22 1.19.63 1.65.06.07.14.19.14.35 0 .28-.22.5-.5.5-4.41 0-8-3.59-8-8Zm2.5-2a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM8 7.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM14.5 6a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm1.5 5.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var dropper = {
      name: "dropper",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.67 3c-.26 0-.51.1-.71.29l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42l-2.34-2.34c-.2-.19-.45-.29-.7-.29Zm-.01 2.41.92.92-2.69 2.69-.92-.92 2.69-2.69ZM5 17.08 6.92 19l8.06-8.06-1.92-1.92L5 17.08Z"
    };
    var texture = {
      name: "texture",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.88 3 3 11.88v2.83L14.71 3h-2.83Zm7.63.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41ZM3 5c0-1.1.9-2 2-2h2L3 7V5Zm16 16c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2Zm-6.88 0H9.29L21 9.29v2.83L12.12 21Z"
    };
    var pram = {
      name: "pram",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.5 10V2c4.42 0 8 3.58 8 8h-8Zm2-5.66V8h3.66a6.032 6.032 0 0 0-3.66-3.66ZM6.94 11l-.95-2H2.5v2h2.22s1.89 4.07 2.12 4.42C5.74 16.01 5 17.17 5 18.5 5 20.43 6.57 22 8.5 22c1.76 0 3.22-1.3 3.46-3h2.08c.24 1.7 1.7 3 3.46 3 1.93 0 3.5-1.57 3.5-3.5 0-1.04-.46-1.97-1.18-2.61A7.948 7.948 0 0 0 21.5 11H6.94ZM7 18.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5S9.33 17 8.5 17 7 17.67 7 18.5ZM17.5 20c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5Zm.45-4.97.29-.37c.4-.51.71-1.07.92-1.66H7.87c.125.254.237.486.333.686.159.328.275.568.337.674l.44.67c1.18.17 2.18.93 2.68 1.97h2.68a3.505 3.505 0 0 1 3.61-1.97Z"
    };
    var fridge = {
      name: "fridge",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6 2 12 .01c1.1 0 2 .88 2 1.99v16c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V4a2 2 0 0 1 2-2Zm2 3h2v3H8V5Zm0 7h2v5H8v-5Zm10 8H6v-9.02h12V20ZM6 9h12V4H6v5Z"
    };
    var briefcase = {
      name: "briefcase",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 7h-4V5l-2-2h-4L8 5v2H4c-1.1 0-2 .9-2 2v5c0 .75.4 1.38 1 1.73V19c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2v-3.28c.59-.35 1-.99 1-1.72V9c0-1.1-.9-2-2-2ZM10 5h4v2h-4V5Zm10 4H4v5h5v-3h6v3h5V9Zm-7 6h-2v-2h2v2Zm-8 4h14v-3h-4v1H9v-1H5v3Z"
    };
    var dice = {
      name: "dice",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 2v14H5V5h14ZM6 16.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM7.5 6a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm3 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm6 3a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM15 7.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var toilet = {
      name: "toilet",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 6c1.11 0 2-.89 2-2 0-1.11-.89-2-2-2-1.11 0-2 .89-2 2 0 1.11.89 2 2 2Zm-2 8.5V22h4v-7.5h1.5V9c0-1.1-.9-2-2-2h-3c-1.1 0-2 .9-2 2v5.5H5ZM17.5 16v6h-3v-6h-3l2.54-7.63A2 2 0 0 1 15.94 7h.12c.86 0 1.62.55 1.9 1.37L20.5 16h-3ZM18 4c0 1.11-.89 2-2 2-1.11 0-2-.89-2-2 0-1.11.89-2 2-2 1.11 0 2 .89 2 2Z"
    };
    var nature_people = {
      name: "nature_people",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22.085 9.085c0-3.87-3.13-7-7-7s-7 3.13-7 7a6.98 6.98 0 0 0 5.83 6.89v3.94h-8v-3h1v-4c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v4h1v5h16v-2h-3v-3.88a7 7 0 0 0 6.17-6.95Zm-17.67-1.17a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm5.67 1.17c0 2.76 2.24 5 5 5s5-2.24 5-5-2.24-5-5-5-5 2.24-5 5Z"
    };
    var nature = {
      name: "nature",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.885 16.035h.03v3.88h6v2h-14v-2h6v-3.94a6.98 6.98 0 0 1-5.83-6.89c0-3.87 3.13-7 7-7s7 3.13 7 7c0 3.59-2.71 6.55-6.2 6.95Zm-.8-11.95c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5Z"
    };
    var snow = {
      name: "snow",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 11h-4.17l3.24-3.24-1.41-1.42L15 11h-2V9l4.66-4.66-1.42-1.41L13 6.17V2h-2v4.17L7.76 2.93 6.34 4.34 11 9v2H9L4.34 6.34 2.93 7.76 6.17 11H2v2h4.17l-3.24 3.24 1.41 1.42L9 13h2v2l-4.66 4.66 1.42 1.41L11 17.83V22h2v-4.17l3.24 3.24 1.42-1.41L13 15v-2h2l4.66 4.66 1.41-1.42L17.83 13H22v-2Z"
    };
    var thermostat = {
      name: "thermostat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2c1.66 0 3 1.34 3 3v8c1.21.91 2 2.37 2 4 0 2.76-2.24 5-5 5s-5-2.24-5-5c0-1.63.79-3.09 2-4V5c0-1.66 1.34-3 3-3Zm0 2c-.55 0-1 .45-1 1v6h2V9h-1V8h1V6h-1V5h1c0-.55-.45-1-1-1Z"
    };
    var money = {
      name: "money",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 4v16h20V4H2Zm5 4H5v8h2V8Zm5 8H9c-.55 0-1-.45-1-1V9c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1Zm3 0h3c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1Zm1-6h1v4h-1v-4Zm-6 0h1v4h-1v-4Zm-6 8h16V6H4v12Z"
    };
    var dollar = {
      name: "dollar",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2Zm-9 13h2v-1h1c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1h-3v-1h4V8h-2V7h-2v1h-1c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h3v1H9v2h2v1Zm-7 1h16V6H4v12Z"
    };
    var flower = {
      name: "flower",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.66 13.57c.15 0 .29-.01.43-.03A3.15 3.15 0 0 0 12 15.5c1.31 0 2.44-.81 2.91-1.96a3.145 3.145 0 0 0 3.57-3.11c0-.71-.25-1.39-.67-1.93.43-.54.67-1.22.67-1.93a3.145 3.145 0 0 0-3.57-3.11A3.15 3.15 0 0 0 12 1.5c-1.31 0-2.44.81-2.91 1.96a3.145 3.145 0 0 0-3.57 3.11c0 .71.25 1.39.67 1.93-.43.54-.68 1.22-.68 1.93 0 1.73 1.41 3.14 3.15 3.14ZM12 13.5c-.62 0-1.12-.49-1.14-1.1l.12-1.09c.32.12.66.19 1.02.19s.71-.07 1.03-.19l.11 1.09c-.02.61-.52 1.1-1.14 1.1Zm2.7-2.13c.18.13.4.2.64.2.63 0 1.15-.51 1.15-1.15 0-.44-.26-.84-.66-1.03l-.88-.42c-.12.74-.51 1.38-1.06 1.83l.81.57Zm-.01-5.74c.2-.13.42-.2.65-.2.63 0 1.14.51 1.14 1.14 0 .44-.25.83-.66 1.03l-.88.42c-.12-.74-.51-1.38-1.07-1.83l.82-.56ZM13.14 4.6c-.02-.61-.52-1.1-1.14-1.1-.62 0-1.12.49-1.14 1.1l.12 1.09c.32-.12.66-.19 1.02-.19s.71.07 1.03.19l.11-1.09Zm-4.48.83c.24 0 .46.07.64.2l.81.56c-.55.45-.94 1.09-1.06 1.83l-.88-.42c-.4-.2-.66-.59-.66-1.03 0-.63.52-1.14 1.15-1.14Zm.39 3.55-.88.42c-.4.2-.66.59-.65 1.02 0 .63.51 1.14 1.14 1.14.23 0 .45-.07.65-.2l.81-.55c-.56-.45-.95-1.09-1.07-1.83ZM12 22.5a9 9 0 0 0 9-9 9 9 0 0 0-9 9Zm-9-9a9 9 0 0 0 9 9 9 9 0 0 0-9-9Zm11.44 6.56c.71-1.9 2.22-3.42 4.12-4.12a7.04 7.04 0 0 1-4.12 4.12Zm-9-4.12c1.9.71 3.42 2.22 4.12 4.12a7.04 7.04 0 0 1-4.12-4.12Z"
    };
    var laundry = {
      name: "laundry",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6 2 12 .01c1.11 0 2 .88 2 1.99v16c0 1.11-.89 2-2 2H6c-1.11 0-2-.89-2-2V4c0-1.11.89-2 2-2Zm-.01 2L6 20h12V4H5.99ZM8 5a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm2 1a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm2 13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5Zm2.36-2.64c1.3-1.3 1.3-3.42 0-4.72l-4.72 4.72c1.3 1.3 3.42 1.3 4.72 0Z"
    };
    var cake = {
      name: "cake",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 5a2 2 0 1 1-4 0c0-.38.1-.73.29-1.03L12 1l1.71 2.97c.19.3.29.65.29 1.03Zm-1 5h5c1.66 0 3 1.34 3 3v9c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1v-9c0-1.66 1.34-3 3-3h5V8h2v2ZM5 21v-3c.9-.01 1.76-.37 2.4-1.01l1.09-1.07 1.07 1.07c1.31 1.31 3.59 1.3 4.89 0l1.08-1.07 1.07 1.07c.64.64 1.5 1 2.4 1.01v3H5Zm12.65-5.07c.36.37.84.56 1.35.57V13c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v3.5c.51-.01.99-.21 1.34-.57l2.14-2.13 2.13 2.13c.74.74 2.03.74 2.77 0l2.14-2.13 2.13 2.13Z"
    };
    var cocktail = {
      name: "cocktail",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 3H3v2l8 9v5H6v2h12v-2h-5v-5l8-9V3Zm-6.23 6L12 12.11 9.23 9h5.54ZM5.66 5l1.77 2h9.14l1.78-2H5.66Z"
    };
    var coffee = {
      name: "coffee",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 3h16c1.11 0 2 .89 2 2v3c0 1.11-.89 2-2 2h-2v3c0 2.21-1.79 4-4 4H8c-2.21 0-4-1.79-4-4V3Zm12 10V5H6v8c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2Zm2-5V5h2v3h-2ZM2 19h18v2H2v-2Z"
    };
    var drink = {
      name: "drink",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3 2 2.01 18.23C5.13 21.23 5.97 22 7 22h10c1.03 0 1.87-.77 1.99-1.77L21 2H3Zm4 18.01L5.89 10H18.1L17 20l-10 .01ZM5.67 8h12.66l.43-4H5.23l.44 4ZM12 19c1.66 0 3-1.34 3-3 0-2-3-5.4-3-5.4S9 14 9 16c0 1.66 1.34 3 3 3Zm1-3c0-.36-.41-1.18-1-2.09-.59.9-1 1.72-1 2.09 0 .55.45 1 1 1s1-.45 1-1Z"
    };
    var pizza = {
      name: "pizza",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.01 6C5.23 3.54 8.43 2 12 2c3.57 0 6.78 1.55 8.99 4L12 22 3.01 6Zm2.5.36L12 17.92l6.49-11.56A10.152 10.152 0 0 0 12 4c-2.38 0-4.68.85-6.49 2.36ZM9 5.5c-.83 0-1.5.67-1.5 1.5S8.17 8.5 9 8.5s1.5-.67 1.5-1.5S9.82 5.5 9 5.5Zm3 9c-.83 0-1.5-.67-1.5-1.5s.68-1.5 1.5-1.5 1.5.67 1.5 1.5-.68 1.5-1.5 1.5Z"
    };
    var fast_food = {
      name: "fast_food",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 1v4h5l-1.65 16.53c-.1.82-.79 1.47-1.63 1.47H18v-2h1.39l1.4-14h-9.56L11 5h5V1h2ZM8.5 8.99C4.75 8.99 1 11 1 15h15c0-4-3.75-6.01-7.5-6.01ZM1 21.98c0 .56.45 1.01 1.01 1.01H15c.56 0 1.01-.45 1.01-1.01V21H1v.98Zm7.5-10.99c-1.41 0-3.77.46-4.88 2.01h9.76c-1.11-1.55-3.47-2.01-4.88-2.01ZM1 17h15v2H1v-2Z"
    };
    var restaurant = {
      name: "restaurant",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 9h2V2h2v7c0 2.21-1.79 4-4 4v9H7v-9c-2.21 0-4-1.79-4-4V2h2v7h2V2h2v7Zm7 5V6c0-1.76 2.24-4 5-4v20h-2v-8h-3Z"
    };
    var dining = {
      name: "dining",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.85 9.939c-1.59 1.59-3.74 2.09-5.27 1.38l-1.47 1.47 6.88 6.88-1.41 1.41-6.88-6.88-6.89 6.87-1.41-1.41 9.76-9.76c-.71-1.53-.21-3.68 1.38-5.27 1.92-1.91 4.66-2.27 6.12-.81 1.47 1.47 1.1 4.21-.81 6.12Zm-9.22.36-2.83 2.83-4.19-4.18a4.008 4.008 0 0 1 0-5.66l7.02 7.01Z"
    };
    var puzzle = {
      name: "puzzle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.25 4.75a2.5 2.5 0 0 1 5 0h4c1.1 0 2 .9 2 2v4a2.5 2.5 0 0 1 0 5v4c0 1.1-.9 2-2 2h-3.8v-.3c0-1.49-1.21-2.7-2.7-2.7-1.49 0-2.7 1.21-2.7 2.7v.3h-3.8c-1.1 0-2-.9-2-2v-3.8h.3c1.49 0 2.7-1.21 2.7-2.7 0-1.49-1.21-2.7-2.7-2.7h-.29v-3.8c0-1.1.89-2 1.99-2h4Zm3 0c0-.28-.22-.5-.5-.5s-.5.22-.5.5v2h-6l.01 2.12c1.75.68 2.99 2.39 2.99 4.38 0 1.99-1.25 3.7-3 4.38v2.12h2.12c.68-1.75 2.39-3 4.38-3 1.99 0 3.7 1.25 4.38 3h2.12v-6h2c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-2v-6h-6v-2Z"
    };
    var smoking_off = {
      name: "smoking_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.03 8.175H14.5a3.35 3.35 0 0 1 0-6.7v1.5c-1.02 0-1.85.73-1.85 1.75s.83 2 1.85 2h1.53c1.87 0 3.47 1.35 3.47 3.16v1.64H18v-1.3c0-1.31-.92-2.05-1.97-2.05Zm.97 4.35h-2.34l2.34 2.34v-2.34Zm2.5 0H18v3h1.5v-3Zm2.5 0h-1.5v3H22v-3Zm-3.15-8.27c.62-.61 1-1.45 1-2.38h-1.5c0 1.02-.83 1.85-1.85 1.85v1.5c2.24 0 4 1.83 4 4.07v2.23H22v-2.24c0-2.22-1.28-4.14-3.15-5.03ZM2 5.525l1.41-1.41 17 17-1.41 1.41-7-7H2v-3h7l-7-7Z"
    };
    var smoking = {
      name: "smoking",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.85 6.85c0 .93-.38 1.77-1 2.38 1.87.89 3.15 2.81 3.15 5.03v2.24h-1.5v-2.23c0-2.24-1.76-4.07-4-4.07V8.7c1.02 0 1.85-.83 1.85-1.85S17.52 5 16.5 5V3.5c1.85 0 3.35 1.5 3.35 3.35ZM14.5 11.7h1.53c1.87 0 3.47 1.35 3.47 3.16v1.64H18v-1.3c0-1.31-.92-2.05-1.97-2.05H14.5a3.35 3.35 0 0 1 0-6.7v1.5c-1.02 0-1.85.73-1.85 1.75s.83 2 1.85 2ZM2 17.5h15v3H2v-3Zm16 0h1.5v3H18v-3Zm2.5 0H22v3h-1.5v-3Z"
    };
    var widgets = {
      name: "widgets",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m16 2.345-5.66 5.65v-4.34h-8v8h8v-3.66l5.66 5.66h-3.66v8h8v-8H16l5.66-5.66L16 2.345Zm2.83 5.66L16 5.175l-2.83 2.83 2.83 2.83 2.83-2.83ZM8.34 9.655v-4h-4v4h4Zm10 6v4h-4v-4h4Zm-10 4v-4h-4v4h4Zm-6-6h8v8h-8v-8Z"
    };
    var puzzle_filled = {
      name: "puzzle_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.75 2.25a2.5 2.5 0 0 0-2.5 2.5h-4c-1.1 0-1.99.9-1.99 2v3.8h.29c1.49 0 2.7 1.21 2.7 2.7 0 1.49-1.21 2.7-2.7 2.7h-.3v3.8c0 1.1.9 2 2 2h3.8v-.3c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7v.3h3.8c1.1 0 2-.9 2-2v-4a2.5 2.5 0 0 0 0-5v-4c0-1.1-.9-2-2-2h-4a2.5 2.5 0 0 0-2.5-2.5Z"
    };
    var bandage = {
      name: "bandage",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m17.745 12 3.98-3.98a.996.996 0 0 0 0-1.41l-4.34-4.34a.996.996 0 0 0-1.41 0l-3.98 3.98-3.98-3.98a1.001 1.001 0 0 0-1.41 0l-4.34 4.34a.996.996 0 0 0 0 1.41L6.245 12l-3.98 3.98a.996.996 0 0 0 0 1.41l4.34 4.34c.39.39 1.02.39 1.41 0l3.98-3.98 3.98 3.98c.2.2.45.29.71.29.26 0 .51-.1.71-.29l4.34-4.34a.996.996 0 0 0 0-1.41L17.745 12Zm-5.73-3.02c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1Zm-8.34-1.66 3.63 3.62 3.62-3.63-3.62-3.62-3.63 3.63Zm6.34 5.66c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1Zm1 1c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Zm3-3c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1Zm-.97 5.72 3.63 3.62 3.62-3.63-3.62-3.62-3.63 3.63Z"
    };
    var brush = {
      name: "brush",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.169 3c-.26 0-.51.1-.71.29l-8.96 8.96 2.75 2.75 8.96-8.96a.996.996 0 0 0 0-1.41l-1.34-1.34c-.2-.2-.45-.29-.7-.29ZM7.499 16c.55 0 1 .45 1 1 0 1.1-.9 2-2 2-.17 0-.33-.02-.5-.05.31-.55.5-1.21.5-1.95 0-.55.45-1 1-1Zm-3 1c0-1.66 1.34-3 3-3s3 1.34 3 3c0 2.21-1.79 4-4 4-1.51 0-3.08-.78-4-2 .84 0 2-.69 2-2Z"
    };
    var measure$1 = {
      name: "measure",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6h18c1.1 0 2 .9 2 2v8c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V8c0-1.1.9-2 2-2Zm0 10h18V8h-2v4h-2V8h-2v4h-2V8h-2v4H9V8H7v4H5V8H3v8Z"
    };
    var report_bug = {
      name: "report_bug",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.19 8H20v2h-2.09c.05.33.09.66.09 1v1h2v2h-2v1c0 .34-.04.67-.09 1H20v2h-2.81c-1.04 1.79-2.97 3-5.19 3s-4.15-1.21-5.19-3H4v-2h2.09c-.05-.33-.09-.66-.09-1v-1H4v-2h2v-1c0-.34.04-.67.09-1H4V8h2.81c.45-.78 1.07-1.45 1.81-1.96L7 4.41 8.41 3l2.18 2.17c.45-.11.92-.17 1.41-.17.49 0 .96.06 1.42.17L15.59 3 17 4.41l-1.63 1.63c.75.51 1.37 1.18 1.82 1.96ZM16 15v-4c0-.22-.03-.47-.07-.69l-.1-.65-.38-.65c-.3-.53-.71-.97-1.21-1.31l-.61-.42-.68-.16a3.787 3.787 0 0 0-1.89 0l-.74.18-.57.39A4.1 4.1 0 0 0 8.54 9l-.37.65-.1.65c-.04.22-.07.47-.07.7v4c0 .23.03.48.07.71l.1.65.37.64c.72 1.23 2.04 2 3.46 2s2.74-.76 3.46-2l.37-.65.1-.65c.04-.23.07-.48.07-.7Zm-6-1h4v2h-4v-2Zm4-4h-4v2h4v-2Z"
    };
    var build_wrench = {
      name: "build_wrench",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m13.576 9.91 9.08 9.08c.4.4.4 1.03 0 1.41l-2.3 2.3a.996.996 0 0 1-1.41 0l-9.11-9.11c-2.32.87-5.03.38-6.89-1.48-2.3-2.29-2.51-5.88-.65-8.42l3.83 3.83 1.42-1.41-3.84-3.85c2.55-1.86 6.13-1.65 8.43.65a6.505 6.505 0 0 1 1.44 7Zm-3.38 1.22 9.46 9.46.88-.89-9.45-9.45c.46-.59.76-1.25.88-1.96.25-1.39-.16-2.88-1.24-3.96-.95-.94-2.2-1.38-3.44-1.31l3.09 3.09-4.24 4.24-3.09-3.09c-.07 1.24.37 2.5 1.32 3.44a4.472 4.472 0 0 0 3.83 1.25c.71-.1 1.39-.37 2-.82Z"
    };
    var gavel = {
      name: "gavel",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.375 6.66-2.83 2.83-5.66-5.66L12.715 1l5.66 5.66Zm-9.91-1.42-2.83 2.83 14.14 14.14 2.83-2.83L8.465 5.24ZM13.395 21h-12v2h12v-2Zm-3.51-5.86-5.66-5.66-2.83 2.83 5.66 5.66 2.83-2.83Z"
    };
    var placeholder_icon = {
      name: "placeholder_icon",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 5H3c0-1.1.9-2 2-2v2Zm0 8H3v-2h2v2Zm2 8h2v-2H7v2ZM5 9H3V7h2v2Zm8-6h-2v2h2V3Zm6 2V3c1.1 0 2 .9 2 2h-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm0-4H3v-2h2v2ZM9 3H7v2h2V3Zm4 18h-2v-2h2v2Zm6-8h2v-2h-2v2Zm2 6c0 1.1-.9 2-2 2v-2h2ZM19 9h2V7h-2v2Zm2 8h-2v-2h2v2Zm-6 4h2v-2h-2v2Zm2-16h-2V3h2v2Z",
      sizes: {
        small: {
          name: "placeholder_icon_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M4 4H2c0-1.1.9-2 2-2v2Zm0 6H2V8h2v2Zm1 6h2v-2H5v2ZM4 7H2V5h2v2Zm6-5H8v2h2V2Zm4 2V2c1.1 0 2 .9 2 2h-2ZM4 16v-2H2c0 1.1.9 2 2 2Zm0-3H2v-2h2v2ZM7 2H5v2h2V2Zm3 14H8v-2h2v2Zm4-6h2V8h-2v2Zm2 4c0 1.1-.9 2-2 2v-2h2Zm-2-7h2V5h-2v2Zm2 6h-2v-2h2v2Zm-5 3h2v-2h-2v2Zm2-12h-2V2h2v2Z"
        }
      }
    };
    var offline_document = {
      name: "offline_document",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6ZM6 20V4h7v5h5v11H6Zm5-9h2v4h2.5L12 19l-3.5-4H11v-4Z"
    };
    var folder_shared = {
      name: "folder_shared",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6h8c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2l.01-12c0-1.1.89-2 1.99-2h6l2 2ZM4 6v12h16V8h-8.83l-2-2H4Zm11 7c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2Zm4 3v1h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2Z"
    };
    var folder_add = {
      name: "folder_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 6h-8l-2-2H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2ZM4 18V6h5.17l2 2H20v10H4Zm10-4h-2v-2h2v-2h2v2h2v2h-2v2h-2v-2Z"
    };
    var folder_open = {
      name: "folder_open",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6h8c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2l.01-12c0-1.1.89-2 1.99-2h6l2 2ZM4 8v10h16V8H4Z"
    };
    var folder = {
      name: "folder",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 4h6l2 2h8c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2l.01-12c0-1.1.89-2 1.99-2Zm7.17 4-2-2H4v12h16V8h-8.83Z"
    };
    var file_description = {
      name: "file_description",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6Zm2 10H8v2h8v-2Zm0 4H8v2h8v-2ZM6 20h12V9h-5V4H6v16Z"
    };
    var file = {
      name: "file",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 2h8l6 6v12c0 1.1-.9 2-2 2H5.99C4.89 22 4 21.1 4 20l.01-16c0-1.1.89-2 1.99-2Zm0 2v16h12V9h-5V4H6Z"
    };
    var folder_favorite = {
      name: "folder_favorite",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2ZM4 18V6h5.17l2 2H20v10H4Zm8.39-1 .69-2.96-2.3-1.99 3.03-.26L15 9l1.19 2.79 3.03.26-2.3 1.99.69 2.96L15 15.47 12.39 17Z"
    };
    var file_add = {
      name: "file_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6Zm-1 9h-2v3H8v2h3v3h2v-3h3v-2h-3v-3Zm-7 9h12V9h-5V4H6v16Z"
    };
    var library_video = {
      name: "library_video",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 2h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2ZM2 6h2v14h14v2H4c-1.1 0-2-.9-2-2V6Zm18 10H8V4h12v12Zm-8-1.5v-9l6 4.5-6 4.5Z"
    };
    var library_add = {
      name: "library_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 2h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2ZM2 6h2v14h14v2H4c-1.1 0-2-.9-2-2V6Zm18 10H8V4h12v12Zm-5-2h-2v-3h-3V9h3V6h2v3h3v2h-3v3Z"
    };
    var library_books = {
      name: "library_books",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 2h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2ZM2 6h2v14h14v2H4c-1.1 0-2-.9-2-2V6Zm6 10V4h12v12H8Zm10-7h-8v2h8V9Zm-8 3h4v2h-4v-2Zm8-6h-8v2h8V6Z"
    };
    var library_music = {
      name: "library_music",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 2h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 14h12V4H8v12Zm4.5-1a2.5 2.5 0 0 0 2.5-2.5V7h3V5h-4v5.51c-.42-.32-.93-.51-1.5-.51a2.5 2.5 0 0 0 0 5ZM2 6h2v14h14v2H4c-1.1 0-2-.9-2-2V6Z"
    };
    var library_image = {
      name: "library_image",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm12.21 8.83 2.75-3.54L19.5 15h-11l2.75-3.53 1.96 2.36ZM7 17h14V3H7v14Z"
    };
    var library_pdf = {
      name: "library_pdf",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8 2h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2Zm0 14h12V4H8v12ZM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6Zm12 3v3c0 .55-.45 1-1 1h-2V8h2c.55 0 1 .45 1 1Zm-2 0h1v3h-1V9Zm5 2h-1v2h-1V8h2v1h-1v1h1v1Zm-9 0h1c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1H9v5h1v-2Zm1-2h-1v1h1V9Z"
    };
    var download = {
      name: "download",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 9.5h-4v-6H9v6H5l7 7 7-7Zm-8 2v-6h2v6h1.17L12 13.67 9.83 11.5H11Zm8 9v-2H5v2h14Z"
    };
    var upload = {
      name: "upload",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 16.5v-6h4l-7-7-7 7h4v6h6ZM12 6.33l2.17 2.17H13v6h-2v-6H9.83L12 6.33Zm7 14.17v-2H5v2h14Z"
    };
    var download_done = {
      name: "download_done",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m5 10.7 4.6 4.6L19 6l-2-2-7.4 7.4L7 8.8l-2 1.9ZM19 18H5v2h14v-2Z"
    };
    var cloud_upload = {
      name: "cloud_upload",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96ZM19 18H6c-2.21 0-4-1.79-4-4 0-2.05 1.53-3.76 3.56-3.97l1.07-.11.5-.95A5.469 5.469 0 0 1 12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5 1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3Zm-8.45-5H8l4-4 4 4h-2.55v3h-2.9v-3Z"
    };
    var cloud_off = {
      name: "cloud_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.41 2.93 3 4.34l2.77 2.77h-.42A5.994 5.994 0 0 0 0 13.07c0 3.31 2.69 6 6 6h11.73l2 2 1.41-1.41L4.41 2.93ZM24 14.07c0-2.64-2.05-4.78-4.65-4.96A7.49 7.49 0 0 0 12 3.07c-1.33 0-2.57.36-3.65.97l1.49 1.49c.67-.29 1.39-.46 2.16-.46 3.04 0 5.5 2.46 5.5 5.5v.5H19a2.996 2.996 0 0 1 1.79 5.4l1.41 1.41c1.09-.92 1.8-2.27 1.8-3.81Zm-22-1c0 2.21 1.79 4 4 4h9.73l-8-8H6c-2.21 0-4 1.79-4 4Z"
    };
    var cloud_download = {
      name: "cloud_download",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96ZM19 18H6c-2.21 0-4-1.79-4-4 0-2.05 1.53-3.76 3.56-3.97l1.07-.11.5-.95A5.469 5.469 0 0 1 12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5 1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3Zm-8.45-8h2.9v3H16l-4 4-4-4h2.55v-3Z"
    };
    var cloud_done = {
      name: "cloud_done",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96ZM19 18H6c-2.21 0-4-1.79-4-4 0-2.05 1.53-3.76 3.56-3.97l1.07-.11.5-.95A5.469 5.469 0 0 1 12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5 1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3ZM7.91 12.09 10 14.18l4.6-4.6 1.41 1.41L10 17l-3.5-3.5 1.41-1.41Z"
    };
    var cloud$1 = {
      name: "cloud",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.35 8.04A7.496 7.496 0 0 1 12 4a7.49 7.49 0 0 1 7.35 6.04c2.6.18 4.65 2.32 4.65 4.96 0 2.76-2.24 5-5 5H6c-3.31 0-6-2.69-6-6 0-3.09 2.34-5.64 5.35-5.96Zm12.04 2.39A5.503 5.503 0 0 0 12 6C9.94 6 8.08 7.14 7.13 8.97l-.5.95-1.07.11A3.973 3.973 0 0 0 2 14c0 2.21 1.79 4 4 4h13c1.65 0 3-1.35 3-3a2.98 2.98 0 0 0-2.78-2.96l-1.53-.11-.3-1.5Z"
    };
    var offline = {
      name: "offline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2.02c-5.51 0-9.98 4.47-9.98 9.98 0 5.51 4.47 9.98 9.98 9.98 5.51 0 9.98-4.47 9.98-9.98 0-5.51-4.47-9.98-9.98-9.98Zm0 17.96c-4.4 0-7.98-3.58-7.98-7.98S7.6 4.02 12 4.02 19.98 7.6 19.98 12 16.4 19.98 12 19.98ZM8.25 13.5l4.5-8.5v5.5h3L11.39 19v-5.5H8.25Z"
    };
    var offline_saved = {
      name: "offline_saved",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.5 6.5 2 12 2s10 4.5 10 10-4.5 10-10 10S2 17.5 2 12Zm2 0c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm13 3v2H7v-2h10ZM8.4 9.3l1.9 1.9 5.3-5.3L17 7.3 10.3 14 7 10.7l1.4-1.4Z"
    };
    var collection_1 = {
      name: "collection_1",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm15 10h-2V7h-2V5h4v10Zm-9 2h14V3H7v14Z"
    };
    var collection_2 = {
      name: "collection_2",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm20 12H7V3h14v14Zm-8-4h4v2h-6v-4a2 2 0 0 1 2-2h2V7h-4V5h4a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-2v2Z"
    };
    var collection_3 = {
      name: "collection_3",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2Zm0 16h14V3H7v14ZM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5Zm14 6.5V13a2 2 0 0 1-2 2h-4v-2h4v-2h-2V9h2V7h-4V5h4a2 2 0 0 1 2 2v1.5c0 .83-.67 1.5-1.5 1.5.83 0 1.5.67 1.5 1.5Z"
    };
    var collection_4 = {
      name: "collection_4",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm16 10h-2v-4h-4V5h2v4h2V5h2v10ZM7 17h14V3H7v14Z"
    };
    var collection_5 = {
      name: "collection_5",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2Zm0 16h14V3H7v14ZM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5Zm14 6v2a2 2 0 0 1-2 2h-4v-2h4v-2h-4V5h6v2h-4v2h2a2 2 0 0 1 2 2Z"
    };
    var collection_6 = {
      name: "collection_6",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5Zm4 12h14V3H7v14Zm6-2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2V7h4V5h-4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2Zm2-4h-2v2h2v-2Z"
    };
    var collection_7 = {
      name: "collection_7",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm20 12H7V3h14v14ZM17 7l-4 8h-2l4-8h-4V5h6v2Z"
    };
    var collection_8 = {
      name: "collection_8",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2ZM1 5h2v16h16v2H3c-1.1 0-2-.9-2-2V5Zm20 12H7V3h14v14Zm-6-2h-2a2 2 0 0 1-2-2v-1.5c0-.83.67-1.5 1.5-1.5-.83 0-1.5-.67-1.5-1.5V7a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v1.5c0 .83-.67 1.5-1.5 1.5.83 0 1.5.67 1.5 1.5V13a2 2 0 0 1-2 2Zm-2-8h2v2h-2V7Zm2 4h-2v2h2v-2Z"
    };
    var collection_9 = {
      name: "collection_9",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5Zm4 12h14V3H7v14Zm8-12h-2a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2v2h-4v2h4a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2Zm-2 4h2V7h-2v2Z"
    };
    var collection_9_plus = {
      name: "collection_9_plus",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2ZM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5Zm11 7V8a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h1v1H9v2h3a2 2 0 0 0 2-2Zm-3-4v1h1V8h-1Zm8 1h2V3H7v14h14v-6h-2v2h-2v-2h-2V9h2V7h2v2Z"
    };
    var attachment = {
      name: "attachment",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 16H6.5c-2.21 0-4-1.79-4-4s1.79-4 4-4H19a2.5 2.5 0 0 1 0 5H8.5c-.55 0-1-.45-1-1s.45-1 1-1H18V9.5H8.5a2.5 2.5 0 0 0 0 5H19c2.21 0 4-1.79 4-4s-1.79-4-4-4H6.5C3.46 6.5 1 8.96 1 12s2.46 5.5 5.5 5.5H18V16Z"
    };
    var attach_file = {
      name: "attach_file",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H9.5v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4s-4 1.79-4 4v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6H16Z"
    };
    var image$2 = {
      name: "image",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 2v14H5V5h14Zm-7.86 10.73 3-3.87L18 17H6l3-3.86 2.14 2.59Z"
    };
    var movie_file = {
      name: "movie_file",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m20 8-2-4h4v14c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2h1l2 4h3L8 4h2l2 4h3l-2-4h2l2 4h3Zm0 2H5.76L4 6.47V18h16v-8Z"
    };
    var slideshow = {
      name: "slideshow",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm-9 13 5-4-5-4v8Zm-5 3h14V5H5v14Z"
    };
    var image_add = {
      name: "image_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.5 1.5v3h3v2h-3v2.99s-1.99.01-2 0V6.5h-3s.01-1.99 0-2h3v-3h2Zm-2 19h-14v-14h9v-2h-9c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-9h-2v9Zm-7.79-3.17-1.96-2.36L5 18.5h11l-3.54-4.71-2.75 3.54Z"
    };
    var sun = {
      name: "sun",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 1.05h2V4h-2V1.05Zm-6.04 2.5 1.8 1.79-1.42 1.41-1.79-1.79 1.41-1.41ZM4 11H1v2h3v-2Zm16.448-6.048L19.04 3.545l-1.788 1.789 1.407 1.407 1.789-1.79ZM17.24 18.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4ZM23 11h-3v2h3v-2ZM12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6Zm-4 6c0 2.21 1.79 4 4 4s4-1.79 4-4-1.79-4-4-4-4 1.79-4 4Zm5 8v2.95h-2V20h2Zm-8.04.45-1.41-1.41 1.79-1.8 1.41 1.41-1.79 1.8Z"
    };
    var battery_alert = {
      name: "battery_alert",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4ZM13 18h-2v-2h2v2Zm-2-4h2V9h-2v5Z"
    };
    var battery_charging = {
      name: "battery_charging",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 4h1.67C16.4 4 17 4.6 17 5.33v15.34c0 .73-.6 1.33-1.34 1.33H8.33C7.6 22 7 21.4 7 20.66V5.33C7 4.6 7.6 4 8.33 4H10V2h4v2Zm-3 10.5V20l4-7.5h-2V7l-4 7.5h2Z"
    };
    var battery = {
      name: "battery",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4Z"
    };
    var battery_unknown = {
      name: "battery_unknown",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4ZM13 16v2h-2v-2h2Zm.63-2.6c.29-.29.67-.71.67-.71.43-.43.7-1.03.7-1.69 0-1.66-1.34-3-3-3s-3 1.34-3 3h1.5c0-.83.67-1.5 1.5-1.5a1.498 1.498 0 0 1 1.06 2.56l-.93.94c-.47.48-.93 1.17-.93 2h1.6c0-.45.35-1.12.83-1.6Z"
    };
    var flame = {
      name: "flame",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.5 1.335s.74 2.65.74 4.8c0 2.06-1.35 3.73-3.41 3.73-2.07 0-3.63-1.67-3.63-3.73l.03-.36C5.21 8.175 4 11.285 4 14.665c0 4.42 3.58 8 8 8s8-3.58 8-8c0-5.39-2.59-10.2-6.5-13.33Zm-1.93 12.49c-1.36.28-2.17 1.16-2.17 2.41 0 1.34 1.11 2.42 2.49 2.42 2.05 0 3.71-1.66 3.71-3.71 0-1.07-.15-2.12-.46-3.12-.79 1.07-2.2 1.72-3.57 2Zm-5.57.84c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.56-.66-5.03-1.89-7.23-.53 2.6-2.62 4.43-5.28 4.43-1.56 0-2.96-.62-3.97-1.63-.56 1.39-.86 2.9-.86 4.43Z"
    };
    var waves = {
      name: "waves",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 16.99c-1.35 0-2.2.42-2.95.8-.65.33-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8-1.38 0-2.2.42-2.95.8-.65.33-1.17.6-2.05.6v1.95c1.35 0 2.2-.42 2.95-.8.65-.33 1.17-.6 2.05-.6.88 0 1.4.25 2.05.6.75.38 1.57.8 2.95.8 1.38 0 2.2-.42 2.95-.8.65-.33 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8Zm0-4.45c-1.35 0-2.2.43-2.95.8-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8-1.38 0-2.2.43-2.95.8-.65.32-1.17.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.57.8 2.95.8 1.38 0 2.2-.43 2.95-.8.65-.35 1.15-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8v-1.95c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8Zm2.95-8.08c-.75-.38-1.58-.8-2.95-.8s-2.2.42-2.95.8c-.65.32-1.18.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.37-1.57-.8-2.95-.8-1.38 0-2.2.42-2.95.8-.65.33-1.17.6-2.05.6v1.93c1.35 0 2.2-.43 2.95-.8.65-.33 1.17-.6 2.05-.6.88 0 1.4.25 2.05.6.75.38 1.57.8 2.95.8 1.38 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V5.04c-.9 0-1.4-.25-2.05-.58ZM17 8.09c-1.35 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6-.9 0-1.4-.25-2.05-.6-.75-.38-1.57-.8-2.95-.8-1.38 0-2.2.43-2.95.8-.65.35-1.15.6-2.05.6v1.95c1.35 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6.87 0 1.4.25 2.05.6.75.38 1.57.8 2.95.8 1.38 0 2.2-.43 2.95-.8.65-.32 1.18-.6 2.05-.6.9 0 1.4.25 2.05.6.75.38 1.58.8 2.95.8V9.49c-.9 0-1.4-.25-2.05-.6-.75-.38-1.6-.8-2.95-.8Z"
    };
    var ev_station = {
      name: "ev_station",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.53 7.22-.01.01c.45.45.73 1.08.73 1.77v9.5a2.5 2.5 0 0 1-5 0v-5h-1.5V21h-10V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v7h1c1.1 0 2 .9 2 2v4.5c0 .55.45 1 1 1s1-.45 1-1v-7.21c-.31.13-.64.21-1 .21a2.5 2.5 0 0 1-2.5-2.5c0-1.07.67-1.97 1.61-2.33l-2.11-2.11 1.06-1.06 3.72 3.72ZM11.75 19V5h-6v14h6Zm6-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1Zm-12 3.5 4-7.5v5h2l-4 7v-4.5h-2Z"
    };
    var gas_station = {
      name: "gas_station",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.53 7.22-.01.01c.45.45.73 1.08.73 1.77v9.5a2.5 2.5 0 0 1-5 0v-5h-1.5V21h-10V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v7h1c1.1 0 2 .9 2 2v4.5c0 .55.45 1 1 1s1-.45 1-1v-7.21c-.31.13-.64.21-1 .21a2.5 2.5 0 0 1-2.5-2.5c0-1.07.67-1.97 1.61-2.33l-2.11-2.11 1.06-1.06 3.72 3.72ZM11.75 19v-7h-6v7h6Zm0-9h-6V5h6v5Zm5-1c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Z"
    };
    var light = {
      name: "light",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 1.525h6v4.81c1.79 1.04 3 2.97 3 5.19 0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.22 1.21-4.15 3-5.19v-4.81Zm4 2v3.96l1 .58c1.24.72 2 2.04 2 3.46 0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.42.77-2.74 2-3.46l1-.58v-3.96h2Zm-9 6.95H1v2h3v-2Zm-.45 8.09 1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8Zm9.45.91v3h-2v-3h2Zm7-9h3v2h-3v-2Zm-.97 9.51-1.79-1.8 1.4-1.4 1.8 1.79-1.41 1.41Z"
    };
    var power_button = {
      name: "power_button",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3h2v4c1.1 0 2 .9 2 2v5.49L14.5 18v3h-5v-3L6 14.5V8.98C6 7.89 6.9 6.99 7.99 7H8V3h2v4h4V3Zm2 10.66V9H8v4.65l3.5 3.52V19h1v-1.83l3.5-3.51Z"
    };
    var power_button_off = {
      name: "power_button_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.215 2.505h2v3.88l-2-2v-1.88Zm8 9.88v-3.88h-3.88l-2-2h3.88v-4h2v4c1.1 0 2 .9 2 2v5.48l-.2.2-1.8-1.8Zm-11.88-9.04-1.41 1.41 3.29 3.29v5.96l3.5 3.5v3h5v-3l.48-.48 4.47 4.47 1.41-1.41-16.74-16.74Z"
    };
    var turbine = {
      name: "turbine",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 23h-1v-6.57C9.93 17.4 8.52 18 7 18c-3.25 0-6-2.75-6-6v-1h6.57C6.6 9.93 6 8.52 6 7c0-3.25 2.75-6 6-6h1v6.57C14.07 6.6 15.48 6 17 6c3.25 0 6 2.75 6 6v1h-6.57c.97 1.07 1.57 2.48 1.57 4 0 3.25-2.75 6-6 6Zm1-9.87v7.74c1.7-.46 3-2.04 3-3.87s-1.3-3.41-3-3.87ZM3.13 13c.46 1.7 2.04 3 3.87 3s3.41-1.3 3.87-3H3.13Zm10-2h7.74c-.46-1.7-2.05-3-3.87-3-1.82 0-3.41 1.3-3.87 3ZM11 3.13C9.3 3.59 8 5.18 8 7c0 1.82 1.3 3.41 3 3.87V3.13Z"
    };
    var lightbulb = {
      name: "lightbulb",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7ZM9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1Zm5-7.3.85-.6A4.997 4.997 0 0 0 17 9c0-2.76-2.24-5-5-5S7 6.24 7 9c0 1.63.8 3.16 2.15 4.1l.85.6V16h4v-2.3Z"
    };
    var power = {
      name: "power",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 3h2v10h-2V3Zm5.41 3.59 1.42-1.42A8.932 8.932 0 0 1 21 12a9 9 0 0 1-18 0c0-2.74 1.23-5.18 3.17-6.83l1.41 1.41A6.995 6.995 0 0 0 12 19c3.87 0 7-3.13 7-7a6.92 6.92 0 0 0-2.59-5.41Z"
    };
    var flare = {
      name: "flare",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 1h2v6h-2V1ZM9.17 7.76 7.05 5.64 5.64 7.05l2.12 2.12 1.41-1.41ZM7 11H1v2h6v-2Zm11.36-3.95-1.41-1.41-2.12 2.12 1.41 1.41 2.12-2.12ZM17 11h6v2h-6v-2Zm-5-2c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3Zm4.95 9.36-2.12-2.12 1.41-1.41 2.12 2.12-1.41 1.41ZM5.64 16.95l1.41 1.41 2.12-2.12-1.41-1.41-2.12 2.12ZM13 23h-2v-6h2v6Z"
    };
    var electrical = {
      name: "electrical",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2 1 21h22L12 2Zm0 3.99L19.53 19H4.47L12 5.99Zm-1.397 8.836-1.357 3.558 4.342-3.9-1.246-.476L13.7 10.45l-4.342 3.901 1.246.475Z"
    };
    var wind_turbine = {
      name: "wind_turbine",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.496 2.427A.496.496 0 0 0 12 2a.496.496 0 0 0-.496.427l-.888 6.929c-.27.259-.467.593-.56.968l-5.858 4.327a.48.48 0 0 0-.131.633.506.506 0 0 0 .627.205l6.272-2.581-.417 8.116H9V22h6v-.976h-1.55l-.414-8.084 6.267 2.588c.234.097.505.01.631-.203a.482.482 0 0 0-.135-.635l-5.842-4.304a1.997 1.997 0 0 0-.573-1.03l-.888-6.929Zm-.188 6.397L12 6.42l-.308 2.403a2.015 2.015 0 0 1 .616 0Zm-2.183 2.674-2.134 1.576 2.457-1.012a1.996 1.996 0 0 1-.323-.564Zm3.407.588 2.44 1.007-2.112-1.556c-.08.201-.191.386-.328.549ZM12 13.233l.446 7.791h-.892l.446-7.79Zm1-2.433a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
    };
    var substation_onshore = {
      name: "substation_onshore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-1v3h-2v-3H8v3H6v-3H5a2 2 0 0 1-2-2V6Zm16 0H5v6h14V6Zm-8.52 5.42.828-2.17-.76-.29 2.649-2.38-.828 2.17.76.29-2.65 2.38ZM21 18H3v2h18v-2Z"
    };
    var substation_offshore = {
      name: "substation_offshore",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 6a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-1v2l-2-1v-1H8v1l-2 1v-2H5a2 2 0 0 1-2-2V6Zm16 0H5v6h14V6Zm-2.998 10a6.985 6.985 0 0 1-4 1.28c-1.39 0-2.78-.43-4-1.28-1.22.85-2.61 1.32-4 1.32h-2v2h2c1.38 0 2.74-.35 4-.99 1.26.64 2.63.97 4 .97s2.74-.32 4-.97c1.26.65 2.62.99 4 .99h2v-2h-2c-1.39 0-2.78-.47-4-1.32Zm-4.694-6.75-.828 2.17 2.649-2.38-.76-.29.828-2.17-2.65 2.38.76.29Z"
    };
    var link_off = {
      name: "link_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.11 7.445 2 4.335l1.41-1.41 16.74 16.74-1.41 1.41-4.01-4.01H13v-1.73l-2.27-2.27H8v-2h.73l-2.07-2.07a3.097 3.097 0 0 0-2.76 3.07c0 1.71 1.39 3.1 3.1 3.1h4v1.9H7c-2.76 0-5-2.24-5-5 0-2.09 1.29-3.88 3.11-4.62ZM17 7.065h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.27-.77 2.37-1.87 2.84l1.4 1.4a4.986 4.986 0 0 0 2.37-4.24c0-2.76-2.24-5-5-5Zm-2.61 4 1.61 1.61v-1.61h-1.61Z"
    };
    var link$1 = {
      name: "link",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 15H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-2Zm6-8h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5Zm-1 4H8v2h8v-2Z"
    };
    var camera_add_photo = {
      name: "camera_add_photo",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.5 6.5h-3v3h-2v-3h-3v-2h3v-3h2v3h3v2Zm9.83 0h3.17c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2h-16c-1.1 0-2-.9-2-2v-9h2v9h16v-12h-4.05l-1.83-2H10.5v-2h6l1.83 2Zm-4.83 13c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5Zm0-8c1.65 0 3 1.35 3 3s-1.35 3-3 3-3-1.35-3-3 1.35-3 3-3Z"
    };
    var code = {
      name: "code",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m4.8 12 4.6 4.6L8 18l-6-6 6-6 1.4 1.4L4.8 12Zm14.4 0-4.6 4.6L16 18l6-6-6-6-1.4 1.4 4.6 4.6Z"
    };
    var gesture = {
      name: "gesture",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6.38 5.68c-.31-.13-1.01.51-1.71 1.22L2.92 5.19c.22-.27.52-.57.88-.93.25-.25 1.4-1.25 2.72-1.25.87 0 2.51.69 2.51 2.86 0 1.36-.52 2.14-1.3 3.28-.45.66-1.5 2.43-1.85 3.52-.36 1.09-.09 1.92.36 1.92.412 0 .824-.496 1.078-.802l.032-.038c.23-.24 1.71-1.99 2.29-2.72.76-.93 2.69-2.84 4.94-2.84 2.94 0 3.88 2.55 4.03 4.2h2.47v2.5h-2.46c-.4 4.77-3.06 6.1-4.69 6.1-1.77 0-3.21-1.39-3.21-3.09s1.6-4.73 5.38-5.37l-.02-.154c-.1-.752-.215-1.636-1.74-1.636-1.25 0-2.87 1.95-4.08 3.44l-.013.015C9.143 15.558 8.266 16.641 7.2 16.95c-.9.27-1.89.1-2.64-.46-.86-.64-1.34-1.7-1.34-2.98 0-2.108 1.98-5.011 2.656-6.004.1-.147.172-.252.204-.306.3-.49.8-1.32.3-1.52Zm6.84 12.16c0 .46.43.72.74.72.7 0 1.83-.79 2.13-3.48-2.14.56-2.87 2.16-2.87 2.76Z"
    };
    var text_rotation_up = {
      name: "text_rotation_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18 4-3 3h2v13h2V7h2l-3-3Zm-4 12.4-2.2-.9v-5l2.2-.9V7.5L3 12.25v1.5l11 4.75v-2.1Zm-4-5.27L4.98 13 10 14.87v-3.74Z"
    };
    var text_rotation_vertical = {
      name: "text_rotation_vertical",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m9.25 17-3 3-3-3h2V4h2v13h2ZM16 5h-1.5L9.75 16h2.1l.9-2.2h5l.9 2.2h2.1L16 5Zm-2.62 7 1.87-5.02L17.12 12h-3.74Z"
    };
    var text_rotation_angled_down = {
      name: "text_rotation_angled_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11.875 8.23 3.54 3.54-.92 2.19 1.48 1.48 4.42-11.14-1.06-1.05-11.14 4.42 1.49 1.48 2.19-.92Zm3.75 12.52v-4.24l-1.41 1.41-9.2-9.19-1.41 1.41 9.19 9.19-1.41 1.42h4.24Zm.61-10.7 2.23-4.87-4.87 2.23 2.64 2.64Z"
    };
    var text_rotation_angled_up = {
      name: "text_rotation_angled_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m8.23 12.13 3.54-3.54 2.19.92 1.48-1.48L4.31 3.61 3.25 4.67l4.42 11.14 1.48-1.48-.92-2.2Zm8.28-3.75 1.41 1.41-9.19 9.19 1.41 1.41 9.19-9.19 1.42 1.42V8.38h-4.24ZM5.18 5.54l2.23 4.87 2.64-2.64-4.87-2.23Z"
    };
    var text_rotation_down = {
      name: "text_rotation_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6 20 3-3H7V4H5v13H3l3 3Zm6.2-11.5v5l-2.2.9v2.1l11-4.75v-1.5L10 5.5v2.1l2.2.9Zm1.8 4.37L19.02 11 14 9.13v3.74Z"
    };
    var text_rotation_none = {
      name: "text_rotation_none",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7.6 14 .9-2.2h5l.9 2.2h2.1L11.75 3h-1.5L5.5 14h2.1ZM20 18l-3-3v2H4v2h13v2l3-3Zm-7.13-8L11 4.98 9.13 10h3.74Z"
    };
    var opacity$1 = {
      name: "opacity",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 2.345 5.66 5.65a8.02 8.02 0 0 1 2.34 5.64c0 2-.78 4.11-2.34 5.67a7.99 7.99 0 0 1-11.32 0C4.78 17.745 4 15.635 4 13.635s.78-4.08 2.34-5.64L12 2.345Zm-4.24 7.25c-1.14 1.13-1.75 2.4-1.76 4.4h12c-.01-2-.62-3.23-1.76-4.35L12 5.265l-4.24 4.33Z"
    };
    var invert_colors = {
      name: "invert_colors",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 2.345 5.66 5.66c3.12 3.12 3.12 8.19 0 11.31a7.98 7.98 0 0 1-5.66 2.34c-2.05 0-4.1-.78-5.66-2.34-3.12-3.12-3.12-8.19 0-11.31L12 2.345Zm-4.24 15.56a5.928 5.928 0 0 0 4.24 1.76V5.175l-4.24 4.25A5.928 5.928 0 0 0 6 13.665c0 1.6.62 3.1 1.76 4.24Z"
    };
    var flip_to_back = {
      name: "flip_to_back",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 5a2 2 0 0 1 2-2v2H7Zm2 2H7v2h2V7Zm0 4H7v2h2v-2Zm4 4h-2v2h2v-2Zm6-10V3c1.1 0 2 .9 2 2h-2Zm-6-2h-2v2h2V3ZM9 15v2a2 2 0 0 1-2-2h2Zm10-2h2v-2h-2v2Zm2-4h-2V7h2v2Zm-2 8c1.1 0 2-.9 2-2h-2v2ZM3 7h2v12h12v2H5a2 2 0 0 1-2-2V7Zm12-2h2V3h-2v2Zm2 12h-2v-2h2v2Z"
    };
    var flip_to_front = {
      name: "flip_to_front",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H9a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2ZM3 9h2V7H3v2Zm0 4h2v-2H3v2Zm0 4h2v-2H3v2Zm2 2v2a2 2 0 0 1-2-2h2Zm12 2h-2v-2h2v2Zm-8-6h10V5H9v10Zm2 6h2v-2h-2v2Zm-2 0H7v-2h2v2Z"
    };
    var insert_link = {
      name: "insert_link",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1ZM8 13h8v-2H8v2Zm5-6h4c2.76 0 5 2.24 5 5s-2.24 5-5 5h-4v-1.9h4c1.71 0 3.1-1.39 3.1-3.1 0-1.71-1.39-3.1-3.1-3.1h-4V7Z"
    };
    var functions = {
      name: "functions",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 4H6v2l6.5 6L6 18v2h12v-3h-7l5-5-5-5h7V4Z"
    };
    var format_strikethrough = {
      name: "format_strikethrough",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6.85 8.575c0 .64.13 1.19.39 1.67.032.063.076.133.117.198l.033.052H12c-.64-.22-1.03-.45-1.41-.7-.49-.33-.74-.73-.74-1.21 0-.23.05-.45.15-.66.1-.21.25-.39.44-.55.19-.15.43-.27.72-.36.29-.09.64-.13 1.03-.13.4 0 .76.06 1.06.16.3.11.55.25.75.44.2.19.35.41.44.68.1.26.15.54.15.85h3.01c0-.66-.13-1.26-.38-1.81s-.61-1.03-1.08-1.43a4.94 4.94 0 0 0-1.69-.94c-.67-.23-1.4-.34-2.21-.34-.79 0-1.52.1-2.18.29-.65.2-1.22.48-1.7.83-.48.36-.85.79-1.11 1.29-.27.51-.4 1.06-.4 1.67ZM21 11.495v2.02h-3.87c.06.1.12.22.17.33.21.47.31 1.01.31 1.61 0 .64-.13 1.21-.38 1.71s-.61.93-1.07 1.27c-.46.34-1.02.6-1.67.79-.65.19-1.38.28-2.18.28-.48 0-.96-.05-1.44-.13-.48-.09-.94-.22-1.38-.39a5.69 5.69 0 0 1-1.22-.65c-.38-.26-.7-.57-.98-.92-.28-.36-.49-.76-.65-1.21-.16-.45-.24-1.03-.24-1.58h2.97c0 .45.11.9.25 1.21.14.31.34.56.59.75.25.19.56.33.91.42.35.09.75.13 1.18.13.38 0 .72-.05 1.01-.13.29-.09.52-.2.71-.35.19-.15.33-.33.42-.53.09-.21.14-.43.14-.66 0-.26-.04-.49-.11-.69-.08-.21-.22-.4-.43-.57-.21-.17-.5-.34-.87-.51a7.225 7.225 0 0 0-.269-.098c-.095-.033-.193-.067-.281-.102H3v-2h18Z"
    };
    var wrap_text = {
      name: "wrap_text",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.5 4h-16v2h16V4Zm-16 14h6v-2h-6v2Zm0-8h13c2.21 0 4 1.79 4 4s-1.79 4-4 4h-2v2l-3-3 3-3v2h2.25c1.1 0 2-.9 2-2s-.9-2-2-2H3.5v-2Z"
    };
    var vertical_align_top = {
      name: "vertical_align_top",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 5V3h16v2H4Zm7 6H8l4-4 4 4h-3v10h-2V11Z"
    };
    var vertical_align_center = {
      name: "vertical_align_center",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 5h-3V1h-2v4H8l4 4 4-4ZM8 19h3v4h2v-4h3l-4-4-4 4Zm-4-6v-2h16v2H4Z"
    };
    var vertical_align_bottom = {
      name: "vertical_align_bottom",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 13h3l-4 4-4-4h3V3h2v10Zm-9 8v-2h16v2H4Z"
    };
    var title$1 = {
      name: "title",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 4.5v3h5.5v12h3v-12H19v-3H5Z"
    };
    var text_field = {
      name: "text_field",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.5 7.5v-3h13v3h-5v12h-3v-12h-5Zm10 2h9v3h-3v7h-3v-7h-3v-3Z"
    };
    var format_shape = {
      name: "format_shape",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M23 1v6h-2v10h2v6h-6v-2H7v2H1v-6h2V7H1V1h6v2h10V1h6ZM5 3H3v2h2V3Zm0 18H3v-2h2v2Zm2-4v2h10v-2h2V7h-2V5H7v2H5v10h2Zm14 4h-2v-2h2v2ZM19 3v2h2V3h-2Zm-5.27 11h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2Zm-.43-1.26h-2.61L12 8.91l1.3 3.83Z"
    };
    var format_quote = {
      name: "format_quote",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.62 18H3.38l2-4H3V6h8v7.24L8.62 18Zm4.76 0h5.24L21 13.24V6h-8v8h2.38l-2 4Zm4-2h-.76l2-4H15V8h4v4.76L17.38 16Zm-10 0h-.76l2-4H5V8h4v4.76L7.38 16Z"
    };
    var format_list_numbered = {
      name: "format_list_numbered",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 8h-1V5h-1V4h2v4Zm0 9.5V17h-2v-1h3v4h-3v-1h2v-.5h-1v-1h1Zm-2-6.5h1.8l-1.8 2.1v.9h3v-1H3.7l1.8-2.1V10h-3v1Zm5-4V5h14v2h-14Zm0 12h14v-2h-14v2Zm14-6h-14v-2h14v2Z"
    };
    var format_list_bulleted = {
      name: "format_list_bulleted",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.75 6c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5Zm0 6c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5Zm1.5 4.5c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5Zm17 2.5h-14v-2h14v2Zm-14-6h14v-2h-14v2Zm0-6V5h14v2h-14Z"
    };
    var format_line_spacing = {
      name: "format_line_spacing",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.75 7h-2.5v10h2.5l-3.5 3.5-3.5-3.5h2.5V7h-2.5l3.5-3.5L8.75 7Zm1.5 0V5h12v2h-12Zm0 12h12v-2h-12v2Zm12-6h-12v-2h12v2Z"
    };
    var format_size = {
      name: "format_size",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M8.5 7.5v-3h13v3h-5v12h-3v-12h-5Zm-3 5h-3v-3h9v3h-3v7h-3v-7Z"
    };
    var format_highlight = {
      name: "format_highlight",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.001 2h-2v3h2V2Zm-7 12 3 3v5h6v-5l3-3V9h-12v5Zm2-3h8v2.17l-3 3V20h-2v-3.83l-3-3V11ZM3.503 5.874 4.917 4.46l2.122 2.12-1.414 1.416-2.122-2.12Zm15.58-1.411-2.122 2.12 1.413 1.415 2.123-2.12-1.413-1.415Z"
    };
    var format_underline = {
      name: "format_underline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6V3h2.5v8c0 1.93 1.57 3.5 3.5 3.5s3.5-1.57 3.5-3.5V3H18v8ZM5 21v-2h14v2H5Z"
    };
    var format_italics = {
      name: "format_italics",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 5v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V5h-8Z"
    };
    var format_indent_increase = {
      name: "format_indent_increase",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm4 7-4 4V8l4 4Zm14 9H3v-2h18v2Zm-10-4h10v-2H11v2Zm0-8h10V7H11v2Zm10 4H11v-2h10v2Z"
    };
    var format_indent_decrease = {
      name: "format_indent_decrease",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm4 11-4-4 4-4v8Zm14 1H11v-2h10v2ZM3 21h18v-2H3v2Zm8-12h10V7H11v2Zm10 4H11v-2h10v2Z"
    };
    var format_color_text = {
      name: "format_color_text",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11 1.5-5.5 14h2.25l1.12-3h6.25l1.12 3h2.25L13 1.5h-2Zm-1.38 9L12 4.17l2.38 6.33H9.62Zm14.38 8H0v4h24v-4Z"
    };
    var format_color_reset = {
      name: "format_color_reset",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6.195c1.53 2 3.08 4.43 3.71 6.24l2.23 2.23c.03-.27.06-.55.06-.83 0-3.98-6-10.8-6-10.8s-1.18 1.35-2.5 3.19l1.44 1.44c.34-.51.7-1 1.06-1.47Zm-6.59-1.22L4 6.385l3.32 3.32c-.77 1.46-1.32 2.92-1.32 4.13 0 3.31 2.69 6 6 6 1.52 0 2.9-.57 3.95-1.5l2.63 2.63 1.42-1.41L5.41 4.975ZM8 13.835c0 2.21 1.79 4 4 4 .96 0 1.83-.36 2.53-.92l-5.72-5.72c-.49 1.02-.81 1.95-.81 2.64Z"
    };
    var format_color_fill = {
      name: "format_color_fill",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7.62 0 8.94 8.94c.59.59.59 1.54 0 2.12l-5.5 5.5c-.29.29-.68.44-1.06.44s-.77-.15-1.06-.44l-5.5-5.5a1.49 1.49 0 0 1 0-2.12l5.15-5.15-2.38-2.38L7.62 0ZM10 5.21 5.21 10h9.58L10 5.21Zm9 6.29s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5Zm5 8.5H0v4h24v-4Z"
    };
    var format_clear = {
      name: "format_clear",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3 5.34 1.41-1.41 14.73 14.73-1.41 1.41-5.66-5.66-1.57 3.66h-3l2.47-5.76L3 5.34Zm18-1.27v3h-5.79l-1.45 3.38-2.09-2.1.55-1.28h-1.83l-3-3H21Z"
    };
    var format_bold = {
      name: "format_bold",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.225 11.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4h-6.25v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42Zm-5.6-4.29h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3Zm0 9h3.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5h-3.5v3Z"
    };
    var format_align_right = {
      name: "format_align_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm6 4h12V7H9v2Zm12 4H3v-2h18v2ZM9 17h12v-2H9v2Zm-6 4h18v-2H3v2Z"
    };
    var format_align_left = {
      name: "format_align_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm12 2H3v2h12V7Zm0 8H3v2h12v-2Zm6-2H3v-2h18v2ZM3 21h18v-2H3v2Z"
    };
    var format_align_justify = {
      name: "format_align_justify",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm0 4h18V7H3v2Zm18 4H3v-2h18v2ZM3 17h18v-2H3v2Zm0 4h18v-2H3v2Z"
    };
    var format_align_center = {
      name: "format_align_center",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5V3h18v2H3Zm4 2v2h10V7H7Zm14 6H3v-2h18v2ZM7 15v2h10v-2H7Zm-4 6h18v-2H3v2Z"
    };
    var drag_handle = {
      name: "drag_handle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 9h16v2H4V9Zm16 6H4v-2h16v2Z"
    };
    var keyboard_space_bar = {
      name: "keyboard_space_bar",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M18 9v4H6V9H4v6h16V9h-2Z"
    };
    var border_vertical = {
      name: "border_vertical",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5h2V3H3v2Zm0 4h2V7H3v2Zm6 12H7v-2h2v2Zm-2-8h2v-2H7v2Zm-2 0H3v-2h2v2Zm-2 8h2v-2H3v2Zm2-4H3v-2h2v2ZM7 5h2V3H7v2Zm14 12h-2v-2h2v2Zm-10 4h2V3h-2v18Zm10 0h-2v-2h2v2Zm-2-8h2v-2h-2v2Zm0-8V3h2v2h-2Zm0 4h2V7h-2v2Zm-2-4h-2V3h2v2Zm-2 16h2v-2h-2v2Zm2-8h-2v-2h2v2Z"
    };
    var border_top = {
      name: "border_top",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3v2h18V3H3Zm0 6h2V7H3v2Zm4 4h2v-2H7v2Zm0 8h2v-2H7v2Zm6-8h-2v-2h2v2Zm-2 8h2v-2h-2v2Zm-6-4H3v-2h2v2Zm-2 4h2v-2H3v2Zm2-8H3v-2h2v2Zm8 4h-2v-2h2v2Zm6-8h2V7h-2v2Zm2 4h-2v-2h2v2Zm0 4h-2v-2h2v2Zm-6 4h2v-2h-2v2ZM13 9h-2V7h2v2Zm6 12h2v-2h-2v2Zm-2-8h-2v-2h2v2Z"
    };
    var border_style = {
      name: "border_style",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3v18h2V5h16V3H3Zm18 10h-2v-2h2v2Zm-2 4h2v-2h-2v2ZM7 21h2v-2H7v2Zm10 0h-2v-2h2v2Zm4 0h-2v-2h2v2Zm-8 0h-2v-2h2v2Zm8-12h-2V7h2v2Z"
    };
    var border_right = {
      name: "border_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 5h2V3H3v2Zm4 16h2v-2H7v2ZM9 5H7V3h2v2Zm-2 8h2v-2H7v2Zm-2 8H3v-2h2v2Zm6 0h2v-2h-2v2Zm-6-8H3v-2h2v2Zm-2 4h2v-2H3v2Zm2-8H3V7h2v2Zm6 8h2v-2h-2v2Zm6-4h-2v-2h2v2Zm2-10v18h2V3h-2Zm-2 18h-2v-2h2v2ZM15 5h2V3h-2v2Zm-2 8h-2v-2h2v2Zm-2-8h2V3h-2v2Zm2 4h-2V7h2v2Z"
    };
    var border_outer = {
      name: "border_outer",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3v18h18V3H3Zm10 4h-2v2h2V7Zm0 4h-2v2h2v-2Zm2 0h2v2h-2v-2ZM5 19h14V5H5v14Zm8-4h-2v2h2v-2Zm-6-4h2v2H7v-2Z"
    };
    var border_left = {
      name: "border_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 21H3V3h2v18Zm8-16h-2V3h2v2Zm-2 12h2v-2h-2v2Zm0 4h2v-2h-2v2Zm0-12h2V7h-2v2Zm2 4h-2v-2h2v2Zm-6 8h2v-2H7v2ZM9 5H7V3h2v2Zm-2 8h2v-2H7v2Zm12-4h2V7h-2v2Zm-2 12h-2v-2h2v2Zm2-4h2v-2h-2v2Zm0-12V3h2v2h-2Zm0 8h2v-2h-2v2Zm2 8h-2v-2h2v2Zm-6-8h2v-2h-2v2Zm2-8h-2V3h2v2Z"
    };
    var border_inner = {
      name: "border_inner",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 3h2v2H7V3ZM3 7h2v2H3V7Zm0 14h2v-2H3v2Zm4 0h2v-2H7v2Zm-4-4h2v-2H3v2ZM5 3H3v2h2V3Zm10 0h2v2h-2V3Zm4 6h2V7h-2v2Zm0-4V3h2v2h-2Zm-4 16h2v-2h-2v2ZM11 3h2v8h8v2h-8v8h-2v-8H3v-2h8V3Zm8 18h2v-2h-2v2Zm2-4h-2v-2h2v2Z"
    };
    var border_horizontal = {
      name: "border_horizontal",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h2v2H3V3Zm2 4H3v2h2V7ZM3 21h2v-2H3v2Zm2-4H3v-2h2v2Zm2 4h2v-2H7v2ZM9 3H7v2h2V3Zm6 0h2v2h-2V3Zm-2 4h-2v2h2V7Zm-2-4h2v2h-2V3Zm8 14h2v-2h-2v2Zm-6 4h-2v-2h2v2ZM3 13h18v-2H3v2Zm16-8V3h2v2h-2Zm0 4h2V7h-2v2Zm-6 8h-2v-2h2v2Zm2 4h2v-2h-2v2Zm6 0h-2v-2h2v2Z"
    };
    var border_color = {
      name: "border_color",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.71 4.042a.996.996 0 0 0 0-1.41L18.37.292a.996.996 0 0 0-1.41 0L15 2.252l3.75 3.75 1.96-1.96ZM4 13.252l10-10 3.75 3.75L7.75 17H4v-3.75ZM6 15h.92l8-8-.92-.92-8 8v.92Zm18 5H0V24h24v-4Z"
    };
    var border_clear = {
      name: "border_clear",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 5h2V3H7v2Zm0 8h2v-2H7v2Zm2 8H7v-2h2v2Zm2-4h2v-2h-2v2Zm2 4h-2v-2h2v2ZM3 21h2v-2H3v2Zm2-4H3v-2h2v2Zm-2-4h2v-2H3v2Zm2-4H3V7h2v2ZM3 5h2V3H3v2Zm10 8h-2v-2h2v2Zm6 4h2v-2h-2v2Zm2-4h-2v-2h2v2Zm-2 8h2v-2h-2v2Zm2-12h-2V7h2v2ZM11 9h2V7h-2v2Zm8-4V3h2v2h-2Zm-8 0h2V3h-2v2Zm6 16h-2v-2h2v2Zm-2-8h2v-2h-2v2Zm2-8h-2V3h2v2Z"
    };
    var border_bottom = {
      name: "border_bottom",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3h2v2H3V3Zm4 0h2v2H7V3Zm2 8H7v2h2v-2Zm4 4h-2v2h2v-2Zm0-4h-2v2h2v-2Zm0-4h-2v2h2V7Zm2 4h2v2h-2v-2Zm-2-8h-2v2h2V3Zm2 0h2v2h-2V3Zm4 10h2v-2h-2v2Zm2 4h-2v-2h2v2ZM5 7H3v2h2V7Zm14-2V3h2v2h-2Zm0 4h2V7h-2v2ZM3 11h2v2H3v-2Zm0 10h18v-2H3v2Zm0-6h2v2H3v-2Z"
    };
    var border_all = {
      name: "border_all",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M3 3v18h18V3H3Zm8 16H5v-6h6v6Zm-6-8h6V5H5v6Zm14 8h-6v-6h6v6Zm-6-8h6V5h-6v6Z"
    };
    var keyboard_backspace = {
      name: "keyboard_backspace",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21v-2Z"
    };
    var keyboard_capslock = {
      name: "keyboard_capslock",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.59 13.205 12 8.615l-4.59 4.59L6 11.795l6-6 6 6-1.41 1.41Zm1.41 3v2H6v-2h12Z"
    };
    var keyboard_return = {
      name: "keyboard_return",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.5 7v4H6.33l3.58-3.59L8.5 6l-6 6 6 6 1.41-1.41L6.33 13H21.5V7h-2Z"
    };
    var keyboard_tab = {
      name: "keyboard_tab",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m15.67 11-3.58-3.59L13.5 6l6 6-6 6-1.42-1.41L15.67 13H1.5v-2h14.17Zm6.83 7h-2V6h2v12Z"
    };
    var rotate_3d = {
      name: "rotate_3d",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11.345.03.66-.03c6.29 0 11.44 4.84 11.94 10.99h-1.5c-.35-3.76-2.69-6.93-5.96-8.48l-1.33 1.33-3.81-3.81Zm-2.93 14.93c-.19 0-.37-.03-.52-.08a1.07 1.07 0 0 1-.4-.24c-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44.23-.19.42-.43.55-.72.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56a1.67 1.67 0 0 0-.23-.51c-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31a2.097 2.097 0 0 0 .89-.75c.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96a1.78 1.78 0 0 0-.51-.69c-.2-.19-.47-.33-.77-.43-.31-.09-.65-.14-1.02-.14-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45a.94.94 0 0 1 .25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49a.87.87 0 0 1-.25.37c-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09h-.77v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33Zm-.89 6.52A10.487 10.487 0 0 1 1.555 13h-1.5c.51 6.16 5.66 11 11.95 11l.66-.03-3.81-3.81-1.33 1.32Zm8.3-13.21c.44.18.82.44 1.14.77.32.33.57.73.74 1.2.17.47.26.99.26 1.57v.4c0 .58-.09 1.1-.26 1.57-.17.46-.42.86-.74 1.19-.32.33-.71.58-1.16.76-.45.18-.96.27-1.51.27h-2.3V8h2.36c.54 0 1.03.09 1.47.27Zm.75 3.93c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4Z"
    };
    var spellcheck = {
      name: "spellcheck",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.72 15.25h2.09l-5.11-13H6.84l-5.11 13h2.09l1.12-3h5.64l1.14 3Zm-6.02-5 2.07-5.52 2.07 5.52H5.7Zm7.07 8.68 8.09-8.09 1.41 1.41-9.49 9.5-5.09-5.09 1.41-1.41 3.67 3.68Z"
    };
    var rotate_90_degrees_ccw = {
      name: "rotate_90_degrees_ccw",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13.57 4.62c2.3 0 4.61.88 6.36 2.64a8.98 8.98 0 0 1 0 12.72 8.95 8.95 0 0 1-6.36 2.64c-1.49 0-2.98-.38-4.33-1.12l1.49-1.49a6.973 6.973 0 0 0 7.79-1.44 7.007 7.007 0 0 0 0-9.9 6.973 6.973 0 0 0-4.95-2.05v3.24L9.33 5.62l4.24-4.24v3.24ZM7.91 7.03l-6.48 6.49L7.92 20l6.49-6.48-6.5-6.49Zm-3.65 6.49 3.66-3.66 3.65 3.66-3.66 3.66-3.65-3.66Z"
    };
    var rotate_left = {
      name: "rotate_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.965 2.535v3.07c3.95.49 7 3.85 7 7.93s-3.05 7.44-7 7.93v-2.02c2.84-.48 5-2.94 5-5.91s-2.16-5.43-5-5.91v3.91l-4.55-4.45 4.55-4.55Zm-7.3 6.11 1.41 1.42c-.53.75-.88 1.6-1.02 2.47h-2.02c.17-1.39.73-2.73 1.63-3.89Zm-1.63 5.89h2.02c.14.88.49 1.72 1.01 2.47l-1.41 1.42c-.9-1.16-1.45-2.5-1.62-3.89Zm3.03 5.32c1.16.9 2.51 1.44 3.9 1.61v-2.03c-.87-.15-1.71-.49-2.46-1.03l-1.44 1.45Z"
    };
    var flip$3 = {
      name: "flip",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M13 23h-2V1h2v22ZM3 19V5c0-1.1.9-2 2-2h4v2H5v14h4v2H5c-1.1 0-2-.9-2-2ZM19 9h2V7h-2v2Zm-4 12h2v-2h-2v2Zm4-18v2h2c0-1.1-.9-2-2-2Zm0 14h2v-2h-2v2ZM17 5h-2V3h2v2Zm2 8h2v-2h-2v2Zm2 6c0 1.1-.9 2-2 2v-2h2Z"
    };
    var edit_text = {
      name: "edit_text",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.659 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83a.996.996 0 0 0 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29Zm-3.6 6.02.92.92L5.919 19h-.92v-.92l9.06-9.06Zm-11.06 8.23 11.06-11.06 3.75 3.75L6.749 21h-3.75v-3.75Z"
    };
    var crop_rotate = {
      name: "crop_rotate",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.416.038c.21-.02.413-.038.634-.038C18.34 0 23.49 4.84 24 11h-1.5c-.36-3.76-2.7-6.93-5.97-8.48L15.2 3.85 11.39.04l.026-.002ZM1.5 13c.36 3.76 2.7 6.93 5.97 8.49l1.33-1.34 3.81 3.82c-.073.003-.146.008-.218.012a7.058 7.058 0 0 1-.442.018C5.66 24 .51 19.16 0 13h1.5ZM16 14h2V8a2 2 0 0 0-2-2h-6v2h6v6ZM8 4v12h12v2h-2v2h-2v-2H8a2 2 0 0 1-2-2V8H4V6h2V4h2Z"
    };
    var crop = {
      name: "crop",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 1v16h16v2h-4v4h-2v-4H7c-1.1 0-2-.9-2-2V7H1V5h4V1h2Zm12 14h-2V7H9V5h8c1.1 0 2 .9 2 2v8Z"
    };
    var rotate_right = {
      name: "rotate_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11.035 2.535 4.55 4.55-4.55 4.45v-3.91c-2.84.48-5 2.94-5 5.91s2.16 5.43 5 5.91v2.02c-3.95-.49-7-3.85-7-7.93s3.06-7.44 7-7.93v-3.07Zm7.31 6.11c.9 1.16 1.45 2.5 1.62 3.89h-2.02c-.14-.87-.48-1.72-1.02-2.47l1.42-1.42Zm-5.31 10.79v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03Zm5.31-1.01-1.42-1.41c.54-.76.88-1.61 1.02-2.48h2.02a7.906 7.906 0 0 1-1.62 3.89Z"
    };
    var video_chat = {
      name: "video_chat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2Zm0 14H5.17L4 17.17V4h16v12Zm-3-3-3-2.4V13H7V7h7v2.4L17 7v6Z"
    };
    var comment_important = {
      name: "comment_important",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H6l-4 4V4c0-1.1.9-2 2-2Zm1.17 14H20V4H4v13.17L5.17 16ZM11 12h2v2h-2v-2Zm2-6h-2v4h2V6Z"
    };
    var comment_more = {
      name: "comment_more",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2Zm0 14H5.17L4 17.17V4h16v12ZM9 9H7v2h2V9Zm6 0h2v2h-2V9Zm-2 0h-2v2h2V9Z"
    };
    var email_draft = {
      name: "email_draft",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M21.99 9.5c0-.72-.37-1.35-.94-1.7L12 2.5 2.95 7.8c-.57.35-.95.98-.95 1.7v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10Zm-2 0v.01L12 14.5l-8-5 8-4.68 7.99 4.68ZM4 11.84v7.66h16l-.01-7.63L12 16.86l-8-5.02Z"
    };
    var share_screen_off = {
      name: "share_screen_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M1.11 2.84 2.66 4.4c-.41.37-.66.89-.66 1.48v9.98c0 1.1.9 2 2.01 2H0v2h18.13l2.71 2.71 1.41-1.41L2.52 1.43 1.11 2.84Zm20.68 15.02 2 2H24v-2h-2.21ZM4.13 5.88H4v10h10.13l-3.46-3.48c-1.54.38-2.71 1.17-3.67 2.46.31-1.48.94-2.93 2.08-4.05L4.13 5.88Zm15.87 0v10.19l1.3 1.3c.42-.37.7-.89.7-1.49v-10a2 2 0 0 0-2-2H7.8l2 2H20Zm-4.28 5.91-2.79-2.78.07-.02V6.86l4 3.73-1.28 1.2Z"
    };
    var share_screen = {
      name: "share_screen",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 18c1.1 0 1.99-.9 1.99-2L22 6a2 2 0 0 0-2-2H4c-1.11 0-2 .89-2 2v10a2 2 0 0 0 2 2H0v2h24v-2h-4ZM4 16V6h16v10.01L4 16Zm3-1c.56-2.67 2.11-5.33 6-5.87V7l4 3.73-4 3.74v-2.19c-2.78 0-4.61.85-6 2.72Z"
    };
    var unsubscribe = {
      name: "unsubscribe",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20.488 5.498v9.04c.78.79 1.19 1.94.94 3.18-.27 1.34-1.36 2.44-2.7 2.71-2.08.42-3.9-1.01-4.18-2.93H4.498c-1.1 0-2-.9-2-2v-10c0-1.1.9-2 2-2h13.99c1.1 0 2 .9 2 2Zm-8.99 3.5 6.99-3.5H4.498l7 3.5Zm3.35 6.5H4.498v-8l7 3.5 7-3.5v6.05l-.108-.014a2.886 2.886 0 0 0-.392-.036c-1.39 0-2.59.82-3.15 2Zm1.15 1v1h4v-1h-4Z"
    };
    var email = {
      name: "email",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6Zm-2 0-8 5-8-5h16Zm-8 7L4 8v10h16V8l-8 5Z"
    };
    var dialpad = {
      name: "dialpad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 3c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Zm6 18c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2ZM6 7c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm-2 8c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2ZM18 5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2Zm-8 10c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Zm8-2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm-2-4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Zm-4-2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2Zm-2-4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var contacts = {
      name: "contacts",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 0h16v2H4V0Zm0 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2Zm0 14h16V6H4v12Zm0 4v2h16v-2H4Zm8-10a2.5 2.5 0 0 0 0-5 2.5 2.5 0 0 0 0 5Zm1-2.5c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm4 6.49C17 13.9 13.69 13 12 13s-5 .9-5 2.99V17h10v-1.01Zm-5-1.49c-1.16 0-2.58.48-3.19 1h6.39c-.61-.52-2.03-1-3.2-1Z"
    };
    var contact_phone = {
      name: "contact_phone",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 3H2C.9 3 0 3.9 0 5v14c0 1.1.9 2 2 2h20c1.1 0 1.99-.9 1.99-2L24 5c0-1.1-.9-2-2-2ZM2 19V5h20v14H2Zm19-3-1.99 1.99A7.512 7.512 0 0 1 16.28 14c-.18-.64-.28-1.31-.28-2s.1-1.36.28-2a7.474 7.474 0 0 1 2.73-3.99L21 8l-1.51 2h-1.64c-.22.63-.35 1.3-.35 2s.13 1.37.35 2h1.64L21 16ZM9 12c1.65 0 3-1.35 3-3s-1.35-3-3-3-3 1.35-3 3 1.35 3 3 3Zm1-3c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm5 7.59c0-2.5-3.97-3.58-6-3.58s-6 1.08-6 3.58V18h12v-1.41ZM9 15c-1.3 0-2.78.5-3.52 1h7.04c-.75-.51-2.22-1-3.52-1Z"
    };
    var contact_email = {
      name: "contact_email",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 3h20c1.1 0 2 .9 2 2l-.01 14c0 1.1-.89 2-1.99 2H2c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2Zm0 16h20V5H2v14ZM21 6h-7v5h7V6Zm-3.5 3.75L20 8V7l-2.5 1.75L15 7v1l2.5 1.75ZM9 12c1.65 0 3-1.35 3-3s-1.35-3-3-3-3 1.35-3 3 1.35 3 3 3Zm1-3c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1Zm5 7.59c0-2.5-3.97-3.58-6-3.58s-6 1.08-6 3.58V18h12v-1.41ZM9 15c-1.3 0-2.78.5-3.52 1h7.04c-.75-.51-2.22-1-3.52-1Z"
    };
    var email_alpha = {
      name: "email_alpha",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10v1.43C22 15.4 20.47 17 18.5 17c-1.19 0-2.31-.58-2.96-1.47-.9.91-2.16 1.47-3.54 1.47-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5v1.43c0 .79.71 1.57 1.5 1.57s1.5-.78 1.5-1.57V12c0-4.34-3.66-8-8-8s-8 3.66-8 8 3.66 8 8 8h5v2h-5C6.48 22 2 17.52 2 12Zm7 0c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3Z"
    };
    var call_add = {
      name: "call_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.43 14.93c1.12.37 2.32.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1l-2.2 2.21c1.44 2.84 3.76 5.15 6.59 6.59l2.2-2.2c.2-.19.45-.29.71-.29.1 0 .21.02.31.05ZM6.98 7.58c-.23-.83-.38-1.7-.45-2.58h-1.5c.09 1.32.35 2.58.75 3.79l1.2-1.21ZM19 18.97c-1.32-.09-2.6-.35-3.8-.76l1.2-1.2c.85.24 1.72.39 2.6.45v1.51ZM18 3v3h3v2h-3v3h-2V8h-3V6h3V3h2Z"
    };
    var call_end = {
      name: "call_end",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M.29 12.24C3.34 9.35 7.46 7.57 12 7.57c4.54 0 8.66 1.78 11.71 4.67.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28a11.27 11.27 0 0 0-2.67-1.85.996.996 0 0 1-.56-.9v-3.1c-1.44-.48-2.99-.73-4.59-.73-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.65a.956.956 0 0 1-.29-.7c0-.28.11-.53.29-.71Zm5.11-1.15v1.7c-.65.37-1.28.79-1.87 1.27l-1.07-1.07c.91-.75 1.9-1.38 2.94-1.9Zm13.19 0 .01.005V12.8c.67.38 1.3.8 1.88 1.27L21.55 13a14.798 14.798 0 0 0-2.95-1.905v-.005h-.01Z"
    };
    var call = {
      name: "call",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 3h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.2-.19.45-.29.71-.29.1 0 .21.01.31.05 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1Zm2.54 2c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51Zm9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19Z"
    };
    var comment_discussion = {
      name: "comment_discussion",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 2H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1Zm-1 2v7H5.17L4 12.17V4h11Zm4 2h2c.55 0 1 .45 1 1v15l-4-4H7c-.55 0-1-.45-1-1v-2h13V6Z"
    };
    var comment_chat = {
      name: "comment_chat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2H4Zm0 2h16v12H5.17L4 17.17V4Zm10 8H6v2h8v-2ZM6 9h12v2H6V9Zm12-3H6v2h12V6Z"
    };
    var comment_solid = {
      name: "comment_solid",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2Z"
    };
    var comment = {
      name: "comment",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H6l-4 4V4c0-1.1.9-2 2-2Zm2 14h14V4H4v14l2-2Z"
    };
    var mood_very_happy = {
      name: "mood_very_happy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Zm5-10.5c0 .83-.67 1.5-1.5 1.5S14 10.33 14 9.5 14.67 8 15.5 8s1.5.67 1.5 1.5ZM8.5 11c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11Zm8.61 3c-.8 2.04-2.78 3.5-5.11 3.5-2.33 0-4.31-1.46-5.11-3.5h10.22Z"
    };
    var mood_very_sad = {
      name: "mood_very_sad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Zm5-10.5c0 .83-.67 1.5-1.5 1.5S14 10.33 14 9.5 14.67 8 15.5 8s1.5.67 1.5 1.5ZM8.5 11c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11Zm-1.61 6c.8-2.04 2.78-3.5 5.11-3.5 2.33 0 4.31 1.46 5.11 3.5H6.89Z"
    };
    var mood_sad = {
      name: "mood_sad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM8.5 8a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7 0a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm-8.62 9.5a5.495 5.495 0 0 1 10.24 0h-1.67c-.7-1.19-1.97-2-3.45-2-1.48 0-2.76.81-3.45 2H6.88ZM4 12c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8-8 3.58-8 8Z"
    };
    var mood_neutral = {
      name: "mood_neutral",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM7 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM15.5 8a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM9 15.5V14h6v1.5H9ZM4 12c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8-8 3.58-8 8Z"
    };
    var mood_happy = {
      name: "mood_happy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2ZM8.5 8a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm7 0a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm-6.95 6c.7 1.19 1.97 2 3.45 2 1.48 0 2.75-.81 3.45-2h1.67a5.495 5.495 0 0 1-10.24 0h1.67ZM4 12c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8-8 3.58-8 8Z"
    };
    var mood_extremely_sad = {
      name: "mood_extremely_sad",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.47 6.47 2 11.99 2 17.52 2 22 6.47 22 12s-4.49 10-10.01 10S2 17.53 2 12Zm5.82 0 1.06-1.06L9.94 12 11 10.94 9.94 9.88 11 8.82 9.94 7.76 8.88 8.82 7.82 7.76 6.76 8.82l1.06 1.06-1.06 1.06L7.82 12ZM12 13.5c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5Zm0 6.5c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Zm3.12-11.18 1.06-1.06 1.06 1.06-1.06 1.06 1.06 1.06L16.18 12l-1.06-1.06L14.06 12 13 10.94l1.06-1.06L13 8.82l1.06-1.06 1.06 1.06Z"
    };
    var mood_extremely_happy = {
      name: "mood_extremely_happy",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10C17.51 22 22 17.53 22 12S17.52 2 11.99 2ZM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Zm2.06-9L13 9.94l2.12-2.12 2.12 2.12L16.18 11l-1.06-1.06L14.06 11ZM8.88 9.94 9.94 11 11 9.94 8.88 7.82 6.76 9.94 7.82 11l1.06-1.06ZM17.11 14c-.8 2.04-2.78 3.5-5.11 3.5-2.33 0-4.31-1.46-5.11-3.5h10.22Z"
    };
    var comment_add = {
      name: "comment_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M22 4c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4Zm-2 13.17L18.83 16H4V4h16v13.17ZM11 5h2v4h4v2h-4v4h-2v-4H7V9h4V5Z"
    };
    var comment_chat_off = {
      name: "comment_chat_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.34.93.93 2.34l2.01 2.01-.01 16.99 4-4h9l5.73 5.73 1.41-1.41L2.34.93Zm18.59 14.41v-12H7.59l-2-2h15.34c1.1 0 2 .9 2 2v12c0 .9-.61 1.66-1.43 1.91l-1.91-1.91h1.34Zm-12-4h-2v2h2v-2Zm10-3h-6.34l2 2h4.34v-2Zm-8-3h8v2h-7.34l-.66-.66V5.34Zm-6 11.17 1.17-1.17h7.83l-5-5h-2v-2l-2-2v10.17Z"
    };
    var comment_notes = {
      name: "comment_notes",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 2h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H6l-4 4 .01-18c0-1.1.89-2 1.99-2Zm1.17 14H20V4H4v13.17l.58-.58.59-.59ZM6 12h2v2H6v-2Zm2-3H6v2h2V9ZM6 6h2v2H6V6Zm9 6h-5v2h5v-2Zm-5-3h8v2h-8V9Zm8-3h-8v2h8V6Z"
    };
    var mail_unread = {
      name: "mail_unread",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 7H10v2h10v12H4V9h2v4h2V5h6V1H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2Z"
    };
    var thumbs_down = {
      name: "thumbs_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 2H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 22l6.59-6.59c.36-.36.58-.86.58-1.41V4c0-1.1-.9-2-2-2Zm0 12-4.34 4.34L12 13H3v-2l3-7h9v10Zm8-12h-4v12h4V2Z"
    };
    var thumbs_up_down = {
      name: "thumbs_up_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 5c.55 0 1 .45 1 1v1.25c0 .19-.04.38-.11.55l-2.26 5.29c-.23.53-.76.91-1.38.91H1.5C.67 14 0 13.33 0 12.5V6c0-.41.17-.79.44-1.06L5.38 0l.79.79c.2.21.33.49.33.8l-.02.23L5.82 5H11Zm-3.08 7L10 7.13V7H3.36l.57-2.72L2 6.21V12h5.92Zm14.58-2h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5Zm-2.43 9.72L22 17.79V12h-5.92L14 16.87V17h6.64l-.57 2.72Z"
    };
    var support = {
      name: "support",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.5 19.695v3.6l1.43-.69c5.13-2.47 8.57-7.45 8.57-12.4 0-5.24-4.26-9.5-9.5-9.5s-9.5 4.26-9.5 9.5c0 5.07 3.99 9.23 9 9.49Zm-7-9.49c0-4.14 3.36-7.5 7.5-7.5 4.14 0 7.5 3.36 7.5 7.5 0 3.72-2.36 7.5-6 9.8v-2.3H12c-4.14 0-7.5-3.36-7.5-7.5Zm8.5 4v2h-2v-2h2Zm-.23-4.678c-.828.635-1.77 1.357-1.77 3.178h2c0-1.095.711-1.717 1.44-2.354.77-.673 1.56-1.363 1.56-2.646 0-2.21-1.79-4-4-4s-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 .88-.58 1.324-1.23 1.822Z"
    };
    var help = {
      name: "help",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-1 17v-2h2v2h-2Zm3.17-6.83.9-.92c.57-.57.93-1.37.93-2.25 0-2.21-1.79-4-4-4S8 6.79 8 9h2c0-1.1.9-2 2-2s2 .9 2 2c0 .55-.22 1.05-.59 1.41l-1.24 1.26C11.45 12.4 11 13.4 11 14.5v.5h2c0-1.5.45-2.1 1.17-2.83Z"
    };
    var help_outline = {
      name: "help_outline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm11 4v2h-2v-2h2Zm-1 4c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8ZM8 10c0-2.21 1.79-4 4-4s4 1.79 4 4c0 1.283-.79 1.973-1.56 2.646C13.712 13.283 13 13.905 13 15h-2c0-1.821.942-2.543 1.77-3.178.65-.498 1.23-.943 1.23-1.822 0-1.1-.9-2-2-2s-2 .9-2 2H8Z"
    };
    var info_circle = {
      name: "info_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12.01 22C17.53 22 22 17.52 22 12S17.53 2 12.01 2C6.48 2 2 6.48 2 12s4.48 10 10.01 10ZM13 9V7h-2v2h2Zm0 8v-6h-2v6h2Zm7-5c0-4.42-3.58-8-8-8s-8 3.58-8 8 3.58 8 8 8 8-3.58 8-8Z"
    };
    var thumbs_up = {
      name: "thumbs_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9 22h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 2 7.58 8.59C7.22 8.95 7 9.45 7 10v10c0 1.1.9 2 2 2Zm0-12 4.34-4.34L12 11h9v2l-3 7H9V10Zm-4 0H1v12h4V10Z",
      sizes: {
        small: {
          name: "thumbs_up_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M5.625 17h7.313c.674 0 1.25-.4 1.494-.976l2.454-5.64c.073-.184.114-.376.114-.584V8.2c0-.88-.606-1.2-1.5-1.2H10l1.02-4.056.024-.256c0-.328-.138-.632-.357-.848L9.826 1 4.47 6.272A1.578 1.578 0 0 0 4 7.4v8c0 .88.731 1.6 1.625 1.6ZM6 7.5l3.5-4L8 9h7v1l-2 5H6V7.5ZM3 7H1v10h2V7Z"
        }
      }
    };
    var donut_large = {
      name: "donut_large",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.025 12c0 3.52 2.61 6.43 6 6.92v3.03c-5.05-.5-9-4.76-9-9.95 0-5.19 3.95-9.45 9-9.95v3.03c-3.39.49-6 3.4-6 6.92Zm8-6.92a7 7 0 0 1 5.92 5.92h3.03c-.47-4.72-4.23-8.48-8.95-8.95v3.03Zm5.92 7.92a7 7 0 0 1-5.92 5.92v3.03c4.72-.47 8.48-4.23 8.95-8.95h-3.03Z"
    };
    var donut_outlined = {
      name: "donut_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2.025 12c0 5.19 3.95 9.45 9 9.95v-7.13c-1.16-.42-2-1.52-2-2.82 0-1.3.84-2.4 2-2.82V2.05c-5.05.5-9 4.76-9 9.95Zm19.95-1h-7.13c-.31-.85-.97-1.51-1.82-1.82V2.05c4.72.47 8.48 4.23 8.95 8.95Zm-2.53-2c-.82-2-2.42-3.6-4.42-4.42v3.43c.37.28.71.62.99.99h3.43Zm-10.42-.98V4.58c-2.96 1.18-5 4.07-5 7.42 0 3.35 2.04 6.24 5 7.43v-3.44c-1.23-.93-2-2.4-2-3.99 0-1.59.77-3.06 2-3.98Zm4 6.8v7.13c4.72-.47 8.48-4.23 8.95-8.95h-7.13c-.31.85-.97 1.51-1.82 1.82Zm2.99.18c-.28.38-.62.71-.99.99v3.43c2-.82 3.6-2.42 4.42-4.42h-3.43Z"
    };
    var table_chart = {
      name: "table_chart",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19.5 3h-15c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 2v3h-15V5h15Zm-10 14h5v-9h-5v9Zm-5-9h3v9h-3v-9Zm12 0v9h3v-9h-3Z"
    };
    var multiline_chart = {
      name: "multiline_chart",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m22 7.175-1.41-1.41-2.85 3.21c-2.06-2.32-4.91-3.72-8.13-3.72-2.89 0-5.54 1.16-7.61 3l1.42 1.42c1.7-1.49 3.85-2.42 6.19-2.42 2.74 0 5.09 1.26 6.77 3.24l-2.88 3.24-4-4-7.5 7.51 1.5 1.5 6-6.01 4 4 4.05-4.55c.75 1.35 1.25 2.9 1.44 4.55H21c-.22-2.3-.95-4.39-2.04-6.14L22 7.175Z"
    };
    var pie_chart = {
      name: "pie_chart",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm11-1h6.93A8.002 8.002 0 0 0 13 4.07V11Zm-9 1c0-4.07 3.06-7.44 7-7.93v15.86c-3.94-.49-7-3.86-7-7.93Zm9 1v6.93A8.002 8.002 0 0 0 19.93 13H13Z"
    };
    var bubble_chart = {
      name: "bubble_chart",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16 3a5.51 5.51 0 0 0-5.5 5.5c0 3.03 2.47 5.5 5.5 5.5s5.5-2.47 5.5-5.5S19.03 3 16 3ZM2.5 14c0-2.21 1.79-4 4-4s4 1.79 4 4-1.79 4-4 4-4-1.79-4-4Zm2 0c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2Zm10.01 1c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3Zm-1 3c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1ZM12.5 8.5c0 1.93 1.57 3.5 3.5 3.5s3.5-1.57 3.5-3.5S17.93 5 16 5s-3.5 1.57-3.5 3.5Z"
    };
    var scatter_plot = {
      name: "scatter_plot",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.2 10.2c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4Zm-8 4c0 2.21 1.79 4 4 4s4-1.79 4-4-1.79-4-4-4-4 1.79-4 4Zm2 0c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Zm4-8c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Zm7.6 15.6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4Zm-2-4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2Z"
    };
    var bar_chart = {
      name: "bar_chart",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.6 5h2.8v14h-2.8V5ZM5 9.2h3V19H5V9.2ZM19 13h-2.8v6H19v-6Z"
    };
    var assignment = {
      name: "assignment",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.82 4H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-.14 0-.27-.01-.4-.03a2.008 2.008 0 0 1-1.44-1.19c-.1-.24-.16-.51-.16-.78V6c0-.28.06-.54.16-.77A2.008 2.008 0 0 1 4.6 4.04c.13-.03.26-.04.4-.04h4.18C9.6 2.84 10.7 2 12 2c1.3 0 2.4.84 2.82 2ZM7 10V8h10v2H7Zm10 4v-2H7v2h10Zm-3 2H7v2h7v-2ZM12 3.75c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75ZM5 20h14V6H5v14Z"
    };
    var assignment_user = {
      name: "assignment_user",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 4h-4.18C14.4 2.84 13.3 2 12 2c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2Zm-7-.25c.22 0 .41.1.55.25.12.13.2.31.2.5 0 .41-.34.75-.75.75s-.75-.34-.75-.75c0-.19.08-.37.2-.5.14-.15.33-.25.55-.25ZM5 6v14h14V6H5Zm7 1c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3Zm-1 3c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1Zm-5 7.47V19h12v-1.53c0-2.5-3.97-3.58-6-3.58s-6 1.07-6 3.58Zm6-1.59c-1.31 0-3 .56-3.69 1.12h7.38c-.68-.56-2.38-1.12-3.69-1.12Z"
    };
    var assignment_important = {
      name: "assignment_important",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.82 4H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-.14 0-.27-.01-.4-.03a2.008 2.008 0 0 1-1.44-1.19c-.1-.24-.16-.51-.16-.78V6c0-.28.06-.54.16-.77A2.008 2.008 0 0 1 4.6 4.04c.13-.03.26-.04.4-.04h4.18C9.6 2.84 10.7 2 12 2c1.3 0 2.4.84 2.82 2ZM11 14V8h2v6h-2Zm0 4v-2h2v2h-2Zm1-14.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75ZM5 20h14V6H5v14Z"
    };
    var assignment_return = {
      name: "assignment_return",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.82 4H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-.14 0-.27-.01-.4-.03a2.008 2.008 0 0 1-1.44-1.19c-.1-.24-.16-.51-.16-.78V6c0-.28.06-.54.16-.77A2.008 2.008 0 0 1 4.6 4.04c.13-.03.26-.04.4-.04h4.18C9.6 2.84 10.7 2 12 2c1.3 0 2.4.84 2.82 2ZM16 15h-4v3l-5-5 5-5v3h4v4ZM12 3.75c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75ZM5 20h14V6H5v14Z"
    };
    var assignment_returned = {
      name: "assignment_returned",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.82 4H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-.14 0-.27-.01-.4-.03a2.008 2.008 0 0 1-1.44-1.19c-.1-.24-.16-.51-.16-.78V6c0-.28.06-.54.16-.77A2.008 2.008 0 0 1 4.6 4.04c.13-.03.26-.04.4-.04h4.18C9.6 2.84 10.7 2 12 2c1.3 0 2.4.84 2.82 2ZM14 13h3l-5 5-5-5h3V9h4v4Zm-2-9.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75ZM5 20h14V6H5v14Z"
    };
    var assignment_turned_in = {
      name: "assignment_turned_in",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14.82 4H19c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-.14 0-.27-.01-.4-.03a2.008 2.008 0 0 1-1.44-1.19c-.1-.24-.16-.51-.16-.78V6c0-.28.06-.54.16-.77A2.008 2.008 0 0 1 4.6 4.04c.13-.03.26-.04.4-.04h4.18C9.6 2.84 10.7 2 12 2c1.3 0 2.4.84 2.82 2Zm1.77 4.58L18 10l-8 8-4-4 1.41-1.41L10 15.17l6.59-6.59ZM12 3.75c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75ZM5 20h14V6H5v14Z"
    };
    var timeline = {
      name: "timeline",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M23 8c0 1.1-.9 2-2 2a1.7 1.7 0 0 1-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2 2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55 4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02 9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55 2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56A1.7 1.7 0 0 1 19 8c0-1.1.9-2 2-2s2 .9 2 2Z"
    };
    var trending_down = {
      name: "trending_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m16 18 2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6h-6Z"
    };
    var trending_flat = {
      name: "trending_flat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m21.5 12-4-4v3h-15v2h15v3l4-4Z"
    };
    var trending_up = {
      name: "trending_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m16 6 2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6h-6Z"
    };
    var eject = {
      name: "eject",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 5 5.33 15h13.34L12 5Zm7 12v2H5v-2h14Zm-4.07-4L12 8.6 9.07 13h5.86Z"
    };
    var music_note = {
      name: "music_note",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 13.55V3h6v4h-4v10c0 2.21-1.79 4-4 4s-4-1.79-4-4 1.79-4 4-4c.73 0 1.41.21 2 .55ZM8 17c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2Z"
    };
    var music_note_off = {
      name: "music_note_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11.93 10.51 4.34 2.93 2.93 4.34l9 9v.28c-.94-.54-2.1-.75-3.33-.32-1.34.48-2.37 1.67-2.61 3.07a4.007 4.007 0 0 0 4.59 4.65c1.96-.31 3.35-2.11 3.35-4.1v-1.58l5.73 5.73 1.41-1.41-9.14-9.15Zm2-3.44h4v-4h-6v4.61l2 2V7.07Zm-6 10c0 1.1.9 2 2 2s2-.9 2-2-.9-2-2-2-2 .9-2 2Z"
    };
    var mic = {
      name: "mic",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15 11.5c0 1.66-1.34 3-3 3s-3-1.34-3-3v-6c0-1.66 1.34-3 3-3s3 1.34 3 3v6Zm-3 5c2.76 0 5-2.24 5-5h2c0 3.53-2.61 6.43-6 6.92v3.08h-2v-3.08c-3.39-.49-6-3.39-6-6.92h2c0 2.76 2.24 5 5 5Z"
    };
    var mic_outlined = {
      name: "mic_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 14.5c1.66 0 3-1.34 3-3v-6c0-1.66-1.34-3-3-3s-3 1.34-3 3v6c0 1.66 1.34 3 3 3Zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1v-6Zm1 11c2.76 0 5-2.24 5-5h2c0 3.53-2.61 6.43-6 6.92v3.08h-2v-3.08c-3.39-.49-6-3.39-6-6.92h2c0 2.76 2.24 5 5 5Z"
    };
    var mic_off = {
      name: "mic_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.72 5.39c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2l-.01 3.91 1.81 1.79v-5.6c0-1.66-1.34-3-3-3-1.54 0-2.79 1.16-2.96 2.65l1.76 1.76V5.39Zm8.2 6.1h-1.7c0 .58-.1 1.13-.27 1.64l1.27 1.27c.44-.88.7-1.87.7-2.91Zm-16-6.73 1.41-1.41L21.08 20.1l-1.41 1.41-4.2-4.2c-.78.45-1.64.77-2.55.9v3.28h-2v-3.28c-3.28-.49-6-3.31-6-6.72h1.7c0 3 2.54 5.1 5.3 5.1.81 0 1.6-.19 2.31-.52l-1.66-1.66c-.21.05-.42.08-.65.08-1.66 0-3-1.34-3-3v-.73l-6-6Z"
    };
    var volume_up = {
      name: "volume_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 5.29V3.23c4.01.91 7 4.49 7 8.77 0 4.28-2.99 7.86-7 8.77v-2.06c2.89-.86 5-3.54 5-6.71s-2.11-5.85-5-6.71ZM3 15V9h4l5-5v16l-5-5H3Zm7 .17V8.83L7.83 11H5v2h2.83L10 15.17ZM16.5 12A4.5 4.5 0 0 0 14 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02Z"
    };
    var volume_off = {
      name: "volume_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m4.34 2.935-1.41 1.41 4.36 4.36-.29.3H3v6h4l5 5v-6.59l4.18 4.18c-.65.49-1.38.88-2.18 1.11v2.06a8.94 8.94 0 0 0 3.61-1.75l2.05 2.05 1.41-1.41L4.34 2.935ZM10 15.175l-2.17-2.17H5v-2h2.83l.88-.88 1.29 1.29v3.76Zm8.59-.83c.26-.73.41-1.52.41-2.34 0-3.17-2.11-5.85-5-6.71v-2.06c4.01.91 7 4.49 7 8.77 0 1.39-.32 2.7-.88 3.87l-1.53-1.53ZM12 4.005l-1.88 1.88L12 7.765v-3.76Zm2 3.97a4.5 4.5 0 0 1 2.5 4.03c0 .08-.01.16-.02.24L14 9.765v-1.79Z"
    };
    var volume_mute = {
      name: "volume_mute",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11.5 9 5-5v16l-5-5h-4V9h4Zm3 6.17V8.83L12.33 11H9.5v2h2.83l2.17 2.17Z"
    };
    var volume_down = {
      name: "volume_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5.25 9v6h4l5 5V4l-5 5h-4Zm11-1.03v8.05c1.48-.73 2.5-2.25 2.5-4.02a4.5 4.5 0 0 0-2.5-4.03Zm-4 7.2V8.83L10.08 11H7.25v2h2.83l2.17 2.17Z"
    };
    var videocam_off = {
      name: "videocam_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m9.99 8.57-2-2-4.15-4.14-1.41 1.41 2.73 2.73h-.73c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.55-.18l3.18 3.18 1.41-1.41-8.86-8.86-2.72-2.73Zm-4.56 8v-8h1.73l8 8H5.43Zm10-5.39V8.57h-2.61l-2-2h5.61c.55 0 1 .45 1 1v3.5l4-4v10.11l-6-6Z"
    };
    var videocam = {
      name: "videocam",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 6h12c.55 0 1 .45 1 1v3.5l4-4v11l-4-4V17c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1Zm11 10V8H5v8h10Z"
    };
    var video_call = {
      name: "video_call",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4ZM15 16H5V8h10v8Zm-4-1H9v-2H7v-2h2V9h2v2h2v2h-2v2Z"
    };
    var missed_video_call = {
      name: "missed_video_call",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4Zm-2-1.83V16H5V8h10v.67ZM11 15l-3.89-3.89v2.55H6V9.22h4.44v1.11H7.89l3.11 3.1 2.99-3.01.78.79L11 15Z"
    };
    var playlist_play = {
      name: "playlist_play",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M16.5 5h-12v2h12V5Zm0 4h-12v2h12V9Zm-12 4h8v2h-8v-2Zm15 3-5 3v-6l5 3Z"
    };
    var playlist_added = {
      name: "playlist_added",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M1.5 5h12v2h-12V5Zm0 4h12v2h-12V9Zm0 6h8v-2h-8v2Zm21-3L21 10.5 15.51 16l-3.01-3-1.5 1.5 4.51 4.5 6.99-7Z"
    };
    var playlist_add = {
      name: "playlist_add",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 5h12v2H2V5Zm0 4h12v2H2V9Zm16 0h-2v4h-4v2h4v4h2v-4h4v-2h-4V9Zm-8 6H2v-2h8v2Z"
    };
    var snooze = {
      name: "snooze",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m2.055 5.749 1.281 1.536L7.944 3.44 6.663 1.905 2.055 5.75Zm14.001-2.307 1.281-1.536 4.608 3.843-1.282 1.536-4.607-3.843ZM9 11.095h3.63L9 15.295v1.8h6v-2h-3.63l3.63-4.2v-1.8H9v2Zm3-5c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.14-7-7 3.14-7 7-7Zm-9 7A9 9 0 1 1 21 13.097 9 9 0 0 1 3 13.095Z"
    };
    var shuffle$1 = {
      name: "shuffle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10.59 9.17 5.41 4 4 5.41l5.17 5.17 1.42-1.41ZM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5Zm-1.08 10.82 1.41-1.41 3.13 3.13L20 14.5V20h-5.5l2.05-2.05-3.13-3.13Z"
    };
    var repeat_one = {
      name: "repeat_one",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7 7h10v3l4-4-4-4v3H5v6h2V7Zm12 6h-2v4H7v-3l-4 4 4 4v-3h12v-6Zm-6-4v6h-1.5v-4H10v-1l2-1h1Z"
    };
    var repeat$1 = {
      name: "repeat",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17 7H7v4H5V5h12V2l4 4-4 4V7ZM7 17h10v-4h2v6H7v3l-4-4 4-4v3Z"
    };
    var movie = {
      name: "movie",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m20 8-2-4h4v14c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2l.01-12c0-1.1.89-2 1.99-2h1l2 4h3L8 4h2l2 4h3l-2-4h2l2 4h3ZM5.76 10 4 6.47V18h16v-8H5.76Z"
    };
    var res_hd_outlined = {
      name: "res_hd_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2Zm0 16H5V5h14v14Zm-9.5-6h-2v2H6V9h1.5v2.5h2V9H11v6H9.5v-2Zm8.5 1v-4c0-.55-.45-1-1-1h-4v6h4c.55 0 1-.45 1-1Zm-3.5-.5h2v-3h-2v3Z"
    };
    var res_hd_filled = {
      name: "res_hd_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Zm4.5 10h-2v2H6V9h1.5v2.5h2V9H11v6H9.5v-2Zm8.5 1v-4c0-.55-.45-1-1-1h-4v6h4c.55 0 1-.45 1-1Zm-3.5-.5h2v-3h-2v3Z"
    };
    var forward_30 = {
      name: "forward_30",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 20c3.31 0 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8V2l5 5-5 5V8c-3.31 0-6 2.69-6 6s2.69 6 6 6Zm-1.66-3.66c.08-.03.14-.07.2-.12l.041-.047c.035-.038.067-.072.089-.123.03-.07.04-.15.04-.24 0-.11-.02-.21-.05-.29a.483.483 0 0 0-.14-.2.648.648 0 0 0-.22-.11.885.885 0 0 0-.29-.04h-.45v-.66h.43c.22 0 .37-.05.48-.16.11-.11.16-.25.16-.43 0-.08-.01-.16-.04-.22a.62.62 0 0 0-.11-.17.544.544 0 0 0-.18-.11.625.625 0 0 0-.25-.04c-.08 0-.15 0-.22.03s-.13.06-.18.1a.455.455 0 0 0-.17.35h-.85c0-.18.04-.33.11-.48.07-.15.18-.27.3-.37.12-.1.28-.18.44-.23.16-.05.35-.08.54-.08.22 0 .41.03.59.08s.33.13.46.23.23.22.3.38c.07.16.11.33.11.53 0 .09-.01.18-.04.27-.03.09-.08.17-.13.25-.05.08-.12.15-.2.22-.08.07-.18.12-.28.17.24.09.42.22.54.39.12.17.18.38.18.61 0 .2-.04.38-.12.53a1.1 1.1 0 0 1-.32.39c-.14.1-.29.19-.48.24-.19.05-.39.08-.6.08-.18 0-.36-.02-.53-.07-.17-.05-.32-.13-.46-.23s-.25-.22-.33-.38c-.08-.16-.12-.34-.12-.55h.85c0 .08.02.15.05.22.03.07.07.12.13.17a.69.69 0 0 0 .45.15c.1 0 .19-.01.27-.04Zm4.1-3.56c-.18-.07-.37-.1-.59-.1-.22 0-.41.03-.59.1s-.33.18-.45.33c-.12.15-.23.34-.29.57-.06.23-.1.5-.1.82v.74c0 .32.04.6.11.82.07.22.17.42.3.57.13.15.28.26.46.33s.37.1.59.1c.22 0 .41-.03.59-.1s.33-.18.45-.33c.12-.15.22-.34.29-.57.07-.23.1-.5.1-.82v-.74c0-.32-.04-.6-.11-.82-.07-.22-.17-.42-.3-.57-.13-.15-.28-.26-.46-.33Zm-.03 3.05c.03-.13.04-.29.04-.48h.01v-.97c0-.19-.01-.35-.04-.48s-.07-.23-.12-.31a.436.436 0 0 0-.19-.17.655.655 0 0 0-.5 0c-.08.03-.13.09-.19.17-.06.08-.09.18-.12.31s-.04.29-.04.48v.97c0 .19.01.35.04.48s.07.24.12.32c.05.08.12.14.19.17a.655.655 0 0 0 .5 0c.08-.03.14-.09.19-.17.05-.08.08-.19.11-.32Z"
    };
    var forward_10 = {
      name: "forward_10",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 20c3.31 0 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8V2l5 5-5 5V8c-3.31 0-6 2.69-6 6s2.69 6 6 6Zm-1.1-7.27V17h-.85v-3.26l-1.01.31v-.69l1.77-.63h.09Zm3.42.05c-.18-.07-.37-.1-.59-.1-.22 0-.41.03-.59.1s-.33.18-.45.33c-.12.15-.23.34-.29.57-.06.23-.1.5-.1.82v.74c0 .32.04.6.11.82.07.22.17.42.3.57.13.15.28.26.46.33s.37.1.59.1c.22 0 .41-.03.59-.1s.33-.18.45-.33c.12-.15.22-.34.29-.57.07-.23.1-.5.1-.82v-.74c0-.32-.04-.6-.11-.82-.07-.22-.17-.42-.3-.57-.13-.15-.29-.26-.46-.33Zm-.03 3.05c.03-.13.04-.29.04-.48h.01v-.97c0-.19-.01-.35-.04-.48s-.07-.23-.12-.31a.436.436 0 0 0-.19-.17.655.655 0 0 0-.5 0c-.08.03-.13.09-.19.17-.06.08-.09.18-.12.31s-.04.29-.04.48v.97c0 .19.01.35.04.48s.07.24.12.32c.05.08.12.14.19.17a.655.655 0 0 0 .5 0c.08-.03.14-.09.19-.17.05-.08.08-.19.11-.32Z"
    };
    var forward_5 = {
      name: "forward_5",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 20c3.31 0 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8V2l5 5-5 5V8c-3.31 0-6 2.69-6 6s2.69 6 6 6Zm.3-3.68c.07-.04.13-.1.18-.17.05-.07.09-.15.11-.24.02-.09.03-.19.03-.31s-.01-.21-.04-.31a.681.681 0 0 0-.13-.24.538.538 0 0 0-.21-.15.853.853 0 0 0-.3-.05c-.07 0-.15.01-.2.02-.05.01-.1.03-.15.05-.05.02-.08.04-.12.07-.04.03-.07.06-.1.09l-.67-.17.25-2.17h2.39v.71h-1.7l-.11.92a.369.369 0 0 0 .048-.021c.017-.009.037-.019.062-.029.025-.01.05-.018.075-.025a.879.879 0 0 0 .075-.025.822.822 0 0 1 .18-.04c.06-.01.13-.02.2-.02.21 0 .39.04.55.1.16.06.3.16.41.28.11.12.19.28.25.45.06.17.09.38.09.6 0 .19-.03.37-.09.54-.06.17-.15.32-.27.45-.12.13-.27.23-.45.31-.18.08-.4.12-.64.12-.18 0-.36-.03-.53-.08-.17-.05-.33-.13-.46-.24-.13-.11-.24-.23-.32-.39-.08-.16-.12-.33-.13-.53h.84c.02.17.08.31.19.41.11.1.25.15.42.15.1 0 .2-.02.27-.06Z"
    };
    var replay_30 = {
      name: "replay_30",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2v4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8h2c0 3.31 2.69 6 6 6s6-2.69 6-6-2.69-6-6-6v4L7 7l5-5Zm-1.99 12.49h-.45v.65h.47c.11 0 .2.02.29.04a.508.508 0 0 1 .36.31c.03.08.05.18.05.29 0 .09-.01.17-.04.24a.561.561 0 0 1-.33.3c-.08.03-.17.04-.27.04-.09 0-.17-.02-.25-.04a.49.49 0 0 1-.2-.11c-.06-.05-.1-.1-.13-.17a.545.545 0 0 1-.05-.22h-.85c0 .21.04.4.12.55.08.15.2.27.33.38.13.11.29.18.46.23.17.05.35.07.53.07.22 0 .41-.03.6-.08s.34-.14.48-.24c.14-.1.24-.24.32-.39.08-.15.12-.33.12-.53 0-.23-.06-.43-.18-.61s-.3-.3-.54-.39a1.1 1.1 0 0 0 .48-.39.853.853 0 0 0 .17-.52c0-.2-.04-.38-.11-.53-.07-.15-.17-.28-.3-.38-.13-.1-.28-.18-.46-.23-.18-.05-.38-.08-.59-.08-.19 0-.37.03-.54.08-.17.05-.31.13-.44.23a1.067 1.067 0 0 0-.41.85h.85a.455.455 0 0 1 .17-.35.4.4 0 0 1 .18-.1.78.78 0 0 1 .22-.03c.09 0 .18.02.25.04s.13.06.18.11a.538.538 0 0 1 .15.39c0 .18-.05.32-.16.43-.11.11-.27.16-.48.16Zm5.29.75c0 .32-.03.6-.1.82-.07.22-.17.42-.29.57-.12.15-.28.26-.45.33-.17.07-.37.1-.59.1-.22 0-.41-.03-.59-.1s-.33-.18-.46-.33c-.13-.15-.23-.34-.3-.57-.07-.23-.11-.5-.11-.82v-.74c0-.32.03-.6.1-.82.07-.22.17-.42.29-.57.12-.15.28-.26.45-.33.17-.07.37-.1.59-.1.22 0 .41.03.59.1s.33.18.46.33c.13.15.23.34.3.57.07.23.11.5.11.82v.74Zm-.89-1.34c.03.13.04.29.04.48h-.01v.97c0 .19-.01.35-.04.48-.02.13-.06.24-.11.32-.05.08-.12.14-.19.17a.655.655 0 0 1-.5 0 .389.389 0 0 1-.19-.17c-.05-.08-.09-.19-.12-.32s-.04-.29-.04-.48v-.97c0-.19.01-.35.04-.48s.07-.23.12-.31c.05-.08.12-.14.19-.17a.655.655 0 0 1 .5 0c.08.03.14.09.19.17.05.08.09.18.12.31Z"
    };
    var replay_10 = {
      name: "replay_10",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2v4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8h2c0 3.31 2.69 6 6 6s6-2.69 6-6-2.69-6-6-6v4L7 7l5-5Zm-1.95 15h.85v-4.27h-.09l-1.77.63v.69l1.01-.31V17Zm5.13-1.76c0 .32-.03.6-.1.82-.07.22-.17.42-.29.57-.12.15-.28.26-.45.33-.17.07-.37.1-.59.1-.22 0-.41-.03-.59-.1s-.33-.18-.46-.33c-.13-.15-.23-.34-.3-.57-.07-.23-.11-.5-.11-.82v-.74c0-.32.03-.6.1-.82.07-.22.17-.42.29-.57.12-.15.28-.26.45-.33.17-.07.37-.1.59-.1.22 0 .41.03.59.1s.33.18.46.33c.13.15.23.34.3.57.07.23.11.5.11.82v.74Zm-.89-1.34c.03.13.04.29.04.48h-.01v.97c0 .19-.02.35-.04.48s-.06.24-.11.32c-.05.08-.12.14-.19.17a.655.655 0 0 1-.5 0 .389.389 0 0 1-.19-.17c-.05-.08-.09-.19-.12-.32s-.04-.29-.04-.48v-.97c0-.19.01-.35.04-.48s.07-.23.12-.31c.05-.08.12-.14.19-.17a.655.655 0 0 1 .5 0c.08.03.14.09.19.17.05.08.09.18.12.31Z"
    };
    var replay_5 = {
      name: "replay_5",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2v4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8h2c0 3.31 2.69 6 6 6s6-2.69 6-6-2.69-6-6-6v4L7 7l5-5Zm-1.06 10.73-.25 2.17.67.16.022-.023a.29.29 0 0 1 .078-.067c.02-.01.04-.023.06-.035a.66.66 0 0 1 .21-.085c.05-.01.12-.02.2-.02.11 0 .22.02.3.05.08.03.15.08.21.15.06.07.1.14.13.24.03.1.04.2.04.31 0 .11 0 .21-.03.31s-.07.18-.11.25a.49.49 0 0 1-.45.23.65.65 0 0 1-.42-.15c-.11-.09-.17-.23-.19-.41h-.84c0 .2.05.38.13.53.08.15.18.29.32.39.14.1.29.19.46.24.17.05.35.08.53.08.25 0 .46-.05.64-.12.18-.07.33-.18.45-.31s.21-.28.27-.45c.06-.17.09-.35.09-.54 0-.22-.04-.42-.09-.6-.05-.18-.14-.33-.25-.45-.11-.12-.25-.21-.41-.28a1.35 1.35 0 0 0-.75-.08c-.03.005-.06.012-.09.02s-.06.015-.09.02c-.06.01-.11.03-.15.05a.619.619 0 0 1-.05.021c-.022.01-.043.017-.06.029l.11-.92h1.7v-.71h-2.39Z"
    };
    var replay = {
      name: "replay",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 6V2L7 7l5 5V8c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8Z"
    };
    var play_circle_outlined = {
      name: "play_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm4-8-6 4.5v-9l6 4.5Z"
    };
    var play_circle = {
      name: "play_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm14 0-6-4.5v9l6-4.5Z"
    };
    var play = {
      name: "play",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m17.5 12-11 7V5l11 7Zm-3.73 0L8.5 8.64v6.72L13.77 12Z"
    };
    var pause_circle_outlined = {
      name: "pause_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm9 4H9V8h2v8Zm1 4c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8Zm3-4h-2V8h2v8Z"
    };
    var pause_circle = {
      name: "pause_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-1 14H9V8h2v8Zm2 0h2V8h-2v8Z"
    };
    var pause = {
      name: "pause",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 19H6V5h4v14Zm4 0V5h4v14h-4Z"
    };
    var stop$1 = {
      name: "stop",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 6h12v12H6V6Zm10 10V8H8v8h8Z"
    };
    var record = {
      name: "record",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4 12c0-4.42 3.58-8 8-8s8 3.58 8 8-3.58 8-8 8-8-3.58-8-8Zm14 0c0-3.31-2.69-6-6-6s-6 2.69-6 6 2.69 6 6 6 6-2.69 6-6Z"
    };
    var skip_previous = {
      name: "skip_previous",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M6 6h2v12H6V6Zm3.5 6 8.5 6V6l-8.5 6Zm3.47 0L16 14.14V9.86L12.97 12Z"
    };
    var skip_next = {
      name: "skip_next",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6 18 8.5-6L6 6v12Zm2-8.14L11.03 12 8 14.14V9.86ZM18 6h-2v12h2V6Z"
    };
    var fast_rewind = {
      name: "fast_rewind",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m3.25 12 8.5-6v12l-8.5-6Zm17.5-6-8.5 6 8.5 6V6ZM6.72 12l3.03 2.14V9.86L6.72 12Zm9 0 3.03 2.14V9.86L15.72 12Z"
    };
    var fast_forward = {
      name: "fast_forward",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m11.75 12-8.5 6V6l8.5 6Zm.5 6 8.5-6-8.5-6v12Zm-3.97-6L5.25 9.86v4.28L8.28 12Zm9 0-3.03-2.14v4.28L17.28 12Z"
    };
    var closed_caption_outlined = {
      name: "closed_caption_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 4h14c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm0 14h14V6H5v12Zm2-3h3c.55 0 1-.45 1-1v-1H9.5v.5h-2v-3h2v.5H11v-1c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1Zm10 0h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1h-1.5v-.5h-2v3h2V13H18v1c0 .55-.45 1-1 1Z"
    };
    var closed_caption_filled = {
      name: "closed_caption_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 4h14c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm2 11h3c.55 0 1-.45 1-1v-1H9.5v.5h-2v-3h2v.5H11v-1c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1Zm7 0h3c.55 0 1-.45 1-1v-1h-1.5v.5h-2v-3h2v.5H18v-1c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1Z"
    };
    var res_4k_outlined = {
      name: "res_4k_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M19 3H5c-1.1 0-2 .9-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5a2 2 0 0 0-2-2Zm0 2v14H5V5h14Zm-8 10H9.5v-1.5h-3V9H8v3h1.5V9H11v3h1v1.51h-1V15Zm5.2-3 2-3h-1.7l-2 3V9H13v6h1.5v-3l2 3h1.7l-2-3Z"
    };
    var res_4k_filled = {
      name: "res_4k_filled",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 3h14a2 2 0 0 1 2 2v14c0 1.1-.9 2-2 2H5a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2Zm6 12H9.5v-1.5h-3V9H8v3h1.5V9H11v3h1v1.51h-1V15Zm5.2-3 2-3h-1.7l-2 3V9H13v6h1.5v-3l2 3h1.7l-2-3Z"
    };
    var record_voice = {
      name: "record_voice",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.44 4.13 1.63-1.63c3.91 4.05 3.9 10.11 0 14l-1.63-1.63c2.77-3.18 2.77-7.72 0-10.74ZM13 9.5c0 2.21-1.79 4-4 4s-4-1.79-4-4 1.79-4 4-4 4 1.79 4 4Zm-2 0c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2Zm-2 6c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4Zm0 2c-2.69 0-5.78 1.28-6 2h12c-.2-.71-3.3-2-6-2Zm6.08-9.95c.84 1.18.84 2.71 0 3.89l1.68 1.69c2.02-2.02 2.02-5.07 0-7.27l-1.68 1.69Z"
    };
    var record_voice_off = {
      name: "record_voice_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m18.442 4.13 1.63-1.63c3.86 3.99 3.89 9.94.15 13.83l-1.64-1.64c2.62-3.17 2.58-7.59-.14-10.56Zm-3.36 3.42 1.68-1.69c1.98 2.15 2.01 5.11.11 7.13l-1.7-1.7c.74-1.16.71-2.61-.09-3.74Zm-5.65-2.01 3.53 3.53a3.979 3.979 0 0 0-3.53-3.53Zm-6.43-.77 1.41-1.41 16.73 16.73-1.41 1.41-3.02-3.02c.18.32.29.65.29 1.02v2h-16v-2c0-2.66 5.33-4 8-4 1.78 0 4.74.6 6.51 1.78l-4.4-4.4c-.61.39-1.33.62-2.11.62-2.21 0-4-1.79-4-4 0-.78.23-1.5.62-2.11l-2.62-2.62Zm0 14.73c.22-.72 3.31-2 6-2 2.7 0 5.8 1.29 6 2h-12Zm4-10c0 1.1.9 2 2 2 .22 0 .42-.04.62-.11l-2.51-2.51c-.07.2-.11.4-.11.62Z"
    };
    var stop_circle = {
      name: "stop_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm14-4H8v8h8V8Z"
    };
    var stop_circle_outlined = {
      name: "stop_circle_outlined",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm2 0c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm12-4H8v8h8V8Z"
    };
    var expand = {
      name: "expand",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M9.563 12 4 6.645 5.713 5 13 12l-7.287 7L4 17.355 9.563 12Zm7 0L11 6.645 12.713 5 20 12l-7.287 7L11 17.355 16.563 12Z"
    };
    var last_page = {
      name: "last_page",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m10.385 12-4.59-4.59L7.205 6l6 6-6 6-1.41-1.41 4.59-4.59Zm7.82-6h-2v12h2V6Z"
    };
    var first_page = {
      name: "first_page",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.795 6h-2v12h2V6Zm5.82 6 4.59 4.59-1.41 1.41-6-6 6-6 1.41 1.41-4.59 4.59Z"
    };
    var unfold_more = {
      name: "unfold_more",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.17 9 12 5.83 8.83 9 7.41 7.59 12 3l4.58 4.59L15.17 9Zm-6.34 6L12 18.17 15.17 15l1.42 1.41L12 21l-4.58-4.59L8.83 15Z"
    };
    var unfold_less = {
      name: "unfold_less",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m15.17 4 1.42 1.41L12 10 7.41 5.41 8.83 4 12 7.17 15.17 4ZM8.83 20l-1.42-1.41L12 14l4.58 4.59L15.17 20 12 16.83 8.83 20Z"
    };
    var swap_horizontal = {
      name: "swap_horizontal",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.01 5 21 9l-3.99 4v-3H10V8h7.01V5ZM3 15l3.99-4v3H14v2H6.99v3L3 15Z"
    };
    var swap_horizontal_circle = {
      name: "swap_horizontal_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm2 0c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm11-5.5V9h-4v2h4v2.5l3.5-3.5L15 6.5ZM5.5 14 9 10.5V13h4v2H9v2.5L5.5 14Z"
    };
    var swap_vertical = {
      name: "swap_vertical",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M5 6.99 9 3l4 3.99h-3V14H8V6.99H5ZM16 10v7.01h3L15 21l-4-3.99h3V10h2Z"
    };
    var swap_vertical_circle = {
      name: "swap_vertical_circle",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.48 2 12 2s10 4.48 10 10-4.48 10-10 10S2 17.52 2 12Zm2 0c0 4.41 3.59 8 8 8s8-3.59 8-8-3.59-8-8-8-8 3.59-8 8Zm2.5-3L10 5.5 13.5 9H11v4H9V9H6.5Zm7.5 9.5 3.5-3.5H15v-4h-2v4h-2.5l3.5 3.5Z"
    };
    var chevron_down = {
      name: "chevron_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7.41 8.295 4.59 4.58 4.59-4.58L18 9.705l-6 6-6-6 1.41-1.41Z",
      sizes: {
        small: {
          name: "chevron_down_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M5.175 6 9 9.709 12.825 6 14 7.142 9 12 4 7.142 5.175 6Z"
        }
      }
    };
    var chevron_left = {
      name: "chevron_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.705 16.59 11.125 12l4.58-4.59L14.295 6l-6 6 6 6 1.41-1.41Z",
      sizes: {
        small: {
          name: "chevron_left_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M12 12.827 8.291 9.002 12 5.177l-1.142-1.175-4.858 5 4.858 5L12 12.827Z"
        }
      }
    };
    var chevron_right = {
      name: "chevron_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m8.295 16.59 4.58-4.59-4.58-4.59L9.705 6l6 6-6 6-1.41-1.41Z",
      sizes: {
        small: {
          name: "chevron_right_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m6 12.827 3.709-3.825L6 5.177l1.142-1.175 4.858 5-4.858 5L6 12.827Z"
        }
      }
    };
    var chevron_up = {
      name: "chevron_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7.41 15.705 4.59-4.58 4.59 4.58 1.41-1.41-6-6-6 6 1.41 1.41Z",
      sizes: {
        small: {
          name: "chevron_up_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m5.174 12.002 3.825-3.709 3.825 3.709 1.175-1.142-5-4.859-5 4.859 1.175 1.142Z"
        }
      }
    };
    var arrow_back = {
      name: "arrow_back",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2Z",
      sizes: {
        small: {
          name: "arrow_back_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M15 8H6.5l4-4L9 3 3 9l6 6 1.5-1-4-4H15V8Z"
        }
      }
    };
    var arrow_down = {
      name: "arrow_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8Z",
      sizes: {
        small: {
          name: "arrow_down_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M8 3v8.5l-4-4L3 9l6 6 6-6-1-1.5-4 4V3H8Z"
        }
      }
    };
    var arrow_forward = {
      name: "arrow_forward",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8Z",
      sizes: {
        small: {
          name: "arrow_forward_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M3 10h8.5l-4 4L9 15l6-6-6-6-1.5 1 4 4H3v2Z"
        }
      }
    };
    var arrow_up = {
      name: "arrow_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8Z",
      sizes: {
        small: {
          name: "arrow_up_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M10 15V6.5l4 4L15 9 9 3 3 9l1 1.5 4-4V15h2Z"
        }
      }
    };
    var arrow_back_ios = {
      name: "arrow_back_ios",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m17.835 3.87-1.78-1.77-9.89 9.9 9.9 9.9 1.77-1.77L9.705 12l8.13-8.13Z",
      sizes: {
        small: {
          name: "arrow_back_ios_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M13.377 2.903 12.04 1.575 4.624 9l7.425 7.425 1.328-1.327L7.279 9l6.098-6.097Z"
        }
      }
    };
    var arrow_forward_ios = {
      name: "arrow_forward_ios",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m6.165 20.13 1.77 1.77 9.9-9.9-9.9-9.9-1.77 1.77 8.13 8.13-8.13 8.13Z",
      sizes: {
        small: {
          name: "arrow_forward_ios_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m4.623 2.903 1.335-1.328L13.376 9l-7.425 7.425-1.328-1.327L10.721 9 4.623 2.903Z"
        }
      }
    };
    var arrow_drop_down = {
      name: "arrow_drop_down",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7 9.5 5 5 5-5H7Z",
      sizes: {
        small: {
          name: "arrow_drop_down_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m4 6.5 5 5 5-5H4Z"
        }
      }
    };
    var arrow_drop_up = {
      name: "arrow_drop_up",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m7 14.5 5-5 5 5H7Z",
      sizes: {
        small: {
          name: "arrow_drop_up_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m14 11.5-5-5-5 5h10Z"
        }
      }
    };
    var arrow_drop_right = {
      name: "arrow_drop_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m9.5 17 5-5-5-5v10Z",
      sizes: {
        small: {
          name: "arrow_drop_right_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m6.5 14 5-5-5-5v10Z"
        }
      }
    };
    var arrow_drop_left = {
      name: "arrow_drop_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m14.5 7-5 5 5 5V7Z",
      sizes: {
        small: {
          name: "arrow_drop_left_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m11.5 4-5 5 5 5V4Z"
        }
      }
    };
    var subdirectory_arrow_left = {
      name: "subdirectory_arrow_left",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m10.5 8.5 1.42 1.42-3.59 3.58h9.17v-10h2v12H8.33l3.59 3.58-1.42 1.42-6-6 6-6Z",
      sizes: {
        small: {
          name: "subdirectory_arrow_left_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "m8 7 1 1-2.753 2.125h6.878V3h1.5v8.625H6.247L9 14l-1 1-4.625-4.125L8 7Z"
        }
      }
    };
    var subdirectory_arrow_right = {
      name: "subdirectory_arrow_right",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m19.5 14.5-6 6-1.42-1.42 3.59-3.58H4.5v-12h2v10h9.17l-3.59-3.58L13.5 8.5l6 6Z",
      sizes: {
        small: {
          name: "subdirectory_arrow_right_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M10 7 9 8l2.752 2.125H4.875V3h-1.5v8.625h8.377L9 14l1 1 4.625-4.125L10 7Z"
        }
      }
    };
    var collapse = {
      name: "collapse",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.437 12 13 17.355 11.287 19 4 12l7.287-7L13 6.645 7.437 12Zm7 0L20 17.355 18.287 19 11 12l7.288-7L20 6.645 14.437 12Z"
    };
    var label$1 = {
      name: "label",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M15.5 5c.67 0 1.27.33 1.63.84L21.5 12l-4.37 6.16c-.36.51-.96.84-1.63.84l-11-.01c-1.1 0-2-.89-2-1.99V7c0-1.1.9-1.99 2-1.99l11-.01Zm-11 12h11l3.55-5-3.55-5h-11v10Z"
    };
    var label_off = {
      name: "label_off",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 4.22 3.58 5.8c-.36.35-.58.85-.58 1.39v10c0 1.1.9 1.99 2 1.99l11 .01c.28 0 .55-.07.79-.18l2.18 2.18 1.41-1.41L3.41 2.81 2 4.22Zm14 2.97 3.55 5-1.63 2.29 1.43 1.43L22 12.19l-4.37-6.16c-.36-.51-.96-.84-1.63-.84l-7.37.01 2 1.99H16Zm-11 10h9.97L5 7.22v9.97Z"
    };
    var tag = {
      name: "tag",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42ZM13 20.01 4 11V4h7v-.01l9 9-7 7.02ZM5 6.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"
    };
    var high_priority = {
      name: "high_priority",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 3h-4v12h4V3Zm-4 16a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    };
    var new_label = {
      name: "new_label",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.25 12.5 4.75 9H3.5v6h1.25v-3.5L7.3 15h1.2V9H7.25v3.5ZM9.5 15h4v-1.25H11v-1.11h2.5v-1.26H11v-1.12h2.5V9h-4v6Zm9.75-1.5V9h1.25v5c0 .55-.45 1-1 1h-4c-.55 0-1-.45-1-1V9h1.25v4.51h1.13V9.99h1.25v3.51h1.12Z"
    };
    var new_alert = {
      name: "new_alert",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m20.56 9.215 2.44 2.78-2.44 2.78.34 3.68-3.61.82-1.89 3.18-3.4-1.46-3.4 1.47-1.89-3.18-3.61-.82.34-3.69L1 11.995l2.44-2.79-.34-3.68 3.61-.81 1.89-3.18 3.4 1.46 3.4-1.46 1.89 3.18 3.61.82-.34 3.68Zm-1.81 7.68-.26-2.79 1.85-2.11-1.85-2.11.26-2.79-2.74-.62-1.43-2.41L12 5.175l-2.58-1.1-1.43 2.41-2.74.61.26 2.78-1.85 2.12 1.85 2.1-.26 2.8 2.74.62 1.43 2.41 2.58-1.11 2.58 1.11 1.43-2.41 2.74-.62Zm-5.75-1.9v2h-2v-2h2Zm0-8h-2v6h2v-6Z"
    };
    var flag$1 = {
      name: "flag",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M4.5 3.5h9l.4 2h5.6v10h-7l-.4-2H6.5v7h-2v-17Zm7.76 4-.4-2H6.5v6h7.24l.4 2h3.36v-6h-5.24Z"
    };
    var pin = {
      name: "pin",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.5 9H4v6h1.5v-2h2c.85 0 1.5-.65 1.5-1.5v-1C9 9.65 8.35 9 7.5 9Zm5 6H11V9h1.5v6Zm6.25-2.5V9H20v6h-1.2l-2.55-3.5V15H15V9h1.25l2.5 3.5Zm-13.25-1h2v-1h-2v1Z"
    };
    var tag_main_equipment = {
      name: "tag_main_equipment",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12.4 2.6 9 9c.4.3.6.9.6 1.4 0 .5-.2 1-.6 1.4l-7 7c-.3.4-.8.6-1.4.6-.6 0-1.1-.2-1.4-.6l-9-9c-.4-.3-.6-.8-.6-1.4V4c0-1.1.9-2 2-2h7c.6 0 1.1.2 1.4.6ZM4 11l9 9 7-7-9-9H4v7Zm2.5-6C5.7 5 5 5.7 5 6.5S5.7 8 6.5 8 8 7.3 8 6.5 7.3 5 6.5 5Zm10.3 8.7 1.4-1.4-5.8-5.7-1.5 1.5L12 12l-3.8-1.2-1.5 1.5 5.7 5.7 1.4-1.4-1.5-1.5-1.8-1.6 3 .7.9-.9-.8-3 1.7 1.9 1.5 1.5Z"
    };
    var tag_special_equipment = {
      name: "tag_special_equipment",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m21.4 11.6-9-9c-.3-.4-.8-.6-1.4-.6H4c-1.1 0-2 .9-2 2v7c0 .6.2 1.1.6 1.4l9 9c.3.4.8.6 1.4.6.6 0 1.1-.2 1.4-.6l7-7c.4-.4.6-.9.6-1.4 0-.5-.2-1.1-.6-1.4ZM13 20l-9-9V4h7l9 9-7 7ZM5 6.5C5 5.7 5.7 5 6.5 5S8 5.7 8 6.5 7.3 8 6.5 8 5 7.3 5 6.5Zm6.4 3.8c-.6.3-1.4.7-1.8 1.2-.4.4-.6.8-.3 1.1.361.361.9.126 1.545-.155.961-.42 2.158-.942 3.355.255 1.3 1.3.8 3-.4 4.1-.6.6-1.3 1-2 1.3l-1.4-1.4c.7-.2 1.6-.7 2.1-1.2.4-.4.6-.9.2-1.2-.414-.414-.983-.16-1.649.14-.942.422-2.08.932-3.25-.24-1.3-1.3-.7-2.8.4-3.9.5-.5 1.2-1 1.8-1.2l1.4 1.2Zm6.8 1.8-5.7-5.7L11 7.8l5.7 5.8 1.5-1.5Z"
    };
    var tag_more = {
      name: "tag_more",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42ZM13 20.01 4 11V4h7v-.01l9 9-7 7.02ZM6.657 6.657a1.358 1.358 0 0 1 1.914 0 1.358 1.358 0 0 1 0 1.914 1.358 1.358 0 0 1-1.914 0 1.358 1.358 0 0 1 0-1.914ZM12.4 12.4a1.358 1.358 0 0 1 1.913 0 1.358 1.358 0 0 1 0 1.914 1.358 1.358 0 0 1-1.914 0 1.358 1.358 0 0 1 0-1.914ZM11.442 9.528a1.357 1.357 0 0 0-1.914 0 1.358 1.358 0 0 0 0 1.915 1.358 1.358 0 0 0 1.914 0 1.358 1.358 0 0 0 0-1.915Z"
    };
    var tag_relations = {
      name: "tag_relations",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M10 4h4v4h-1v3h8v5h1v4h-4v-4h1v-3h-6v3h1v4h-4v-4h1v-3H5v3h1v4H2v-4h1v-5h8V8h-1V4Z"
    };
    var pregnant_woman = {
      name: "pregnant_woman",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M11 2c-1.11 0-2 .89-2 2 0 1.11.89 2 2 2 1.11 0 2-.89 2-2 0-1.11-.89-2-2-2Zm3 8c1.17.49 1.99 1.66 2 3v4h-3v5h-3v-5H8v-7c0-1.66 1.34-3 3-3s3 1.34 3 3Z"
    };
    var wheelchair = {
      name: "wheelchair",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M12 2a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm7 11v-2c-1.54.02-3.09-.75-4.07-1.83l-1.29-1.43c-.17-.19-.38-.34-.61-.45-.005 0-.007-.003-.01-.005-.002-.003-.005-.005-.01-.005H13c-.35-.2-.75-.3-1.19-.26C10.76 7.11 10 8.04 10 9.09V15c0 1.1.9 2 2 2h5v5h2v-5.5c0-1.1-.9-2-2-2h-3v-3.45c1.29 1.07 3.25 1.94 5 1.95ZM7 17c0 1.66 1.34 3 3 3 1.31 0 2.42-.84 2.83-2h2.07A5 5 0 1 1 9 12.1v2.07c-1.16.42-2 1.52-2 2.83Z"
    };
    var accessible_forward = {
      name: "accessible_forward",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M17.5 2.27a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-3 14.46h-2c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3v-2c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5Zm1.14-3.5h1.86c1.1 0 2 .9 2 2v5.5h-2v-5h-4.98c-1.46 0-2.45-1.57-1.85-2.9l1.83-4.1h-2.21l-.65 1.53-1.92-.53.67-1.8c.33-.73 1.06-1.2 1.87-1.2h5.2c1.48 0 2.46 1.5 1.85 2.83l-1.67 3.67Z"
    };
    var language = {
      name: "language",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M2 12C2 6.48 6.47 2 11.99 2 17.52 2 22 6.48 22 12s-4.48 10-10.01 10C6.47 22 2 17.52 2 12Zm13.97-4h2.95a8.03 8.03 0 0 0-4.33-3.56c.6 1.11 1.06 2.31 1.38 3.56ZM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96ZM4 12c0 .69.1 1.36.26 2h3.38c-.08-.66-.14-1.32-.14-2 0-.68.06-1.34.14-2H4.26c-.16.64-.26 1.31-.26 2Zm1.08 4h2.95c.32 1.25.78 2.45 1.38 3.56A7.987 7.987 0 0 1 5.08 16Zm0-8h2.95c.32-1.25.78-2.45 1.38-3.56-1.84.63-3.37 1.9-4.33 3.56ZM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96ZM9.5 12c0 .68.07 1.34.16 2h4.68c.09-.66.16-1.32.16-2 0-.68-.07-1.35-.16-2H9.66c-.09.65-.16 1.32-.16 2Zm5.09 7.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 0 1-4.33 3.56ZM16.5 12c0 .68-.06 1.34-.14 2h3.38c.16-.64.26-1.31.26-2s-.1-1.36-.26-2h-3.38c.08.66.14 1.32.14 2Z"
    };
    var google_translate = {
      name: "google_translate",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M20 5h-9.12L10 2H4c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h7l1 3h8c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2ZM7.17 14.59c-2.25 0-4.09-1.83-4.09-4.09s1.83-4.09 4.09-4.09c1.04 0 1.99.37 2.74 1.07l.07.06-1.23 1.18-.06-.05c-.29-.27-.78-.59-1.52-.59-1.31 0-2.38 1.09-2.38 2.42 0 1.33 1.07 2.42 2.38 2.42 1.37 0 1.96-.87 2.12-1.46H7.08V9.91h3.95l.01.07c.04.21.05.4.05.61 0 2.35-1.61 4-3.92 4Zm7.22-.01c-.45-.52-.86-1.1-1.19-1.7l.65 2.23.54-.53Zm-.42-2.46h-.99l-.31-1.04h3.99s-.34 1.31-1.56 2.74c-.52-.62-.89-1.23-1.13-1.7ZM20 21c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1h-8.82l1.18 4.04h1.96V9h1.04v1.04H19v1.04h-1.27c-.32 1.26-1.02 2.48-1.92 3.51l2.71 2.68-.73.73-2.68-2.69-.92.92L15 19l-2 2h7Z"
    };
    var hearing = {
      name: "hearing",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M7.64 3.03 6.22 1.61A10.965 10.965 0 0 0 3 9.39c0 3.04 1.23 5.79 3.22 7.78l1.41-1.41A9.011 9.011 0 0 1 5 9.39C5 6.9 6.01 4.65 7.64 3.03ZM17 20.39c-.29 0-.56-.06-.76-.15-.71-.37-1.21-.88-1.71-2.38-.505-1.546-1.452-2.277-2.365-2.98l-.025-.02-.01-.008c-.787-.607-1.603-1.238-2.31-2.522-.53-.96-.82-2.01-.82-2.94 0-2.8 2.2-5 5-5s5 2.2 5 5h2c0-3.93-3.07-7-7-7s-7 3.07-7 7c0 1.26.38 2.65 1.07 3.9.91 1.65 1.98 2.48 2.85 3.15.81.62 1.39 1.07 1.71 2.05.6 1.82 1.37 2.84 2.73 3.55A3.999 3.999 0 0 0 21 18.39h-2c0 1.1-.9 2-2 2Zm-3-8.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5Z"
    };
    var translate$3 = {
      name: "translate",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04ZM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12Zm-1 2.67L15.88 17h3.24l-1.62-4.33Z"
    };
    var accessible = {
      name: "accessible",
      prefix: "eds",
      height: "24",
      width: "24",
      svgPathData: "M14 4c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2Zm-2 3c2.83 0 5.89-.3 8.5-1l.5 2c-1.86.5-4 .83-6 1v13h-2v-6h-2v6H9V9c-2-.17-4.14-.5-6-1l.5-2c2.61.7 5.67 1 8.5 1Z",
      sizes: {
        small: {
          name: "accessible_small",
          prefix: "eds",
          height: "18",
          width: "18",
          svgPathData: "M10.5 3c0 .825-.675 1.5-1.5 1.5S7.5 3.825 7.5 3 8.175 1.5 9 1.5s1.5.675 1.5 1.5ZM9 5.25c2.123 0 4.418-.225 6.375-.75L15.75 6c-1.395.375-3 .622-4.5.75v9.75h-1.5V12h-1.5v4.5h-1.5V6.75c-1.5-.128-3.105-.375-4.5-.75l.375-1.5c1.957.525 4.253.75 6.375.75Z"
        }
      }
    };
    const icons = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      accessible,
      accessible_forward,
      account_circle,
      add: add$5,
      add_box,
      add_circle_filled,
      add_circle_outlined,
      aerial_drone,
      alarm,
      alarm_add,
      alarm_off,
      alarm_on,
      all_out,
      anchor,
      android,
      apple_airplay,
      apple_app_store,
      apple_logo,
      approve,
      apps,
      archive,
      arrow_back,
      arrow_back_ios,
      arrow_down,
      arrow_drop_down,
      arrow_drop_left,
      arrow_drop_right,
      arrow_drop_up,
      arrow_forward,
      arrow_forward_ios,
      arrow_up,
      assignment,
      assignment_important,
      assignment_return,
      assignment_returned,
      assignment_turned_in,
      assignment_user,
      attach_file,
      attachment,
      autorenew,
      baby,
      badge,
      bandage,
      bar_chart,
      battery,
      battery_alert,
      battery_charging,
      battery_unknown,
      beach,
      bearing,
      beat,
      bike,
      block,
      blocked,
      blocked_off,
      bluetooth,
      bluetooth_connected,
      bluetooth_disabled,
      bluetooth_searching,
      boat,
      bookmark_collection,
      bookmark_filled,
      bookmark_outlined,
      bookmarks,
      border_all,
      border_bottom,
      border_clear,
      border_color,
      border_horizontal,
      border_inner,
      border_left,
      border_outer,
      border_right,
      border_style,
      border_top,
      border_vertical,
      boundaries,
      briefcase,
      brush,
      bubble_chart,
      build_wrench,
      bus,
      business,
      cable,
      cafe,
      cake,
      calendar: calendar$1,
      calendar_accept,
      calendar_date_range,
      calendar_event,
      calendar_reject,
      calendar_today,
      call,
      call_add,
      call_end,
      camera,
      camera_add_photo,
      car,
      car_wash,
      category,
      change_history,
      check,
      check_circle_outlined,
      checkbox: checkbox$1,
      checkbox_indeterminate,
      checkbox_outline,
      chevron_down,
      chevron_left,
      chevron_right,
      chevron_up,
      chrome,
      cinema,
      circuit,
      city,
      clear: clear$1,
      close,
      close_circle_outlined,
      closed_caption_filled,
      closed_caption_outlined,
      cloud: cloud$1,
      cloud_done,
      cloud_download,
      cloud_off,
      cloud_upload,
      cocktail,
      code,
      coffee,
      collapse,
      collapse_screen,
      collection_1,
      collection_2,
      collection_3,
      collection_4,
      collection_5,
      collection_6,
      collection_7,
      collection_8,
      collection_9,
      collection_9_plus,
      color_palette,
      comment,
      comment_add,
      comment_chat,
      comment_chat_off,
      comment_discussion,
      comment_important,
      comment_more,
      comment_notes,
      comment_solid,
      commute,
      compare: compare$a,
      compass_calibration,
      computer,
      contact_email,
      contact_phone,
      contacts,
      convenience_store,
      copy: copy$3,
      craning,
      credit_card,
      crop,
      crop_rotate,
      cut,
      dashboard,
      delete_forever,
      delete_multiple,
      delete_to_trash,
      departure_board,
      desktop_mac,
      desktop_windows,
      details,
      device_unknown,
      dialpad,
      dice,
      dining,
      directions,
      dns,
      do_not_disturb,
      dock,
      dollar,
      done,
      done_all,
      donut_large,
      donut_outlined,
      download,
      download_done,
      drag_handle,
      drink,
      dropper,
      ducting,
      edit,
      edit_text,
      eject,
      electrical,
      email,
      email_alpha,
      email_draft,
      engineering,
      enlarge,
      error_filled,
      error_outlined,
      ev_station,
      exit_to_app,
      expand,
      expand_screen,
      explore,
      explore_off,
      external_link,
      face,
      facebook,
      facebook_messenger,
      fast_food,
      fast_forward,
      fast_rewind,
      fault,
      favorite_filled,
      favorite_outlined,
      file,
      file_add,
      file_copy,
      file_description,
      filter_alt,
      filter_alt_active,
      filter_alt_off,
      filter_list,
      fingerprint_scanner,
      first_page,
      flag: flag$1,
      flagged,
      flagged_off,
      flame,
      flare,
      flash_off,
      flash_on,
      flight,
      flight_land,
      flight_takeoff,
      flip: flip$3,
      flip_to_back,
      flip_to_front,
      flower,
      focus_center,
      folder,
      folder_add,
      folder_favorite,
      folder_open,
      folder_shared,
      format_align_center,
      format_align_justify,
      format_align_left,
      format_align_right,
      format_bold,
      format_clear,
      format_color_fill,
      format_color_reset,
      format_color_text,
      format_highlight,
      format_indent_decrease,
      format_indent_increase,
      format_italics,
      format_line_spacing,
      format_list_bulleted,
      format_list_numbered,
      format_quote,
      format_shape,
      format_size,
      format_strikethrough,
      format_underline,
      formula,
      forward_10,
      forward_30,
      forward_5,
      fridge,
      fullscreen,
      fullscreen_exit,
      functions,
      gamepad,
      gas,
      gas_station,
      gavel,
      gear,
      gesture,
      github,
      go_to,
      google_cast,
      google_cast_connected,
      google_maps,
      google_play,
      google_translate,
      gps_fixed,
      gps_not_fixed,
      gps_off,
      grid_layer,
      grid_layers,
      grid_off,
      grid_on,
      grocery_store,
      group: group$1,
      group_add,
      gym,
      hand_radio,
      headset,
      headset_mic,
      hearing,
      heat_trace,
      help,
      help_outline,
      high_priority,
      hill_shading,
      history,
      home,
      hospital,
      hotel,
      hourglass_empty,
      hourglass_full,
      image: image$2,
      image_add,
      in_progress,
      inbox,
      infinity,
      info_circle,
      insert_link,
      inspect_3d,
      inspect_rotation,
      instagram,
      instrument,
      invert: invert$1,
      invert_colors,
      ios_logo,
      iphone,
      junction_box,
      key: key$1,
      keyboard,
      keyboard_backspace,
      keyboard_capslock,
      keyboard_hide,
      keyboard_return,
      keyboard_space_bar,
      keyboard_tab,
      keyboard_voice,
      label: label$1,
      label_off,
      language,
      last_page,
      launch,
      laundry,
      layers,
      layers_off,
      library,
      library_add,
      library_books,
      library_image,
      library_music,
      library_pdf,
      library_video,
      light,
      lightbulb,
      line: line$3,
      link: link$1,
      link_off,
      linkedin,
      list,
      lock,
      lock_add,
      lock_off,
      lock_open,
      log_in,
      log_out,
      loop,
      mail_unread,
      mall,
      manual_valve,
      map: map$2,
      maximize,
      measure: measure$1,
      meeting_room,
      meeting_room_off,
      memory,
      menu,
      mic,
      mic_off,
      mic_outlined,
      microsoft_edge,
      microsoft_excel,
      microsoft_onedrive,
      microsoft_outlook,
      microsoft_powerpoint,
      microsoft_word,
      minimize,
      miniplayer,
      miniplayer_fullscreen,
      missed_video_call,
      money,
      mood_extremely_happy,
      mood_extremely_sad,
      mood_happy,
      mood_neutral,
      mood_sad,
      mood_very_happy,
      mood_very_sad,
      more_horizontal,
      more_vertical,
      motorcycle,
      mouse,
      move_to_inbox,
      movie,
      movie_file,
      multiline_chart,
      music_note,
      music_note_off,
      nature,
      nature_people,
      navigation,
      near_me,
      new_alert,
      new_label,
      no_craning,
      notifications,
      notifications_active,
      notifications_add,
      notifications_important,
      notifications_off,
      notifications_paused,
      offline,
      offline_document,
      offline_saved,
      oil,
      oil_barrel,
      onshore_drone,
      opacity: opacity$1,
      open_in_browser,
      open_side_sheet,
      pan_tool,
      parking,
      paste,
      pause,
      pause_circle,
      pause_circle_outlined,
      person,
      person_add,
      pharmacy,
      phone,
      pie_chart,
      pin,
      pin_drop,
      pipe_support,
      pizza,
      place: place$1,
      place_add,
      place_edit,
      place_person,
      place_unknown,
      placeholder_icon,
      platform: platform$1,
      play,
      play_circle,
      play_circle_outlined,
      playlist_add,
      playlist_added,
      playlist_play,
      pool,
      power,
      power_bi,
      power_button,
      power_button_off,
      pram,
      pregnant_woman,
      pressure,
      print,
      print_off,
      priority_high,
      priority_low,
      puzzle,
      puzzle_filled,
      radio_button_selected,
      radio_button_unselected,
      railway,
      receipt,
      record,
      record_voice,
      record_voice_off,
      redo,
      reduce: reduce$1,
      refresh,
      remove: remove$2,
      remove_outlined,
      reorder,
      repeat: repeat$1,
      repeat_one,
      replay,
      replay_10,
      replay_30,
      replay_5,
      reply,
      reply_all,
      report,
      report_bug,
      report_off,
      res_4k_filled,
      res_4k_outlined,
      res_hd_filled,
      res_hd_outlined,
      restaurant,
      restore,
      restore_from_trash,
      restore_page,
      rotate_3d,
      rotate_90_degrees_ccw,
      rotate_left,
      rotate_right,
      router,
      run: run$1,
      satellite,
      save,
      scanner,
      scatter_plot,
      school,
      search,
      search_find_replace,
      search_in_page,
      searched_history,
      security,
      select_all,
      send,
      setting_backup_restore,
      settings,
      share,
      share_screen,
      share_screen_off,
      sheet_bottom_position,
      sheet_leftposition,
      sheet_rightposition,
      sheet_topposition,
      shipping,
      shopping_basket,
      shopping_card,
      shopping_cart_add,
      shopping_cart_off,
      shuffle: shuffle$1,
      signature,
      sim_card,
      skip_next,
      skip_previous,
      skype,
      slack,
      slideshow,
      smartwatch,
      smoking,
      smoking_off,
      snooze,
      snow,
      sort: sort$1,
      sort_by_alpha,
      speaker,
      speaker_group,
      spellcheck,
      spotify,
      star_circle,
      star_filled,
      star_half,
      star_outlined,
      stop: stop$1,
      stop_circle,
      stop_circle_outlined,
      store,
      style: style$2,
      subdirectory_arrow_left,
      subdirectory_arrow_right,
      subsea_drone,
      substation_offshore,
      substation_onshore,
      subway,
      subway_tunnel,
      sun,
      support,
      surface_layer,
      swap_horizontal,
      swap_horizontal_circle,
      swap_vertical,
      swap_vertical_circle,
      switch_off,
      switch_on,
      sync,
      sync_off,
      sync_problem,
      table_chart,
      tablet_android,
      tablet_ipad,
      tag,
      tag_main_equipment,
      tag_more,
      tag_relations,
      tag_special_equipment,
      taxi,
      telecom,
      terrain,
      text_field,
      text_rotation_angled_down,
      text_rotation_angled_up,
      text_rotation_down,
      text_rotation_none,
      text_rotation_up,
      text_rotation_vertical,
      texture,
      thermostat,
      thumb_pin,
      thumbs_down,
      thumbs_up,
      thumbs_up_down,
      ticket,
      time: time$2,
      timeline,
      timer: timer$2,
      timer_off,
      title: title$1,
      toc,
      toilet,
      toll,
      toolbox,
      toolbox_rope,
      toolbox_wheel,
      touch: touch$1,
      track_changes,
      traffic_light,
      train,
      tram,
      transfer,
      transit,
      transit_enter_exit,
      translate: translate$3,
      trending_down,
      trending_flat,
      trending_up,
      trip_origin,
      tune,
      turbine,
      tv,
      twitter,
      unarchive,
      undo,
      unfold_less,
      unfold_more,
      unsubscribe,
      update: update$7,
      upload,
      usb,
      users_circle,
      van,
      verified,
      verified_user,
      vertical_align_bottom,
      vertical_align_center,
      vertical_align_top,
      vertical_split,
      video_call,
      video_chat,
      videocam,
      videocam_off,
      view_360,
      view_agenda,
      view_array,
      view_carousel,
      view_column,
      view_day,
      view_list,
      view_module,
      view_quilt,
      view_stream,
      view_week,
      visibility,
      visibility_off,
      volume_down,
      volume_mute,
      volume_off,
      volume_up,
      walk,
      warning_filled,
      warning_outlined,
      waves,
      well,
      wellbore,
      whats_app,
      wheelchair,
      widgets,
      wifi,
      wifi_off,
      wind_turbine,
      work,
      work_off,
      work_outline,
      world,
      wrap_text,
      youtube,
      youtube_alt,
      zip_file,
      zoom_in,
      zoom_out
    }, Symbol.toStringTag, { value: "Module" }));
    function get_each_context$9(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list2[i];
      return child_ctx;
    }
    function create_else_block$4(ctx) {
      let path_1;
      return {
        c() {
          path_1 = svg_element("path");
          attr$6(
            path_1,
            "d",
            /*path*/
            ctx[4]
          );
          attr$6(
            path_1,
            "fill",
            /*color*/
            ctx[0]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, path_1, anchor2);
        },
        p(ctx2, dirty) {
          if (dirty & /*color*/
          1) {
            attr$6(
              path_1,
              "fill",
              /*color*/
              ctx2[0]
            );
          }
        },
        d(detaching) {
          if (detaching) {
            detach(path_1);
          }
        }
      };
    }
    function create_if_block$a(ctx) {
      let each_1_anchor;
      let each_value = ensure_array_like(
        /*path*/
        ctx[4]
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
      }
      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty$1();
        },
        m(target2, anchor2) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(target2, anchor2);
            }
          }
          insert$2(target2, each_1_anchor, anchor2);
        },
        p(ctx2, dirty) {
          if (dirty & /*path, color*/
          17) {
            each_value = ensure_array_like(
              /*path*/
              ctx2[4]
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$9(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$9(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function create_each_block$9(ctx) {
      let path_1;
      return {
        c() {
          path_1 = svg_element("path");
          attr$6(
            path_1,
            "d",
            /*p*/
            ctx[6]
          );
          attr$6(
            path_1,
            "fill",
            /*color*/
            ctx[0]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, path_1, anchor2);
        },
        p(ctx2, dirty) {
          if (dirty & /*color*/
          1) {
            attr$6(
              path_1,
              "fill",
              /*color*/
              ctx2[0]
            );
          }
        },
        d(detaching) {
          if (detaching) {
            detach(path_1);
          }
        }
      };
    }
    function create_fragment$l(ctx) {
      let svg;
      let svg_class_value;
      function select_block_type(ctx2, dirty) {
        if (Array.isArray(
          /*path*/
          ctx2[4]
        ))
          return create_if_block$a;
        return create_else_block$4;
      }
      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      return {
        c() {
          svg = svg_element("svg");
          if_block.c();
          attr$6(svg, "class", svg_class_value = null_to_empty(
            /*spin*/
            ctx[3] ? "spin-svg" : ""
          ) + " svelte-to7caz");
          attr$6(
            svg,
            "width",
            /*width*/
            ctx[1]
          );
          attr$6(
            svg,
            "height",
            /*height*/
            ctx[2]
          );
          attr$6(svg, "viewBox", "0 0 24 24");
          attr$6(svg, "fill", "none");
          attr$6(svg, "xmlns", "http://www.w3.org/2000/svg");
        },
        m(target2, anchor2) {
          insert$2(target2, svg, anchor2);
          if_block.m(svg, null);
        },
        p(ctx2, [dirty]) {
          if_block.p(ctx2, dirty);
          if (dirty & /*spin*/
          8 && svg_class_value !== (svg_class_value = null_to_empty(
            /*spin*/
            ctx2[3] ? "spin-svg" : ""
          ) + " svelte-to7caz")) {
            attr$6(svg, "class", svg_class_value);
          }
          if (dirty & /*width*/
          2) {
            attr$6(
              svg,
              "width",
              /*width*/
              ctx2[1]
            );
          }
          if (dirty & /*height*/
          4) {
            attr$6(
              svg,
              "height",
              /*height*/
              ctx2[2]
            );
          }
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(svg);
          }
          if_block.d();
        }
      };
    }
    function instance$k($$self, $$props, $$invalidate) {
      let { name: name2 = "add" } = $$props;
      let { color: color2 = "currentColor" } = $$props;
      let { width: width2 = icons[name2].width } = $$props;
      let { height: height2 = icons[name2].height } = $$props;
      let { spin = false } = $$props;
      const path2 = icons[name2].svgPathData;
      $$self.$$set = ($$props2) => {
        if ("name" in $$props2)
          $$invalidate(5, name2 = $$props2.name);
        if ("color" in $$props2)
          $$invalidate(0, color2 = $$props2.color);
        if ("width" in $$props2)
          $$invalidate(1, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(2, height2 = $$props2.height);
        if ("spin" in $$props2)
          $$invalidate(3, spin = $$props2.spin);
      };
      return [color2, width2, height2, spin, path2, name2];
    }
    class Icon extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$k, create_fragment$l, safe_not_equal, {
          name: 5,
          color: 0,
          width: 1,
          height: 2,
          spin: 3
        });
      }
    }
    const get_controls_slot_changes = (dirty) => ({});
    const get_controls_slot_context = (ctx) => ({});
    const get_open_button_slot_changes = (dirty) => ({});
    const get_open_button_slot_context = (ctx) => ({});
    function create_default_slot_1(ctx) {
      let t4;
      let icon;
      let current2;
      icon = new Icon({ props: { name: "arrow_forward" } });
      return {
        c() {
          t4 = text$3("Controls ");
          create_component(icon.$$.fragment);
        },
        m(target2, anchor2) {
          insert$2(target2, t4, anchor2);
          mount_component(icon, target2, anchor2);
          current2 = true;
        },
        p: noop$6,
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
          destroy_component(icon, detaching);
        }
      };
    }
    function fallback_block_1(ctx) {
      let button;
      let current2;
      button = new Button({
        props: {
          variant: "solid",
          color: "secondary",
          disabled: !/*doneWaiting*/
          ctx[1],
          $$slots: { default: [create_default_slot_1] },
          $$scope: { ctx }
        }
      });
      button.$on(
        "click",
        /*toggleOpen*/
        ctx[2]
      );
      return {
        c() {
          create_component(button.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(button, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const button_changes = {};
          if (dirty & /*doneWaiting*/
          2)
            button_changes.disabled = !/*doneWaiting*/
            ctx2[1];
          if (dirty & /*$$scope*/
          64) {
            button_changes.$$scope = { dirty, ctx: ctx2 };
          }
          button.$set(button_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(button.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(button.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(button, detaching);
        }
      };
    }
    function create_default_slot(ctx) {
      let icon;
      let t02;
      let span2;
      let current2;
      icon = new Icon({ props: { name: "arrow_back" } });
      return {
        c() {
          create_component(icon.$$.fragment);
          t02 = space();
          span2 = element$2("span");
          span2.textContent = "Close";
          attr$6(span2, "class", "select-none");
        },
        m(target2, anchor2) {
          mount_component(icon, target2, anchor2);
          insert$2(target2, t02, anchor2);
          insert$2(target2, span2, anchor2);
          current2 = true;
        },
        p: noop$6,
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t02);
            detach(span2);
          }
          destroy_component(icon, detaching);
        }
      };
    }
    function fallback_block$1(ctx) {
      let t4;
      return {
        c() {
          t4 = text$3('Add controls to the \\"controls\\" slot');
        },
        m(target2, anchor2) {
          insert$2(target2, t4, anchor2);
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
        }
      };
    }
    function create_fragment$k(ctx) {
      let span2;
      let t02;
      let div4;
      let div0;
      let t12;
      let nav;
      let div1;
      let button;
      let t22;
      let div3;
      let div2;
      let current2;
      let mounted;
      let dispose;
      const open_button_slot_template = (
        /*#slots*/
        ctx[5]["open-button"]
      );
      const open_button_slot = create_slot(
        open_button_slot_template,
        ctx,
        /*$$scope*/
        ctx[6],
        get_open_button_slot_context
      );
      const open_button_slot_or_fallback = open_button_slot || fallback_block_1(ctx);
      button = new Button({
        props: {
          variant: "outlined",
          color: "secondary",
          $$slots: { default: [create_default_slot] },
          $$scope: { ctx }
        }
      });
      button.$on(
        "click",
        /*toggleOpen*/
        ctx[2]
      );
      const controls_slot_template = (
        /*#slots*/
        ctx[5].controls
      );
      const controls_slot = create_slot(
        controls_slot_template,
        ctx,
        /*$$scope*/
        ctx[6],
        get_controls_slot_context
      );
      const controls_slot_or_fallback = controls_slot || fallback_block$1();
      return {
        c() {
          span2 = element$2("span");
          if (open_button_slot_or_fallback)
            open_button_slot_or_fallback.c();
          t02 = space();
          div4 = element$2("div");
          div0 = element$2("div");
          t12 = space();
          nav = element$2("nav");
          div1 = element$2("div");
          create_component(button.$$.fragment);
          t22 = space();
          div3 = element$2("div");
          div2 = element$2("div");
          if (controls_slot_or_fallback)
            controls_slot_or_fallback.c();
          attr$6(div0, "class", "fixed top-0 left-0 h-dvh w-dvw sidebar-backdrop svelte-1ot833g");
          toggle_class(
            div0,
            "sidebar-backdrop--visible",
            /*open*/
            ctx[0]
          );
          attr$6(div1, "class", "w-full flex justify-end p-2 border-b border-gray-200");
          attr$6(div2, "class", "flex flex-col gap-4 px-3 min-w-96");
          attr$6(div3, "class", "flex flex-1 overflow-y-scroll");
          attr$6(nav, "class", "fixed flex flex-col top-0 left-0 h-dvh sidebar svelte-1ot833g");
          toggle_class(
            nav,
            "sidebar--open",
            /*open*/
            ctx[0]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, span2, anchor2);
          if (open_button_slot_or_fallback) {
            open_button_slot_or_fallback.m(span2, null);
          }
          append$2(span2, t02);
          append$2(span2, div4);
          append$2(div4, div0);
          append$2(div4, t12);
          append$2(div4, nav);
          append$2(nav, div1);
          mount_component(button, div1, null);
          append$2(nav, t22);
          append$2(nav, div3);
          append$2(div3, div2);
          if (controls_slot_or_fallback) {
            controls_slot_or_fallback.m(div2, null);
          }
          current2 = true;
          if (!mounted) {
            dispose = [
              listen(
                div0,
                "click",
                /*toggleOpen*/
                ctx[2]
              ),
              action_destroyer(portal.call(null, div4, "#global-portal"))
            ];
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          if (open_button_slot) {
            if (open_button_slot.p && (!current2 || dirty & /*$$scope*/
            64)) {
              update_slot_base(
                open_button_slot,
                open_button_slot_template,
                ctx2,
                /*$$scope*/
                ctx2[6],
                !current2 ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx2[6]
                ) : get_slot_changes(
                  open_button_slot_template,
                  /*$$scope*/
                  ctx2[6],
                  dirty,
                  get_open_button_slot_changes
                ),
                get_open_button_slot_context
              );
            }
          } else {
            if (open_button_slot_or_fallback && open_button_slot_or_fallback.p && (!current2 || dirty & /*doneWaiting*/
            2)) {
              open_button_slot_or_fallback.p(ctx2, !current2 ? -1 : dirty);
            }
          }
          if (!current2 || dirty & /*open*/
          1) {
            toggle_class(
              div0,
              "sidebar-backdrop--visible",
              /*open*/
              ctx2[0]
            );
          }
          const button_changes = {};
          if (dirty & /*$$scope*/
          64) {
            button_changes.$$scope = { dirty, ctx: ctx2 };
          }
          button.$set(button_changes);
          if (controls_slot) {
            if (controls_slot.p && (!current2 || dirty & /*$$scope*/
            64)) {
              update_slot_base(
                controls_slot,
                controls_slot_template,
                ctx2,
                /*$$scope*/
                ctx2[6],
                !current2 ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx2[6]
                ) : get_slot_changes(
                  controls_slot_template,
                  /*$$scope*/
                  ctx2[6],
                  dirty,
                  get_controls_slot_changes
                ),
                get_controls_slot_context
              );
            }
          }
          if (!current2 || dirty & /*open*/
          1) {
            toggle_class(
              nav,
              "sidebar--open",
              /*open*/
              ctx2[0]
            );
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(open_button_slot_or_fallback, local);
          transition_in(button.$$.fragment, local);
          transition_in(controls_slot_or_fallback, local);
          current2 = true;
        },
        o(local) {
          transition_out(open_button_slot_or_fallback, local);
          transition_out(button.$$.fragment, local);
          transition_out(controls_slot_or_fallback, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(span2);
          }
          if (open_button_slot_or_fallback)
            open_button_slot_or_fallback.d(detaching);
          destroy_component(button);
          if (controls_slot_or_fallback)
            controls_slot_or_fallback.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$j($$self, $$props, $$invalidate) {
      let { $$slots: slots = {}, $$scope } = $$props;
      let { waitFor = void 0 } = $$props;
      let doneWaiting = false;
      (async () => {
        if (waitFor)
          await waitFor;
        $$invalidate(1, doneWaiting = true);
      })();
      let { experiment } = $$props;
      let { open = false } = $$props;
      const backdropCloseListener = (e3) => {
        if (e3.code === "Escape") {
          $$invalidate(0, open = false);
          window.removeEventListener("keypress", backdropCloseListener);
        }
      };
      const toggleOpen = () => {
        if (!open)
          window.addEventListener("keypress", backdropCloseListener);
        else
          window.removeEventListener("keypress", backdropCloseListener);
        $$invalidate(0, open = !open);
      };
      $$self.$$set = ($$props2) => {
        if ("waitFor" in $$props2)
          $$invalidate(3, waitFor = $$props2.waitFor);
        if ("experiment" in $$props2)
          $$invalidate(4, experiment = $$props2.experiment);
        if ("open" in $$props2)
          $$invalidate(0, open = $$props2.open);
        if ("$$scope" in $$props2)
          $$invalidate(6, $$scope = $$props2.$$scope);
      };
      return [open, doneWaiting, toggleOpen, waitFor, experiment, slots, $$scope];
    }
    class Sidebar extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$j, create_fragment$k, safe_not_equal, { waitFor: 3, experiment: 4, open: 0 });
      }
    }
    var has$2 = Object.prototype.hasOwnProperty;
    function find$4(iter, tar, key2) {
      for (key2 of iter.keys()) {
        if (dequal(key2, tar))
          return key2;
      }
    }
    function dequal(foo, bar2) {
      var ctor, len, tmp;
      if (foo === bar2)
        return true;
      if (foo && bar2 && (ctor = foo.constructor) === bar2.constructor) {
        if (ctor === Date)
          return foo.getTime() === bar2.getTime();
        if (ctor === RegExp)
          return foo.toString() === bar2.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar2.length) {
            while (len-- && dequal(foo[len], bar2[len]))
              ;
          }
          return len === -1;
        }
        if (ctor === Set) {
          if (foo.size !== bar2.size) {
            return false;
          }
          for (len of foo) {
            tmp = len;
            if (tmp && typeof tmp === "object") {
              tmp = find$4(bar2, tmp);
              if (!tmp)
                return false;
            }
            if (!bar2.has(tmp))
              return false;
          }
          return true;
        }
        if (ctor === Map) {
          if (foo.size !== bar2.size) {
            return false;
          }
          for (len of foo) {
            tmp = len[0];
            if (tmp && typeof tmp === "object") {
              tmp = find$4(bar2, tmp);
              if (!tmp)
                return false;
            }
            if (!dequal(len[1], bar2.get(tmp))) {
              return false;
            }
          }
          return true;
        }
        if (ctor === ArrayBuffer) {
          foo = new Uint8Array(foo);
          bar2 = new Uint8Array(bar2);
        } else if (ctor === DataView) {
          if ((len = foo.byteLength) === bar2.byteLength) {
            while (len-- && foo.getInt8(len) === bar2.getInt8(len))
              ;
          }
          return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
          if ((len = foo.byteLength) === bar2.byteLength) {
            while (len-- && foo[len] === bar2[len])
              ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has$2.call(foo, ctor) && ++len && !has$2.call(bar2, ctor))
              return false;
            if (!(ctor in bar2) || !dequal(foo[ctor], bar2[ctor]))
              return false;
          }
          return Object.keys(bar2).length === len;
        }
      }
      return foo !== foo && bar2 !== bar2;
    }
    function back(array2, index2, increment2, loop2 = true) {
      const previousIndex = index2 - increment2;
      if (previousIndex <= 0) {
        return loop2 ? array2[array2.length - 1] : array2[0];
      }
      return array2[previousIndex];
    }
    function forward(array2, index2, increment2, loop2 = true) {
      const nextIndex = index2 + increment2;
      if (nextIndex > array2.length - 1) {
        return loop2 ? array2[0] : array2[array2.length - 1];
      }
      return array2[nextIndex];
    }
    function next(array2, index2, loop2 = true) {
      if (index2 === array2.length - 1) {
        return loop2 ? array2[0] : array2[index2];
      }
      return array2[index2 + 1];
    }
    function prev(array2, currentIndex, loop2 = true) {
      if (currentIndex <= 0) {
        return loop2 ? array2[array2.length - 1] : array2[0];
      }
      return array2[currentIndex - 1];
    }
    function last(array2) {
      return array2[array2.length - 1];
    }
    function wrapArray(array2, startIndex) {
      return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
    }
    function toggle$1(item, array2, compare2 = dequal) {
      const itemIdx = array2.findIndex((innerItem) => compare2(innerItem, item));
      if (itemIdx !== -1) {
        array2.splice(itemIdx, 1);
      } else {
        array2.push(item);
      }
      return array2;
    }
    function styleToString(style2) {
      return Object.keys(style2).reduce((str, key2) => {
        if (style2[key2] === void 0)
          return str;
        return str + `${key2}:${style2[key2]};`;
      }, "");
    }
    function disabledAttr(disabled) {
      return disabled ? true : void 0;
    }
    const hiddenInputAttrs = {
      type: "hidden",
      "aria-hidden": true,
      hidden: true,
      tabIndex: -1,
      style: styleToString({
        position: "absolute",
        opacity: 0,
        "pointer-events": "none",
        margin: 0,
        transform: "translateX(-100%)"
      })
    };
    function lightable(value2) {
      function subscribe2(run2) {
        run2(value2);
        return () => {
        };
      }
      return { subscribe: subscribe2 };
    }
    function getElementByMeltId(id2) {
      if (!isBrowser)
        return null;
      const el = document.querySelector(`[data-melt-id="${id2}"]`);
      return isHTMLElement$1(el) ? el : null;
    }
    const hiddenAction = (obj) => {
      return new Proxy(obj, {
        get(target2, prop, receiver) {
          return Reflect.get(target2, prop, receiver);
        },
        ownKeys(target2) {
          return Reflect.ownKeys(target2).filter((key2) => key2 !== "action");
        }
      });
    };
    const isFunctionWithParams = (fn) => {
      return typeof fn === "function";
    };
    function builder(name2, args) {
      const { stores, action, returned } = args ?? {};
      const derivedStore = (() => {
        if (stores && returned) {
          return derived(stores, (values2) => {
            const result = returned(values2);
            if (isFunctionWithParams(result)) {
              const fn = (...args2) => {
                return hiddenAction({
                  ...result(...args2),
                  [`data-melt-${name2}`]: "",
                  action: action ?? noop$5
                });
              };
              fn.action = action ?? noop$5;
              return fn;
            }
            return hiddenAction({
              ...result,
              [`data-melt-${name2}`]: "",
              action: action ?? noop$5
            });
          });
        } else {
          const returnedFn = returned;
          const result = returnedFn == null ? void 0 : returnedFn();
          if (isFunctionWithParams(result)) {
            const resultFn = (...args2) => {
              return hiddenAction({
                ...result(...args2),
                [`data-melt-${name2}`]: "",
                action: action ?? noop$5
              });
            };
            resultFn.action = action ?? noop$5;
            return lightable(resultFn);
          }
          return lightable(hiddenAction({
            ...result,
            [`data-melt-${name2}`]: "",
            action: action ?? noop$5
          }));
        }
      })();
      const actionFn = action ?? (() => {
      });
      actionFn.subscribe = derivedStore.subscribe;
      return actionFn;
    }
    function builderArray(name2, args) {
      const { stores, returned, action } = args;
      const { subscribe: subscribe2 } = derived(stores, (values2) => returned(values2).map((value2) => hiddenAction({
        ...value2,
        [`data-melt-${name2}`]: "",
        action: action ?? noop$5
      })));
      const actionFn = action ?? (() => {
      });
      actionFn.subscribe = subscribe2;
      return actionFn;
    }
    function createElHelpers(prefix) {
      const name2 = (part) => part ? `${prefix}-${part}` : prefix;
      const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ""}`;
      const selector2 = (part) => `[data-melt-${prefix}${part ? `-${part}` : ""}]`;
      const getEl = (part) => document.querySelector(selector2(part));
      return {
        name: name2,
        attribute,
        selector: selector2,
        getEl
      };
    }
    const isBrowser = typeof document !== "undefined";
    const isFunction$1 = (v) => typeof v === "function";
    function isElement$1(element2) {
      return element2 instanceof Element;
    }
    function isHTMLElement$1(element2) {
      return element2 instanceof HTMLElement;
    }
    function isHTMLInputElement(element2) {
      return element2 instanceof HTMLInputElement;
    }
    function isHTMLLabelElement(element2) {
      return element2 instanceof HTMLLabelElement;
    }
    function isHTMLButtonElement(element2) {
      return element2 instanceof HTMLButtonElement;
    }
    function isElementDisabled(element2) {
      const ariaDisabled = element2.getAttribute("aria-disabled");
      const disabled = element2.getAttribute("disabled");
      const dataDisabled = element2.hasAttribute("data-disabled");
      if (ariaDisabled === "true" || disabled !== null || dataDisabled) {
        return true;
      }
      return false;
    }
    function isContentEditable$1(element2) {
      if (!isHTMLElement$1(element2))
        return false;
      return element2.isContentEditable;
    }
    function isObject$1(value2) {
      return value2 !== null && typeof value2 === "object";
    }
    function isReadable(value2) {
      return isObject$1(value2) && "subscribe" in value2;
    }
    function executeCallbacks(...callbacks) {
      return (...args) => {
        for (const callback of callbacks) {
          if (typeof callback === "function") {
            callback(...args);
          }
        }
      };
    }
    function noop$5() {
    }
    function addEventListener$1(target2, event2, handler, options) {
      const events2 = Array.isArray(event2) ? event2 : [event2];
      events2.forEach((_event) => target2.addEventListener(_event, handler, options));
      return () => {
        events2.forEach((_event) => target2.removeEventListener(_event, handler, options));
      };
    }
    function addMeltEventListener(target2, event2, handler, options) {
      const events2 = Array.isArray(event2) ? event2 : [event2];
      if (typeof handler === "function") {
        const handlerWithMelt = withMelt((_event) => handler(_event));
        events2.forEach((_event) => target2.addEventListener(_event, handlerWithMelt, options));
        return () => {
          events2.forEach((_event) => target2.removeEventListener(_event, handlerWithMelt, options));
        };
      }
      return () => noop$5();
    }
    function dispatchMeltEvent(originalEvent) {
      const node = originalEvent.currentTarget;
      if (!isHTMLElement$1(node))
        return null;
      const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {
        detail: {
          originalEvent
        },
        cancelable: true
      });
      node.dispatchEvent(customMeltEvent);
      return customMeltEvent;
    }
    function withMelt(handler) {
      return (event2) => {
        const customEvent = dispatchMeltEvent(event2);
        if (customEvent == null ? void 0 : customEvent.defaultPrevented)
          return;
        return handler(event2);
      };
    }
    function addHighlight(element2) {
      element2.setAttribute("data-highlighted", "");
    }
    function removeHighlight(element2) {
      element2.removeAttribute("data-highlighted");
    }
    function getOptions(el) {
      return Array.from(el.querySelectorAll('[role="option"]:not([data-disabled])')).filter((el2) => isHTMLElement$1(el2));
    }
    function omit$1(obj, ...keys2) {
      const result = {};
      for (const key2 of Object.keys(obj)) {
        if (!keys2.includes(key2)) {
          result[key2] = obj[key2];
        }
      }
      return result;
    }
    function stripValues(inputObject, toStrip, recursive) {
      return Object.fromEntries(Object.entries(inputObject).filter(([_, value2]) => !dequal(value2, toStrip)));
    }
    const overridable = (store2, onChange) => {
      const update2 = (updater2, sideEffect) => {
        store2.update((curr) => {
          const next2 = updater2(curr);
          let res = next2;
          if (onChange) {
            res = onChange({ curr, next: next2 });
          }
          sideEffect == null ? void 0 : sideEffect(res);
          return res;
        });
      };
      const set2 = (curr) => {
        update2(() => curr);
      };
      return {
        ...store2,
        update: update2,
        set: set2
      };
    };
    function sleep$1(ms) {
      return new Promise((resolve2) => setTimeout(resolve2, ms));
    }
    let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    let nanoid = (size2 = 21) => {
      let id2 = "";
      let i = size2;
      while (i--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    function generateId() {
      return nanoid(10);
    }
    function generateIds(args) {
      return args.reduce((acc, curr) => {
        acc[curr] = generateId();
        return acc;
      }, {});
    }
    const kbd = {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      A: "a",
      P: "p"
    };
    const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
    const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
    const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    function debounce$1(fn, wait = 500) {
      let timeout2 = null;
      return function(...args) {
        const later = () => {
          timeout2 = null;
          fn(...args);
        };
        timeout2 && clearTimeout(timeout2);
        timeout2 = setTimeout(later, wait);
      };
    }
    const isDom = () => typeof window !== "undefined";
    function getPlatform() {
      const agent = navigator.userAgentData;
      return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
    }
    const pt = (v) => isDom() && v.test(getPlatform().toLowerCase());
    const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
    const isMac = () => pt(/^mac/) && !isTouchDevice();
    const isApple = () => pt(/mac|iphone|ipad|ipod/i);
    const isIos = () => isApple() && !isMac();
    const LOCK_CLASSNAME = "data-melt-scroll-lock";
    function assignStyle(el, style2) {
      if (!el)
        return;
      const previousStyle = el.style.cssText;
      Object.assign(el.style, style2);
      return () => {
        el.style.cssText = previousStyle;
      };
    }
    function setCSSProperty(el, property2, value2) {
      if (!el)
        return;
      const previousValue = el.style.getPropertyValue(property2);
      el.style.setProperty(property2, value2);
      return () => {
        if (previousValue) {
          el.style.setProperty(property2, previousValue);
        } else {
          el.style.removeProperty(property2);
        }
      };
    }
    function getPaddingProperty(documentElement) {
      const documentLeft = documentElement.getBoundingClientRect().left;
      const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
      return scrollbarX ? "paddingLeft" : "paddingRight";
    }
    function removeScroll(_document) {
      const doc = _document ?? document;
      const win = doc.defaultView ?? window;
      const { documentElement, body } = doc;
      const locked = body.hasAttribute(LOCK_CLASSNAME);
      if (locked)
        return noop$5;
      body.setAttribute(LOCK_CLASSNAME, "");
      const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
      const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
      const paddingProperty = getPaddingProperty(documentElement);
      const scrollbarSidePadding = win.getComputedStyle(body)[paddingProperty];
      const setStyle2 = () => assignStyle(body, {
        overflow: "hidden",
        [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
      });
      const setIOSStyle = () => {
        const { scrollX, scrollY, visualViewport } = win;
        const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
        const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
        const restoreStyle = assignStyle(body, {
          position: "fixed",
          overflow: "hidden",
          top: `${-(scrollY - Math.floor(offsetTop))}px`,
          left: `${-(scrollX - Math.floor(offsetLeft))}px`,
          right: "0",
          [paddingProperty]: `calc(${scrollbarSidePadding} + ${scrollbarWidth}px)`
        });
        return () => {
          restoreStyle == null ? void 0 : restoreStyle();
          win.scrollTo(scrollX, scrollY);
        };
      };
      const cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
      return () => {
        cleanups.forEach((fn) => fn == null ? void 0 : fn());
        body.removeAttribute(LOCK_CLASSNAME);
      };
    }
    function derivedVisible(obj) {
      const { open, forceVisible, activeTrigger } = obj;
      return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);
    }
    const safeOnMount = (fn) => {
      try {
        onMount(fn);
      } catch {
        return fn();
      }
    };
    const safeOnDestroy = (fn) => {
      try {
        onDestroy(fn);
      } catch {
        return fn();
      }
    };
    function derivedWithUnsubscribe(stores, fn) {
      let unsubscribers = [];
      const onUnsubscribe = (cb) => {
        unsubscribers.push(cb);
      };
      const unsubscribe2 = () => {
        unsubscribers.forEach((fn2) => fn2());
        unsubscribers = [];
      };
      const derivedStore = derived(stores, ($storeValues) => {
        unsubscribe2();
        return fn($storeValues, onUnsubscribe);
      });
      safeOnDestroy(unsubscribe2);
      const subscribe2 = (...args) => {
        const unsub = derivedStore.subscribe(...args);
        return () => {
          unsub();
          unsubscribe2();
        };
      };
      return {
        ...derivedStore,
        subscribe: subscribe2
      };
    }
    function effect(stores, fn) {
      const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
        return {
          stores: stores2,
          onUnsubscribe
        };
      }).subscribe(({ stores: stores2, onUnsubscribe }) => {
        const returned = fn(stores2);
        if (returned) {
          onUnsubscribe(returned);
        }
      });
      safeOnDestroy(unsub);
      return unsub;
    }
    function toWritableStores(properties) {
      const result = {};
      Object.keys(properties).forEach((key2) => {
        const propertyKey = key2;
        const value2 = properties[propertyKey];
        result[propertyKey] = writable(value2);
      });
      return result;
    }
    function handleRovingFocus(nextElement) {
      if (!isBrowser)
        return;
      sleep$1(1).then(() => {
        const currentFocusedElement = document.activeElement;
        if (!isHTMLElement$1(currentFocusedElement) || currentFocusedElement === nextElement)
          return;
        currentFocusedElement.tabIndex = -1;
        if (nextElement) {
          nextElement.tabIndex = 0;
          nextElement.focus();
        }
      });
    }
    const ignoredKeys = /* @__PURE__ */ new Set(["Shift", "Control", "Alt", "Meta", "CapsLock", "NumLock"]);
    const defaults$4 = {
      onMatch: handleRovingFocus,
      getCurrentItem: () => document.activeElement
    };
    function createTypeaheadSearch(args = {}) {
      const withDefaults = { ...defaults$4, ...args };
      const typed = writable([]);
      const resetTyped = debounce$1(() => {
        typed.update(() => []);
      });
      const handleTypeaheadSearch = (key2, items) => {
        if (ignoredKeys.has(key2))
          return;
        const currentItem = withDefaults.getCurrentItem();
        const $typed = get_store_value(typed);
        if (!Array.isArray($typed)) {
          return;
        }
        $typed.push(key2.toLowerCase());
        typed.set($typed);
        const candidateItems = items.filter((item) => {
          if (item.getAttribute("disabled") === "true" || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("data-disabled")) {
            return false;
          }
          return true;
        });
        const isRepeated = $typed.length > 1 && $typed.every((char) => char === $typed[0]);
        const normalizeSearch = isRepeated ? $typed[0] : $typed.join("");
        const currentItemIndex = isHTMLElement$1(currentItem) ? candidateItems.indexOf(currentItem) : -1;
        let wrappedItems = wrapArray(candidateItems, Math.max(currentItemIndex, 0));
        const excludeCurrentItem = normalizeSearch.length === 1;
        if (excludeCurrentItem) {
          wrappedItems = wrappedItems.filter((v) => v !== currentItem);
        }
        const nextItem = wrappedItems.find((item) => (item == null ? void 0 : item.innerText) && item.innerText.toLowerCase().startsWith(normalizeSearch.toLowerCase()));
        if (isHTMLElement$1(nextItem) && nextItem !== currentItem) {
          withDefaults.onMatch(nextItem);
        }
        resetTyped();
      };
      return {
        typed,
        resetTyped,
        handleTypeaheadSearch
      };
    }
    function getPortalParent(node) {
      let parent = node.parentElement;
      while (isHTMLElement$1(parent) && !parent.hasAttribute("data-portal")) {
        parent = parent.parentElement;
      }
      return parent || "body";
    }
    function getPortalDestination(node, portalProp) {
      const portalParent = getPortalParent(node);
      if (portalProp !== void 0)
        return portalProp;
      if (portalParent === "body")
        return document.body;
      return null;
    }
    function createClickOutsideIgnore(meltId) {
      return (e3) => {
        const target2 = e3.target;
        const triggerEl = getElementByMeltId(meltId);
        if (!triggerEl || !isElement$1(target2))
          return false;
        const id2 = triggerEl.id;
        if (isHTMLLabelElement(target2) && id2 === target2.htmlFor) {
          return true;
        }
        if (target2.closest(`label[for="${id2}"]`)) {
          return true;
        }
        return false;
      };
    }
    function snapValueToStep(value2, min2, max2, step) {
      const remainder = (value2 - (isNaN(min2) ? 0 : min2)) % step;
      let snappedValue = Math.abs(remainder) * 2 >= step ? value2 + Math.sign(remainder) * (step - Math.abs(remainder)) : value2 - remainder;
      if (!isNaN(min2)) {
        if (snappedValue < min2) {
          snappedValue = min2;
        } else if (!isNaN(max2) && snappedValue > max2) {
          snappedValue = min2 + Math.floor((max2 - min2) / step) * step;
        }
      } else if (!isNaN(max2) && snappedValue > max2) {
        snappedValue = Math.floor(max2 / step) * step;
      }
      const string = step.toString();
      const index2 = string.indexOf(".");
      const precision = index2 >= 0 ? string.length - index2 : 0;
      if (precision > 0) {
        const pow2 = Math.pow(10, precision);
        snappedValue = Math.round(snappedValue * pow2) / pow2;
      }
      return snappedValue;
    }
    const defaults$3 = {
      disabled: false,
      required: false,
      name: void 0,
      value: "on",
      defaultChecked: false
    };
    function createCheckbox(props) {
      const withDefaults = { ...defaults$3, ...props };
      const options = toWritableStores(omit$1(withDefaults, "checked", "defaultChecked"));
      const { disabled, name: name2, required: required2, value: value2 } = options;
      const checkedWritable = withDefaults.checked ?? writable(withDefaults.defaultChecked);
      const checked = overridable(checkedWritable, withDefaults == null ? void 0 : withDefaults.onCheckedChange);
      const root2 = builder("checkbox", {
        stores: [checked, disabled, required2],
        returned: ([$checked, $disabled, $required]) => {
          return {
            "data-disabled": disabledAttr($disabled),
            disabled: disabledAttr($disabled),
            "data-state": $checked === "indeterminate" ? "indeterminate" : $checked ? "checked" : "unchecked",
            type: "button",
            role: "checkbox",
            "aria-checked": $checked === "indeterminate" ? "mixed" : $checked,
            "aria-required": $required
          };
        },
        action: (node) => {
          const unsub = executeCallbacks(addMeltEventListener(node, "keydown", (e3) => {
            if (e3.key === kbd.ENTER)
              e3.preventDefault();
          }), addMeltEventListener(node, "click", () => {
            if (get_store_value(disabled))
              return;
            checked.update((value3) => {
              if (value3 === "indeterminate")
                return true;
              return !value3;
            });
          }));
          return {
            destroy: unsub
          };
        }
      });
      const input = builder("checkbox-input", {
        stores: [checked, name2, value2, required2, disabled],
        returned: ([$checked, $name, $value, $required, $disabled]) => {
          return {
            type: "checkbox",
            "aria-hidden": true,
            hidden: true,
            tabindex: -1,
            name: $name,
            value: $value,
            checked: $checked === "indeterminate" ? false : $checked,
            required: $required,
            disabled: disabledAttr($disabled),
            style: styleToString({
              position: "absolute",
              opacity: 0,
              "pointer-events": "none",
              margin: 0,
              transform: "translateX(-100%)"
            })
          };
        }
      });
      const isIndeterminate = derived(checked, ($checked) => $checked === "indeterminate");
      const isChecked = derived(checked, ($checked) => $checked === true);
      return {
        elements: {
          root: root2,
          input
        },
        states: {
          checked
        },
        helpers: {
          isIndeterminate,
          isChecked
        },
        options
      };
    }
    const documentClickStore = readable(void 0, (set2) => {
      function clicked(event2) {
        set2(event2);
        set2(void 0);
      }
      const unsubscribe2 = addEventListener$1(document, "pointerup", clicked, {
        passive: false,
        capture: true
      });
      return unsubscribe2;
    });
    const useClickOutside = (node, config = {}) => {
      let options = { enabled: true, ...config };
      function isEnabled() {
        return typeof options.enabled === "boolean" ? options.enabled : get_store_value(options.enabled);
      }
      const unsubscribe2 = documentClickStore.subscribe((e3) => {
        var _a2;
        if (!isEnabled() || !e3 || e3.target === node) {
          return;
        }
        const composedPath = e3.composedPath();
        if (composedPath.includes(node))
          return;
        if (options.ignore) {
          if (isFunction$1(options.ignore)) {
            if (options.ignore(e3))
              return;
          } else if (Array.isArray(options.ignore)) {
            if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
              return ignoreEl && (e3.target === ignoreEl || composedPath.includes(ignoreEl));
            }))
              return;
          }
        }
        (_a2 = options.handler) == null ? void 0 : _a2.call(options, e3);
      });
      return {
        update(params2) {
          options = { ...options, ...params2 };
        },
        destroy() {
          unsubscribe2();
        }
      };
    };
    const documentEscapeKeyStore = readable(void 0, (set2) => {
      function keydown(event2) {
        if (event2 && event2.key === kbd.ESCAPE) {
          set2(event2);
        }
        set2(void 0);
      }
      const unsubscribe2 = addEventListener$1(document, "keydown", keydown, {
        passive: false
      });
      return unsubscribe2;
    });
    const useEscapeKeydown = (node, config = {}) => {
      let unsub = noop$5;
      function update2(config2 = {}) {
        unsub();
        const options = { enabled: true, ...config2 };
        const enabled = isReadable(options.enabled) ? options.enabled : readable(options.enabled);
        unsub = executeCallbacks(
          // Handle escape keydowns
          documentEscapeKeyStore.subscribe((e3) => {
            var _a2;
            if (!e3 || !get_store_value(enabled))
              return;
            const target2 = e3.target;
            if (!isHTMLElement$1(target2) || target2.closest("[data-escapee]") !== node) {
              return;
            }
            e3.preventDefault();
            if (options.ignore) {
              if (isFunction$1(options.ignore)) {
                if (options.ignore(e3))
                  return;
              } else if (Array.isArray(options.ignore)) {
                if (options.ignore.length > 0 && options.ignore.some((ignoreEl) => {
                  return ignoreEl && target2 === ignoreEl;
                }))
                  return;
              }
            }
            (_a2 = options.handler) == null ? void 0 : _a2.call(options, e3);
          }),
          effect(enabled, ($enabled) => {
            if ($enabled) {
              node.dataset.escapee = "";
            } else {
              delete node.dataset.escapee;
            }
          })
        );
      }
      update2(config);
      return {
        update: update2,
        destroy() {
          node.removeAttribute("data-escapee");
          unsub();
        }
      };
    };
    const min$3 = Math.min;
    const max$3 = Math.max;
    const round = Math.round;
    const floor$1 = Math.floor;
    const createCoords = (v) => ({
      x: v,
      y: v
    });
    const oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    const oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    function clamp$1(start2, value2, end) {
      return max$3(start2, min$3(value2, end));
    }
    function evaluate$1(value2, param2) {
      return typeof value2 === "function" ? value2(param2) : value2;
    }
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getOppositeAxis(axis2) {
      return axis2 === "x" ? "y" : "x";
    }
    function getAxisLength(axis2) {
      return axis2 === "y" ? "height" : "width";
    }
    function getSideAxis(placement) {
      return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
    }
    function getAlignmentAxis(placement) {
      return getOppositeAxis(getSideAxis(placement));
    }
    function getAlignmentSides(placement, rects, rtl) {
      if (rtl === void 0) {
        rtl = false;
      }
      const alignment = getAlignment(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const length2 = getAxisLength(alignmentAxis);
      let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
      if (rects.reference[length2] > rects.floating[length2]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
      }
      return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
    }
    function getSideList(side, isStart, rtl) {
      const lr = ["left", "right"];
      const rl = ["right", "left"];
      const tb = ["top", "bottom"];
      const bt = ["bottom", "top"];
      switch (side) {
        case "top":
        case "bottom":
          if (rtl)
            return isStart ? rl : lr;
          return isStart ? lr : rl;
        case "left":
        case "right":
          return isStart ? tb : bt;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      let list2 = getSideList(getSide(placement), direction === "start", rtl);
      if (alignment) {
        list2 = list2.map((side) => side + "-" + alignment);
        if (flipAlignment) {
          list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
        }
      }
      return list2;
    }
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
    }
    function expandPaddingObject(padding2) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding2
      };
    }
    function getPaddingObject(padding2) {
      return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
        top: padding2,
        right: padding2,
        bottom: padding2,
        left: padding2
      };
    }
    function rectToClientRect(rect2) {
      return {
        ...rect2,
        top: rect2.y,
        left: rect2.x,
        right: rect2.x + rect2.width,
        bottom: rect2.y + rect2.height
      };
    }
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {
        reference,
        floating
      } = _ref;
      const sideAxis = getSideAxis(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const alignLength = getAxisLength(alignmentAxis);
      const side = getSide(placement);
      const isVertical = sideAxis === "y";
      const commonX = reference.x + reference.width / 2 - floating.width / 2;
      const commonY = reference.y + reference.height / 2 - floating.height / 2;
      const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
      let coords;
      switch (side) {
        case "top":
          coords = {
            x: commonX,
            y: reference.y - floating.height
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
        case "right":
          coords = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
        case "left":
          coords = {
            x: reference.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference.x,
            y: reference.y
          };
      }
      switch (getAlignment(placement)) {
        case "start":
          coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case "end":
          coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }
    const computePosition$1 = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i = 0; i < validMiddleware.length; i++) {
        const {
          name: name2,
          fn
        } = validMiddleware[i];
        const {
          x: nextX,
          y: nextY,
          data: data2,
          reset: reset2
        } = await fn({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name2]: {
            ...middlewareData[name2],
            ...data2
          }
        };
        if (reset2 && resetCount <= 50) {
          resetCount++;
          if (typeof reset2 === "object") {
            if (reset2.placement) {
              statefulPlacement = reset2.placement;
            }
            if (reset2.rects) {
              rects = reset2.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset2.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i = -1;
          continue;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    async function detectOverflow(state, options) {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const {
        x: x2,
        y: y2,
        platform: platform2,
        rects,
        elements,
        strategy
      } = state;
      const {
        boundary = "clippingAncestors",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding: padding2 = 0
      } = evaluate$1(options, state);
      const paddingObject2 = getPaddingObject(padding2);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element2 = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
        element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
      }));
      const rect2 = elementContext === "floating" ? {
        ...rects.floating,
        x: x2,
        y: y2
      } : rects.reference;
      const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
      const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
        x: 1,
        y: 1
      } : {
        x: 1,
        y: 1
      };
      const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rect2,
        offsetParent,
        strategy
      }) : rect2);
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject2.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject2.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject2.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject2.right) / offsetScale.x
      };
    }
    const arrow$1 = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements,
          middlewareData
        } = state;
        const {
          element: element2,
          padding: padding2 = 0
        } = evaluate$1(options, state) || {};
        if (element2 == null) {
          return {};
        }
        const paddingObject2 = getPaddingObject(padding2);
        const coords = {
          x: x2,
          y: y2
        };
        const axis2 = getAlignmentAxis(placement);
        const length2 = getAxisLength(axis2);
        const arrowDimensions = await platform2.getDimensions(element2);
        const isYAxis2 = axis2 === "y";
        const minProp = isYAxis2 ? "top" : "left";
        const maxProp = isYAxis2 ? "bottom" : "right";
        const clientProp = isYAxis2 ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length2] + rects.reference[axis2] - coords[axis2] - rects.floating[length2];
        const startDiff = coords[axis2] - rects.reference[axis2];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length2];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
        const minPadding = min$3(paddingObject2[minProp], largestPossiblePadding);
        const maxPadding = min$3(paddingObject2[maxProp], largestPossiblePadding);
        const min$12 = minPadding;
        const max2 = clientSize - arrowDimensions[length2] - maxPadding;
        const center2 = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
        const offset2 = clamp$1(min$12, center2, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center2 != offset2 && rects.reference[length2] / 2 - (center2 < min$12 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center2 < min$12 ? center2 - min$12 : center2 - max2 : 0;
        return {
          [axis2]: coords[axis2] + alignmentOffset,
          data: {
            [axis2]: offset2,
            centerOffset: center2 - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    const flip$2 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate$1(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    async function convertValueToCoords(state, options) {
      const {
        placement,
        platform: platform2,
        elements
      } = state;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getSideAxis(placement) === "y";
      const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = evaluate$1(options, state);
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
      };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    }
    const offset$4 = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    const shift$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x3,
                  y: y3
                } = _ref;
                return {
                  x: x3,
                  y: y3
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate$1(options, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2
            }
          };
        }
      };
    };
    const size$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          const {
            placement,
            rects,
            platform: platform2,
            elements
          } = state;
          const {
            apply: apply2 = () => {
            },
            ...detectOverflowOptions
          } = evaluate$1(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis2 = getSideAxis(placement) === "y";
          const {
            width: width2,
            height: height2
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height2 - overflow[heightSide];
          const overflowAvailableWidth = width2 - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis2) {
            const maximumClippingWidth = width2 - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min$3(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height2 - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min$3(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max$3(overflow.left, 0);
            const xMax = max$3(overflow.right, 0);
            const yMin = max$3(overflow.top, 0);
            const yMax = max$3(overflow.bottom, 0);
            if (isYAxis2) {
              availableWidth = width2 - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$3(overflow.left, overflow.right));
            } else {
              availableHeight = height2 - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$3(overflow.top, overflow.bottom));
            }
          }
          await apply2({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform2.getDimensions(elements.floating);
          if (width2 !== nextDimensions.width || height2 !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
    function getNodeName(node) {
      if (isNode(node)) {
        return (node.nodeName || "").toLowerCase();
      }
      return "#document";
    }
    function getWindow(node) {
      var _node$ownerDocument;
      return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement(node) {
      var _ref;
      return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
    }
    function isNode(value2) {
      return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
    }
    function isElement(value2) {
      return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
    }
    function isHTMLElement(value2) {
      return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
    }
    function isShadowRoot(value2) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
    }
    function isOverflowElement(element2) {
      const {
        overflow,
        overflowX,
        overflowY,
        display
      } = getComputedStyle$1(element2);
      return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
    }
    function isTableElement(element2) {
      return ["table", "td", "th"].includes(getNodeName(element2));
    }
    function isContainingBlock(element2) {
      const webkit = isWebKit();
      const css = getComputedStyle$1(element2);
      return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value2) => (css.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css.contain || "").includes(value2));
    }
    function getContainingBlock(element2) {
      let currentNode = getParentNode(element2);
      while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        } else {
          currentNode = getParentNode(currentNode);
        }
      }
      return null;
    }
    function isWebKit() {
      if (typeof CSS === "undefined" || !CSS.supports)
        return false;
      return CSS.supports("-webkit-backdrop-filter", "none");
    }
    function isLastTraversableNode(node) {
      return ["html", "body", "#document"].includes(getNodeName(node));
    }
    function getComputedStyle$1(element2) {
      return getWindow(element2).getComputedStyle(element2);
    }
    function getNodeScroll(element2) {
      if (isElement(element2)) {
        return {
          scrollLeft: element2.scrollLeft,
          scrollTop: element2.scrollTop
        };
      }
      return {
        scrollLeft: element2.pageXOffset,
        scrollTop: element2.pageYOffset
      };
    }
    function getParentNode(node) {
      if (getNodeName(node) === "html") {
        return node;
      }
      const result = (
        // Step into the shadow DOM of the parent of a slotted node.
        node.assignedSlot || // DOM Element detected.
        node.parentNode || // ShadowRoot detected.
        isShadowRoot(node) && node.host || // Fallback.
        getDocumentElement(node)
      );
      return isShadowRoot(result) ? result.host : result;
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode(node);
      if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
      }
      if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
      }
      return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list2, traverseIframes) {
      var _node$ownerDocument2;
      if (list2 === void 0) {
        list2 = [];
      }
      if (traverseIframes === void 0) {
        traverseIframes = true;
      }
      const scrollableAncestor = getNearestOverflowAncestor(node);
      const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
      const win = getWindow(scrollableAncestor);
      if (isBody) {
        return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
      }
      return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }
    function getCssDimensions(element2) {
      const css = getComputedStyle$1(element2);
      let width2 = parseFloat(css.width) || 0;
      let height2 = parseFloat(css.height) || 0;
      const hasOffset = isHTMLElement(element2);
      const offsetWidth = hasOffset ? element2.offsetWidth : width2;
      const offsetHeight = hasOffset ? element2.offsetHeight : height2;
      const shouldFallback = round(width2) !== offsetWidth || round(height2) !== offsetHeight;
      if (shouldFallback) {
        width2 = offsetWidth;
        height2 = offsetHeight;
      }
      return {
        width: width2,
        height: height2,
        $: shouldFallback
      };
    }
    function unwrapElement(element2) {
      return !isElement(element2) ? element2.contextElement : element2;
    }
    function getScale$1(element2) {
      const domElement = unwrapElement(element2);
      if (!isHTMLElement(domElement)) {
        return createCoords(1);
      }
      const rect2 = domElement.getBoundingClientRect();
      const {
        width: width2,
        height: height2,
        $: $2
      } = getCssDimensions(domElement);
      let x2 = ($2 ? round(rect2.width) : rect2.width) / width2;
      let y2 = ($2 ? round(rect2.height) : rect2.height) / height2;
      if (!x2 || !Number.isFinite(x2)) {
        x2 = 1;
      }
      if (!y2 || !Number.isFinite(y2)) {
        y2 = 1;
      }
      return {
        x: x2,
        y: y2
      };
    }
    const noOffsets = /* @__PURE__ */ createCoords(0);
    function getVisualOffsets(element2) {
      const win = getWindow(element2);
      if (!isWebKit() || !win.visualViewport) {
        return noOffsets;
      }
      return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
      };
    }
    function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
        return false;
      }
      return isFixed;
    }
    function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      const clientRect = element2.getBoundingClientRect();
      const domElement = unwrapElement(element2);
      let scale2 = createCoords(1);
      if (includeScale) {
        if (offsetParent) {
          if (isElement(offsetParent)) {
            scale2 = getScale$1(offsetParent);
          }
        } else {
          scale2 = getScale$1(element2);
        }
      }
      const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
      let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
      let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
      let width2 = clientRect.width / scale2.x;
      let height2 = clientRect.height / scale2.y;
      if (domElement) {
        const win = getWindow(domElement);
        const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
        let currentIFrame = win.frameElement;
        while (currentIFrame && offsetParent && offsetWin !== win) {
          const iframeScale = getScale$1(currentIFrame);
          const iframeRect = currentIFrame.getBoundingClientRect();
          const css = getComputedStyle$1(currentIFrame);
          const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
          const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
          x2 *= iframeScale.x;
          y2 *= iframeScale.y;
          width2 *= iframeScale.x;
          height2 *= iframeScale.y;
          x2 += left2;
          y2 += top2;
          currentIFrame = getWindow(currentIFrame).frameElement;
        }
      }
      return rectToClientRect({
        width: width2,
        height: height2,
        x: x2,
        y: y2
      });
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let {
        rect: rect2,
        offsetParent,
        strategy
      } = _ref;
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      if (offsetParent === documentElement) {
        return rect2;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      let scale2 = createCoords(1);
      const offsets2 = createCoords(0);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent);
          scale2 = getScale$1(offsetParent);
          offsets2.x = offsetRect.x + offsetParent.clientLeft;
          offsets2.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      return {
        width: rect2.width * scale2.x,
        height: rect2.height * scale2.y,
        x: rect2.x * scale2.x - scroll.scrollLeft * scale2.x + offsets2.x,
        y: rect2.y * scale2.y - scroll.scrollTop * scale2.y + offsets2.y
      };
    }
    function getClientRects(element2) {
      return Array.from(element2.getClientRects());
    }
    function getWindowScrollBarX(element2) {
      return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
    }
    function getDocumentRect(element2) {
      const html = getDocumentElement(element2);
      const scroll = getNodeScroll(element2);
      const body = element2.ownerDocument.body;
      const width2 = max$3(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
      const height2 = max$3(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
      let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
      const y2 = -scroll.scrollTop;
      if (getComputedStyle$1(body).direction === "rtl") {
        x2 += max$3(html.clientWidth, body.clientWidth) - width2;
      }
      return {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      };
    }
    function getViewportRect(element2, strategy) {
      const win = getWindow(element2);
      const html = getDocumentElement(element2);
      const visualViewport = win.visualViewport;
      let width2 = html.clientWidth;
      let height2 = html.clientHeight;
      let x2 = 0;
      let y2 = 0;
      if (visualViewport) {
        width2 = visualViewport.width;
        height2 = visualViewport.height;
        const visualViewportBased = isWebKit();
        if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      };
    }
    function getInnerBoundingClientRect(element2, strategy) {
      const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
      const top2 = clientRect.top + element2.clientTop;
      const left2 = clientRect.left + element2.clientLeft;
      const scale2 = isHTMLElement(element2) ? getScale$1(element2) : createCoords(1);
      const width2 = element2.clientWidth * scale2.x;
      const height2 = element2.clientHeight * scale2.y;
      const x2 = left2 * scale2.x;
      const y2 = top2 * scale2.y;
      return {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      };
    }
    function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
      let rect2;
      if (clippingAncestor === "viewport") {
        rect2 = getViewportRect(element2, strategy);
      } else if (clippingAncestor === "document") {
        rect2 = getDocumentRect(getDocumentElement(element2));
      } else if (isElement(clippingAncestor)) {
        rect2 = getInnerBoundingClientRect(clippingAncestor, strategy);
      } else {
        const visualOffsets = getVisualOffsets(element2);
        rect2 = {
          ...clippingAncestor,
          x: clippingAncestor.x - visualOffsets.x,
          y: clippingAncestor.y - visualOffsets.y
        };
      }
      return rectToClientRect(rect2);
    }
    function hasFixedPositionAncestor(element2, stopNode) {
      const parentNode = getParentNode(element2);
      if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
        return false;
      }
      return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
    }
    function getClippingElementAncestors(element2, cache2) {
      const cachedResult = cache2.get(element2);
      if (cachedResult) {
        return cachedResult;
      }
      let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
      let currentContainingBlockComputedStyle = null;
      const elementIsFixed = getComputedStyle$1(element2).position === "fixed";
      let currentNode = elementIsFixed ? getParentNode(element2) : element2;
      while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
        const computedStyle = getComputedStyle$1(currentNode);
        const currentNodeIsContaining = isContainingBlock(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") {
          currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
        if (shouldDropCurrentNode) {
          result = result.filter((ancestor) => ancestor !== currentNode);
        } else {
          currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = getParentNode(currentNode);
      }
      cache2.set(element2, result);
      return result;
    }
    function getClippingRect(_ref) {
      let {
        element: element2,
        boundary,
        rootBoundary,
        strategy
      } = _ref;
      const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
      const clippingAncestors = [...elementClippingAncestors, rootBoundary];
      const firstClippingAncestor = clippingAncestors[0];
      const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
        const rect2 = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
        accRect.top = max$3(rect2.top, accRect.top);
        accRect.right = min$3(rect2.right, accRect.right);
        accRect.bottom = min$3(rect2.bottom, accRect.bottom);
        accRect.left = max$3(rect2.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
      return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
      };
    }
    function getDimensions(element2) {
      const {
        width: width2,
        height: height2
      } = getCssDimensions(element2);
      return {
        width: width2,
        height: height2
      };
    }
    function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      const isFixed = strategy === "fixed";
      const rect2 = getBoundingClientRect(element2, true, isFixed, offsetParent);
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets2 = createCoords(0);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isOffsetParentAnElement) {
          const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
          offsets2.x = offsetRect.x + offsetParent.clientLeft;
          offsets2.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          offsets2.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect2.left + scroll.scrollLeft - offsets2.x,
        y: rect2.top + scroll.scrollTop - offsets2.y,
        width: rect2.width,
        height: rect2.height
      };
    }
    function getTrueOffsetParent(element2, polyfill) {
      if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
        return null;
      }
      if (polyfill) {
        return polyfill(element2);
      }
      return element2.offsetParent;
    }
    function getOffsetParent(element2, polyfill) {
      const window2 = getWindow(element2);
      if (!isHTMLElement(element2)) {
        return window2;
      }
      let offsetParent = getTrueOffsetParent(element2, polyfill);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
        return window2;
      }
      return offsetParent || getContainingBlock(element2) || window2;
    }
    const getElementRects = async function(_ref) {
      let {
        reference,
        floating,
        strategy
      } = _ref;
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
        floating: {
          x: 0,
          y: 0,
          ...await getDimensionsFn(floating)
        }
      };
    };
    function isRTL(element2) {
      return getComputedStyle$1(element2).direction === "rtl";
    }
    const platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale: getScale$1,
      isElement,
      isRTL
    };
    function observeMove(element2, onMove) {
      let io = null;
      let timeoutId;
      const root2 = getDocumentElement(element2);
      function cleanup() {
        clearTimeout(timeoutId);
        io && io.disconnect();
        io = null;
      }
      function refresh2(skip, threshold2) {
        if (skip === void 0) {
          skip = false;
        }
        if (threshold2 === void 0) {
          threshold2 = 1;
        }
        cleanup();
        const {
          left: left2,
          top: top2,
          width: width2,
          height: height2
        } = element2.getBoundingClientRect();
        if (!skip) {
          onMove();
        }
        if (!width2 || !height2) {
          return;
        }
        const insetTop = floor$1(top2);
        const insetRight = floor$1(root2.clientWidth - (left2 + width2));
        const insetBottom = floor$1(root2.clientHeight - (top2 + height2));
        const insetLeft = floor$1(left2);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
          rootMargin,
          threshold: max$3(0, min$3(1, threshold2)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries2) {
          const ratio = entries2[0].intersectionRatio;
          if (ratio !== threshold2) {
            if (!isFirstUpdate) {
              return refresh2();
            }
            if (!ratio) {
              timeoutId = setTimeout(() => {
                refresh2(false, 1e-7);
              }, 100);
            } else {
              refresh2(false, ratio);
            }
          }
          isFirstUpdate = false;
        }
        try {
          io = new IntersectionObserver(handleObserve, {
            ...options,
            // Handle <iframe>s
            root: root2.ownerDocument
          });
        } catch (e3) {
          io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element2);
      }
      refresh2(true);
      return cleanup;
    }
    function autoUpdate(reference, floating, update2, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        ancestorScroll = true,
        ancestorResize = true,
        elementResize = typeof ResizeObserver === "function",
        layoutShift = typeof IntersectionObserver === "function",
        animationFrame = false
      } = options;
      const referenceEl = unwrapElement(reference);
      const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.addEventListener("scroll", update2, {
          passive: true
        });
        ancestorResize && ancestor.addEventListener("resize", update2);
      });
      const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
      let reobserveFrame = -1;
      let resizeObserver = null;
      if (elementResize) {
        resizeObserver = new ResizeObserver((_ref) => {
          let [firstEntry] = _ref;
          if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
            resizeObserver.unobserve(floating);
            cancelAnimationFrame(reobserveFrame);
            reobserveFrame = requestAnimationFrame(() => {
              resizeObserver && resizeObserver.observe(floating);
            });
          }
          update2();
        });
        if (referenceEl && !animationFrame) {
          resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
      }
      let frameId;
      let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
      if (animationFrame) {
        frameLoop();
      }
      function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
          update2();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
      }
      update2();
      return () => {
        ancestors.forEach((ancestor) => {
          ancestorScroll && ancestor.removeEventListener("scroll", update2);
          ancestorResize && ancestor.removeEventListener("resize", update2);
        });
        cleanupIo && cleanupIo();
        resizeObserver && resizeObserver.disconnect();
        resizeObserver = null;
        if (animationFrame) {
          cancelAnimationFrame(frameId);
        }
      };
    }
    const shift = shift$1;
    const flip$1 = flip$2;
    const size = size$1;
    const arrow = arrow$1;
    const computePosition = (reference, floating, options) => {
      const cache2 = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache2
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
    const defaultConfig$3 = {
      strategy: "absolute",
      placement: "top",
      gutter: 5,
      flip: true,
      sameWidth: false,
      overflowPadding: 8
    };
    const ARROW_TRANSFORM = {
      bottom: "rotate(45deg)",
      left: "rotate(135deg)",
      top: "rotate(225deg)",
      right: "rotate(315deg)"
    };
    function useFloating(reference, floating, opts = {}) {
      if (!floating || !reference || opts === null)
        return {
          destroy: noop$5
        };
      const options = { ...defaultConfig$3, ...opts };
      const arrowEl = floating.querySelector("[data-arrow=true]");
      const middleware = [];
      if (options.flip) {
        middleware.push(flip$1({
          boundary: options.boundary,
          padding: options.overflowPadding
        }));
      }
      const arrowOffset = isHTMLElement$1(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
      if (options.gutter || options.offset) {
        const data2 = options.gutter ? { mainAxis: options.gutter } : options.offset;
        if ((data2 == null ? void 0 : data2.mainAxis) != null) {
          data2.mainAxis += arrowOffset;
        }
        middleware.push(offset$4(data2));
      }
      middleware.push(shift({
        boundary: options.boundary,
        crossAxis: options.overlap,
        padding: options.overflowPadding
      }));
      if (arrowEl) {
        middleware.push(arrow({ element: arrowEl, padding: 8 }));
      }
      middleware.push(size({
        padding: options.overflowPadding,
        apply({ rects, availableHeight, availableWidth }) {
          if (options.sameWidth) {
            Object.assign(floating.style, {
              width: `${Math.round(rects.reference.width)}px`,
              minWidth: "unset"
            });
          }
          if (options.fitViewport) {
            Object.assign(floating.style, {
              maxWidth: `${availableWidth}px`,
              maxHeight: `${availableHeight}px`
            });
          }
        }
      }));
      function compute() {
        if (!reference || !floating)
          return;
        const { placement, strategy } = options;
        computePosition(reference, floating, {
          placement,
          middleware,
          strategy
        }).then((data2) => {
          const x2 = Math.round(data2.x);
          const y2 = Math.round(data2.y);
          Object.assign(floating.style, {
            position: options.strategy,
            top: `${y2}px`,
            left: `${x2}px`
          });
          if (isHTMLElement$1(arrowEl) && data2.middlewareData.arrow) {
            const { x: x3, y: y3 } = data2.middlewareData.arrow;
            const dir = data2.placement.split("-")[0];
            Object.assign(arrowEl.style, {
              position: "absolute",
              left: x3 != null ? `${x3}px` : "",
              top: y3 != null ? `${y3}px` : "",
              [dir]: `calc(100% - ${arrowOffset}px)`,
              transform: ARROW_TRANSFORM[dir],
              backgroundColor: "inherit",
              zIndex: "inherit"
            });
          }
          return data2;
        });
      }
      Object.assign(floating.style, {
        position: options.strategy
      });
      return {
        destroy: autoUpdate(reference, floating, compute)
      };
    }
    /*!
    * tabbable 6.2.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    var NoElement = typeof Element === "undefined";
    var matches = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element2) {
      var _element$getRootNode;
      return element2 === null || element2 === void 0 ? void 0 : (_element$getRootNode = element2.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element2);
    } : function(element2) {
      return element2 === null || element2 === void 0 ? void 0 : element2.ownerDocument;
    };
    var isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    var isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    var getCandidates = function getCandidates2(el, includeContainer, filter2) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter2);
      return candidates;
    };
    var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element2 = elementsToCheck.shift();
        if (isInert(element2, false)) {
          continue;
        }
        if (element2.tagName === "SLOT") {
          var assigned = element2.assignedElements();
          var content2 = assigned.length ? assigned : element2.children;
          var nestedCandidates = getCandidatesIteratively2(content2, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element2,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches.call(element2, candidateSelector);
          if (validCandidate && options.filter(element2) && (includeContainer || !elements.includes(element2))) {
            candidates.push(element2);
          }
          var shadowRoot = element2.shadowRoot || // check for an undisclosed shadow
          typeof options.getShadowRoot === "function" && options.getShadowRoot(element2);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element2));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element2.children : shadowRoot.children, true, options);
            if (options.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element2,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element2.children);
          }
        }
      }
      return candidates;
    };
    var hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    var getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
      return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
    };
    var isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    var isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    var isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === "SUMMARY";
      });
      return r;
    };
    var getCheckedRadio = function getCheckedRadio2(nodes, form2) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form2) {
          return nodes[i];
        }
      }
    };
    var isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name2) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    var isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    var isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    var isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    var isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width2 = _node$getBoundingClie.width, height2 = _node$getBoundingClie.height;
      return width2 === 0 && height2 === 0;
    };
    var isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);
              if (child.tagName === "LEGEND") {
                return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
      }
      return true;
    };
    var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    var sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i) {
        var isScope = !!item.scopeParent;
        var element2 = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element2, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element2;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element2);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    var tabbable = function tabbable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options),
          flatten: false,
          getShadowRoot: options.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
      }
      return sortByOrder(candidates);
    };
    var focusable = function focusable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options),
          flatten: true,
          getShadowRoot: options.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
      }
      return candidates;
    };
    var isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    var isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
    /*!
    * focus-trap 7.5.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    */
    function ownKeys(e3, r) {
      var t4 = Object.keys(e3);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e3);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
        })), t4.push.apply(t4, o);
      }
      return t4;
    }
    function _objectSpread2(e3) {
      for (var r = 1; r < arguments.length; r++) {
        var t4 = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t4), true).forEach(function(r2) {
          _defineProperty(e3, r2, t4[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r2) {
          Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t4, r2));
        });
      }
      return e3;
    }
    function _defineProperty(obj, key2, value2) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    var activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap2) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap2) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap2);
        if (trapIndex === -1) {
          trapStack.push(trap2);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap2);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap2) {
        var trapIndex = trapStack.indexOf(trap2);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    var isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    var isEscapeEvent = function isEscapeEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Escape" || (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Esc" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 27;
    };
    var isTabEvent = function isTabEvent2(e3) {
      return (e3 === null || e3 === void 0 ? void 0 : e3.key) === "Tab" || (e3 === null || e3 === void 0 ? void 0 : e3.keyCode) === 9;
    };
    var isKeyForward = function isKeyForward2(e3) {
      return isTabEvent(e3) && !e3.shiftKey;
    };
    var isKeyBackward = function isKeyBackward2(e3) {
      return isTabEvent(e3) && e3.shiftKey;
    };
    var delay = function delay2(fn) {
      return setTimeout(fn, 0);
    };
    var findIndex = function findIndex2(arr, fn) {
      var idx = -1;
      arr.every(function(value2, i) {
        if (fn(value2)) {
          idx = i;
          return false;
        }
        return true;
      });
      return idx;
    };
    var valueOrHandler = function valueOrHandler2(value2) {
      for (var _len = arguments.length, params2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params2[_key - 1] = arguments[_key];
      }
      return typeof value2 === "function" ? value2.apply(void 0, params2) : value2;
    };
    var getActualTarget = function getActualTarget2(event2) {
      return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
    };
    var internalTrapStack = [];
    var createFocusTrap$1 = function createFocusTrap2(elements, userOptions) {
      var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap2;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element2, event2) {
        var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element2) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element2;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params2[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params2);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config.tabbableOptions)) {
          if (findContainerIndex(doc.activeElement) >= 0) {
            node = doc.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config.tabbableOptions);
          var focusableNodes = focusable(container, config.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward2) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward2 ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group2) {
          return group2.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g) {
          return g.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var getActiveElement = function getActiveElement2(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return getActiveElement2(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target2 = _ref2.target, event2 = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target2 = target2 || getActualTarget(event2);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target2, event2);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target2 === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target2 || isFocusable(target2, config.tabbableOptions) && !isTabbable(target2, config.tabbableOptions) && !containerGroup.nextTabbableNode(target2, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target2) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event2)) {
              destinationNode = containerGroup.nextTabbableNode(target2, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target2 === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target2 || isFocusable(target2, config.tabbableOptions) && !isTabbable(target2, config.tabbableOptions) && !containerGroup.nextTabbableNode(target2))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target2) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event2)) {
              destinationNode = containerGroup.nextTabbableNode(target2);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e3) {
        var target2 = getActualTarget(e3);
        if (findContainerIndex(target2, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          trap2.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event2) {
        var target2 = getActualTarget(event2);
        var targetContained = findContainerIndex(target2, event2) >= 0;
        if (targetContained || target2 instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target2;
          }
        } else {
          event2.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g) {
                return g.tabbableNodes.some(function(n) {
                  return getTabIndex(n) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event2) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event2;
        var destinationNode = findNextNavNode({
          event: event2,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event2)) {
            event2.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event2) {
        if (isEscapeEvent(event2) && valueOrHandler(config.escapeDeactivates, event2) !== false) {
          event2.preventDefault();
          trap2.deactivate();
          return;
        }
        if (config.isKeyForward(event2) || config.isKeyBackward(event2)) {
          checkKeyNav(event2, config.isKeyBackward(event2));
        }
      };
      var checkClick = function checkClick2(e3) {
        var target2 = getActualTarget(e3);
        if (findContainerIndex(target2, e3) >= 0) {
          return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e3)) {
          return;
        }
        if (valueOrHandler(config.allowOutsideClick, e3)) {
          return;
        }
        e3.preventDefault();
        e3.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap2);
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener("focusin", checkFocusIn, true);
        doc.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap2;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc.removeEventListener("focusin", checkFocusIn, true);
        doc.removeEventListener("mousedown", checkPointerDown, true);
        doc.removeEventListener("touchstart", checkPointerDown, true);
        doc.removeEventListener("click", checkClick, true);
        doc.removeEventListener("keydown", checkKey, true);
        return trap2;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap2 = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options = _objectSpread2({
            onDeactivate: config.onDeactivate,
            onPostDeactivate: config.onPostDeactivate,
            checkCanReturnFocus: config.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap2);
          var onDeactivate = getOption(options, "onDeactivate");
          var onPostDeactivate = getOption(options, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
          var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause2(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element2) {
            return typeof element2 === "string" ? doc.querySelector(element2) : element2;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap2.updateContainerElements(elements);
      return trap2;
    };
    function createFocusTrap(config = {}) {
      let trap2;
      const { immediate, ...focusTrapOptions } = config;
      const hasFocus = writable(false);
      const isPaused = writable(false);
      const activate = (opts) => trap2 == null ? void 0 : trap2.activate(opts);
      const deactivate = (opts) => {
        trap2 == null ? void 0 : trap2.deactivate(opts);
      };
      const pause2 = () => {
        if (trap2) {
          trap2.pause();
          isPaused.set(true);
        }
      };
      const unpause = () => {
        if (trap2) {
          trap2.unpause();
          isPaused.set(false);
        }
      };
      const useFocusTrap = (node) => {
        trap2 = createFocusTrap$1(node, {
          ...focusTrapOptions,
          onActivate() {
            var _a2;
            hasFocus.set(true);
            (_a2 = config.onActivate) == null ? void 0 : _a2.call(config);
          },
          onDeactivate() {
            var _a2;
            hasFocus.set(false);
            (_a2 = config.onDeactivate) == null ? void 0 : _a2.call(config);
          }
        });
        if (immediate) {
          activate();
        }
        return {
          destroy() {
            deactivate();
            trap2 = void 0;
          }
        };
      };
      return {
        useFocusTrap,
        hasFocus: readonly(hasFocus),
        isPaused: readonly(isPaused),
        activate,
        deactivate,
        pause: pause2,
        unpause
      };
    }
    const defaultConfig$2 = {
      floating: {},
      focusTrap: {},
      clickOutside: {},
      escapeKeydown: {},
      portal: "body"
    };
    const usePopper = (popperElement, args) => {
      popperElement.dataset.escapee = "";
      const { anchorElement, open, options } = args;
      if (!anchorElement || !open || !options) {
        return { destroy: noop$5 };
      }
      const opts = { ...defaultConfig$2, ...options };
      const callbacks = [];
      if (opts.portal !== null) {
        const portal2 = usePortal(popperElement, opts.portal);
        if (portal2 == null ? void 0 : portal2.destroy) {
          callbacks.push(portal2.destroy);
        }
      }
      callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
      if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap({
          immediate: true,
          escapeDeactivates: false,
          allowOutsideClick: true,
          returnFocusOnDeactivate: false,
          fallbackFocus: popperElement,
          ...opts.focusTrap
        });
        const usedFocusTrap = useFocusTrap(popperElement);
        if (usedFocusTrap == null ? void 0 : usedFocusTrap.destroy) {
          callbacks.push(usedFocusTrap.destroy);
        }
      }
      if (opts.clickOutside !== null) {
        callbacks.push(useClickOutside(popperElement, {
          enabled: open,
          handler: (e3) => {
            if (e3.defaultPrevented)
              return;
            if (isHTMLElement$1(anchorElement) && !anchorElement.contains(e3.target)) {
              open.set(false);
              anchorElement.focus();
            }
          },
          ...opts.clickOutside
        }).destroy);
      }
      if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
          enabled: open,
          handler: () => {
            open.set(false);
          },
          ...opts.escapeKeydown
        }).destroy);
      }
      const unsubscribe2 = executeCallbacks(...callbacks);
      return {
        destroy() {
          unsubscribe2();
        }
      };
    };
    const usePortal = (el, target2 = "body") => {
      let targetEl;
      if (!isHTMLElement$1(target2) && typeof target2 !== "string") {
        return {
          destroy: noop$5
        };
      }
      async function update2(newTarget) {
        target2 = newTarget;
        if (typeof target2 === "string") {
          targetEl = document.querySelector(target2);
          if (targetEl === null) {
            await tick$1();
            targetEl = document.querySelector(target2);
          }
          if (targetEl === null) {
            throw new Error(`No element found matching css selector: "${target2}"`);
          }
        } else if (target2 instanceof HTMLElement) {
          targetEl = target2;
        } else {
          throw new TypeError(`Unknown portal target type: ${target2 === null ? "null" : typeof target2}. Allowed types: string (CSS selector) or HTMLElement.`);
        }
        el.dataset.portal = "";
        targetEl.appendChild(el);
        el.hidden = false;
      }
      function destroy() {
        el.remove();
      }
      update2(target2);
      return {
        update: update2,
        destroy
      };
    };
    function createLabel() {
      const root2 = builder("label", {
        action: (node) => {
          const mouseDown = addMeltEventListener(node, "mousedown", (e3) => {
            if (!e3.defaultPrevented && e3.detail > 1) {
              e3.preventDefault();
            }
          });
          return {
            destroy: mouseDown
          };
        }
      });
      return {
        elements: {
          root: root2
        }
      };
    }
    const INTERACTION_KEYS = [kbd.ARROW_LEFT, kbd.ESCAPE, kbd.ARROW_RIGHT, kbd.SHIFT, kbd.CAPS_LOCK, kbd.CONTROL, kbd.ALT, kbd.META, kbd.ENTER, kbd.F1, kbd.F2, kbd.F3, kbd.F4, kbd.F5, kbd.F6, kbd.F7, kbd.F8, kbd.F9, kbd.F10, kbd.F11, kbd.F12];
    const defaults$2 = {
      positioning: {
        placement: "bottom",
        sameWidth: true
      },
      scrollAlignment: "nearest",
      loop: true,
      defaultOpen: false,
      closeOnOutsideClick: true,
      preventScroll: true,
      closeOnEscape: true,
      forceVisible: false,
      portal: void 0,
      builder: "listbox",
      disabled: false,
      required: false,
      name: void 0,
      typeahead: true,
      highlightOnHover: true,
      onOutsideClick: void 0
    };
    const listboxIdParts = ["trigger", "menu", "label"];
    function createListbox(props) {
      const withDefaults = { ...defaults$2, ...props };
      const activeTrigger = writable(null);
      const highlightedItem = writable(null);
      const selectedWritable = withDefaults.selected ?? writable(withDefaults.defaultSelected);
      const selected = overridable(selectedWritable, withDefaults == null ? void 0 : withDefaults.onSelectedChange);
      const highlighted = derived(highlightedItem, ($highlightedItem) => $highlightedItem ? getOptionProps($highlightedItem) : void 0);
      const openWritable = withDefaults.open ?? writable(withDefaults.defaultOpen);
      const open = overridable(openWritable, withDefaults == null ? void 0 : withDefaults.onOpenChange);
      const options = toWritableStores({
        ...omit$1(withDefaults, "open", "defaultOpen", "builder", "ids"),
        multiple: withDefaults.multiple ?? false
      });
      const { scrollAlignment, loop: loop2, closeOnOutsideClick, closeOnEscape, preventScroll, portal: portal2, forceVisible, positioning, multiple, arrowSize, disabled, required: required2, typeahead, name: nameProp, highlightOnHover, onOutsideClick } = options;
      const { name: name2, selector: selector2 } = createElHelpers(withDefaults.builder);
      const ids = toWritableStores({ ...generateIds(listboxIdParts), ...withDefaults.ids });
      const { handleTypeaheadSearch } = createTypeaheadSearch({
        onMatch: (element2) => {
          highlightedItem.set(element2);
          element2.scrollIntoView({ block: get_store_value(scrollAlignment) });
        },
        getCurrentItem() {
          return get_store_value(highlightedItem);
        }
      });
      function getOptionProps(el) {
        const value2 = el.getAttribute("data-value");
        const label3 = el.getAttribute("data-label");
        const disabled2 = el.hasAttribute("data-disabled");
        return {
          value: value2 ? JSON.parse(value2) : value2,
          label: label3 ?? el.textContent ?? void 0,
          disabled: disabled2 ? true : false
        };
      }
      const setOption = (newOption) => {
        selected.update(($option) => {
          const $multiple = get_store_value(multiple);
          if ($multiple) {
            const optionArr = Array.isArray($option) ? $option : [];
            return toggle$1(newOption, optionArr, (itemA, itemB) => dequal(itemA.value, itemB.value));
          }
          return newOption;
        });
      };
      function selectItem(item) {
        const props2 = getOptionProps(item);
        setOption(props2);
      }
      async function openMenu() {
        open.set(true);
        const triggerEl = document.getElementById(get_store_value(ids.trigger));
        if (!triggerEl)
          return;
        activeTrigger.set(triggerEl);
        await tick$1();
        const menuElement = document.getElementById(get_store_value(ids.menu));
        if (!isHTMLElement$1(menuElement))
          return;
        const selectedItem = menuElement.querySelector("[aria-selected=true]");
        if (!isHTMLElement$1(selectedItem))
          return;
        highlightedItem.set(selectedItem);
      }
      function closeMenu() {
        open.set(false);
        highlightedItem.set(null);
      }
      const isVisible = derivedVisible({ open, forceVisible, activeTrigger });
      const isSelected = derived([selected], ([$selected]) => {
        return (value2) => {
          if (Array.isArray($selected)) {
            return $selected.some((o) => dequal(o.value, value2));
          }
          if (isObject$1(value2)) {
            return dequal($selected == null ? void 0 : $selected.value, stripValues(value2, void 0));
          }
          return dequal($selected == null ? void 0 : $selected.value, value2);
        };
      });
      const isHighlighted = derived([highlighted], ([$value]) => {
        return (item) => {
          return dequal($value == null ? void 0 : $value.value, item);
        };
      });
      const trigger = builder(name2("trigger"), {
        stores: [open, highlightedItem, disabled, ids.menu, ids.trigger, ids.label],
        returned: ([$open, $highlightedItem, $disabled, $menuId, $triggerId, $labelId]) => {
          return {
            "aria-activedescendant": $highlightedItem == null ? void 0 : $highlightedItem.id,
            "aria-autocomplete": "list",
            "aria-controls": $menuId,
            "aria-expanded": $open,
            "aria-labelledby": $labelId,
            // autocomplete: 'off',
            id: $triggerId,
            role: "combobox",
            disabled: disabledAttr($disabled)
          };
        },
        action: (node) => {
          const isInput2 = isHTMLInputElement(node);
          const unsubscribe2 = executeCallbacks(
            addMeltEventListener(node, "click", () => {
              node.focus();
              const $open = get_store_value(open);
              if ($open) {
                closeMenu();
              } else {
                openMenu();
              }
            }),
            // Handle all input key events including typing, meta, and navigation.
            addMeltEventListener(node, "keydown", (e3) => {
              const $open = get_store_value(open);
              if (!$open) {
                if (INTERACTION_KEYS.includes(e3.key)) {
                  return;
                }
                if (e3.key === kbd.TAB) {
                  return;
                }
                if (e3.key === kbd.BACKSPACE && isInput2 && node.value === "") {
                  return;
                }
                if (e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
                  return;
                }
                openMenu();
                tick$1().then(() => {
                  const $selectedItem = get_store_value(selected);
                  if ($selectedItem)
                    return;
                  const menuEl = document.getElementById(get_store_value(ids.menu));
                  if (!isHTMLElement$1(menuEl))
                    return;
                  const enabledItems = Array.from(menuEl.querySelectorAll(`${selector2("item")}:not([data-disabled]):not([data-hidden])`)).filter((item) => isHTMLElement$1(item));
                  if (!enabledItems.length)
                    return;
                  if (e3.key === kbd.ARROW_DOWN) {
                    highlightedItem.set(enabledItems[0]);
                    enabledItems[0].scrollIntoView({ block: get_store_value(scrollAlignment) });
                  } else if (e3.key === kbd.ARROW_UP) {
                    highlightedItem.set(last(enabledItems));
                    last(enabledItems).scrollIntoView({ block: get_store_value(scrollAlignment) });
                  }
                });
              }
              if (e3.key === kbd.TAB) {
                closeMenu();
                return;
              }
              if (e3.key === kbd.ENTER || e3.key === kbd.SPACE && isHTMLButtonElement(node)) {
                e3.preventDefault();
                const $highlightedItem = get_store_value(highlightedItem);
                if ($highlightedItem) {
                  selectItem($highlightedItem);
                }
                if (!get_store_value(multiple)) {
                  closeMenu();
                }
              }
              if (e3.key === kbd.ARROW_UP && e3.altKey) {
                closeMenu();
              }
              if (FIRST_LAST_KEYS.includes(e3.key)) {
                e3.preventDefault();
                const menuElement = document.getElementById(get_store_value(ids.menu));
                if (!isHTMLElement$1(menuElement))
                  return;
                const itemElements = getOptions(menuElement);
                if (!itemElements.length)
                  return;
                const candidateNodes = itemElements.filter((opt) => !isElementDisabled(opt) && opt.dataset.hidden === void 0);
                const $currentItem = get_store_value(highlightedItem);
                const currentIndex = $currentItem ? candidateNodes.indexOf($currentItem) : -1;
                const $loop = get_store_value(loop2);
                const $scrollAlignment = get_store_value(scrollAlignment);
                let nextItem;
                switch (e3.key) {
                  case kbd.ARROW_DOWN:
                    nextItem = next(candidateNodes, currentIndex, $loop);
                    break;
                  case kbd.ARROW_UP:
                    nextItem = prev(candidateNodes, currentIndex, $loop);
                    break;
                  case kbd.PAGE_DOWN:
                    nextItem = forward(candidateNodes, currentIndex, 10, $loop);
                    break;
                  case kbd.PAGE_UP:
                    nextItem = back(candidateNodes, currentIndex, 10, $loop);
                    break;
                  case kbd.HOME:
                    nextItem = candidateNodes[0];
                    break;
                  case kbd.END:
                    nextItem = last(candidateNodes);
                    break;
                  default:
                    return;
                }
                highlightedItem.set(nextItem);
                nextItem == null ? void 0 : nextItem.scrollIntoView({ block: $scrollAlignment });
              } else if (get_store_value(typeahead)) {
                const menuEl = document.getElementById(get_store_value(ids.menu));
                if (!isHTMLElement$1(menuEl))
                  return;
                handleTypeaheadSearch(e3.key, getOptions(menuEl));
              }
            })
          );
          let unsubEscapeKeydown = noop$5;
          const escape2 = useEscapeKeydown(node, {
            handler: closeMenu,
            enabled: derived([open, closeOnEscape], ([$open, $closeOnEscape]) => {
              return $open && $closeOnEscape;
            })
          });
          if (escape2 && escape2.destroy) {
            unsubEscapeKeydown = escape2.destroy;
          }
          return {
            destroy() {
              unsubscribe2();
              unsubEscapeKeydown();
            }
          };
        }
      });
      const menu2 = builder(name2("menu"), {
        stores: [isVisible, ids.menu],
        returned: ([$isVisible, $menuId]) => {
          return {
            hidden: $isVisible ? void 0 : true,
            id: $menuId,
            role: "listbox",
            style: styleToString({ display: $isVisible ? void 0 : "none" })
          };
        },
        action: (node) => {
          let unsubPopper = noop$5;
          const unsubscribe2 = executeCallbacks(
            // Bind the popper portal to the input element.
            effect([isVisible, portal2, closeOnOutsideClick, positioning, activeTrigger], ([$isVisible, $portal, $closeOnOutsideClick, $positioning, $activeTrigger]) => {
              unsubPopper();
              if (!$isVisible || !$activeTrigger)
                return;
              const ignoreHandler = createClickOutsideIgnore(get_store_value(ids.trigger));
              const popper = usePopper(node, {
                anchorElement: $activeTrigger,
                open,
                options: {
                  floating: $positioning,
                  focusTrap: null,
                  clickOutside: $closeOnOutsideClick ? {
                    handler: (e3) => {
                      var _a2;
                      (_a2 = get_store_value(onOutsideClick)) == null ? void 0 : _a2(e3);
                      if (e3.defaultPrevented)
                        return;
                      const target2 = e3.target;
                      if (!isElement$1(target2))
                        return;
                      if (target2 === $activeTrigger || $activeTrigger.contains(target2)) {
                        return;
                      }
                      closeMenu();
                    },
                    ignore: ignoreHandler
                  } : null,
                  escapeKeydown: null,
                  portal: getPortalDestination(node, $portal)
                }
              });
              if (popper && popper.destroy) {
                unsubPopper = popper.destroy;
              }
            })
          );
          return {
            destroy: () => {
              unsubscribe2();
              unsubPopper();
            }
          };
        }
      });
      const { elements: { root: labelBuilder } } = createLabel();
      const { action: labelAction } = get_store_value(labelBuilder);
      const label2 = builder(name2("label"), {
        stores: [ids.label, ids.trigger],
        returned: ([$labelId, $triggerId]) => {
          return {
            id: $labelId,
            for: $triggerId
          };
        },
        action: labelAction
      });
      const option = builder(name2("option"), {
        stores: [isSelected],
        returned: ([$isSelected]) => (props2) => {
          const selected2 = $isSelected(props2.value);
          return {
            "data-value": JSON.stringify(props2.value),
            "data-label": props2.label,
            "data-disabled": disabledAttr(props2.disabled),
            "aria-disabled": props2.disabled ? true : void 0,
            "aria-selected": selected2,
            "data-selected": selected2 ? "" : void 0,
            id: generateId(),
            role: "option"
          };
        },
        action: (node) => {
          const unsubscribe2 = executeCallbacks(addMeltEventListener(node, "click", (e3) => {
            if (isElementDisabled(node)) {
              e3.preventDefault();
              return;
            }
            selectItem(node);
            if (!get_store_value(multiple)) {
              closeMenu();
            }
          }), effect(highlightOnHover, ($highlightOnHover) => {
            if (!$highlightOnHover)
              return;
            const unsub = executeCallbacks(addMeltEventListener(node, "mouseover", () => {
              highlightedItem.set(node);
            }), addMeltEventListener(node, "mouseleave", () => {
              highlightedItem.set(null);
            }));
            return unsub;
          }));
          return { destroy: unsubscribe2 };
        }
      });
      const group2 = builder(name2("group"), {
        returned: () => {
          return (groupId) => ({
            role: "group",
            "aria-labelledby": groupId
          });
        }
      });
      const groupLabel = builder(name2("group-label"), {
        returned: () => {
          return (groupId) => ({
            id: groupId
          });
        }
      });
      const hiddenInput = builder(name2("hidden-input"), {
        stores: [selected, required2, nameProp],
        returned: ([$selected, $required, $name]) => {
          const value2 = Array.isArray($selected) ? $selected.map((o) => o.value) : $selected == null ? void 0 : $selected.value;
          return {
            ...hiddenInputAttrs,
            required: $required ? true : void 0,
            value: value2,
            name: $name
          };
        }
      });
      const arrow2 = builder(name2("arrow"), {
        stores: arrowSize,
        returned: ($arrowSize) => ({
          "data-arrow": true,
          style: styleToString({
            position: "absolute",
            width: `var(--arrow-size, ${$arrowSize}px)`,
            height: `var(--arrow-size, ${$arrowSize}px)`
          })
        })
      });
      safeOnMount(() => {
        if (!isBrowser)
          return;
        const menuEl = document.getElementById(get_store_value(ids.menu));
        if (!menuEl)
          return;
        const triggerEl = document.getElementById(get_store_value(ids.trigger));
        if (triggerEl) {
          activeTrigger.set(triggerEl);
        }
        const selectedEl = menuEl.querySelector("[data-selected]");
        if (!isHTMLElement$1(selectedEl))
          return;
      });
      effect([highlightedItem], ([$highlightedItem]) => {
        if (!isBrowser)
          return;
        const menuElement = document.getElementById(get_store_value(ids.menu));
        if (!isHTMLElement$1(menuElement))
          return;
        getOptions(menuElement).forEach((node) => {
          if (node === $highlightedItem) {
            addHighlight(node);
          } else {
            removeHighlight(node);
          }
        });
      });
      effect([open], ([$open]) => {
        if (!isBrowser)
          return;
        let unsubScroll = noop$5;
        if (get_store_value(preventScroll) && $open) {
          unsubScroll = removeScroll();
        }
        return () => {
          unsubScroll();
        };
      });
      return {
        ids,
        elements: {
          trigger,
          group: group2,
          option,
          menu: menu2,
          groupLabel,
          label: label2,
          hiddenInput,
          arrow: arrow2
        },
        states: {
          open,
          selected,
          highlighted,
          highlightedItem
        },
        helpers: {
          isSelected,
          isHighlighted,
          closeMenu
        },
        options
      };
    }
    const { name: name$3 } = createElHelpers("combobox");
    function createCombobox(props) {
      const listbox = createListbox({ ...props, builder: "combobox", typeahead: false });
      const inputValue = writable("");
      const touchedInput = writable(false);
      const input = builder(name$3("input"), {
        stores: [listbox.elements.trigger, inputValue],
        returned: ([$trigger, $inputValue]) => {
          return {
            ...omit$1($trigger, "action"),
            role: "combobox",
            value: $inputValue
          };
        },
        action: (node) => {
          const unsubscribe2 = executeCallbacks(
            addMeltEventListener(node, "input", (e3) => {
              if (!isHTMLInputElement(e3.target) && !isContentEditable$1(e3.target))
                return;
              touchedInput.set(true);
            }),
            // This shouldn't be cancelled ever, so we don't use addMeltEventListener.
            addEventListener$1(node, "input", (e3) => {
              if (isHTMLInputElement(e3.target)) {
                inputValue.set(e3.target.value);
              }
              if (isContentEditable$1(e3.target)) {
                inputValue.set(e3.target.innerText);
              }
            })
          );
          let unsubEscapeKeydown = noop$5;
          const escape2 = useEscapeKeydown(node, {
            handler: () => {
              listbox.helpers.closeMenu();
            }
          });
          if (escape2 && escape2.destroy) {
            unsubEscapeKeydown = escape2.destroy;
          }
          const { destroy } = listbox.elements.trigger(node);
          return {
            destroy() {
              destroy == null ? void 0 : destroy();
              unsubscribe2();
              unsubEscapeKeydown();
            }
          };
        }
      });
      effect(listbox.states.open, ($open) => {
        if (!$open) {
          touchedInput.set(false);
        }
      });
      return {
        ...listbox,
        elements: {
          ...omit$1(listbox.elements, "trigger"),
          input
        },
        states: {
          ...listbox.states,
          touchedInput,
          inputValue
        }
      };
    }
    const defaults$1 = {
      defaultValue: [],
      min: 0,
      max: 100,
      step: 1,
      orientation: "horizontal",
      dir: "ltr",
      disabled: false
    };
    const { name: name$2 } = createElHelpers("slider");
    const createSlider = (props) => {
      const withDefaults = { ...defaults$1, ...props };
      const options = toWritableStores(omit$1(withDefaults, "value", "onValueChange", "defaultValue"));
      const { min: min2, max: max2, step, orientation, dir, disabled } = options;
      const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);
      const value2 = overridable(valueWritable, withDefaults == null ? void 0 : withDefaults.onValueChange);
      const isActive = writable(false);
      const currentThumbIndex = writable(0);
      const activeThumb = writable(null);
      const meltIds = generateIds(["root"]);
      const updatePosition = (val, index2) => {
        value2.update((prev2) => {
          if (!prev2)
            return [val];
          if (prev2[index2] === val)
            return prev2;
          const newValue = [...prev2];
          const direction2 = newValue[index2] > val ? -1 : 1;
          function swap2() {
            newValue[index2] = newValue[index2 + direction2];
            newValue[index2 + direction2] = val;
            const thumbs2 = getAllThumbs();
            if (thumbs2) {
              thumbs2[index2 + direction2].focus();
              activeThumb.set({ thumb: thumbs2[index2 + direction2], index: index2 + direction2 });
            }
          }
          if (direction2 === -1 && val < newValue[index2 - 1]) {
            swap2();
            return newValue;
          } else if (direction2 === 1 && val > newValue[index2 + 1]) {
            swap2();
            return newValue;
          }
          const $min = get_store_value(min2);
          const $max = get_store_value(max2);
          const $step = get_store_value(step);
          newValue[index2] = snapValueToStep(val, $min, $max, $step);
          return newValue;
        });
      };
      const getAllThumbs = () => {
        const root3 = getElementByMeltId(meltIds.root);
        if (!root3)
          return null;
        return Array.from(root3.querySelectorAll('[data-melt-part="thumb"]')).filter((thumb) => isHTMLElement$1(thumb));
      };
      const position2 = derived([min2, max2], ([$min, $max]) => {
        return (val) => {
          const pos = (val - $min) / ($max - $min) * 100;
          return pos;
        };
      });
      const direction = derived([orientation, dir], ([$orientation, $dir]) => {
        if ($orientation === "horizontal") {
          return $dir === "rtl" ? "rl" : "lr";
        } else {
          return $dir === "rtl" ? "tb" : "bt";
        }
      });
      const root2 = builder(name$2(), {
        stores: [disabled, orientation, dir],
        returned: ([$disabled, $orientation, $dir]) => {
          return {
            dir: $dir,
            disabled: disabledAttr($disabled),
            "data-disabled": disabledAttr($disabled),
            "data-orientation": $orientation,
            style: $disabled ? void 0 : `touch-action: ${$orientation === "horizontal" ? "pan-y" : "pan-x"}`,
            "data-melt-id": meltIds.root
          };
        }
      });
      const range2 = builder(name$2("range"), {
        stores: [value2, direction, position2],
        returned: ([$value, $direction, $position]) => {
          const minimum = $value.length > 1 ? $position(Math.min(...$value) ?? 0) : 0;
          const maximum = 100 - $position(Math.max(...$value) ?? 0);
          const style2 = {
            position: "absolute"
          };
          switch ($direction) {
            case "lr": {
              style2.left = `${minimum}%`;
              style2.right = `${maximum}%`;
              break;
            }
            case "rl": {
              style2.right = `${minimum}%`;
              style2.left = `${maximum}%`;
              break;
            }
            case "bt": {
              style2.bottom = `${minimum}%`;
              style2.top = `${maximum}%`;
              break;
            }
            case "tb": {
              style2.top = `${minimum}%`;
              style2.bottom = `${maximum}%`;
              break;
            }
          }
          return {
            style: styleToString(style2)
          };
        }
      });
      const thumbs = builderArray(name$2("thumb"), {
        stores: [value2, position2, min2, max2, disabled, orientation, direction],
        returned: ([$value, $position, $min, $max, $disabled, $orientation, $direction]) => {
          return Array.from({ length: $value.length || 1 }, (_, i) => {
            const currentThumb = get_store_value(currentThumbIndex);
            if (currentThumb < $value.length) {
              currentThumbIndex.update((prev2) => prev2 + 1);
            }
            const thumbValue = $value[i];
            const thumbPosition = `${$position(thumbValue)}%`;
            const style2 = {
              position: "absolute"
            };
            switch ($direction) {
              case "lr": {
                style2.left = thumbPosition;
                style2.translate = "-50% 0";
                break;
              }
              case "rl": {
                style2.right = thumbPosition;
                style2.translate = "50% 0";
                break;
              }
              case "bt": {
                style2.bottom = thumbPosition;
                style2.translate = "0 50%";
                break;
              }
              case "tb": {
                style2.top = thumbPosition;
                style2.translate = "0 -50%";
                break;
              }
            }
            return {
              role: "slider",
              "aria-valuemin": $min,
              "aria-valuemax": $max,
              "aria-valuenow": thumbValue,
              "aria-disabled": disabledAttr($disabled),
              "aria-orientation": $orientation,
              "data-melt-part": "thumb",
              "data-value": thumbValue,
              style: styleToString(style2),
              tabindex: $disabled ? -1 : 0
            };
          });
        },
        action: (node) => {
          const unsub = addMeltEventListener(node, "keydown", (event2) => {
            if (get_store_value(disabled))
              return;
            const target2 = event2.currentTarget;
            if (!isHTMLElement$1(target2))
              return;
            const thumbs2 = getAllThumbs();
            if (!(thumbs2 == null ? void 0 : thumbs2.length))
              return;
            const index2 = thumbs2.indexOf(target2);
            currentThumbIndex.set(index2);
            if (![
              kbd.ARROW_LEFT,
              kbd.ARROW_RIGHT,
              kbd.ARROW_UP,
              kbd.ARROW_DOWN,
              kbd.HOME,
              kbd.END
            ].includes(event2.key)) {
              return;
            }
            event2.preventDefault();
            const $min = get_store_value(min2);
            const $max = get_store_value(max2);
            const $step = get_store_value(step);
            const $value = get_store_value(value2);
            const $orientation = get_store_value(orientation);
            const $direction = get_store_value(direction);
            const thumbValue = $value[index2];
            switch (event2.key) {
              case kbd.HOME: {
                updatePosition($min, index2);
                break;
              }
              case kbd.END: {
                updatePosition($max, index2);
                break;
              }
              case kbd.ARROW_LEFT: {
                if ($orientation !== "horizontal")
                  break;
                if (event2.metaKey) {
                  const newValue = $direction === "rl" ? $max : $min;
                  updatePosition(newValue, index2);
                } else if ($direction === "rl" && thumbValue < $max) {
                  updatePosition(thumbValue + $step, index2);
                } else if ($direction === "lr" && thumbValue > $min) {
                  updatePosition(thumbValue - $step, index2);
                }
                break;
              }
              case kbd.ARROW_RIGHT: {
                if ($orientation !== "horizontal")
                  break;
                if (event2.metaKey) {
                  const newValue = $direction === "rl" ? $min : $max;
                  updatePosition(newValue, index2);
                } else if ($direction === "rl" && thumbValue > $min) {
                  updatePosition(thumbValue - $step, index2);
                } else if ($direction === "lr" && thumbValue < $max) {
                  updatePosition(thumbValue + $step, index2);
                }
                break;
              }
              case kbd.ARROW_UP: {
                if (event2.metaKey) {
                  const newValue = $direction === "tb" ? $min : $max;
                  updatePosition(newValue, index2);
                } else if ($direction === "tb" && thumbValue > $min) {
                  updatePosition(thumbValue - $step, index2);
                } else if ($direction !== "tb" && thumbValue < $max) {
                  updatePosition(thumbValue + $step, index2);
                }
                break;
              }
              case kbd.ARROW_DOWN: {
                if (event2.metaKey) {
                  const newValue = $direction === "tb" ? $max : $min;
                  updatePosition(newValue, index2);
                } else if ($direction === "tb" && thumbValue < $max) {
                  updatePosition(thumbValue + $step, index2);
                } else if ($direction !== "tb" && thumbValue > $min) {
                  updatePosition(thumbValue - $step, index2);
                }
                break;
              }
            }
          });
          return {
            destroy: unsub
          };
        }
      });
      const ticks2 = builderArray(name$2("tick"), {
        stores: [value2, min2, max2, step, direction],
        returned: ([$value, $min, $max, $step, $direction]) => {
          const difference = $max - $min;
          let count2 = Math.ceil(difference / $step);
          if (difference % $step == 0) {
            count2++;
          }
          return Array.from({ length: count2 }, (_, i) => {
            const tickPosition = `${i * ($step / ($max - $min)) * 100}%`;
            const isFirst = i === 0;
            const isLast = i === count2 - 1;
            const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
            const style2 = {
              position: "absolute"
            };
            switch ($direction) {
              case "lr": {
                style2.left = tickPosition;
                style2.translate = `${offsetPercentage}% 0`;
                break;
              }
              case "rl": {
                style2.right = tickPosition;
                style2.translate = `${-offsetPercentage}% 0`;
                break;
              }
              case "bt": {
                style2.bottom = tickPosition;
                style2.translate = `0 ${-offsetPercentage}%`;
                break;
              }
              case "tb": {
                style2.top = tickPosition;
                style2.translate = `0 ${offsetPercentage}%`;
                break;
              }
            }
            const tickValue = $min + i * $step;
            const bounded = $value.length === 1 ? tickValue <= $value[0] : $value[0] <= tickValue && tickValue <= $value[$value.length - 1];
            return {
              "data-bounded": bounded ? true : void 0,
              "data-value": tickValue,
              style: styleToString(style2)
            };
          });
        }
      });
      effect([root2, min2, max2, disabled, orientation, direction, step], ([$root, $min, $max, $disabled, $orientation, $direction, $step]) => {
        if (!isBrowser || $disabled)
          return;
        const applyPosition = (clientXY, activeThumbIdx, start2, end) => {
          const percent = (clientXY - start2) / (end - start2);
          const val = percent * ($max - $min) + $min;
          if (val < $min) {
            updatePosition($min, activeThumbIdx);
          } else if (val > $max) {
            updatePosition($max, activeThumbIdx);
          } else {
            const step2 = $step;
            const min3 = $min;
            const currentStep = Math.floor((val - min3) / step2);
            const midpointOfCurrentStep = min3 + currentStep * step2 + step2 / 2;
            const midpointOfNextStep = min3 + (currentStep + 1) * step2 + step2 / 2;
            const newValue = val >= midpointOfCurrentStep && val < midpointOfNextStep ? (currentStep + 1) * step2 + min3 : currentStep * step2 + min3;
            if (newValue <= $max) {
              updatePosition(newValue, activeThumbIdx);
            }
          }
        };
        const getClosestThumb = (e3) => {
          const thumbs2 = getAllThumbs();
          if (!thumbs2)
            return;
          thumbs2.forEach((thumb2) => thumb2.blur());
          const distances = thumbs2.map((thumb2) => {
            if ($orientation === "horizontal") {
              const { left: left2, right: right2 } = thumb2.getBoundingClientRect();
              return Math.abs(e3.clientX - (left2 + right2) / 2);
            } else {
              const { top: top2, bottom: bottom2 } = thumb2.getBoundingClientRect();
              return Math.abs(e3.clientY - (top2 + bottom2) / 2);
            }
          });
          const thumb = thumbs2[distances.indexOf(Math.min(...distances))];
          const index2 = thumbs2.indexOf(thumb);
          return { thumb, index: index2 };
        };
        const pointerMove = (e3) => {
          if (!get_store_value(isActive))
            return;
          e3.preventDefault();
          e3.stopPropagation();
          const sliderEl = getElementByMeltId($root["data-melt-id"]);
          const closestThumb = get_store_value(activeThumb);
          if (!sliderEl || !closestThumb)
            return;
          closestThumb.thumb.focus();
          const { left: left2, right: right2, top: top2, bottom: bottom2 } = sliderEl.getBoundingClientRect();
          switch ($direction) {
            case "lr": {
              applyPosition(e3.clientX, closestThumb.index, left2, right2);
              break;
            }
            case "rl": {
              applyPosition(e3.clientX, closestThumb.index, right2, left2);
              break;
            }
            case "bt": {
              applyPosition(e3.clientY, closestThumb.index, bottom2, top2);
              break;
            }
            case "tb": {
              applyPosition(e3.clientY, closestThumb.index, top2, bottom2);
              break;
            }
          }
        };
        const pointerDown = (e3) => {
          if (e3.button !== 0)
            return;
          const sliderEl = getElementByMeltId($root["data-melt-id"]);
          const closestThumb = getClosestThumb(e3);
          if (!closestThumb || !sliderEl)
            return;
          const target2 = e3.target;
          if (!isHTMLElement$1(target2) || !sliderEl.contains(target2)) {
            return;
          }
          e3.preventDefault();
          activeThumb.set(closestThumb);
          closestThumb.thumb.focus();
          isActive.set(true);
          pointerMove(e3);
        };
        const pointerUp = () => {
          isActive.set(false);
        };
        const unsub = executeCallbacks(addEventListener$1(document, "pointerdown", pointerDown), addEventListener$1(document, "pointerup", pointerUp), addEventListener$1(document, "pointerleave", pointerUp), addEventListener$1(document, "pointermove", pointerMove));
        return () => {
          unsub();
        };
      });
      effect([step, min2, max2, value2], function fixValue([$step, $min, $max, $value]) {
        const isValidValue = (v) => {
          const snappedValue = snapValueToStep(v, $min, $max, $step);
          return snappedValue === v;
        };
        const gcv = (v) => {
          return snapValueToStep(v, $min, $max, $step);
        };
        if ($value.some((v) => !isValidValue(v))) {
          value2.update((prev2) => {
            return prev2.map(gcv);
          });
        }
      });
      return {
        elements: {
          root: root2,
          thumbs,
          range: range2,
          ticks: ticks2
        },
        states: {
          value: value2
        },
        options
      };
    };
    function create_fragment$j(ctx) {
      let div;
      let span2;
      let t02;
      let t12;
      let button;
      let icon;
      let current2;
      let mounted;
      let dispose;
      icon = new Icon({
        props: { width: "16", height: "16", name: "close" }
      });
      let div_levels = [
        {
          class: "flex items-center gap-1 min-h-7 rounded-full pl-3 chip"
        },
        /*$$restProps*/
        ctx[3]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      return {
        c() {
          div = element$2("div");
          span2 = element$2("span");
          t02 = text$3(
            /*label*/
            ctx[0]
          );
          t12 = space();
          button = element$2("button");
          create_component(icon.$$.fragment);
          attr$6(span2, "class", "chip__label svelte-1pdhqvn");
          attr$6(button, "aria-label", "Remove");
          attr$6(button, "class", "flex items-center justify-center rounded-full chip__button svelte-1pdhqvn");
          set_attributes(div, div_data);
          toggle_class(div, "svelte-1pdhqvn", true);
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          append$2(div, span2);
          append$2(span2, t02);
          append$2(div, t12);
          append$2(div, button);
          mount_component(icon, button, null);
          ctx[4](div);
          current2 = true;
          if (!mounted) {
            dispose = listen(
              button,
              "click",
              /*onDeleteClick*/
              ctx[2]
            );
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          if (!current2 || dirty & /*label*/
          1)
            set_data(
              t02,
              /*label*/
              ctx2[0]
            );
          set_attributes(div, div_data = get_spread_update(div_levels, [
            {
              class: "flex items-center gap-1 min-h-7 rounded-full pl-3 chip"
            },
            dirty & /*$$restProps*/
            8 && /*$$restProps*/
            ctx2[3]
          ]));
          toggle_class(div, "svelte-1pdhqvn", true);
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_component(icon);
          ctx[4](null);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$i($$self, $$props, $$invalidate) {
      const omit_props_names = ["label"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let { label: label2 = "" } = $$props;
      let chip;
      const dispatch2 = createEventDispatcher();
      const onDeleteClick = () => {
        dispatch2("delete", { chip });
      };
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          chip = $$value;
          $$invalidate(1, chip);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("label" in $$new_props)
          $$invalidate(0, label2 = $$new_props.label);
      };
      return [label2, chip, onDeleteClick, $$restProps, div_binding];
    }
    class Chip extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$i, create_fragment$j, safe_not_equal, { label: 0 });
      }
    }
    function get_each_context$8(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[27] = list2[i];
      child_ctx[30] = i;
      const constants_0 = (
        /*$option*/
        child_ctx[12](
          /*o*/
          child_ctx[27]
        )
      );
      child_ctx[28] = constants_0;
      return child_ctx;
    }
    const get_item_slot_changes = (dirty) => ({
      option: dirty[0] & /*options*/
      4,
      index: dirty[0] & /*options*/
      4
    });
    const get_item_slot_context = (ctx) => ({
      option: (
        /*o*/
        ctx[27]
      ),
      index: (
        /*index*/
        ctx[30]
      )
    });
    function get_each_context_1$1(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[31] = list2[i];
      return child_ctx;
    }
    function create_else_block_1(ctx) {
      let icon;
      let current2;
      icon = new Icon({ props: { name: "arrow_drop_down" } });
      return {
        c() {
          create_component(icon.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(icon, target2, anchor2);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(icon, detaching);
        }
      };
    }
    function create_if_block_2$3(ctx) {
      let icon;
      let current2;
      icon = new Icon({ props: { name: "arrow_drop_up" } });
      return {
        c() {
          create_component(icon.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(icon, target2, anchor2);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(icon, detaching);
        }
      };
    }
    function create_if_block_1$5(ctx) {
      let div;
      let div_style_value;
      let current2;
      let each_value_1 = ensure_array_like(
        /*$selected*/
        ctx[6]
      );
      let each_blocks = [];
      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      return {
        c() {
          div = element$2("div");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          attr$6(div, "class", "flex flex-wrap gap-1");
          attr$6(div, "style", div_style_value = `max-width:${/*maxChipContainerWidth*/
          ctx[0]};`);
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(div, null);
            }
          }
          current2 = true;
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*$selected, onChipRemove*/
          1048640) {
            each_value_1 = ensure_array_like(
              /*$selected*/
              ctx2[6]
            );
            let i;
            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block_1$1(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(div, null);
              }
            }
            group_outros();
            for (i = each_value_1.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
          if (!current2 || dirty[0] & /*maxChipContainerWidth*/
          1 && div_style_value !== (div_style_value = `max-width:${/*maxChipContainerWidth*/
          ctx2[0]};`)) {
            attr$6(div, "style", div_style_value);
          }
        },
        i(local) {
          if (current2)
            return;
          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current2 = true;
        },
        o(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function create_each_block_1$1(ctx) {
      let chip;
      let current2;
      chip = new Chip({
        props: {
          label: (
            /*opt*/
            ctx[31].label
          ),
          "data-value": (
            /*opt*/
            ctx[31].value
          )
        }
      });
      chip.$on(
        "delete",
        /*onChipRemove*/
        ctx[20]
      );
      return {
        c() {
          create_component(chip.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(chip, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const chip_changes = {};
          if (dirty[0] & /*$selected*/
          64)
            chip_changes.label = /*opt*/
            ctx2[31].label;
          if (dirty[0] & /*$selected*/
          64)
            chip_changes["data-value"] = /*opt*/
            ctx2[31].value;
          chip.$set(chip_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(chip.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(chip.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(chip, detaching);
        }
      };
    }
    function create_if_block$9(ctx) {
      let ul;
      let each_blocks = [];
      let each_1_lookup = /* @__PURE__ */ new Map();
      let current2;
      let mounted;
      let dispose;
      let each_value = ensure_array_like(
        /*options*/
        ctx[2]
      );
      const get_key = (ctx2) => (
        /*index*/
        ctx2[30]
      );
      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$8(ctx, each_value, i);
        let key2 = get_key(child_ctx);
        each_1_lookup.set(key2, each_blocks[i] = create_each_block$8(key2, child_ctx));
      }
      let each_1_else = null;
      if (!each_value.length) {
        each_1_else = create_else_block$3();
      }
      let ul_levels = [
        {
          class: "flex flex-col p-2 gap-1 combobox__option-list overflow-y-scroll max-h-[400px]"
        },
        /*$menu*/
        ctx[11]
      ];
      let ul_data = {};
      for (let i = 0; i < ul_levels.length; i += 1) {
        ul_data = assign(ul_data, ul_levels[i]);
      }
      return {
        c() {
          ul = element$2("ul");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          if (each_1_else) {
            each_1_else.c();
          }
          set_attributes(ul, ul_data);
          toggle_class(ul, "svelte-1fyktuj", true);
        },
        m(target2, anchor2) {
          insert$2(target2, ul, anchor2);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(ul, null);
            }
          }
          if (each_1_else) {
            each_1_else.m(ul, null);
          }
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(
              /*$menu*/
              ctx[11].action(ul)
            );
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*$option, options, noMinItemHeight, $$scope*/
          8392740) {
            each_value = ensure_array_like(
              /*options*/
              ctx2[2]
            );
            group_outros();
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$8, null, get_each_context$8);
            check_outros();
            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx2, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block$3();
              each_1_else.c();
              each_1_else.m(ul, null);
            } else if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          }
          set_attributes(ul, ul_data = get_spread_update(ul_levels, [
            {
              class: "flex flex-col p-2 gap-1 combobox__option-list overflow-y-scroll max-h-[400px]"
            },
            dirty[0] & /*$menu*/
            2048 && /*$menu*/
            ctx2[11]
          ]));
          toggle_class(ul, "svelte-1fyktuj", true);
        },
        i(local) {
          if (current2)
            return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current2 = true;
        },
        o(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(ul);
          }
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
          if (each_1_else)
            each_1_else.d();
          mounted = false;
          dispose();
        }
      };
    }
    function create_else_block$3(ctx) {
      let li;
      return {
        c() {
          li = element$2("li");
          li.textContent = "No results found\n            ";
          attr$6(li, "class", "relative cursor-pointer rounded-md py-1 pl-8 pr-4");
        },
        m(target2, anchor2) {
          insert$2(target2, li, anchor2);
        },
        p: noop$6,
        d(detaching) {
          if (detaching) {
            detach(li);
          }
        }
      };
    }
    function fallback_block(ctx) {
      let span2;
      let t_value = (
        /*o*/
        ctx[27].label + ""
      );
      let t4;
      return {
        c() {
          span2 = element$2("span");
          t4 = text$3(t_value);
        },
        m(target2, anchor2) {
          insert$2(target2, span2, anchor2);
          append$2(span2, t4);
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*options*/
          4 && t_value !== (t_value = /*o*/
          ctx2[27].label + ""))
            set_data(t4, t_value);
        },
        d(detaching) {
          if (detaching) {
            detach(span2);
          }
        }
      };
    }
    function create_each_block$8(key_1, ctx) {
      let li;
      let t4;
      let li_class_value;
      let current2;
      let mounted;
      let dispose;
      const item_slot_template = (
        /*#slots*/
        ctx[24].item
      );
      const item_slot = create_slot(
        item_slot_template,
        ctx,
        /*$$scope*/
        ctx[23],
        get_item_slot_context
      );
      const item_slot_or_fallback = item_slot || fallback_block(ctx);
      let li_levels = [
        {
          class: li_class_value = "flex items-center relative px-3 scroll-my-2 combobox__option"
        },
        /*__MELTUI_BUILDER_0__*/
        ctx[28]
      ];
      let li_data = {};
      for (let i = 0; i < li_levels.length; i += 1) {
        li_data = assign(li_data, li_levels[i]);
      }
      return {
        key: key_1,
        first: null,
        c() {
          li = element$2("li");
          if (item_slot_or_fallback)
            item_slot_or_fallback.c();
          t4 = space();
          set_attributes(li, li_data);
          toggle_class(li, "min-h-10", !/*noMinItemHeight*/
          ctx[5]);
          toggle_class(li, "svelte-1fyktuj", true);
          this.first = li;
        },
        m(target2, anchor2) {
          insert$2(target2, li, anchor2);
          if (item_slot_or_fallback) {
            item_slot_or_fallback.m(li, null);
          }
          append$2(li, t4);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(
              /*__MELTUI_BUILDER_0__*/
              ctx[28].action(li)
            );
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (item_slot) {
            if (item_slot.p && (!current2 || dirty[0] & /*$$scope, options*/
            8388612)) {
              update_slot_base(
                item_slot,
                item_slot_template,
                ctx,
                /*$$scope*/
                ctx[23],
                !current2 ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx[23]
                ) : get_slot_changes(
                  item_slot_template,
                  /*$$scope*/
                  ctx[23],
                  dirty,
                  get_item_slot_changes
                ),
                get_item_slot_context
              );
            }
          } else {
            if (item_slot_or_fallback && item_slot_or_fallback.p && (!current2 || dirty[0] & /*options*/
            4)) {
              item_slot_or_fallback.p(ctx, !current2 ? [-1, -1] : dirty);
            }
          }
          set_attributes(li, li_data = get_spread_update(li_levels, [
            { class: li_class_value },
            dirty[0] & /*$option, options*/
            4100 && /*__MELTUI_BUILDER_0__*/
            ctx[28]
          ]));
          toggle_class(li, "min-h-10", !/*noMinItemHeight*/
          ctx[5]);
          toggle_class(li, "svelte-1fyktuj", true);
        },
        i(local) {
          if (current2)
            return;
          transition_in(item_slot_or_fallback, local);
          current2 = true;
        },
        o(local) {
          transition_out(item_slot_or_fallback, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          if (item_slot_or_fallback)
            item_slot_or_fallback.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$i(ctx) {
      let div2;
      let label_1;
      let t02;
      let t12;
      let div1;
      let input_1;
      let input_1_value_value;
      let t22;
      let div0;
      let current_block_type_index;
      let if_block0;
      let t32;
      let show_if = (
        /*multiselect*/
        ctx[4] && Array.isArray(
          /*$selected*/
          ctx[6]
        ) && /*$selected*/
        ctx[6].length
      );
      let t4;
      let if_block2_anchor;
      let current2;
      let mounted;
      let dispose;
      let label_1_levels = [
        /*$inputLabel*/
        ctx[9],
        {
          class: "text-xs text-gray-500 p-2 select-none"
        }
      ];
      let label_data = {};
      for (let i = 0; i < label_1_levels.length; i += 1) {
        label_data = assign(label_data, label_1_levels[i]);
      }
      let input_1_levels = [
        /*$input*/
        ctx[10],
        {
          class: "min-h-10 px-3 w-full combobox__field"
        },
        { placeholder: (
          /*placeholder*/
          ctx[3]
        ) },
        {
          value: input_1_value_value = /*valueLabel*/
          ctx[8]()
        }
      ];
      let input_data = {};
      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_data = assign(input_data, input_1_levels[i]);
      }
      const if_block_creators = [create_if_block_2$3, create_else_block_1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (
          /*$open*/
          ctx2[7]
        )
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div0_levels = [
        {
          class: "absolute right-2 top-1/2 z-10 -translate-y-1/2"
        },
        /*$input*/
        ctx[10]
      ];
      let div_data = {};
      for (let i = 0; i < div0_levels.length; i += 1) {
        div_data = assign(div_data, div0_levels[i]);
      }
      let if_block1 = show_if && create_if_block_1$5(ctx);
      let if_block2 = (
        /*$open*/
        ctx[7] && create_if_block$9(ctx)
      );
      return {
        c() {
          div2 = element$2("div");
          label_1 = element$2("label");
          t02 = text$3(
            /*label*/
            ctx[1]
          );
          t12 = space();
          div1 = element$2("div");
          input_1 = element$2("input");
          t22 = space();
          div0 = element$2("div");
          if_block0.c();
          t32 = space();
          if (if_block1)
            if_block1.c();
          t4 = space();
          if (if_block2)
            if_block2.c();
          if_block2_anchor = empty$1();
          set_attributes(label_1, label_data);
          toggle_class(label_1, "svelte-1fyktuj", true);
          set_attributes(input_1, input_data);
          toggle_class(input_1, "svelte-1fyktuj", true);
          set_attributes(div0, div_data);
          toggle_class(div0, "svelte-1fyktuj", true);
          attr$6(div1, "class", "relative");
          attr$6(div2, "class", "flex flex-col gap-1 combobox");
        },
        m(target2, anchor2) {
          insert$2(target2, div2, anchor2);
          append$2(div2, label_1);
          append$2(label_1, t02);
          append$2(div2, t12);
          append$2(div2, div1);
          append$2(div1, input_1);
          if ("value" in input_data) {
            input_1.value = input_data.value;
          }
          if (input_1.autofocus)
            input_1.focus();
          append$2(div1, t22);
          append$2(div1, div0);
          if_blocks[current_block_type_index].m(div0, null);
          append$2(div2, t32);
          if (if_block1)
            if_block1.m(div2, null);
          insert$2(target2, t4, anchor2);
          if (if_block2)
            if_block2.m(target2, anchor2);
          insert$2(target2, if_block2_anchor, anchor2);
          current2 = true;
          if (!mounted) {
            dispose = [
              action_destroyer(
                /*$inputLabel*/
                ctx[9].action(label_1)
              ),
              action_destroyer(
                /*$input*/
                ctx[10].action(input_1)
              ),
              action_destroyer(
                /*$input*/
                ctx[10].action(div0)
              )
            ];
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          if (!current2 || dirty[0] & /*label*/
          2)
            set_data_maybe_contenteditable(
              t02,
              /*label*/
              ctx2[1],
              label_data["contenteditable"]
            );
          set_attributes(label_1, label_data = get_spread_update(label_1_levels, [
            dirty[0] & /*$inputLabel*/
            512 && /*$inputLabel*/
            ctx2[9],
            {
              class: "text-xs text-gray-500 p-2 select-none"
            }
          ]));
          toggle_class(label_1, "svelte-1fyktuj", true);
          set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
            dirty[0] & /*$input*/
            1024 && /*$input*/
            ctx2[10],
            {
              class: "min-h-10 px-3 w-full combobox__field"
            },
            (!current2 || dirty[0] & /*placeholder*/
            8) && { placeholder: (
              /*placeholder*/
              ctx2[3]
            ) },
            (!current2 || dirty[0] & /*valueLabel*/
            256 && input_1_value_value !== (input_1_value_value = /*valueLabel*/
            ctx2[8]()) && input_1.value !== input_1_value_value) && { value: input_1_value_value }
          ]));
          if ("value" in input_data) {
            input_1.value = input_data.value;
          }
          toggle_class(input_1, "svelte-1fyktuj", true);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index !== previous_block_index) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];
            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block0.c();
            }
            transition_in(if_block0, 1);
            if_block0.m(div0, null);
          }
          set_attributes(div0, div_data = get_spread_update(div0_levels, [
            {
              class: "absolute right-2 top-1/2 z-10 -translate-y-1/2"
            },
            dirty[0] & /*$input*/
            1024 && /*$input*/
            ctx2[10]
          ]));
          toggle_class(div0, "svelte-1fyktuj", true);
          if (dirty[0] & /*multiselect, $selected*/
          80)
            show_if = /*multiselect*/
            ctx2[4] && Array.isArray(
              /*$selected*/
              ctx2[6]
            ) && /*$selected*/
            ctx2[6].length;
          if (show_if) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & /*multiselect, $selected*/
              80) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_1$5(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div2, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (
            /*$open*/
            ctx2[7]
          ) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & /*$open*/
              128) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block$9(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current2 = true;
        },
        o(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
            detach(t4);
            detach(if_block2_anchor);
          }
          if_blocks[current_block_type_index].d();
          if (if_block1)
            if_block1.d();
          if (if_block2)
            if_block2.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$h($$self, $$props, $$invalidate) {
      let valueLabel;
      let $selected;
      let $inputValue;
      let $open;
      let $inputLabel;
      let $input;
      let $menu;
      let $option;
      let { $$slots: slots = {}, $$scope } = $$props;
      let { maxChipContainerWidth = "auto" } = $$props;
      let { label: label2 = "" } = $$props;
      let { options = [] } = $$props;
      let { placeholder = "" } = $$props;
      let { multiselect = false } = $$props;
      let { value: value2 } = $$props;
      let { noMinItemHeight = false } = $$props;
      let { customValueLabel = () => value2 } = $$props;
      const dispatch2 = createEventDispatcher();
      const { elements: { menu: menu2, input, option, label: inputLabel }, states: { open, inputValue, selected } } = createCombobox({
        forceVisible: true,
        multiple: multiselect,
        onSelectedChange: ({ next: next2 }) => {
          if (multiselect) {
            $$invalidate(21, value2 = next2.map((v) => v.value));
          } else {
            $$invalidate(21, value2 = next2.value);
          }
          dispatch2("change", { value: value2 });
          return next2;
        },
        defaultSelected: options.filter((o) => !!value2 && value2.includes(o.value))
      });
      component_subscribe($$self, menu2, (value3) => $$invalidate(11, $menu = value3));
      component_subscribe($$self, input, (value3) => $$invalidate(10, $input = value3));
      component_subscribe($$self, option, (value3) => $$invalidate(12, $option = value3));
      component_subscribe($$self, inputLabel, (value3) => $$invalidate(9, $inputLabel = value3));
      component_subscribe($$self, open, (value3) => $$invalidate(7, $open = value3));
      component_subscribe($$self, inputValue, (value3) => $$invalidate(25, $inputValue = value3));
      component_subscribe($$self, selected, (value3) => $$invalidate(6, $selected = value3));
      const onChipRemove = (e3) => {
        const { value: value22 } = e3.detail.chip.dataset;
        selected.update((opts) => {
          const idx = opts.findIndex((opt) => opt.value === value22);
          return opts.filter((_, i) => i !== idx);
        });
      };
      $$self.$$set = ($$props2) => {
        if ("maxChipContainerWidth" in $$props2)
          $$invalidate(0, maxChipContainerWidth = $$props2.maxChipContainerWidth);
        if ("label" in $$props2)
          $$invalidate(1, label2 = $$props2.label);
        if ("options" in $$props2)
          $$invalidate(2, options = $$props2.options);
        if ("placeholder" in $$props2)
          $$invalidate(3, placeholder = $$props2.placeholder);
        if ("multiselect" in $$props2)
          $$invalidate(4, multiselect = $$props2.multiselect);
        if ("value" in $$props2)
          $$invalidate(21, value2 = $$props2.value);
        if ("noMinItemHeight" in $$props2)
          $$invalidate(5, noMinItemHeight = $$props2.noMinItemHeight);
        if ("customValueLabel" in $$props2)
          $$invalidate(22, customValueLabel = $$props2.customValueLabel);
        if ("$$scope" in $$props2)
          $$invalidate(23, $$scope = $$props2.$$scope);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*multiselect, $open, $selected*/
        208) {
          if (!multiselect && !$open) {
            set_store_value(inputValue, $inputValue = ($selected == null ? void 0 : $selected.label) ?? "", $inputValue);
          }
        }
        if ($$self.$$.dirty[0] & /*customValueLabel, value, options, multiselect*/
        6291476) {
          $$invalidate(8, valueLabel = () => {
            if (customValueLabel)
              return customValueLabel(value2, options);
            if (multiselect) {
              return value2.map((v) => options.find((o) => o.value === v).label);
            } else {
              return options.find((o) => o.value === value2).label;
            }
          });
        }
      };
      return [
        maxChipContainerWidth,
        label2,
        options,
        placeholder,
        multiselect,
        noMinItemHeight,
        $selected,
        $open,
        valueLabel,
        $inputLabel,
        $input,
        $menu,
        $option,
        menu2,
        input,
        option,
        inputLabel,
        open,
        inputValue,
        selected,
        onChipRemove,
        value2,
        customValueLabel,
        $$scope,
        slots
      ];
    }
    class Combobox extends SvelteComponent {
      constructor(options) {
        super();
        init$2(
          this,
          options,
          instance$h,
          create_fragment$i,
          safe_not_equal,
          {
            maxChipContainerWidth: 0,
            label: 1,
            options: 2,
            placeholder: 3,
            multiselect: 4,
            value: 21,
            noMinItemHeight: 5,
            customValueLabel: 22
          },
          null,
          [-1, -1]
        );
      }
    }
    const RedsNoDanger = [
      "primary__energy_red_55",
      "substitute__pink_salmon",
      "primary__energy_red_13",
      "substitute__purple_berry",
      "primary__energy_red_34",
      "substitute__pink_rose",
      "primary__energy_red_21"
    ];
    const Greens = [
      "primary__lichen_green",
      "primary__moss_green_100",
      "primary__moss_green_13",
      "primary__moss_green_21",
      "primary__moss_green_34",
      "primary__moss_green_55",
      "substitute__green_cucumber",
      "substitute__green_mint",
      "substitute__green_succulent"
    ];
    const Blues = [
      "primary__slate_blue",
      "primary__mist_blue",
      "substitute__blue_ocean",
      "substitute__blue_overcast",
      "substitute__blue_sky"
    ];
    const Beiges = ["primary__spruce_wood"];
    const WarningReds = [
      "primary__energy_red_100",
      "primary__weathered_red"
    ];
    const _ColorPickingStrategy = [
      Blues,
      RedsNoDanger,
      Greens,
      Beiges
    ];
    const _OverlayColorPickingStrategy = [WarningReds];
    function* PickColor(strategy) {
      const sourceLists = strategy.map((s) => [...s].reverse());
      while (sourceLists.map((s) => s.length).reduce((p, c2) => p + c2, 0) > 0) {
        for (let list2 of sourceLists) {
          if (list2.length > 0)
            yield list2.pop();
        }
      }
    }
    const style$1 = getComputedStyle(document.body);
    const resolveColor = (key2) => style$1.getPropertyValue(`--eds_infographic_${key2}`);
    const SortedEDSColors = [...PickColor(_ColorPickingStrategy)].map(
      (k) => resolveColor(k)
    );
    const SortedEDSWarningColors = [
      ...PickColor(_OverlayColorPickingStrategy)
    ].map((k) => resolveColor(k));
    function ascending$3(a2, b2) {
      return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
    }
    function descending$1(a2, b2) {
      return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
    }
    function bisector(f) {
      let compare12, compare2, delta;
      if (f.length !== 2) {
        compare12 = ascending$3;
        compare2 = (d, x2) => ascending$3(f(d), x2);
        delta = (d, x2) => f(d) - x2;
      } else {
        compare12 = f === ascending$3 || f === descending$1 ? f : zero$4;
        compare2 = f;
        delta = f;
      }
      function left2(a2, x2, lo = 0, hi = a2.length) {
        if (lo < hi) {
          if (compare12(x2, x2) !== 0)
            return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a2[mid], x2) < 0)
              lo = mid + 1;
            else
              hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function right2(a2, x2, lo = 0, hi = a2.length) {
        if (lo < hi) {
          if (compare12(x2, x2) !== 0)
            return hi;
          do {
            const mid = lo + hi >>> 1;
            if (compare2(a2[mid], x2) <= 0)
              lo = mid + 1;
            else
              hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function center2(a2, x2, lo = 0, hi = a2.length) {
        const i = left2(a2, x2, lo, hi - 1);
        return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
      }
      return { left: left2, center: center2, right: right2 };
    }
    function zero$4() {
      return 0;
    }
    function number$7(x2) {
      return x2 === null ? NaN : +x2;
    }
    function* numbers$2(values2, valueof) {
      if (valueof === void 0) {
        for (let value2 of values2) {
          if (value2 != null && (value2 = +value2) >= value2) {
            yield value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
            yield value2;
          }
        }
      }
    }
    const ascendingBisect = bisector(ascending$3);
    const bisectRight$1 = ascendingBisect.right;
    const bisectLeft$1 = ascendingBisect.left;
    bisector(number$7).center;
    const bisect$1 = bisectRight$1;
    function variance(values2, valueof) {
      let count2 = 0;
      let delta;
      let mean2 = 0;
      let sum2 = 0;
      if (valueof === void 0) {
        for (let value2 of values2) {
          if (value2 != null && (value2 = +value2) >= value2) {
            delta = value2 - mean2;
            mean2 += delta / ++count2;
            sum2 += delta * (value2 - mean2);
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
            delta = value2 - mean2;
            mean2 += delta / ++count2;
            sum2 += delta * (value2 - mean2);
          }
        }
      }
      if (count2 > 1)
        return sum2 / (count2 - 1);
    }
    function deviation(values2, valueof) {
      const v = variance(values2, valueof);
      return v ? Math.sqrt(v) : v;
    }
    function extent$1(values2, valueof) {
      let min2;
      let max2;
      if (valueof === void 0) {
        for (const value2 of values2) {
          if (value2 != null) {
            if (min2 === void 0) {
              if (value2 >= value2)
                min2 = max2 = value2;
            } else {
              if (min2 > value2)
                min2 = value2;
              if (max2 < value2)
                max2 = value2;
            }
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null) {
            if (min2 === void 0) {
              if (value2 >= value2)
                min2 = max2 = value2;
            } else {
              if (min2 > value2)
                min2 = value2;
              if (max2 < value2)
                max2 = value2;
            }
          }
        }
      }
      return [min2, max2];
    }
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x2) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
          if (lo)
            p[i++] = lo;
          x2 = hi;
        }
        p[i] = x2;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x2, y2, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x2 = hi;
            y2 = p[--n];
            hi = x2 + y2;
            lo = y2 - (hi - x2);
            if (lo)
              break;
          }
          if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
            y2 = lo * 2;
            x2 = hi + y2;
            if (y2 == x2 - hi)
              hi = x2;
          }
        }
        return hi;
      }
    }
    class InternMap extends Map {
      constructor(entries2, key2 = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
        if (entries2 != null)
          for (const [key3, value2] of entries2)
            this.set(key3, value2);
      }
      get(key2) {
        return super.get(intern_get(this, key2));
      }
      has(key2) {
        return super.has(intern_get(this, key2));
      }
      set(key2, value2) {
        return super.set(intern_set(this, key2), value2);
      }
      delete(key2) {
        return super.delete(intern_delete(this, key2));
      }
    }
    class InternSet extends Set {
      constructor(values2, key2 = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
        if (values2 != null)
          for (const value2 of values2)
            this.add(value2);
      }
      has(value2) {
        return super.has(intern_get(this, value2));
      }
      add(value2) {
        return super.add(intern_set(this, value2));
      }
      delete(value2) {
        return super.delete(intern_delete(this, value2));
      }
    }
    function intern_get({ _intern, _key }, value2) {
      const key2 = _key(value2);
      return _intern.has(key2) ? _intern.get(key2) : value2;
    }
    function intern_set({ _intern, _key }, value2) {
      const key2 = _key(value2);
      if (_intern.has(key2))
        return _intern.get(key2);
      _intern.set(key2, value2);
      return value2;
    }
    function intern_delete({ _intern, _key }, value2) {
      const key2 = _key(value2);
      if (_intern.has(key2)) {
        value2 = _intern.get(key2);
        _intern.delete(key2);
      }
      return value2;
    }
    function keyof(value2) {
      return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
    }
    function permute(source2, keys2) {
      return Array.from(keys2, (key2) => source2[key2]);
    }
    function compareDefined(compare2 = ascending$3) {
      if (compare2 === ascending$3)
        return ascendingDefined;
      if (typeof compare2 !== "function")
        throw new TypeError("compare is not a function");
      return (a2, b2) => {
        const x2 = compare2(a2, b2);
        if (x2 || x2 === 0)
          return x2;
        return (compare2(b2, b2) === 0) - (compare2(a2, a2) === 0);
      };
    }
    function ascendingDefined(a2, b2) {
      return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
    }
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    function tickSpec(start2, stop2, count2) {
      const step = (stop2 - start2) / Math.max(0, count2), power2 = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power2), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power2 < 0) {
        inc = Math.pow(10, -power2) / factor;
        i1 = Math.round(start2 * inc);
        i2 = Math.round(stop2 * inc);
        if (i1 / inc < start2)
          ++i1;
        if (i2 / inc > stop2)
          --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power2) * factor;
        i1 = Math.round(start2 / inc);
        i2 = Math.round(stop2 / inc);
        if (i1 * inc < start2)
          ++i1;
        if (i2 * inc > stop2)
          --i2;
      }
      if (i2 < i1 && 0.5 <= count2 && count2 < 2)
        return tickSpec(start2, stop2, count2 * 2);
      return [i1, i2, inc];
    }
    function ticks(start2, stop2, count2) {
      stop2 = +stop2, start2 = +start2, count2 = +count2;
      if (!(count2 > 0))
        return [];
      if (start2 === stop2)
        return [start2];
      const reverse2 = stop2 < start2, [i1, i2, inc] = reverse2 ? tickSpec(stop2, start2, count2) : tickSpec(start2, stop2, count2);
      if (!(i2 >= i1))
        return [];
      const n = i2 - i1 + 1, ticks2 = new Array(n);
      if (reverse2) {
        if (inc < 0)
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i2 - i) / -inc;
        else
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i2 - i) * inc;
      } else {
        if (inc < 0)
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i1 + i) / -inc;
        else
          for (let i = 0; i < n; ++i)
            ticks2[i] = (i1 + i) * inc;
      }
      return ticks2;
    }
    function tickIncrement(start2, stop2, count2) {
      stop2 = +stop2, start2 = +start2, count2 = +count2;
      return tickSpec(start2, stop2, count2)[2];
    }
    function tickStep(start2, stop2, count2) {
      stop2 = +stop2, start2 = +start2, count2 = +count2;
      const reverse2 = stop2 < start2, inc = reverse2 ? tickIncrement(stop2, start2, count2) : tickIncrement(start2, stop2, count2);
      return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }
    function max$2(values2, valueof) {
      let max2;
      if (valueof === void 0) {
        for (const value2 of values2) {
          if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
            max2 = value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
            max2 = value2;
          }
        }
      }
      return max2;
    }
    function min$2(values2, valueof) {
      let min2;
      if (valueof === void 0) {
        for (const value2 of values2) {
          if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
            min2 = value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
            min2 = value2;
          }
        }
      }
      return min2;
    }
    function quickselect(array2, k, left2 = 0, right2 = Infinity, compare2) {
      k = Math.floor(k);
      left2 = Math.floor(Math.max(0, left2));
      right2 = Math.floor(Math.min(array2.length - 1, right2));
      if (!(left2 <= k && k <= right2))
        return array2;
      compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
      while (right2 > left2) {
        if (right2 - left2 > 600) {
          const n = right2 - left2 + 1;
          const m2 = k - left2 + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left2, Math.floor(k - m2 * s / n + sd));
          const newRight = Math.min(right2, Math.floor(k + (n - m2) * s / n + sd));
          quickselect(array2, k, newLeft, newRight, compare2);
        }
        const t4 = array2[k];
        let i = left2;
        let j = right2;
        swap$1(array2, left2, k);
        if (compare2(array2[right2], t4) > 0)
          swap$1(array2, left2, right2);
        while (i < j) {
          swap$1(array2, i, j), ++i, --j;
          while (compare2(array2[i], t4) < 0)
            ++i;
          while (compare2(array2[j], t4) > 0)
            --j;
        }
        if (compare2(array2[left2], t4) === 0)
          swap$1(array2, left2, j);
        else
          ++j, swap$1(array2, j, right2);
        if (j <= k)
          left2 = j + 1;
        if (k <= j)
          right2 = j - 1;
      }
      return array2;
    }
    function swap$1(array2, i, j) {
      const t4 = array2[i];
      array2[i] = array2[j];
      array2[j] = t4;
    }
    function quantile$1(values2, p, valueof) {
      values2 = Float64Array.from(numbers$2(values2, valueof));
      if (!(n = values2.length) || isNaN(p = +p))
        return;
      if (p <= 0 || n < 2)
        return min$2(values2);
      if (p >= 1)
        return max$2(values2);
      var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$2(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min$2(values2.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }
    function quantileSorted(values2, p, valueof = number$7) {
      if (!(n = values2.length) || isNaN(p = +p))
        return;
      if (p <= 0 || n < 2)
        return +valueof(values2[0], 0, values2);
      if (p >= 1)
        return +valueof(values2[n - 1], n - 1, values2);
      var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
      return value0 + (value1 - value0) * (i - i0);
    }
    function mean(values2, valueof) {
      let count2 = 0;
      let sum2 = 0;
      if (valueof === void 0) {
        for (let value2 of values2) {
          if (value2 != null && (value2 = +value2) >= value2) {
            ++count2, sum2 += value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if ((value2 = valueof(value2, ++index2, values2)) != null && (value2 = +value2) >= value2) {
            ++count2, sum2 += value2;
          }
        }
      }
      if (count2)
        return sum2 / count2;
    }
    function median(values2, valueof) {
      return quantile$1(values2, 0.5, valueof);
    }
    function* flatten(arrays) {
      for (const array2 of arrays) {
        yield* array2;
      }
    }
    function merge$3(arrays) {
      return Array.from(flatten(arrays));
    }
    function range$5(start2, stop2, step) {
      start2 = +start2, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
      var i = -1, n = Math.max(0, Math.ceil((stop2 - start2) / step)) | 0, range2 = new Array(n);
      while (++i < n) {
        range2[i] = start2 + i * step;
      }
      return range2;
    }
    function sum$1(values2, valueof) {
      let sum2 = 0;
      if (valueof === void 0) {
        for (let value2 of values2) {
          if (value2 = +value2) {
            sum2 += value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          if (value2 = +valueof(value2, ++index2, values2)) {
            sum2 += value2;
          }
        }
      }
      return sum2;
    }
    function intersection(values2, ...others) {
      values2 = new InternSet(values2);
      others = others.map(set$6);
      out:
        for (const value2 of values2) {
          for (const other of others) {
            if (!other.has(value2)) {
              values2.delete(value2);
              continue out;
            }
          }
        }
      return values2;
    }
    function set$6(values2) {
      return values2 instanceof InternSet ? values2 : new InternSet(values2);
    }
    function union(...others) {
      const set2 = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set2.add(o);
        }
      }
      return set2;
    }
    function identity$7(x2) {
      return x2;
    }
    var top = 1, right = 2, bottom = 3, left = 4, epsilon$7 = 1e-6;
    function translateX(x2) {
      return "translate(" + x2 + ",0)";
    }
    function translateY(y2) {
      return "translate(0," + y2 + ")";
    }
    function number$6(scale2) {
      return (d) => +scale2(d);
    }
    function center(scale2, offset2) {
      offset2 = Math.max(0, scale2.bandwidth() - offset2 * 2) / 2;
      if (scale2.round())
        offset2 = Math.round(offset2);
      return (d) => +scale2(d) + offset2;
    }
    function entering() {
      return !this.__axis;
    }
    function axis(orient2, scale2) {
      var tickArguments = [], tickValues2 = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient2 === top || orient2 === left ? -1 : 1, x2 = orient2 === left || orient2 === right ? "x" : "y", transform2 = orient2 === top || orient2 === bottom ? translateX : translateY;
      function axis2(context2) {
        var values2 = tickValues2 == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues2, format2 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity$7 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale2.range(), range0 = +range2[0] + offset2, range1 = +range2[range2.length - 1] + offset2, position2 = (scale2.bandwidth ? center : number$6)(scale2.copy(), offset2), selection2 = context2.selection ? context2.selection() : context2, path2 = selection2.selectAll(".domain").data([null]), tick2 = selection2.selectAll(".tick").data(values2, scale2).order(), tickExit = tick2.exit(), tickEnter = tick2.enter().append("g").attr("class", "tick"), line2 = tick2.select("line"), text2 = tick2.select("text");
        path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
        tick2 = tick2.merge(tickEnter);
        line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
        text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient2 === top ? "0em" : orient2 === bottom ? "0.71em" : "0.32em"));
        if (context2 !== selection2) {
          path2 = path2.transition(context2);
          tick2 = tick2.transition(context2);
          line2 = line2.transition(context2);
          text2 = text2.transition(context2);
          tickExit = tickExit.transition(context2).attr("opacity", epsilon$7).attr("transform", function(d) {
            return isFinite(d = position2(d)) ? transform2(d + offset2) : this.getAttribute("transform");
          });
          tickEnter.attr("opacity", epsilon$7).attr("transform", function(d) {
            var p = this.parentNode.__axis;
            return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset2);
          });
        }
        tickExit.remove();
        path2.attr("d", orient2 === left || orient2 === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
        tick2.attr("opacity", 1).attr("transform", function(d) {
          return transform2(position2(d) + offset2);
        });
        line2.attr(x2 + "2", k * tickSizeInner);
        text2.attr(x2, k * spacing).text(format2);
        selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient2 === right ? "start" : orient2 === left ? "end" : "middle");
        selection2.each(function() {
          this.__axis = position2;
        });
      }
      axis2.scale = function(_) {
        return arguments.length ? (scale2 = _, axis2) : scale2;
      };
      axis2.ticks = function() {
        return tickArguments = Array.from(arguments), axis2;
      };
      axis2.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
      };
      axis2.tickValues = function(_) {
        return arguments.length ? (tickValues2 = _ == null ? null : Array.from(_), axis2) : tickValues2 && tickValues2.slice();
      };
      axis2.tickFormat = function(_) {
        return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
      };
      axis2.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
      };
      axis2.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
      };
      axis2.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
      };
      axis2.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
      };
      axis2.offset = function(_) {
        return arguments.length ? (offset2 = +_, axis2) : offset2;
      };
      return axis2;
    }
    function axisBottom(scale2) {
      return axis(bottom, scale2);
    }
    function axisLeft(scale2) {
      return axis(left, scale2);
    }
    var noop$4 = { value: () => {
    } };
    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t4; i < n; ++i) {
        if (!(t4 = arguments[i] + "") || t4 in _ || /[\s.]/.test(t4))
          throw new Error("illegal type: " + t4);
        _[t4] = [];
      }
      return new Dispatch(_);
    }
    function Dispatch(_) {
      this._ = _;
    }
    function parseTypenames$1(typenames, types2) {
      return typenames.trim().split(/^|\s+/).map(function(t4) {
        var name2 = "", i = t4.indexOf(".");
        if (i >= 0)
          name2 = t4.slice(i + 1), t4 = t4.slice(0, i);
        if (t4 && !types2.hasOwnProperty(t4))
          throw new Error("unknown type: " + t4);
        return { type: t4, name: name2 };
      });
    }
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames$1(typename + "", _), t4, i = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i < n)
            if ((t4 = (typename = T[i]).type) && (t4 = get$6(_[t4], typename.name)))
              return t4;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t4 = (typename = T[i]).type)
            _[t4] = set$5(_[t4], typename.name, callback);
          else if (callback == null)
            for (t4 in _)
              _[t4] = set$5(_[t4], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy2 = {}, _ = this._;
        for (var t4 in _)
          copy2[t4] = _[t4].slice();
        return new Dispatch(copy2);
      },
      call: function(type2, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i = 0, n, t4; i < n; ++i)
            args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (t4 = this._[type2], i = 0, n = t4.length; i < n; ++i)
          t4[i].value.apply(that, args);
      },
      apply: function(type2, that, args) {
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (var t4 = this._[type2], i = 0, n = t4.length; i < n; ++i)
          t4[i].value.apply(that, args);
      }
    };
    function get$6(type2, name2) {
      for (var i = 0, n = type2.length, c2; i < n; ++i) {
        if ((c2 = type2[i]).name === name2) {
          return c2.value;
        }
      }
    }
    function set$5(type2, name2, callback) {
      for (var i = 0, n = type2.length; i < n; ++i) {
        if (type2[i].name === name2) {
          type2[i] = noop$4, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
          break;
        }
      }
      if (callback != null)
        type2.push({ name: name2, value: callback });
      return type2;
    }
    var xhtml = "http://www.w3.org/1999/xhtml";
    const namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    function namespace(name2) {
      var prefix = name2 += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns")
        name2 = name2.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name2 } : name2;
    }
    function creatorInherit(name2) {
      return function() {
        var document2 = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
      };
    }
    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator(name2) {
      var fullname = namespace(name2);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
    function none() {
    }
    function selector(selector2) {
      return selector2 == null ? none : function() {
        return this.querySelector(selector2);
      };
    }
    function selection_select(select2) {
      if (typeof select2 !== "function")
        select2 = selector(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group2[i]) && (subnode = select2.call(node, node.__data__, i, group2))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function array$6(x2) {
      return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
    }
    function empty() {
      return [];
    }
    function selectorAll(selector2) {
      return selector2 == null ? empty : function() {
        return this.querySelectorAll(selector2);
      };
    }
    function arrayAll(select2) {
      return function() {
        return array$6(select2.apply(this, arguments));
      };
    }
    function selection_selectAll(select2) {
      if (typeof select2 === "function")
        select2 = arrayAll(select2);
      else
        select2 = selectorAll(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
          if (node = group2[i]) {
            subgroups.push(select2.call(node, node.__data__, i, group2));
            parents.push(node);
          }
        }
      }
      return new Selection$1(subgroups, parents);
    }
    function matcher(selector2) {
      return function() {
        return this.matches(selector2);
      };
    }
    function childMatcher(selector2) {
      return function(node) {
        return node.matches(selector2);
      };
    }
    var find$3 = Array.prototype.find;
    function childFind(match2) {
      return function() {
        return find$3.call(this.children, match2);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild(match2) {
      return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
    }
    var filter$2 = Array.prototype.filter;
    function children$2() {
      return Array.from(this.children);
    }
    function childrenFilter(match2) {
      return function() {
        return filter$2.call(this.children, match2);
      };
    }
    function selection_selectChildren(match2) {
      return this.selectAll(match2 == null ? children$2 : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
    }
    function selection_filter(match2) {
      if (typeof match2 !== "function")
        match2 = matcher(match2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group2[i]) && match2.call(node, node.__data__, i, group2)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function sparse(update2) {
      return new Array(update2.length);
    }
    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum2) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum2;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next2) {
        return this._parent.insertBefore(child, next2);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    function constant$6(x2) {
      return function() {
        return x2;
      };
    }
    function bindIndex(parent, group2, enter, update2, exit, data2) {
      var i = 0, node, groupLength = group2.length, dataLength = data2.length;
      for (; i < dataLength; ++i) {
        if (node = group2[i]) {
          node.__data__ = data2[i];
          update2[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data2[i]);
        }
      }
      for (; i < groupLength; ++i) {
        if (node = group2[i]) {
          exit[i] = node;
        }
      }
    }
    function bindKey(parent, group2, enter, update2, exit, data2, key2) {
      var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
      for (i = 0; i < groupLength; ++i) {
        if (node = group2[i]) {
          keyValues[i] = keyValue = key2.call(node, node.__data__, i, group2) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }
      for (i = 0; i < dataLength; ++i) {
        keyValue = key2.call(parent, data2[i], i, data2) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update2[i] = node;
          node.__data__ = data2[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data2[i]);
        }
      }
      for (i = 0; i < groupLength; ++i) {
        if ((node = group2[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
          exit[i] = node;
        }
      }
    }
    function datum$1(node) {
      return node.__data__;
    }
    function selection_data(value2, key2) {
      if (!arguments.length)
        return Array.from(this, datum$1);
      var bind2 = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
      if (typeof value2 !== "function")
        value2 = constant$6(value2);
      for (var m2 = groups.length, update2 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
        var parent = parents[j], group2 = groups[j], groupLength = group2.length, data2 = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data2.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind2(parent, group2, enterGroup, updateGroup, exitGroup, data2, key2);
        for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1)
              i1 = i0 + 1;
            while (!(next2 = updateGroup[i1]) && ++i1 < dataLength)
              ;
            previous._next = next2 || null;
          }
        }
      }
      update2 = new Selection$1(update2, parents);
      update2._enter = enter;
      update2._exit = exit;
      return update2;
    }
    function arraylike(data2) {
      return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
    }
    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }
    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update2 = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter)
          enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update2 = onupdate(update2);
        if (update2)
          update2 = update2.selection();
      }
      if (onexit == null)
        exit.remove();
      else
        onexit(exit);
      return enter && update2 ? enter.merge(update2).order() : update2;
    }
    function selection_merge(context2) {
      var selection2 = context2.selection ? context2.selection() : context2;
      for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge2[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection$1(merges, this._parents);
    }
    function selection_order() {
      for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
        for (var group2 = groups[j], i = group2.length - 1, next2 = group2[i], node; --i >= 0; ) {
          if (node = group2[i]) {
            if (next2 && node.compareDocumentPosition(next2) ^ 4)
              next2.parentNode.insertBefore(node, next2);
            next2 = node;
          }
        }
      }
      return this;
    }
    function selection_sort(compare2) {
      if (!compare2)
        compare2 = ascending$2;
      function compareNode(a2, b2) {
        return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
      }
      for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group2[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection$1(sortgroups, this._parents).order();
    }
    function ascending$2(a2, b2) {
      return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
    }
    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
    function selection_nodes() {
      return Array.from(this);
    }
    function selection_node() {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group2 = groups[j], i = 0, n = group2.length; i < n; ++i) {
          var node = group2[i];
          if (node)
            return node;
        }
      }
      return null;
    }
    function selection_size() {
      let size2 = 0;
      for (const node of this)
        ++size2;
      return size2;
    }
    function selection_empty() {
      return !this.node();
    }
    function selection_each(callback) {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
          if (node = group2[i])
            callback.call(node, node.__data__, i, group2);
        }
      }
      return this;
    }
    function attrRemove$1(name2) {
      return function() {
        this.removeAttribute(name2);
      };
    }
    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$1(name2, value2) {
      return function() {
        this.setAttribute(name2, value2);
      };
    }
    function attrConstantNS$1(fullname, value2) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value2);
      };
    }
    function attrFunction$1(name2, value2) {
      return function() {
        var v = value2.apply(this, arguments);
        if (v == null)
          this.removeAttribute(name2);
        else
          this.setAttribute(name2, v);
      };
    }
    function attrFunctionNS$1(fullname, value2) {
      return function() {
        var v = value2.apply(this, arguments);
        if (v == null)
          this.removeAttributeNS(fullname.space, fullname.local);
        else
          this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr(name2, value2) {
      var fullname = namespace(name2);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value2 == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value2 === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value2));
    }
    function defaultView(node) {
      return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
    }
    function styleRemove$1(name2) {
      return function() {
        this.style.removeProperty(name2);
      };
    }
    function styleConstant$1(name2, value2, priority) {
      return function() {
        this.style.setProperty(name2, value2, priority);
      };
    }
    function styleFunction$1(name2, value2, priority) {
      return function() {
        var v = value2.apply(this, arguments);
        if (v == null)
          this.style.removeProperty(name2);
        else
          this.style.setProperty(name2, v, priority);
      };
    }
    function selection_style(name2, value2, priority) {
      return arguments.length > 1 ? this.each((value2 == null ? styleRemove$1 : typeof value2 === "function" ? styleFunction$1 : styleConstant$1)(name2, value2, priority == null ? "" : priority)) : styleValue(this.node(), name2);
    }
    function styleValue(node, name2) {
      return node.style.getPropertyValue(name2) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name2);
    }
    function propertyRemove(name2) {
      return function() {
        delete this[name2];
      };
    }
    function propertyConstant(name2, value2) {
      return function() {
        this[name2] = value2;
      };
    }
    function propertyFunction(name2, value2) {
      return function() {
        var v = value2.apply(this, arguments);
        if (v == null)
          delete this[name2];
        else
          this[name2] = v;
      };
    }
    function selection_property(name2, value2) {
      return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name2, value2)) : this.node()[name2];
    }
    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList(node) {
      return node.classList || new ClassList(node);
    }
    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function(name2) {
        var i = this._names.indexOf(name2);
        if (i < 0) {
          this._names.push(name2);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name2) {
        var i = this._names.indexOf(name2);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name2) {
        return this._names.indexOf(name2) >= 0;
      }
    };
    function classedAdd(node, names) {
      var list2 = classList(node), i = -1, n = names.length;
      while (++i < n)
        list2.add(names[i]);
    }
    function classedRemove(node, names) {
      var list2 = classList(node), i = -1, n = names.length;
      while (++i < n)
        list2.remove(names[i]);
    }
    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }
    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }
    function classedFunction(names, value2) {
      return function() {
        (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }
    function selection_classed(name2, value2) {
      var names = classArray(name2 + "");
      if (arguments.length < 2) {
        var list2 = classList(this.node()), i = -1, n = names.length;
        while (++i < n)
          if (!list2.contains(names[i]))
            return false;
        return true;
      }
      return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
    }
    function textRemove() {
      this.textContent = "";
    }
    function textConstant$1(value2) {
      return function() {
        this.textContent = value2;
      };
    }
    function textFunction$1(value2) {
      return function() {
        var v = value2.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text(value2) {
      return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction$1 : textConstant$1)(value2)) : this.node().textContent;
    }
    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value2) {
      return function() {
        this.innerHTML = value2;
      };
    }
    function htmlFunction(value2) {
      return function() {
        var v = value2.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html(value2) {
      return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
    }
    function raise() {
      if (this.nextSibling)
        this.parentNode.appendChild(this);
    }
    function selection_raise() {
      return this.each(raise);
    }
    function lower() {
      if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower() {
      return this.each(lower);
    }
    function selection_append(name2) {
      var create2 = typeof name2 === "function" ? name2 : creator(name2);
      return this.select(function() {
        return this.appendChild(create2.apply(this, arguments));
      });
    }
    function constantNull() {
      return null;
    }
    function selection_insert(name2, before) {
      var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
      });
    }
    function remove$1() {
      var parent = this.parentNode;
      if (parent)
        parent.removeChild(this);
    }
    function selection_remove() {
      return this.each(remove$1);
    }
    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }
    function selection_datum(value2) {
      return arguments.length ? this.property("__data__", value2) : this.node().__data__;
    }
    function contextListener(listener2) {
      return function(event2) {
        listener2.call(this, event2, this.__data__);
      };
    }
    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t4) {
        var name2 = "", i = t4.indexOf(".");
        if (i >= 0)
          name2 = t4.slice(i + 1), t4 = t4.slice(0, i);
        return { type: t4, name: name2 };
      });
    }
    function onRemove(typename) {
      return function() {
        var on2 = this.__on;
        if (!on2)
          return;
        for (var j = 0, i = -1, m2 = on2.length, o; j < m2; ++j) {
          if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on2[++i] = o;
          }
        }
        if (++i)
          on2.length = i;
        else
          delete this.__on;
      };
    }
    function onAdd(typename, value2, options) {
      return function() {
        var on2 = this.__on, o, listener2 = contextListener(value2);
        if (on2)
          for (var j = 0, m2 = on2.length; j < m2; ++j) {
            if ((o = on2[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.options);
              this.addEventListener(o.type, o.listener = listener2, o.options = options);
              o.value = value2;
              return;
            }
          }
        this.addEventListener(typename.type, listener2, options);
        o = { type: typename.type, name: typename.name, value: value2, listener: listener2, options };
        if (!on2)
          this.__on = [o];
        else
          on2.push(o);
      };
    }
    function selection_on(typename, value2, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t4;
      if (arguments.length < 2) {
        var on2 = this.node().__on;
        if (on2)
          for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
            for (i = 0, o = on2[j]; i < n; ++i) {
              if ((t4 = typenames[i]).type === o.type && t4.name === o.name) {
                return o.value;
              }
            }
          }
        return;
      }
      on2 = value2 ? onAdd : onRemove;
      for (i = 0; i < n; ++i)
        this.each(on2(typenames[i], value2, options));
      return this;
    }
    function dispatchEvent(node, type2, params2) {
      var window2 = defaultView(node), event2 = window2.CustomEvent;
      if (typeof event2 === "function") {
        event2 = new event2(type2, params2);
      } else {
        event2 = window2.document.createEvent("Event");
        if (params2)
          event2.initEvent(type2, params2.bubbles, params2.cancelable), event2.detail = params2.detail;
        else
          event2.initEvent(type2, false, false);
      }
      node.dispatchEvent(event2);
    }
    function dispatchConstant(type2, params2) {
      return function() {
        return dispatchEvent(this, type2, params2);
      };
    }
    function dispatchFunction(type2, params2) {
      return function() {
        return dispatchEvent(this, type2, params2.apply(this, arguments));
      };
    }
    function selection_dispatch(type2, params2) {
      return this.each((typeof params2 === "function" ? dispatchFunction : dispatchConstant)(type2, params2));
    }
    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
          if (node = group2[i])
            yield node;
        }
      }
    }
    var root = [null];
    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }
    function selection_selection() {
      return this;
    }
    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };
    function select$1(selector2) {
      return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
    }
    function define(constructor, factory, prototype2) {
      constructor.prototype = factory.prototype = prototype2;
      prototype2.constructor = constructor;
    }
    function extend$1(parent, definition2) {
      var prototype2 = Object.create(parent.prototype);
      for (var key2 in definition2)
        prototype2[key2] = definition2[key2];
      return prototype2;
    }
    function Color() {
    }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color$3, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color$3(format2) {
      var m2, l;
      format2 = (format2 + "").trim().toLowerCase();
      return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function rgba(r, g, b2, a2) {
      if (a2 <= 0)
        r = g = b2 = NaN;
      return new Rgb(r, g, b2, a2);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color))
        o = color$3(o);
      if (!o)
        return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b2, opacity2) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b2, opacity2 == null ? 1 : opacity2);
    }
    function Rgb(r, g, b2, opacity2) {
      this.r = +r;
      this.g = +g;
      this.b = +b2;
      this.opacity = +opacity2;
    }
    define(Rgb, rgb, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
    }
    function clampa(opacity2) {
      return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
    }
    function clampi(value2) {
      return Math.max(0, Math.min(255, Math.round(value2) || 0));
    }
    function hex(value2) {
      value2 = clampi(value2);
      return (value2 < 16 ? "0" : "") + value2.toString(16);
    }
    function hsla(h2, s, l, a2) {
      if (a2 <= 0)
        h2 = s = l = NaN;
      else if (l <= 0 || l >= 1)
        h2 = s = NaN;
      else if (s <= 0)
        h2 = NaN;
      return new Hsl(h2, s, l, a2);
    }
    function hslConvert(o) {
      if (o instanceof Hsl)
        return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color))
        o = color$3(o);
      if (!o)
        return new Hsl();
      if (o instanceof Hsl)
        return o;
      o = o.rgb();
      var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, min2 = Math.min(r, g, b2), max2 = Math.max(r, g, b2), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
      if (s) {
        if (r === max2)
          h2 = (g - b2) / s + (g < b2) * 6;
        else if (g === max2)
          h2 = (b2 - r) / s + 2;
        else
          h2 = (r - g) / s + 4;
        s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
        h2 *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h2;
      }
      return new Hsl(h2, s, l, o.opacity);
    }
    function hsl$2(h2, s, l, opacity2) {
      return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity2 == null ? 1 : opacity2);
    }
    function Hsl(h2, s, l, opacity2) {
      this.h = +h2;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Hsl, hsl$2, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
          hsl2rgb(h2, m1, m2),
          hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
    function clamph(value2) {
      value2 = (value2 || 0) % 360;
      return value2 < 0 ? value2 + 360 : value2;
    }
    function clampt(value2) {
      return Math.max(0, Math.min(1, value2 || 0));
    }
    function hsl2rgb(h2, m1, m2) {
      return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
    }
    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;
    const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$2 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
    function labConvert(o) {
      if (o instanceof Lab)
        return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl)
        return hcl2lab(o);
      if (!(o instanceof Rgb))
        o = rgbConvert(o);
      var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b2 = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b2) / Yn), x2, z;
      if (r === g && g === b2)
        x2 = z = y2;
      else {
        x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b2) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b2) / Zn);
      }
      return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
    }
    function lab$1(l, a2, b2, opacity2) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b2, opacity2 == null ? 1 : opacity2);
    }
    function Lab(l, a2, b2, opacity2) {
      this.l = +l;
      this.a = +a2;
      this.b = +b2;
      this.opacity = +opacity2;
    }
    define(Lab, lab$1, extend$1(Color, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
        x2 = Xn * lab2xyz(x2);
        y2 = Yn * lab2xyz(y2);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
          lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    function xyz2lab(t4) {
      return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0$2;
    }
    function lab2xyz(t4) {
      return t4 > t1$1 ? t4 * t4 * t4 : t2 * (t4 - t0$2);
    }
    function lrgb2rgb(x2) {
      return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb(x2) {
      return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
    }
    function hclConvert(o) {
      if (o instanceof Hcl)
        return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab))
        o = labConvert(o);
      if (o.a === 0 && o.b === 0)
        return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h2 = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$2(h2, c2, l, opacity2) {
      return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c2, l, opacity2 == null ? 1 : opacity2);
    }
    function Hcl(h2, c2, l, opacity2) {
      this.h = +h2;
      this.c = +c2;
      this.l = +l;
      this.opacity = +opacity2;
    }
    function hcl2lab(o) {
      if (isNaN(o.h))
        return new Lab(o.l, 0, 0, o.opacity);
      var h2 = o.h * radians$1;
      return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
    }
    define(Hcl, hcl$2, extend$1(Color, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));
    var A = -0.14861, B$1 = 1.78277, C$1 = -0.29227, D$1 = -0.90649, E = 1.97294, ED = E * D$1, EB = E * B$1, BC_DA = B$1 * C$1 - D$1 * A;
    function cubehelixConvert(o) {
      if (o instanceof Cubehelix)
        return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb))
        o = rgbConvert(o);
      var r = o.r / 255, g = o.g / 255, b2 = o.b / 255, l = (BC_DA * b2 + ED * r - EB * g) / (BC_DA + ED - EB), bl2 = b2 - l, k = (E * (g - l) - C$1 * bl2) / D$1, s = Math.sqrt(k * k + bl2 * bl2) / (E * l * (1 - l)), h2 = s ? Math.atan2(k, bl2) * degrees$2 - 120 : NaN;
      return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s, l, o.opacity);
    }
    function cubehelix$2(h2, s, l, opacity2) {
      return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s, l, opacity2 == null ? 1 : opacity2);
    }
    function Cubehelix(h2, s, l, opacity2) {
      this.h = +h2;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Cubehelix, cubehelix$2, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians$1, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
        return new Rgb(
          255 * (l + a2 * (A * cosh2 + B$1 * sinh2)),
          255 * (l + a2 * (C$1 * cosh2 + D$1 * sinh2)),
          255 * (l + a2 * (E * cosh2)),
          this.opacity
        );
      }
    }));
    function basis(t12, v0, v1, v2, v3) {
      var t22 = t12 * t12, t32 = t22 * t12;
      return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
    }
    function basis$1(values2) {
      var n = values2.length - 1;
      return function(t4) {
        var i = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
        return basis((t4 - i / n) * n, v0, v1, v2, v3);
      };
    }
    function basisClosed(values2) {
      var n = values2.length;
      return function(t4) {
        var i = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
        return basis((t4 - i / n) * n, v0, v1, v2, v3);
      };
    }
    const constant$5 = (x2) => () => x2;
    function linear$2(a2, d) {
      return function(t4) {
        return a2 + t4 * d;
      };
    }
    function exponential(a2, b2, y2) {
      return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t4) {
        return Math.pow(a2 + t4 * b2, y2);
      };
    }
    function hue$1(a2, b2) {
      var d = b2 - a2;
      return d ? linear$2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$5(isNaN(a2) ? b2 : a2);
    }
    function gamma(y2) {
      return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
        return b2 - a2 ? exponential(a2, b2, y2) : constant$5(isNaN(a2) ? b2 : a2);
      };
    }
    function nogamma(a2, b2) {
      var d = b2 - a2;
      return d ? linear$2(a2, d) : constant$5(isNaN(a2) ? b2 : a2);
    }
    const interpolateRgb = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb$1(start2, end) {
        var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
        return function(t4) {
          start2.r = r(t4);
          start2.g = g(t4);
          start2.b = b2(t4);
          start2.opacity = opacity2(t4);
          return start2 + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    }(1);
    function rgbSpline(spline) {
      return function(colors2) {
        var n = colors2.length, r = new Array(n), g = new Array(n), b2 = new Array(n), i, color2;
        for (i = 0; i < n; ++i) {
          color2 = rgb(colors2[i]);
          r[i] = color2.r || 0;
          g[i] = color2.g || 0;
          b2[i] = color2.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b2 = spline(b2);
        color2.opacity = 1;
        return function(t4) {
          color2.r = r(t4);
          color2.g = g(t4);
          color2.b = b2(t4);
          return color2 + "";
        };
      };
    }
    var rgbBasis = rgbSpline(basis$1);
    var rgbBasisClosed = rgbSpline(basisClosed);
    function numberArray(a2, b2) {
      if (!b2)
        b2 = [];
      var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
      return function(t4) {
        for (i = 0; i < n; ++i)
          c2[i] = a2[i] * (1 - t4) + b2[i] * t4;
        return c2;
      };
    }
    function isNumberArray(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    function array$5(a2, b2) {
      return (isNumberArray(b2) ? numberArray : genericArray)(a2, b2);
    }
    function genericArray(a2, b2) {
      var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
      for (i = 0; i < na; ++i)
        x2[i] = interpolate$1$1(a2[i], b2[i]);
      for (; i < nb; ++i)
        c2[i] = b2[i];
      return function(t4) {
        for (i = 0; i < na; ++i)
          c2[i] = x2[i](t4);
        return c2;
      };
    }
    function date$1(a2, b2) {
      var d = /* @__PURE__ */ new Date();
      return a2 = +a2, b2 = +b2, function(t4) {
        return d.setTime(a2 * (1 - t4) + b2 * t4), d;
      };
    }
    function interpolateNumber(a2, b2) {
      return a2 = +a2, b2 = +b2, function(t4) {
        return a2 * (1 - t4) + b2 * t4;
      };
    }
    function object$1(a2, b2) {
      var i = {}, c2 = {}, k;
      if (a2 === null || typeof a2 !== "object")
        a2 = {};
      if (b2 === null || typeof b2 !== "object")
        b2 = {};
      for (k in b2) {
        if (k in a2) {
          i[k] = interpolate$1$1(a2[k], b2[k]);
        } else {
          c2[k] = b2[k];
        }
      }
      return function(t4) {
        for (k in i)
          c2[k] = i[k](t4);
        return c2;
      };
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero$3(b2) {
      return function() {
        return b2;
      };
    }
    function one$2(b2) {
      return function(t4) {
        return b2(t4) + "";
      };
    }
    function interpolateString(a2, b2) {
      var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
      a2 = a2 + "", b2 = b2 + "";
      while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
        if ((bs = bm.index) > bi) {
          bs = b2.slice(bi, bs);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s[i])
            s[i] += bm;
          else
            s[++i] = bm;
        } else {
          s[++i] = null;
          q.push({ i, x: interpolateNumber(am, bm) });
        }
        bi = reB.lastIndex;
      }
      if (bi < b2.length) {
        bs = b2.slice(bi);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      return s.length < 2 ? q[0] ? one$2(q[0].x) : zero$3(b2) : (b2 = q.length, function(t4) {
        for (var i2 = 0, o; i2 < b2; ++i2)
          s[(o = q[i2]).i] = o.x(t4);
        return s.join("");
      });
    }
    function interpolate$1$1(a2, b2) {
      var t4 = typeof b2, c2;
      return b2 == null || t4 === "boolean" ? constant$5(b2) : (t4 === "number" ? interpolateNumber : t4 === "string" ? (c2 = color$3(b2)) ? (b2 = c2, interpolateRgb) : interpolateString : b2 instanceof color$3 ? interpolateRgb : b2 instanceof Date ? date$1 : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object$1 : interpolateNumber)(a2, b2);
    }
    function discrete$1(range2) {
      var n = range2.length;
      return function(t4) {
        return range2[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
      };
    }
    function hue(a2, b2) {
      var i = hue$1(+a2, +b2);
      return function(t4) {
        var x2 = i(t4);
        return x2 - 360 * Math.floor(x2 / 360);
      };
    }
    function interpolateRound(a2, b2) {
      return a2 = +a2, b2 = +b2, function(t4) {
        return Math.round(a2 * (1 - t4) + b2 * t4);
      };
    }
    var degrees$1 = 180 / Math.PI;
    var identity$6 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose(a2, b2, c2, d, e3, f) {
      var scaleX, scaleY2, skewX;
      if (scaleX = Math.sqrt(a2 * a2 + b2 * b2))
        a2 /= scaleX, b2 /= scaleX;
      if (skewX = a2 * c2 + b2 * d)
        c2 -= a2 * skewX, d -= b2 * skewX;
      if (scaleY2 = Math.sqrt(c2 * c2 + d * d))
        c2 /= scaleY2, d /= scaleY2, skewX /= scaleY2;
      if (a2 * d < b2 * c2)
        a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e3,
        translateY: f,
        rotate: Math.atan2(b2, a2) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX,
        scaleY: scaleY2
      };
    }
    var svgNode;
    function parseCss(value2) {
      const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
      return m2.isIdentity ? identity$6 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
    }
    function parseSvg(value2) {
      if (value2 == null)
        return identity$6;
      if (!svgNode)
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value2);
      if (!(value2 = svgNode.transform.baseVal.consolidate()))
        return identity$6;
      value2 = value2.matrix;
      return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
    }
    function interpolateTransform(parse2, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }
      function translate2(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }
      function rotate2(a2, b2, s, q) {
        if (a2 !== b2) {
          if (a2 - b2 > 180)
            b2 += 360;
          else if (b2 - a2 > 180)
            a2 += 360;
          q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
        } else if (b2) {
          s.push(pop(s) + "rotate(" + b2 + degParen);
        }
      }
      function skewX(a2, b2, s, q) {
        if (a2 !== b2) {
          q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) });
        } else if (b2) {
          s.push(pop(s) + "skewX(" + b2 + degParen);
        }
      }
      function scale2(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }
      return function(a2, b2) {
        var s = [], q = [];
        a2 = parse2(a2), b2 = parse2(b2);
        translate2(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s, q);
        rotate2(a2.rotate, b2.rotate, s, q);
        skewX(a2.skewX, b2.skewX, s, q);
        scale2(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s, q);
        a2 = b2 = null;
        return function(t4) {
          var i = -1, n = q.length, o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t4);
          return s.join("");
        };
      };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
    var epsilon2$1 = 1e-12;
    function cosh(x2) {
      return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
    }
    function sinh(x2) {
      return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
    }
    function tanh(x2) {
      return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
    }
    const interpolateZoom = function zoomRho(rho, rho2, rho4) {
      function zoom2(p02, p1) {
        var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t4) {
            return [
              ux0 + t4 * dx,
              uy0 + t4 * dy,
              w0 * Math.exp(rho * t4 * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t4) {
            var s = t4 * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u2 * dx,
              uy0 + u2 * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }
        i.duration = S * 1e3 * rho / Math.SQRT2;
        return i;
      }
      zoom2.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom2;
    }(Math.SQRT2, 2, 4);
    function hsl(hue2) {
      return function(start2, end) {
        var h2 = hue2((start2 = hsl$2(start2)).h, (end = hsl$2(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
        return function(t4) {
          start2.h = h2(t4);
          start2.s = s(t4);
          start2.l = l(t4);
          start2.opacity = opacity2(t4);
          return start2 + "";
        };
      };
    }
    const hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);
    function lab(start2, end) {
      var l = nogamma((start2 = lab$1(start2)).l, (end = lab$1(end)).l), a2 = nogamma(start2.a, end.a), b2 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t4) {
        start2.l = l(t4);
        start2.a = a2(t4);
        start2.b = b2(t4);
        start2.opacity = opacity2(t4);
        return start2 + "";
      };
    }
    function hcl(hue2) {
      return function(start2, end) {
        var h2 = hue2((start2 = hcl$2(start2)).h, (end = hcl$2(end)).h), c2 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
        return function(t4) {
          start2.h = h2(t4);
          start2.c = c2(t4);
          start2.l = l(t4);
          start2.opacity = opacity2(t4);
          return start2 + "";
        };
      };
    }
    const hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);
    function cubehelix(hue2) {
      return function cubehelixGamma(y2) {
        y2 = +y2;
        function cubehelix2(start2, end) {
          var h2 = hue2((start2 = cubehelix$2(start2)).h, (end = cubehelix$2(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
          return function(t4) {
            start2.h = h2(t4);
            start2.s = s(t4);
            start2.l = l(Math.pow(t4, y2));
            start2.opacity = opacity2(t4);
            return start2 + "";
          };
        }
        cubehelix2.gamma = cubehelixGamma;
        return cubehelix2;
      }(1);
    }
    const cubehelix$1 = cubehelix(hue$1);
    var cubehelixLong = cubehelix(nogamma);
    function piecewise(interpolate2, values2) {
      if (values2 === void 0)
        values2 = interpolate2, interpolate2 = interpolate$1$1;
      var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
      while (i < n)
        I[i] = interpolate2(v, v = values2[++i]);
      return function(t4) {
        var i2 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
        return I[i2](t4 - i2);
      };
    }
    function quantize$2(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i)
        samples[i] = interpolator(i / (n - 1));
      return samples;
    }
    const $$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      interpolate: interpolate$1$1,
      interpolateArray: array$5,
      interpolateBasis: basis$1,
      interpolateBasisClosed: basisClosed,
      interpolateCubehelix: cubehelix$1,
      interpolateCubehelixLong: cubehelixLong,
      interpolateDate: date$1,
      interpolateDiscrete: discrete$1,
      interpolateHcl: hcl$1,
      interpolateHclLong: hclLong,
      interpolateHsl: hsl$1,
      interpolateHslLong: hslLong,
      interpolateHue: hue,
      interpolateLab: lab,
      interpolateNumber,
      interpolateNumberArray: numberArray,
      interpolateObject: object$1,
      interpolateRgb,
      interpolateRgbBasis: rgbBasis,
      interpolateRgbBasisClosed: rgbBasisClosed,
      interpolateRound,
      interpolateString,
      interpolateTransformCss,
      interpolateTransformSvg,
      interpolateZoom,
      piecewise,
      quantize: quantize$2
    }, Symbol.toStringTag, { value: "Module" }));
    var frame = 0, timeout$1 = 0, interval$2 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
      clockNow = 0;
    }
    function Timer$1() {
      this._call = this._time = this._next = null;
    }
    Timer$1.prototype = timer$1.prototype = {
      constructor: Timer$1,
      restart: function(callback, delay2, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay2 == null ? 0 : +delay2);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer$1(callback, delay2, time2) {
      var t4 = new Timer$1();
      t4.restart(callback, delay2, time2);
      return t4;
    }
    function timerFlush() {
      now();
      ++frame;
      var t4 = taskHead, e3;
      while (t4) {
        if ((e3 = clockNow - t4._time) >= 0)
          t4._call.call(void 0, e3);
        t4 = t4._next;
      }
      --frame;
    }
    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }
    function poke() {
      var now2 = clock.now(), delay2 = now2 - clockLast;
      if (delay2 > pokeDelay)
        clockSkew -= delay2, clockLast = now2;
    }
    function nap() {
      var t02, t12 = taskHead, t22, time2 = Infinity;
      while (t12) {
        if (t12._call) {
          if (time2 > t12._time)
            time2 = t12._time;
          t02 = t12, t12 = t12._next;
        } else {
          t22 = t12._next, t12._next = null;
          t12 = t02 ? t02._next = t22 : taskHead = t22;
        }
      }
      taskTail = t02;
      sleep(time2);
    }
    function sleep(time2) {
      if (frame)
        return;
      if (timeout$1)
        timeout$1 = clearTimeout(timeout$1);
      var delay2 = time2 - clockNow;
      if (delay2 > 24) {
        if (time2 < Infinity)
          timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
        if (interval$2)
          interval$2 = clearInterval(interval$2);
      } else {
        if (!interval$2)
          clockLast = clock.now(), interval$2 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }
    function timeout(callback, delay2, time2) {
      var t4 = new Timer$1();
      delay2 = delay2 == null ? 0 : +delay2;
      t4.restart((elapsed) => {
        t4.stop();
        callback(elapsed + delay2);
      }, delay2, time2);
      return t4;
    }
    function interval$1(callback, delay2, time2) {
      var t4 = new Timer$1(), total = delay2;
      if (delay2 == null)
        return t4.restart(callback, delay2, time2), t4;
      t4._restart = t4.restart;
      t4.restart = function(callback2, delay3, time3) {
        delay3 = +delay3, time3 = time3 == null ? now() : +time3;
        t4._restart(function tick2(elapsed) {
          elapsed += total;
          t4._restart(tick2, total += delay3, time3);
          callback2(elapsed);
        }, delay3, time3);
      };
      t4.restart(callback, delay2, time2);
      return t4;
    }
    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule(node, name2, id2, index2, group2, timing) {
      var schedules = node.__transition;
      if (!schedules)
        node.__transition = {};
      else if (id2 in schedules)
        return;
      create$3(node, id2, {
        name: name2,
        index: index2,
        // For context during callback.
        group: group2,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init$1(node, id2) {
      var schedule2 = get$5(node, id2);
      if (schedule2.state > CREATED)
        throw new Error("too late; already scheduled");
      return schedule2;
    }
    function set$4(node, id2) {
      var schedule2 = get$5(node, id2);
      if (schedule2.state > STARTED)
        throw new Error("too late; already running");
      return schedule2;
    }
    function get$5(node, id2) {
      var schedule2 = node.__transition;
      if (!schedule2 || !(schedule2 = schedule2[id2]))
        throw new Error("transition not found");
      return schedule2;
    }
    function create$3(node, id2, self) {
      var schedules = node.__transition, tween;
      schedules[id2] = self;
      self.timer = timer$1(schedule2, 0, self.time);
      function schedule2(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start2, self.delay, self.time);
        if (self.delay <= elapsed)
          start2(elapsed - self.delay);
      }
      function start2(elapsed) {
        var i, j, n, o;
        if (self.state !== SCHEDULED)
          return stop2();
        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name)
            continue;
          if (o.state === STARTED)
            return timeout(start2);
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          } else if (+i < id2) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick2, self.delay, self.time);
            tick2(elapsed);
          }
        });
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING)
          return;
        self.state = STARTED;
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }
      function tick2(elapsed) {
        var t4 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop2), self.state = ENDING, 1), i = -1, n = tween.length;
        while (++i < n) {
          tween[i].call(node, t4);
        }
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop2();
        }
      }
      function stop2() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id2];
        for (var i in schedules)
          return;
        delete node.__transition;
      }
    }
    function interrupt(node, name2) {
      var schedules = node.__transition, schedule2, active, empty2 = true, i;
      if (!schedules)
        return;
      name2 = name2 == null ? null : name2 + "";
      for (i in schedules) {
        if ((schedule2 = schedules[i]).name !== name2) {
          empty2 = false;
          continue;
        }
        active = schedule2.state > STARTING && schedule2.state < ENDING;
        schedule2.state = ENDED;
        schedule2.timer.stop();
        schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
        delete schedules[i];
      }
      if (empty2)
        delete node.__transition;
    }
    function selection_interrupt(name2) {
      return this.each(function() {
        interrupt(this, name2);
      });
    }
    function tweenRemove(id2, name2) {
      var tween0, tween1;
      return function() {
        var schedule2 = set$4(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name2) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }
        schedule2.tween = tween1;
      };
    }
    function tweenFunction(id2, name2, value2) {
      var tween0, tween1;
      if (typeof value2 !== "function")
        throw new Error();
      return function() {
        var schedule2 = set$4(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t4 = { name: name2, value: value2 }, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name2) {
              tween1[i] = t4;
              break;
            }
          }
          if (i === n)
            tween1.push(t4);
        }
        schedule2.tween = tween1;
      };
    }
    function transition_tween(name2, value2) {
      var id2 = this._id;
      name2 += "";
      if (arguments.length < 2) {
        var tween = get$5(this.node(), id2).tween;
        for (var i = 0, n = tween.length, t4; i < n; ++i) {
          if ((t4 = tween[i]).name === name2) {
            return t4.value;
          }
        }
        return null;
      }
      return this.each((value2 == null ? tweenRemove : tweenFunction)(id2, name2, value2));
    }
    function tweenValue(transition, name2, value2) {
      var id2 = transition._id;
      transition.each(function() {
        var schedule2 = set$4(this, id2);
        (schedule2.value || (schedule2.value = {}))[name2] = value2.apply(this, arguments);
      });
      return function(node) {
        return get$5(node, id2).value[name2];
      };
    }
    function interpolate$2(a2, b2) {
      var c2;
      return (typeof b2 === "number" ? interpolateNumber : b2 instanceof color$3 ? interpolateRgb : (c2 = color$3(b2)) ? (b2 = c2, interpolateRgb) : interpolateString)(a2, b2);
    }
    function attrRemove(name2) {
      return function() {
        this.removeAttribute(name2);
      };
    }
    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name2, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttribute(name2);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrConstantNS(fullname, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrFunction(name2, interpolate2, value2) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value2(this), string1;
        if (value1 == null)
          return void this.removeAttribute(name2);
        string0 = this.getAttribute(name2);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function attrFunctionNS(fullname, interpolate2, value2) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value2(this), string1;
        if (value1 == null)
          return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function transition_attr(name2, value2) {
      var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate$2;
      return this.attrTween(name2, typeof value2 === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value2)) : value2 == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value2));
    }
    function attrInterpolate(name2, i) {
      return function(t4) {
        this.setAttribute(name2, i.call(this, t4));
      };
    }
    function attrInterpolateNS(fullname, i) {
      return function(t4) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t4));
      };
    }
    function attrTweenNS(fullname, value2) {
      var t02, i0;
      function tween() {
        var i = value2.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t02;
      }
      tween._value = value2;
      return tween;
    }
    function attrTween(name2, value2) {
      var t02, i0;
      function tween() {
        var i = value2.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && attrInterpolate(name2, i);
        return t02;
      }
      tween._value = value2;
      return tween;
    }
    function transition_attrTween(name2, value2) {
      var key2 = "attr." + name2;
      if (arguments.length < 2)
        return (key2 = this.tween(key2)) && key2._value;
      if (value2 == null)
        return this.tween(key2, null);
      if (typeof value2 !== "function")
        throw new Error();
      var fullname = namespace(name2);
      return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
    }
    function delayFunction(id2, value2) {
      return function() {
        init$1(this, id2).delay = +value2.apply(this, arguments);
      };
    }
    function delayConstant(id2, value2) {
      return value2 = +value2, function() {
        init$1(this, id2).delay = value2;
      };
    }
    function transition_delay(value2) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id2, value2)) : get$5(this.node(), id2).delay;
    }
    function durationFunction(id2, value2) {
      return function() {
        set$4(this, id2).duration = +value2.apply(this, arguments);
      };
    }
    function durationConstant(id2, value2) {
      return value2 = +value2, function() {
        set$4(this, id2).duration = value2;
      };
    }
    function transition_duration(value2) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id2, value2)) : get$5(this.node(), id2).duration;
    }
    function easeConstant(id2, value2) {
      if (typeof value2 !== "function")
        throw new Error();
      return function() {
        set$4(this, id2).ease = value2;
      };
    }
    function transition_ease(value2) {
      var id2 = this._id;
      return arguments.length ? this.each(easeConstant(id2, value2)) : get$5(this.node(), id2).ease;
    }
    function easeVarying(id2, value2) {
      return function() {
        var v = value2.apply(this, arguments);
        if (typeof v !== "function")
          throw new Error();
        set$4(this, id2).ease = v;
      };
    }
    function transition_easeVarying(value2) {
      if (typeof value2 !== "function")
        throw new Error();
      return this.each(easeVarying(this._id, value2));
    }
    function transition_filter(match2) {
      if (typeof match2 !== "function")
        match2 = matcher(match2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group2[i]) && match2.call(node, node.__data__, i, group2)) {
            subgroup.push(node);
          }
        }
      }
      return new Transition(subgroups, this._parents, this._name, this._id);
    }
    function transition_merge(transition) {
      if (transition._id !== this._id)
        throw new Error();
      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge2[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Transition(merges, this._parents, this._name, this._id);
    }
    function start(name2) {
      return (name2 + "").trim().split(/^|\s+/).every(function(t4) {
        var i = t4.indexOf(".");
        if (i >= 0)
          t4 = t4.slice(0, i);
        return !t4 || t4 === "start";
      });
    }
    function onFunction(id2, name2, listener2) {
      var on0, on1, sit = start(name2) ? init$1 : set$4;
      return function() {
        var schedule2 = sit(this, id2), on2 = schedule2.on;
        if (on2 !== on0)
          (on1 = (on0 = on2).copy()).on(name2, listener2);
        schedule2.on = on1;
      };
    }
    function transition_on(name2, listener2) {
      var id2 = this._id;
      return arguments.length < 2 ? get$5(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener2));
    }
    function removeFunction(id2) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition)
          if (+i !== id2)
            return;
        if (parent)
          parent.removeChild(this);
      };
    }
    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }
    function transition_select(select2) {
      var name2 = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selector(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group2[i]) && (subnode = select2.call(node, node.__data__, i, group2))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name2, id2, i, subgroup, get$5(node, id2));
          }
        }
      }
      return new Transition(subgroups, this._parents, name2, id2);
    }
    function transition_selectAll(select2) {
      var name2 = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selectorAll(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
          if (node = group2[i]) {
            for (var children2 = select2.call(node, node.__data__, i, group2), child, inherit2 = get$5(node, id2), k = 0, l = children2.length; k < l; ++k) {
              if (child = children2[k]) {
                schedule(child, name2, id2, k, children2, inherit2);
              }
            }
            subgroups.push(children2);
            parents.push(node);
          }
        }
      }
      return new Transition(subgroups, parents, name2, id2);
    }
    var Selection = selection.prototype.constructor;
    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }
    function styleNull(name2, interpolate2) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
      };
    }
    function styleRemove(name2) {
      return function() {
        this.style.removeProperty(name2);
      };
    }
    function styleConstant(name2, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = styleValue(this, name2);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function styleFunction(name2, interpolate2, value2) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name2), value1 = value2(this), string1 = value1 + "";
        if (value1 == null)
          string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function styleMaybeRemove(id2, name2) {
      var on0, on1, listener0, key2 = "style." + name2, event2 = "end." + key2, remove2;
      return function() {
        var schedule2 = set$4(this, id2), on2 = schedule2.on, listener2 = schedule2.value[key2] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
        if (on2 !== on0 || listener0 !== listener2)
          (on1 = (on0 = on2).copy()).on(event2, listener0 = listener2);
        schedule2.on = on1;
      };
    }
    function transition_style(name2, value2, priority) {
      var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate$2;
      return value2 == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value2 === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value2))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value2), priority).on("end.style." + name2, null);
    }
    function styleInterpolate(name2, i, priority) {
      return function(t4) {
        this.style.setProperty(name2, i.call(this, t4), priority);
      };
    }
    function styleTween(name2, value2, priority) {
      var t4, i0;
      function tween() {
        var i = value2.apply(this, arguments);
        if (i !== i0)
          t4 = (i0 = i) && styleInterpolate(name2, i, priority);
        return t4;
      }
      tween._value = value2;
      return tween;
    }
    function transition_styleTween(name2, value2, priority) {
      var key2 = "style." + (name2 += "");
      if (arguments.length < 2)
        return (key2 = this.tween(key2)) && key2._value;
      if (value2 == null)
        return this.tween(key2, null);
      if (typeof value2 !== "function")
        throw new Error();
      return this.tween(key2, styleTween(name2, value2, priority == null ? "" : priority));
    }
    function textConstant(value2) {
      return function() {
        this.textContent = value2;
      };
    }
    function textFunction(value2) {
      return function() {
        var value1 = value2(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }
    function transition_text(value2) {
      return this.tween("text", typeof value2 === "function" ? textFunction(tweenValue(this, "text", value2)) : textConstant(value2 == null ? "" : value2 + ""));
    }
    function textInterpolate(i) {
      return function(t4) {
        this.textContent = i.call(this, t4);
      };
    }
    function textTween(value2) {
      var t02, i0;
      function tween() {
        var i = value2.apply(this, arguments);
        if (i !== i0)
          t02 = (i0 = i) && textInterpolate(i);
        return t02;
      }
      tween._value = value2;
      return tween;
    }
    function transition_textTween(value2) {
      var key2 = "text";
      if (arguments.length < 1)
        return (key2 = this.tween(key2)) && key2._value;
      if (value2 == null)
        return this.tween(key2, null);
      if (typeof value2 !== "function")
        throw new Error();
      return this.tween(key2, textTween(value2));
    }
    function transition_transition() {
      var name2 = this._name, id0 = this._id, id1 = newId();
      for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
          if (node = group2[i]) {
            var inherit2 = get$5(node, id0);
            schedule(node, name2, id1, i, group2, {
              time: inherit2.time + inherit2.delay + inherit2.duration,
              delay: 0,
              duration: inherit2.duration,
              ease: inherit2.ease
            });
          }
        }
      }
      return new Transition(groups, this._parents, name2, id1);
    }
    function transition_end() {
      var on0, on1, that = this, id2 = that._id, size2 = that.size();
      return new Promise(function(resolve2, reject) {
        var cancel = { value: reject }, end = { value: function() {
          if (--size2 === 0)
            resolve2();
        } };
        that.each(function() {
          var schedule2 = set$4(this, id2), on2 = schedule2.on;
          if (on2 !== on0) {
            on1 = (on0 = on2).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }
          schedule2.on = on1;
        });
        if (size2 === 0)
          resolve2();
      });
    }
    var id$1 = 0;
    function Transition(groups, parents, name2, id2) {
      this._groups = groups;
      this._parents = parents;
      this._name = name2;
      this._id = id2;
    }
    function newId() {
      return ++id$1;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
    function cubicInOut(t4) {
      return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
    }
    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    function inherit(node, id2) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id2])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id2} not found`);
        }
      }
      return timing;
    }
    function selection_transition(name2) {
      var id2, timing;
      if (name2 instanceof Transition) {
        id2 = name2._id, name2 = name2._name;
      } else {
        id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
      }
      for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
        for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
          if (node = group2[i]) {
            schedule(node, name2, id2, i, group2, timing || inherit(node, id2));
          }
        }
      }
      return new Transition(groups, this._parents, name2, id2);
    }
    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;
    const pi$3 = Math.PI, tau$3 = 2 * pi$3, epsilon$6 = 1e-6, tauEpsilon = tau$3 - epsilon$6;
    function append$1(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound$1(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0))
        throw new Error(`invalid digits: ${digits}`);
      if (d > 15)
        return append$1;
      const k = 10 ** d;
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }
    let Path$1 = class Path {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append$1 : appendRound$1(digits);
      }
      moveTo(x2, y2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x2, y2) {
        this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      quadraticCurveTo(x12, y12, x2, y2) {
        this._append`Q${+x12},${+y12},${this._x1 = +x2},${this._y1 = +y2}`;
      }
      bezierCurveTo(x12, y12, x2, y2, x3, y3) {
        this._append`C${+x12},${+y12},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
      }
      arcTo(x12, y12, x2, y2, r) {
        x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x12},${this._y1 = y12}`;
        } else if (!(l01_2 > epsilon$6))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
          this._append`L${this._x1 = x12},${this._y1 = y12}`;
        } else {
          let x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon$6) {
            this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
        }
      }
      arc(x2, y2, r, a0, a1, ccw) {
        x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x02},${y02}`;
        } else if (Math.abs(this._x1 - x02) > epsilon$6 || Math.abs(this._y1 - y02) > epsilon$6) {
          this._append`L${x02},${y02}`;
        }
        if (!r)
          return;
        if (da < 0)
          da = da % tau$3 + tau$3;
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw2},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw2},${this._x1 = x02},${this._y1 = y02}`;
        } else if (da > epsilon$6) {
          this._append`A${r},${r},0,${+(da >= pi$3)},${cw2},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
        }
      }
      rect(x2, y2, w2, h2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
      }
      toString() {
        return this._;
      }
    };
    function path$3() {
      return new Path$1();
    }
    path$3.prototype = Path$1.prototype;
    const epsilon$5 = 11102230246251565e-32;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$5) * epsilon$5;
    function sum(elen, e3, flen, f, h2) {
      let Q, Qnew, hh, bvirt;
      let enow = e3[0];
      let fnow = f[0];
      let eindex = 0;
      let findex = 0;
      if (fnow > enow === fnow > -enow) {
        Q = enow;
        enow = e3[++eindex];
      } else {
        Q = fnow;
        fnow = f[++findex];
      }
      let hindex = 0;
      if (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = enow + Q;
          hh = Q - (Qnew - enow);
          enow = e3[++eindex];
        } else {
          Qnew = fnow + Q;
          hh = Q - (Qnew - fnow);
          fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h2[hindex++] = hh;
        }
        while (eindex < elen && findex < flen) {
          if (fnow > enow === fnow > -enow) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e3[++eindex];
          } else {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
          }
          Q = Qnew;
          if (hh !== 0) {
            h2[hindex++] = hh;
          }
        }
      }
      while (eindex < elen) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
        Q = Qnew;
        if (hh !== 0) {
          h2[hindex++] = hh;
        }
      }
      while (findex < flen) {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) {
          h2[hindex++] = hh;
        }
      }
      if (Q !== 0 || hindex === 0) {
        h2[hindex++] = Q;
      }
      return hindex;
    }
    function estimate(elen, e3) {
      let Q = e3[0];
      for (let i = 1; i < elen; i++)
        Q += e3[i];
      return Q;
    }
    function vec(n) {
      return new Float64Array(n);
    }
    const ccwerrboundA = (3 + 16 * epsilon$5) * epsilon$5;
    const ccwerrboundB = (2 + 12 * epsilon$5) * epsilon$5;
    const ccwerrboundC = (9 + 64 * epsilon$5) * epsilon$5 * epsilon$5;
    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);
    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
      let acxtail, acytail, bcxtail, bcytail;
      let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t12, t02, u3;
      const acx = ax - cx;
      const bcx = bx - cx;
      const acy = ay - cy;
      const bcy = by - cy;
      s1 = acx * bcy;
      c2 = splitter * acx;
      ahi = c2 - (c2 - acx);
      alo = acx - ahi;
      c2 = splitter * bcy;
      bhi = c2 - (c2 - bcy);
      blo = bcy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t12 = acy * bcx;
      c2 = splitter * acy;
      ahi = c2 - (c2 - acy);
      alo = acy - ahi;
      c2 = splitter * bcx;
      bhi = c2 - (c2 - bcx);
      blo = bcx - bhi;
      t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t02;
      bvirt = s0 - _i;
      B[0] = s0 - (_i + bvirt) + (bvirt - t02);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t12;
      bvirt = _0 - _i;
      B[1] = _0 - (_i + bvirt) + (bvirt - t12);
      u3 = _j + _i;
      bvirt = u3 - _j;
      B[2] = _j - (u3 - bvirt) + (_i - bvirt);
      B[3] = u3;
      let det = estimate(4, B);
      let errbound = ccwerrboundB * detsum;
      if (det >= errbound || -det >= errbound) {
        return det;
      }
      bvirt = ax - acx;
      acxtail = ax - (acx + bvirt) + (bvirt - cx);
      bvirt = bx - bcx;
      bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
      bvirt = ay - acy;
      acytail = ay - (acy + bvirt) + (bvirt - cy);
      bvirt = by - bcy;
      bcytail = by - (bcy + bvirt) + (bvirt - cy);
      if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
        return det;
      }
      errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
      det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
      if (det >= errbound || -det >= errbound)
        return det;
      s1 = acxtail * bcy;
      c2 = splitter * acxtail;
      ahi = c2 - (c2 - acxtail);
      alo = acxtail - ahi;
      c2 = splitter * bcy;
      bhi = c2 - (c2 - bcy);
      blo = bcy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t12 = acytail * bcx;
      c2 = splitter * acytail;
      ahi = c2 - (c2 - acytail);
      alo = acytail - ahi;
      c2 = splitter * bcx;
      bhi = c2 - (c2 - bcx);
      blo = bcx - bhi;
      t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t02;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t02);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t12;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t12);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const C1len = sum(4, B, 4, u, C1);
      s1 = acx * bcytail;
      c2 = splitter * acx;
      ahi = c2 - (c2 - acx);
      alo = acx - ahi;
      c2 = splitter * bcytail;
      bhi = c2 - (c2 - bcytail);
      blo = bcytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t12 = acy * bcxtail;
      c2 = splitter * acy;
      ahi = c2 - (c2 - acy);
      alo = acy - ahi;
      c2 = splitter * bcxtail;
      bhi = c2 - (c2 - bcxtail);
      blo = bcxtail - bhi;
      t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t02;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t02);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t12;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t12);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const C2len = sum(C1len, C1, 4, u, C2);
      s1 = acxtail * bcytail;
      c2 = splitter * acxtail;
      ahi = c2 - (c2 - acxtail);
      alo = acxtail - ahi;
      c2 = splitter * bcytail;
      bhi = c2 - (c2 - bcytail);
      blo = bcytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t12 = acytail * bcxtail;
      c2 = splitter * acytail;
      ahi = c2 - (c2 - acytail);
      alo = acytail - ahi;
      c2 = splitter * bcxtail;
      bhi = c2 - (c2 - bcxtail);
      blo = bcxtail - bhi;
      t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t02;
      bvirt = s0 - _i;
      u[0] = s0 - (_i + bvirt) + (bvirt - t02);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t12;
      bvirt = _0 - _i;
      u[1] = _0 - (_i + bvirt) + (bvirt - t12);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      const Dlen = sum(C2len, C2, 4, u, D);
      return D[Dlen - 1];
    }
    function orient2d(ax, ay, bx, by, cx, cy) {
      const detleft = (ay - cy) * (bx - cx);
      const detright = (ax - cx) * (by - cy);
      const det = detleft - detright;
      const detsum = Math.abs(detleft + detright);
      if (Math.abs(det) >= ccwerrboundA * detsum)
        return det;
      return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }
    const EPSILON$2 = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);
    class Delaunator {
      static from(points2, getX = defaultGetX, getY = defaultGetY) {
        const n = points2.length;
        const coords = new Float64Array(n * 2);
        for (let i = 0; i < n; i++) {
          const p = points2[i];
          coords[2 * i] = getX(p);
          coords[2 * i + 1] = getY(p);
        }
        return new Delaunator(coords);
      }
      constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== "number")
          throw new Error("Expected coords to contain numbers.");
        this.coords = coords;
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n);
        this._hullNext = new Uint32Array(n);
        this._hullTri = new Uint32Array(n);
        this._hullHash = new Int32Array(this._hashSize).fill(-1);
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);
        this.update();
      }
      update() {
        const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
        const n = coords.length >> 1;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY2 = -Infinity;
        for (let i = 0; i < n; i++) {
          const x2 = coords[2 * i];
          const y2 = coords[2 * i + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY2)
            maxY2 = y2;
          this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY2) / 2;
        let minDist = Infinity;
        let i0, i1, i2;
        for (let i = 0; i < n; i++) {
          const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
          if (d < minDist) {
            i0 = i;
            minDist = d;
          }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];
        minDist = Infinity;
        for (let i = 0; i < n; i++) {
          if (i === i0)
            continue;
          const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
          if (d < minDist && d > 0) {
            i1 = i;
            minDist = d;
          }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];
        let minRadius = Infinity;
        for (let i = 0; i < n; i++) {
          if (i === i0 || i === i1)
            continue;
          const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
          if (r < minRadius) {
            i2 = i;
            minRadius = r;
          }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];
        if (minRadius === Infinity) {
          for (let i = 0; i < n; i++) {
            this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
          }
          quicksort(this._ids, this._dists, 0, n - 1);
          const hull = new Uint32Array(n);
          let j = 0;
          for (let i = 0, d0 = -Infinity; i < n; i++) {
            const id2 = this._ids[i];
            if (this._dists[id2] > d0) {
              hull[j++] = id2;
              d0 = this._dists[id2];
            }
          }
          this.hull = hull.subarray(0, j);
          this.triangles = new Uint32Array(0);
          this.halfedges = new Uint32Array(0);
          return;
        }
        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
          const i = i1;
          const x2 = i1x;
          const y2 = i1y;
          i1 = i2;
          i1x = i2x;
          i1y = i2y;
          i2 = i;
          i2x = x2;
          i2y = y2;
        }
        const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center2.x;
        this._cy = center2.y;
        for (let i = 0; i < n; i++) {
          this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        this._hullStart = i0;
        let hullSize = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        for (let k = 0, xp, yp; k < this._ids.length; k++) {
          const i = this._ids[k];
          const x2 = coords[2 * i];
          const y2 = coords[2 * i + 1];
          if (k > 0 && Math.abs(x2 - xp) <= EPSILON$2 && Math.abs(y2 - yp) <= EPSILON$2)
            continue;
          xp = x2;
          yp = y2;
          if (i === i0 || i === i1 || i === i2)
            continue;
          let start2 = 0;
          for (let j = 0, key2 = this._hashKey(x2, y2); j < this._hashSize; j++) {
            start2 = hullHash[(key2 + j) % this._hashSize];
            if (start2 !== -1 && start2 !== hullNext[start2])
              break;
          }
          start2 = hullPrev[start2];
          let e3 = start2, q;
          while (q = hullNext[e3], orient2d(x2, y2, coords[2 * e3], coords[2 * e3 + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
            e3 = q;
            if (e3 === start2) {
              e3 = -1;
              break;
            }
          }
          if (e3 === -1)
            continue;
          let t4 = this._addTriangle(e3, i, hullNext[e3], -1, -1, hullTri[e3]);
          hullTri[i] = this._legalize(t4 + 2);
          hullTri[e3] = t4;
          hullSize++;
          let n2 = hullNext[e3];
          while (q = hullNext[n2], orient2d(x2, y2, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
            t4 = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
            hullTri[i] = this._legalize(t4 + 2);
            hullNext[n2] = n2;
            hullSize--;
            n2 = q;
          }
          if (e3 === start2) {
            while (q = hullPrev[e3], orient2d(x2, y2, coords[2 * q], coords[2 * q + 1], coords[2 * e3], coords[2 * e3 + 1]) < 0) {
              t4 = this._addTriangle(q, i, e3, -1, hullTri[e3], hullTri[q]);
              this._legalize(t4 + 2);
              hullTri[q] = t4;
              hullNext[e3] = e3;
              hullSize--;
              e3 = q;
            }
          }
          this._hullStart = hullPrev[i] = e3;
          hullNext[e3] = hullPrev[n2] = i;
          hullNext[i] = n2;
          hullHash[this._hashKey(x2, y2)] = i;
          hullHash[this._hashKey(coords[2 * e3], coords[2 * e3 + 1])] = e3;
        }
        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e3 = this._hullStart; i < hullSize; i++) {
          this.hull[i] = e3;
          e3 = hullNext[e3];
        }
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }
      _hashKey(x2, y2) {
        return Math.floor(pseudoAngle(x2 - this._cx, y2 - this._cy) * this._hashSize) % this._hashSize;
      }
      _legalize(a2) {
        const { _triangles: triangles, _halfedges: halfedges, coords } = this;
        let i = 0;
        let ar = 0;
        while (true) {
          const b2 = halfedges[a2];
          const a0 = a2 - a2 % 3;
          ar = a0 + (a2 + 2) % 3;
          if (b2 === -1) {
            if (i === 0)
              break;
            a2 = EDGE_STACK[--i];
            continue;
          }
          const b0 = b2 - b2 % 3;
          const al = a0 + (a2 + 1) % 3;
          const bl2 = b0 + (b2 + 2) % 3;
          const p02 = triangles[ar];
          const pr = triangles[a2];
          const pl = triangles[al];
          const p1 = triangles[bl2];
          const illegal = inCircle(
            coords[2 * p02],
            coords[2 * p02 + 1],
            coords[2 * pr],
            coords[2 * pr + 1],
            coords[2 * pl],
            coords[2 * pl + 1],
            coords[2 * p1],
            coords[2 * p1 + 1]
          );
          if (illegal) {
            triangles[a2] = p1;
            triangles[b2] = p02;
            const hbl = halfedges[bl2];
            if (hbl === -1) {
              let e3 = this._hullStart;
              do {
                if (this._hullTri[e3] === bl2) {
                  this._hullTri[e3] = a2;
                  break;
                }
                e3 = this._hullPrev[e3];
              } while (e3 !== this._hullStart);
            }
            this._link(a2, hbl);
            this._link(b2, halfedges[ar]);
            this._link(ar, bl2);
            const br2 = b0 + (b2 + 1) % 3;
            if (i < EDGE_STACK.length) {
              EDGE_STACK[i++] = br2;
            }
          } else {
            if (i === 0)
              break;
            a2 = EDGE_STACK[--i];
          }
        }
        return ar;
      }
      _link(a2, b2) {
        this._halfedges[a2] = b2;
        if (b2 !== -1)
          this._halfedges[b2] = a2;
      }
      // add a new triangle given vertex indices and adjacent half-edge ids
      _addTriangle(i0, i1, i2, a2, b2, c2) {
        const t4 = this.trianglesLen;
        this._triangles[t4] = i0;
        this._triangles[t4 + 1] = i1;
        this._triangles[t4 + 2] = i2;
        this._link(t4, a2);
        this._link(t4 + 1, b2);
        this._link(t4 + 2, c2);
        this.trianglesLen += 3;
        return t4;
      }
    }
    function pseudoAngle(dx, dy) {
      const p = dx / (Math.abs(dx) + Math.abs(dy));
      return (dy > 0 ? 3 - p : 1 + p) / 4;
    }
    function dist(ax, ay, bx, by) {
      const dx = ax - bx;
      const dy = ay - by;
      return dx * dx + dy * dy;
    }
    function inCircle(ax, ay, bx, by, cx, cy, px2, py2) {
      const dx = ax - px2;
      const dy = ay - py2;
      const ex = bx - px2;
      const ey = by - py2;
      const fx = cx - px2;
      const fy = cy - py2;
      const ap = dx * dx + dy * dy;
      const bp = ex * ex + ey * ey;
      const cp = fx * fx + fy * fy;
      return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
    }
    function circumradius(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;
      const bl2 = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);
      const x2 = (ey * bl2 - dy * cl) * d;
      const y2 = (dx * cl - ex * bl2) * d;
      return x2 * x2 + y2 * y2;
    }
    function circumcenter(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;
      const bl2 = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);
      const x2 = ax + (ey * bl2 - dy * cl) * d;
      const y2 = ay + (dx * cl - ex * bl2) * d;
      return { x: x2, y: y2 };
    }
    function quicksort(ids, dists, left2, right2) {
      if (right2 - left2 <= 20) {
        for (let i = left2 + 1; i <= right2; i++) {
          const temp2 = ids[i];
          const tempDist = dists[temp2];
          let j = i - 1;
          while (j >= left2 && dists[ids[j]] > tempDist)
            ids[j + 1] = ids[j--];
          ids[j + 1] = temp2;
        }
      } else {
        const median2 = left2 + right2 >> 1;
        let i = left2 + 1;
        let j = right2;
        swap(ids, median2, i);
        if (dists[ids[left2]] > dists[ids[right2]])
          swap(ids, left2, right2);
        if (dists[ids[i]] > dists[ids[right2]])
          swap(ids, i, right2);
        if (dists[ids[left2]] > dists[ids[i]])
          swap(ids, left2, i);
        const temp2 = ids[i];
        const tempDist = dists[temp2];
        while (true) {
          do
            i++;
          while (dists[ids[i]] < tempDist);
          do
            j--;
          while (dists[ids[j]] > tempDist);
          if (j < i)
            break;
          swap(ids, i, j);
        }
        ids[left2 + 1] = ids[j];
        ids[j] = temp2;
        if (right2 - i + 1 >= j - left2) {
          quicksort(ids, dists, i, right2);
          quicksort(ids, dists, left2, j - 1);
        } else {
          quicksort(ids, dists, left2, j - 1);
          quicksort(ids, dists, i, right2);
        }
      }
    }
    function swap(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    function defaultGetX(p) {
      return p[0];
    }
    function defaultGetY(p) {
      return p[1];
    }
    const epsilon$4 = 1e-6;
    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
      }
      moveTo(x2, y2) {
        this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x2, y2) {
        this._ += `L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      arc(x2, y2, r) {
        x2 = +x2, y2 = +y2, r = +r;
        const x02 = x2 + r;
        const y02 = y2;
        if (r < 0)
          throw new Error("negative radius");
        if (this._x1 === null)
          this._ += `M${x02},${y02}`;
        else if (Math.abs(this._x1 - x02) > epsilon$4 || Math.abs(this._y1 - y02) > epsilon$4)
          this._ += "L" + x02 + "," + y02;
        if (!r)
          return;
        this._ += `A${r},${r},0,1,1,${x2 - r},${y2}A${r},${r},0,1,1,${this._x1 = x02},${this._y1 = y02}`;
      }
      rect(x2, y2, w2, h2) {
        this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${+w2}v${+h2}h${-w2}Z`;
      }
      value() {
        return this._ || null;
      }
    }
    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x2, y2) {
        this._.push([x2, y2]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x2, y2) {
        this._.push([x2, y2]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }
    let Voronoi$1 = class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
          throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const { delaunay: { points: points2, hull, triangles }, vectors } = this;
        let bx, by;
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x2, y2; i < n; i += 3, j += 2) {
          const t12 = triangles[i] * 2;
          const t22 = triangles[i + 1] * 2;
          const t32 = triangles[i + 2] * 2;
          const x13 = points2[t12];
          const y13 = points2[t12 + 1];
          const x22 = points2[t22];
          const y22 = points2[t22 + 1];
          const x3 = points2[t32];
          const y3 = points2[t32 + 1];
          const dx = x22 - x13;
          const dy = y22 - y13;
          const ex = x3 - x13;
          const ey = y3 - y13;
          const ab = (dx * ey - dy * ex) * 2;
          if (Math.abs(ab) < 1e-9) {
            if (bx === void 0) {
              bx = by = 0;
              for (const i2 of hull)
                bx += points2[i2 * 2], by += points2[i2 * 2 + 1];
              bx /= hull.length, by /= hull.length;
            }
            const a2 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
            x2 = (x13 + x3) / 2 - a2 * ey;
            y2 = (y13 + y3) / 2 + a2 * ex;
          } else {
            const d = 1 / ab;
            const bl2 = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x2 = x13 + (ey * bl2 - dy * cl) * d;
            y2 = y13 + (dx * cl - ex * bl2) * d;
          }
          circumcenters[j] = x2;
          circumcenters[j + 1] = y2;
        }
        let h2 = hull[hull.length - 1];
        let p02, p1 = h2 * 4;
        let x02, x12 = points2[2 * h2];
        let y02, y12 = points2[2 * h2 + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h2 = hull[i];
          p02 = p1, x02 = x12, y02 = y12;
          p1 = h2 * 4, x12 = points2[2 * h2], y12 = points2[2 * h2 + 1];
          vectors[p02 + 2] = vectors[p1] = y02 - y12;
          vectors[p02 + 3] = vectors[p1 + 1] = x12 - x02;
        }
      }
      render(context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
        if (hull.length <= 1)
          return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i)
            continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context2);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t4 = Math.floor(inedges[h1] / 3) * 2;
          const x2 = circumcenters[t4];
          const y2 = circumcenters[t4 + 1];
          const v = h0 * 4;
          const p = this._project(x2, y2, vectors[v + 2], vectors[v + 3]);
          if (p)
            this._renderSegment(x2, y2, p[0], p[1], context2);
        }
        return buffer && buffer.value();
      }
      renderBounds(context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        context2.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const points2 = this._clip(i);
        if (points2 === null || !points2.length)
          return;
        context2.moveTo(points2[0], points2[1]);
        let n = points2.length;
        while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
          n -= 2;
        for (let i2 = 2; i2 < n; i2 += 2) {
          if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
            context2.lineTo(points2[i2], points2[i2 + 1]);
        }
        context2.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const { delaunay: { points: points2 } } = this;
        for (let i = 0, n = points2.length / 2; i < n; ++i) {
          const cell2 = this.cellPolygon(i);
          if (cell2)
            cell2.index = i, yield cell2;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon();
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x02, y02, x12, y12, context2) {
        let S;
        const c0 = this._regioncode(x02, y02);
        const c1 = this._regioncode(x12, y12);
        if (c0 === 0 && c1 === 0) {
          context2.moveTo(x02, y02);
          context2.lineTo(x12, y12);
        } else if (S = this._clipSegment(x02, y02, x12, y12, c0, c1)) {
          context2.moveTo(S[0], S[1]);
          context2.lineTo(S[2], S[3]);
        }
      }
      contains(i, x2, y2) {
        if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2))
          return false;
        return this.delaunay._step(i, x2, y2) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci)
          for (const j of this.delaunay.neighbors(i)) {
            const cj = this._clip(j);
            if (cj)
              loop:
                for (let ai = 0, li = ci.length; ai < li; ai += 2) {
                  for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                    if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                      yield j;
                      break loop;
                    }
                  }
                }
          }
      }
      _cell(i) {
        const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
        const e0 = inedges[i];
        if (e0 === -1)
          return null;
        const points2 = [];
        let e3 = e0;
        do {
          const t4 = Math.floor(e3 / 3);
          points2.push(circumcenters[t4 * 2], circumcenters[t4 * 2 + 1]);
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            break;
          e3 = halfedges[e3];
        } while (e3 !== e0 && e3 !== -1);
        return points2;
      }
      _clip(i) {
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points2 = this._cell(i);
        if (points2 === null)
          return null;
        const { vectors: V } = this;
        const v = i * 4;
        return this._simplify(V[v] || V[v + 1] ? this._clipInfinite(i, points2, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points2));
      }
      _clipFinite(i, points2) {
        const n = points2.length;
        let P = null;
        let x02, y02, x12 = points2[n - 2], y12 = points2[n - 1];
        let c0, c1 = this._regioncode(x12, y12);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x02 = x12, y02 = y12, x12 = points2[j], y12 = points2[j + 1];
          c0 = c1, c1 = this._regioncode(x12, y12);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P)
              P.push(x12, y12);
            else
              P = [x12, y12];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x02, y02, x12, y12, c0, c1)) === null)
                continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x12, y12, x02, y02, c1, c0)) === null)
                continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1)
                this._edge(i, e0, e1, P, P.length);
              if (P)
                P.push(sx0, sy0);
              else
                P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1)
              this._edge(i, e0, e1, P, P.length);
            if (P)
              P.push(sx1, sy1);
            else
              P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x02, y02, x12, y12, c0, c1) {
        const flip2 = c0 < c1;
        if (flip2)
          [x02, y02, x12, y12, c0, c1] = [x12, y12, x02, y02, c1, c0];
        while (true) {
          if (c0 === 0 && c1 === 0)
            return flip2 ? [x12, y12, x02, y02] : [x02, y02, x12, y12];
          if (c0 & c1)
            return null;
          let x2, y2, c2 = c0 || c1;
          if (c2 & 8)
            x2 = x02 + (x12 - x02) * (this.ymax - y02) / (y12 - y02), y2 = this.ymax;
          else if (c2 & 4)
            x2 = x02 + (x12 - x02) * (this.ymin - y02) / (y12 - y02), y2 = this.ymin;
          else if (c2 & 2)
            y2 = y02 + (y12 - y02) * (this.xmax - x02) / (x12 - x02), x2 = this.xmax;
          else
            y2 = y02 + (y12 - y02) * (this.xmin - x02) / (x12 - x02), x2 = this.xmin;
          if (c0)
            x02 = x2, y02 = y2, c0 = this._regioncode(x02, y02);
          else
            x12 = x2, y12 = y2, c1 = this._regioncode(x12, y12);
        }
      }
      _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
        let P = Array.from(points2), p;
        if (p = this._project(P[0], P[1], vx0, vy0))
          P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
          P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1)
              j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x2, y2;
          switch (e0) {
            case 5:
              e0 = 4;
              continue;
            case 4:
              e0 = 6, x2 = this.xmax, y2 = this.ymin;
              break;
            case 6:
              e0 = 2;
              continue;
            case 2:
              e0 = 10, x2 = this.xmax, y2 = this.ymax;
              break;
            case 10:
              e0 = 8;
              continue;
            case 8:
              e0 = 9, x2 = this.xmin, y2 = this.ymax;
              break;
            case 9:
              e0 = 1;
              continue;
            case 1:
              e0 = 5, x2 = this.xmin, y2 = this.ymin;
              break;
          }
          if ((P[j] !== x2 || P[j + 1] !== y2) && this.contains(i, x2, y2)) {
            P.splice(j, 0, x2, y2), j += 2;
          }
        }
        return j;
      }
      _project(x02, y02, vx, vy) {
        let t4 = Infinity, c2, x2, y2;
        if (vy < 0) {
          if (y02 <= this.ymin)
            return null;
          if ((c2 = (this.ymin - y02) / vy) < t4)
            y2 = this.ymin, x2 = x02 + (t4 = c2) * vx;
        } else if (vy > 0) {
          if (y02 >= this.ymax)
            return null;
          if ((c2 = (this.ymax - y02) / vy) < t4)
            y2 = this.ymax, x2 = x02 + (t4 = c2) * vx;
        }
        if (vx > 0) {
          if (x02 >= this.xmax)
            return null;
          if ((c2 = (this.xmax - x02) / vx) < t4)
            x2 = this.xmax, y2 = y02 + (t4 = c2) * vy;
        } else if (vx < 0) {
          if (x02 <= this.xmin)
            return null;
          if ((c2 = (this.xmin - x02) / vx) < t4)
            x2 = this.xmin, y2 = y02 + (t4 = c2) * vy;
        }
        return [x2, y2];
      }
      _edgecode(x2, y2) {
        return (x2 === this.xmin ? 1 : x2 === this.xmax ? 2 : 0) | (y2 === this.ymin ? 4 : y2 === this.ymax ? 8 : 0);
      }
      _regioncode(x2, y2) {
        return (x2 < this.xmin ? 1 : x2 > this.xmax ? 2 : 0) | (y2 < this.ymin ? 4 : y2 > this.ymax ? 8 : 0);
      }
      _simplify(P) {
        if (P && P.length > 4) {
          for (let i = 0; i < P.length; i += 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {
              P.splice(j, 2), i -= 2;
            }
          }
          if (!P.length)
            P = null;
        }
        return P;
      }
    };
    const tau$2 = 2 * Math.PI, pow$4 = Math.pow;
    function pointX(p) {
      return p[0];
    }
    function pointY(p) {
      return p[1];
    }
    function collinear$1(d) {
      const { triangles, coords } = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a2 = 2 * triangles[i], b2 = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross2 = (coords[c2] - coords[a2]) * (coords[b2 + 1] - coords[a2 + 1]) - (coords[b2] - coords[a2]) * (coords[c2 + 1] - coords[a2 + 1]);
        if (cross2 > 1e-10)
          return false;
      }
      return true;
    }
    function jitter(x2, y2, r) {
      return [x2 + Math.sin(x2 + y2) * r, y2 + Math.cos(x2 - y2) * r];
    }
    class Delaunay {
      static from(points2, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
      }
      constructor(points2) {
        this._delaunator = new Delaunator(points2);
        this.inedges = new Int32Array(points2.length / 2);
        this._hullIndex = new Int32Array(points2.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points2 = this.points;
        if (d.hull && d.hull.length > 2 && collinear$1(d)) {
          this.collinear = Int32Array.from({ length: points2.length / 2 }, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
          const e3 = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds2 = [points2[2 * e3], points2[2 * e3 + 1], points2[2 * f], points2[2 * f + 1]], r = 1e-8 * Math.hypot(bounds2[3] - bounds2[1], bounds2[2] - bounds2[0]);
          for (let i = 0, n = points2.length / 2; i < n; ++i) {
            const p = jitter(points2[2 * i], points2[2 * i + 1], r);
            points2[2 * i] = p[0];
            points2[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points2);
        } else {
          delete this.collinear;
        }
        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);
        for (let e3 = 0, n = halfedges.length; e3 < n; ++e3) {
          const p = triangles[e3 % 3 === 2 ? e3 - 2 : e3 + 1];
          if (halfedges[e3] === -1 || inedges[p] === -1)
            inedges[p] = e3;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds2) {
        return new Voronoi$1(this, bounds2);
      }
      *neighbors(i) {
        const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
        if (collinear2) {
          const l = collinear2.indexOf(i);
          if (l > 0)
            yield collinear2[l - 1];
          if (l < collinear2.length - 1)
            yield collinear2[l + 1];
          return;
        }
        const e0 = inedges[i];
        if (e0 === -1)
          return;
        let e3 = e0, p02 = -1;
        do {
          yield p02 = triangles[e3];
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            return;
          e3 = halfedges[e3];
          if (e3 === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p02)
              yield p;
            return;
          }
        } while (e3 !== e0);
      }
      find(x2, y2, i = 0) {
        if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2))
          return -1;
        const i0 = i;
        let c2;
        while ((c2 = this._step(i, x2, y2)) >= 0 && c2 !== i && c2 !== i0)
          i = c2;
        return c2;
      }
      _step(i, x2, y2) {
        const { inedges, hull, _hullIndex, halfedges, triangles, points: points2 } = this;
        if (inedges[i] === -1 || !points2.length)
          return (i + 1) % (points2.length >> 1);
        let c2 = i;
        let dc = pow$4(x2 - points2[i * 2], 2) + pow$4(y2 - points2[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e3 = e0;
        do {
          let t4 = triangles[e3];
          const dt = pow$4(x2 - points2[t4 * 2], 2) + pow$4(y2 - points2[t4 * 2 + 1], 2);
          if (dt < dc)
            dc = dt, c2 = t4;
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            break;
          e3 = halfedges[e3];
          if (e3 === -1) {
            e3 = hull[(_hullIndex[i] + 1) % hull.length];
            if (e3 !== t4) {
              if (pow$4(x2 - points2[e3 * 2], 2) + pow$4(y2 - points2[e3 * 2 + 1], 2) < dc)
                return e3;
            }
            break;
          }
        } while (e3 !== e0);
        return c2;
      }
      render(context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const { points: points2, halfedges, triangles } = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i)
            continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context2.moveTo(points2[ti], points2[ti + 1]);
          context2.lineTo(points2[tj], points2[tj + 1]);
        }
        this.renderHull(context2);
        return buffer && buffer.value();
      }
      renderPoints(context2, r) {
        if (r === void 0 && (!context2 || typeof context2.moveTo !== "function"))
          r = context2, context2 = null;
        r = r == void 0 ? 2 : +r;
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const { points: points2 } = this;
        for (let i = 0, n = points2.length; i < n; i += 2) {
          const x2 = points2[i], y2 = points2[i + 1];
          context2.moveTo(x2 + r, y2);
          context2.arc(x2, y2, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const { hull, points: points2 } = this;
        const h2 = hull[0] * 2, n = hull.length;
        context2.moveTo(points2[h2], points2[h2 + 1]);
        for (let i = 1; i < n; ++i) {
          const h3 = 2 * hull[i];
          context2.lineTo(points2[h3], points2[h3 + 1]);
        }
        context2.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon();
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context2) {
        const buffer = context2 == null ? context2 = new Path() : void 0;
        const { points: points2, triangles } = this;
        const t02 = triangles[i *= 3] * 2;
        const t12 = triangles[i + 1] * 2;
        const t22 = triangles[i + 2] * 2;
        context2.moveTo(points2[t02], points2[t02 + 1]);
        context2.lineTo(points2[t12], points2[t12 + 1]);
        context2.lineTo(points2[t22], points2[t22 + 1]);
        context2.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const { triangles } = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon();
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }
    function flatArray(points2, fx, fy, that) {
      const n = points2.length;
      const array2 = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points2[i];
        array2[i * 2] = fx.call(that, p, i, points2);
        array2[i * 2 + 1] = fy.call(that, p, i, points2);
      }
      return array2;
    }
    function* flatIterable(points2, fx, fy, that) {
      let i = 0;
      for (const p of points2) {
        yield fx.call(that, p, i, points2);
        yield fy.call(that, p, i, points2);
        ++i;
      }
    }
    var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name2, i) {
        return JSON.stringify(name2) + ": d[" + i + '] || ""';
      }).join(",") + "}");
    }
    function customConverter(columns, f) {
      var object2 = objectConverter(columns);
      return function(row, i) {
        return f(object2(row), i, columns);
      };
    }
    function inferColumns(rows) {
      var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });
      return columns;
    }
    function pad$2(value2, width2) {
      var s = value2 + "", length2 = s.length;
      return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s : s;
    }
    function formatYear$1(year) {
      return year < 0 ? "-" + pad$2(-year, 6) : year > 9999 ? "+" + pad$2(year, 6) : pad$2(year, 4);
    }
    function formatDate(date2) {
      var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds = date2.getUTCSeconds(), milliseconds = date2.getUTCMilliseconds();
      return isNaN(date2) ? "Invalid Date" : formatYear$1(date2.getUTCFullYear()) + "-" + pad$2(date2.getUTCMonth() + 1, 2) + "-" + pad$2(date2.getUTCDate(), 2) + (milliseconds ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + ":" + pad$2(seconds, 2) + "." + pad$2(milliseconds, 3) + "Z" : seconds ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + ":" + pad$2(seconds, 2) + "Z" : minutes || hours ? "T" + pad$2(hours, 2) + ":" + pad$2(minutes, 2) + "Z" : "");
    }
    function dsvFormat(delimiter) {
      var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
      function parse2(text2, f) {
        var convert, columns, rows = parseRows(text2, function(row, i) {
          if (convert)
            return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }
      function parseRows(text2, f) {
        var rows = [], N = text2.length, I = 0, n = 0, t4, eof = N <= 0, eol = false;
        if (text2.charCodeAt(N - 1) === NEWLINE)
          --N;
        if (text2.charCodeAt(N - 1) === RETURN)
          --N;
        function token() {
          if (eof)
            return EOF;
          if (eol)
            return eol = false, EOL;
          var i, j = I, c2;
          if (text2.charCodeAt(j) === QUOTE) {
            while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
              ;
            if ((i = I) >= N)
              eof = true;
            else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
              eol = true;
            else if (c2 === RETURN) {
              eol = true;
              if (text2.charCodeAt(I) === NEWLINE)
                ++I;
            }
            return text2.slice(j + 1, i - 1).replace(/""/g, '"');
          }
          while (I < N) {
            if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
              eol = true;
            else if (c2 === RETURN) {
              eol = true;
              if (text2.charCodeAt(I) === NEWLINE)
                ++I;
            } else if (c2 !== DELIMITER)
              continue;
            return text2.slice(j, i);
          }
          return eof = true, text2.slice(j, N);
        }
        while ((t4 = token()) !== EOF) {
          var row = [];
          while (t4 !== EOL && t4 !== EOF)
            row.push(t4), t4 = token();
          if (f && (row = f(row, n++)) == null)
            continue;
          rows.push(row);
        }
        return rows;
      }
      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue2(row[column]);
          }).join(delimiter);
        });
      }
      function format2(rows, columns) {
        if (columns == null)
          columns = inferColumns(rows);
        return [columns.map(formatValue2).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }
      function formatBody(rows, columns) {
        if (columns == null)
          columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }
      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }
      function formatRow(row) {
        return row.map(formatValue2).join(delimiter);
      }
      function formatValue2(value2) {
        return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
      }
      return {
        parse: parse2,
        parseRows,
        format: format2,
        formatBody,
        formatRows,
        formatRow,
        formatValue: formatValue2
      };
    }
    function forceCenter(x2, y2) {
      var nodes, strength = 1;
      if (x2 == null)
        x2 = 0;
      if (y2 == null)
        y2 = 0;
      function force2() {
        var i, n = nodes.length, node, sx = 0, sy = 0;
        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }
        for (sx = (sx / n - x2) * strength, sy = (sy / n - y2) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }
      force2.initialize = function(_) {
        nodes = _;
      };
      force2.x = function(_) {
        return arguments.length ? (x2 = +_, force2) : x2;
      };
      force2.y = function(_) {
        return arguments.length ? (y2 = +_, force2) : y2;
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = +_, force2) : strength;
      };
      return force2;
    }
    function tree_add(d) {
      const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
      return add$4(this.cover(x2, y2), x2, y2, d);
    }
    function add$4(tree2, x2, y2, d) {
      if (isNaN(x2) || isNaN(y2))
        return tree2;
      var parent, node = tree2._root, leaf = { data: d }, x02 = tree2._x0, y02 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;
      if (!node)
        return tree2._root = leaf, tree2;
      while (node.length) {
        if (right2 = x2 >= (xm = (x02 + x12) / 2))
          x02 = xm;
        else
          x12 = xm;
        if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
          y02 = ym;
        else
          y12 = ym;
        if (parent = node, !(node = node[i = bottom2 << 1 | right2]))
          return parent[i] = leaf, tree2;
      }
      xp = +tree2._x.call(null, node.data);
      yp = +tree2._y.call(null, node.data);
      if (x2 === xp && y2 === yp)
        return leaf.next = node, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
      do {
        parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
        if (right2 = x2 >= (xm = (x02 + x12) / 2))
          x02 = xm;
        else
          x12 = xm;
        if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
          y02 = ym;
        else
          y12 = ym;
      } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
      return parent[j] = node, parent[i] = leaf, tree2;
    }
    function addAll(data2) {
      var d, i, n = data2.length, x2, y2, xz = new Array(n), yz = new Array(n), x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
      for (i = 0; i < n; ++i) {
        if (isNaN(x2 = +this._x.call(null, d = data2[i])) || isNaN(y2 = +this._y.call(null, d)))
          continue;
        xz[i] = x2;
        yz[i] = y2;
        if (x2 < x02)
          x02 = x2;
        if (x2 > x12)
          x12 = x2;
        if (y2 < y02)
          y02 = y2;
        if (y2 > y12)
          y12 = y2;
      }
      if (x02 > x12 || y02 > y12)
        return this;
      this.cover(x02, y02).cover(x12, y12);
      for (i = 0; i < n; ++i) {
        add$4(this, xz[i], yz[i], data2[i]);
      }
      return this;
    }
    function tree_cover(x2, y2) {
      if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
        return this;
      var x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1;
      if (isNaN(x02)) {
        x12 = (x02 = Math.floor(x2)) + 1;
        y12 = (y02 = Math.floor(y2)) + 1;
      } else {
        var z = x12 - x02 || 1, node = this._root, parent, i;
        while (x02 > x2 || x2 >= x12 || y02 > y2 || y2 >= y12) {
          i = (y2 < y02) << 1 | x2 < x02;
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0:
              x12 = x02 + z, y12 = y02 + z;
              break;
            case 1:
              x02 = x12 - z, y12 = y02 + z;
              break;
            case 2:
              x12 = x02 + z, y02 = y12 - z;
              break;
            case 3:
              x02 = x12 - z, y02 = y12 - z;
              break;
          }
        }
        if (this._root && this._root.length)
          this._root = node;
      }
      this._x0 = x02;
      this._y0 = y02;
      this._x1 = x12;
      this._y1 = y12;
      return this;
    }
    function tree_data() {
      var data2 = [];
      this.visit(function(node) {
        if (!node.length)
          do
            data2.push(node.data);
          while (node = node.next);
      });
      return data2;
    }
    function tree_extent(_) {
      return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
    }
    function Quad(node, x02, y02, x12, y12) {
      this.node = node;
      this.x0 = x02;
      this.y0 = y02;
      this.x1 = x12;
      this.y1 = y12;
    }
    function tree_find(x2, y2, radius2) {
      var data2, x02 = this._x0, y02 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
      if (node)
        quads.push(new Quad(node, x02, y02, x3, y3));
      if (radius2 == null)
        radius2 = Infinity;
      else {
        x02 = x2 - radius2, y02 = y2 - radius2;
        x3 = x2 + radius2, y3 = y2 + radius2;
        radius2 *= radius2;
      }
      while (q = quads.pop()) {
        if (!(node = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x02 || (y22 = q.y1) < y02)
          continue;
        if (node.length) {
          var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
          quads.push(
            new Quad(node[3], xm, ym, x22, y22),
            new Quad(node[2], x12, ym, xm, y22),
            new Quad(node[1], xm, y12, x22, ym),
            new Quad(node[0], x12, y12, xm, ym)
          );
          if (i = (y2 >= ym) << 1 | x2 >= xm) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        } else {
          var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
          if (d2 < radius2) {
            var d = Math.sqrt(radius2 = d2);
            x02 = x2 - d, y02 = y2 - d;
            x3 = x2 + d, y3 = y2 + d;
            data2 = node.data;
          }
        }
      }
      return data2;
    }
    function tree_remove(d) {
      if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
        return this;
      var parent, node = this._root, retainer, previous, next2, x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right2, bottom2, i, j;
      if (!node)
        return this;
      if (node.length)
        while (true) {
          if (right2 = x2 >= (xm = (x02 + x12) / 2))
            x02 = xm;
          else
            x12 = xm;
          if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
            y02 = ym;
          else
            y12 = ym;
          if (!(parent = node, node = node[i = bottom2 << 1 | right2]))
            return this;
          if (!node.length)
            break;
          if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
            retainer = parent, j = i;
        }
      while (node.data !== d)
        if (!(previous = node, node = node.next))
          return this;
      if (next2 = node.next)
        delete node.next;
      if (previous)
        return next2 ? previous.next = next2 : delete previous.next, this;
      if (!parent)
        return this._root = next2, this;
      next2 ? parent[i] = next2 : delete parent[i];
      if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
        if (retainer)
          retainer[j] = node;
        else
          this._root = node;
      }
      return this;
    }
    function removeAll(data2) {
      for (var i = 0, n = data2.length; i < n; ++i)
        this.remove(data2[i]);
      return this;
    }
    function tree_root() {
      return this._root;
    }
    function tree_size() {
      var size2 = 0;
      this.visit(function(node) {
        if (!node.length)
          do
            ++size2;
          while (node = node.next);
      });
      return size2;
    }
    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x02, y02, x12, y12;
      if (node)
        quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
          var xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
          if (child = node[3])
            quads.push(new Quad(child, xm, ym, x12, y12));
          if (child = node[2])
            quads.push(new Quad(child, x02, ym, xm, y12));
          if (child = node[1])
            quads.push(new Quad(child, xm, y02, x12, ym));
          if (child = node[0])
            quads.push(new Quad(child, x02, y02, xm, ym));
        }
      }
      return this;
    }
    function tree_visitAfter(callback) {
      var quads = [], next2 = [], q;
      if (this._root)
        quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
          if (child = node[0])
            quads.push(new Quad(child, x02, y02, xm, ym));
          if (child = node[1])
            quads.push(new Quad(child, xm, y02, x12, ym));
          if (child = node[2])
            quads.push(new Quad(child, x02, ym, xm, y12));
          if (child = node[3])
            quads.push(new Quad(child, xm, ym, x12, y12));
        }
        next2.push(q);
      }
      while (q = next2.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }
    function defaultX(d) {
      return d[0];
    }
    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }
    function defaultY(d) {
      return d[1];
    }
    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }
    function quadtree(nodes, x2, y2) {
      var tree2 = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
      return nodes == null ? tree2 : tree2.addAll(nodes);
    }
    function Quadtree(x2, y2, x02, y02, x12, y12) {
      this._x = x2;
      this._y = y2;
      this._x0 = x02;
      this._y0 = y02;
      this._x1 = x12;
      this._y1 = y12;
      this._root = void 0;
    }
    function leaf_copy(leaf) {
      var copy2 = { data: leaf.data }, next2 = copy2;
      while (leaf = leaf.next)
        next2 = next2.next = { data: leaf.data };
      return copy2;
    }
    var treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node)
        return copy2;
      if (!node.length)
        return copy2._root = leaf_copy(node), copy2;
      nodes = [{ source: node, target: copy2._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length)
              nodes.push({ source: child, target: node.target[i] = new Array(4) });
            else
              node.target[i] = leaf_copy(child);
          }
        }
      }
      return copy2;
    };
    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;
    function constant$4(x2) {
      return function() {
        return x2;
      };
    }
    function jiggle(random2) {
      return (random2() - 0.5) * 1e-6;
    }
    function x$3(d) {
      return d.x + d.vx;
    }
    function y$3(d) {
      return d.y + d.vy;
    }
    function forceCollide(radius2) {
      var nodes, radii, random2, strength = 1, iterations2 = 1;
      if (typeof radius2 !== "function")
        radius2 = constant$4(radius2 == null ? 1 : +radius2);
      function force2() {
        var i, n = nodes.length, tree2, node, xi, yi, ri, ri2;
        for (var k = 0; k < iterations2; ++k) {
          tree2 = quadtree(nodes, x$3, y$3).visitAfter(prepare2);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree2.visit(apply2);
          }
        }
        function apply2(quad2, x02, y02, x12, y12) {
          var data2 = quad2.data, rj = quad2.r, r = ri + rj;
          if (data2) {
            if (data2.index > node.index) {
              var x2 = xi - data2.x - data2.vx, y2 = yi - data2.y - data2.vy, l = x2 * x2 + y2 * y2;
              if (l < r * r) {
                if (x2 === 0)
                  x2 = jiggle(random2), l += x2 * x2;
                if (y2 === 0)
                  y2 = jiggle(random2), l += y2 * y2;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x2 *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y2 *= l) * r;
                data2.vx -= x2 * (r = 1 - r);
                data2.vy -= y2 * r;
              }
            }
            return;
          }
          return x02 > xi + r || x12 < xi - r || y02 > yi + r || y12 < yi - r;
        }
      }
      function prepare2(quad2) {
        if (quad2.data)
          return quad2.r = radii[quad2.data.index];
        for (var i = quad2.r = 0; i < 4; ++i) {
          if (quad2[i] && quad2[i].r > quad2.r) {
            quad2.r = quad2[i].r;
          }
        }
      }
      function initialize2() {
        if (!nodes)
          return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i)
          node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
      }
      force2.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random2 = _random;
        initialize2();
      };
      force2.iterations = function(_) {
        return arguments.length ? (iterations2 = +_, force2) : iterations2;
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = +_, force2) : strength;
      };
      force2.radius = function(_) {
        return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : radius2;
      };
      return force2;
    }
    function index$1(d) {
      return d.index;
    }
    function find$2(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node)
        throw new Error("node not found: " + nodeId);
      return node;
    }
    function forceLink(links) {
      var id2 = index$1, strength = defaultStrength, strengths, distance = constant$4(30), distances, nodes, count2, bias, random2, iterations2 = 1;
      if (links == null)
        links = [];
      function defaultStrength(link2) {
        return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
      }
      function force2(alpha) {
        for (var k = 0, n = links.length; k < iterations2; ++k) {
          for (var i = 0, link2, source2, target2, x2, y2, l, b2; i < n; ++i) {
            link2 = links[i], source2 = link2.source, target2 = link2.target;
            x2 = target2.x + target2.vx - source2.x - source2.vx || jiggle(random2);
            y2 = target2.y + target2.vy - source2.y - source2.vy || jiggle(random2);
            l = Math.sqrt(x2 * x2 + y2 * y2);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x2 *= l, y2 *= l;
            target2.vx -= x2 * (b2 = bias[i]);
            target2.vy -= y2 * b2;
            source2.vx += x2 * (b2 = 1 - b2);
            source2.vy += y2 * b2;
          }
        }
      }
      function initialize2() {
        if (!nodes)
          return;
        var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link2;
        for (i = 0, count2 = new Array(n); i < m2; ++i) {
          link2 = links[i], link2.index = i;
          if (typeof link2.source !== "object")
            link2.source = find$2(nodeById, link2.source);
          if (typeof link2.target !== "object")
            link2.target = find$2(nodeById, link2.target);
          count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
          count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
        }
        for (i = 0, bias = new Array(m2); i < m2; ++i) {
          link2 = links[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
        }
        strengths = new Array(m2), initializeStrength();
        distances = new Array(m2), initializeDistance();
      }
      function initializeStrength() {
        if (!nodes)
          return;
        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }
      function initializeDistance() {
        if (!nodes)
          return;
        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }
      force2.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random2 = _random;
        initialize2();
      };
      force2.links = function(_) {
        return arguments.length ? (links = _, initialize2(), force2) : links;
      };
      force2.id = function(_) {
        return arguments.length ? (id2 = _, force2) : id2;
      };
      force2.iterations = function(_) {
        return arguments.length ? (iterations2 = +_, force2) : iterations2;
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force2) : strength;
      };
      force2.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force2) : distance;
      };
      return force2;
    }
    const a$1 = 1664525;
    const c$1 = 1013904223;
    const m$1 = 4294967296;
    function lcg$2() {
      let s = 1;
      return () => (s = (a$1 * s + c$1) % m$1) / m$1;
    }
    function x$2(d) {
      return d.x;
    }
    function y$2(d) {
      return d.y;
    }
    var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
    function forceSimulation(nodes) {
      var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer$1(step), event2 = dispatch("tick", "end"), random2 = lcg$2();
      if (nodes == null)
        nodes = [];
      function step() {
        tick2();
        event2.call("tick", simulation2);
        if (alpha < alphaMin) {
          stepper.stop();
          event2.call("end", simulation2);
        }
      }
      function tick2(iterations2) {
        var i, n = nodes.length, node;
        if (iterations2 === void 0)
          iterations2 = 1;
        for (var k = 0; k < iterations2; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;
          forces.forEach(function(force2) {
            force2(alpha);
          });
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null)
              node.x += node.vx *= velocityDecay;
            else
              node.x = node.fx, node.vx = 0;
            if (node.fy == null)
              node.y += node.vy *= velocityDecay;
            else
              node.y = node.fy, node.vy = 0;
          }
        }
        return simulation2;
      }
      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null)
            node.x = node.fx;
          if (node.fy != null)
            node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
            node.x = radius2 * Math.cos(angle2);
            node.y = radius2 * Math.sin(angle2);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }
      function initializeForce(force2) {
        if (force2.initialize)
          force2.initialize(nodes, random2);
        return force2;
      }
      initializeNodes();
      return simulation2 = {
        tick: tick2,
        restart: function() {
          return stepper.restart(step), simulation2;
        },
        stop: function() {
          return stepper.stop(), simulation2;
        },
        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
        },
        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation2) : alpha;
        },
        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
        },
        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
        },
        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
        },
        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
        },
        randomSource: function(_) {
          return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation2) : random2;
        },
        force: function(name2, _) {
          return arguments.length > 1 ? (_ == null ? forces.delete(name2) : forces.set(name2, initializeForce(_)), simulation2) : forces.get(name2);
        },
        find: function(x2, y2, radius2) {
          var i = 0, n = nodes.length, dx, dy, d2, node, closest;
          if (radius2 == null)
            radius2 = Infinity;
          else
            radius2 *= radius2;
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x2 - node.x;
            dy = y2 - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius2)
              closest = node, radius2 = d2;
          }
          return closest;
        },
        on: function(name2, _) {
          return arguments.length > 1 ? (event2.on(name2, _), simulation2) : event2.on(name2);
        }
      };
    }
    function forceManyBody() {
      var nodes, node, random2, alpha, strength = constant$4(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
      function force2(_) {
        var i, n = nodes.length, tree2 = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i)
          node = nodes[i], tree2.visit(apply2);
      }
      function initialize2() {
        if (!nodes)
          return;
        var i, n = nodes.length, node2;
        strengths = new Array(n);
        for (i = 0; i < n; ++i)
          node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
      }
      function accumulate(quad2) {
        var strength2 = 0, q, c2, weight = 0, x2, y2, i;
        if (quad2.length) {
          for (x2 = y2 = i = 0; i < 4; ++i) {
            if ((q = quad2[i]) && (c2 = Math.abs(q.value))) {
              strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
            }
          }
          quad2.x = x2 / weight;
          quad2.y = y2 / weight;
        } else {
          q = quad2;
          q.x = q.data.x;
          q.y = q.data.y;
          do
            strength2 += strengths[q.data.index];
          while (q = q.next);
        }
        quad2.value = strength2;
      }
      function apply2(quad2, x12, _, x2) {
        if (!quad2.value)
          return true;
        var x3 = quad2.x - node.x, y2 = quad2.y - node.y, w2 = x2 - x12, l = x3 * x3 + y2 * y2;
        if (w2 * w2 / theta2 < l) {
          if (l < distanceMax2) {
            if (x3 === 0)
              x3 = jiggle(random2), l += x3 * x3;
            if (y2 === 0)
              y2 = jiggle(random2), l += y2 * y2;
            if (l < distanceMin2)
              l = Math.sqrt(distanceMin2 * l);
            node.vx += x3 * quad2.value * alpha / l;
            node.vy += y2 * quad2.value * alpha / l;
          }
          return true;
        } else if (quad2.length || l >= distanceMax2)
          return;
        if (quad2.data !== node || quad2.next) {
          if (x3 === 0)
            x3 = jiggle(random2), l += x3 * x3;
          if (y2 === 0)
            y2 = jiggle(random2), l += y2 * y2;
          if (l < distanceMin2)
            l = Math.sqrt(distanceMin2 * l);
        }
        do
          if (quad2.data !== node) {
            w2 = strengths[quad2.data.index] * alpha / l;
            node.vx += x3 * w2;
            node.vy += y2 * w2;
          }
        while (quad2 = quad2.next);
      }
      force2.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random2 = _random;
        initialize2();
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : strength;
      };
      force2.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force2) : Math.sqrt(distanceMin2);
      };
      force2.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force2) : Math.sqrt(distanceMax2);
      };
      force2.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force2) : Math.sqrt(theta2);
      };
      return force2;
    }
    function forceX(x2) {
      var strength = constant$4(0.1), nodes, strengths, xz;
      if (typeof x2 !== "function")
        x2 = constant$4(x2 == null ? 0 : +x2);
      function force2(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }
      function initialize2() {
        if (!nodes)
          return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }
      force2.initialize = function(_) {
        nodes = _;
        initialize2();
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : strength;
      };
      force2.x = function(_) {
        return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : x2;
      };
      return force2;
    }
    function forceY(y2) {
      var strength = constant$4(0.1), nodes, strengths, yz;
      if (typeof y2 !== "function")
        y2 = constant$4(y2 == null ? 0 : +y2);
      function force2(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }
      function initialize2() {
        if (!nodes)
          return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }
      force2.initialize = function(_) {
        nodes = _;
        initialize2();
      };
      force2.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : strength;
      };
      force2.y = function(_) {
        return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), initialize2(), force2) : y2;
      };
      return force2;
    }
    function formatDecimal(x2) {
      return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
    }
    function formatDecimalParts(x2, p) {
      if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
        return null;
      var i, coefficient = x2.slice(0, i);
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x2.slice(i + 1)
      ];
    }
    function exponent(x2) {
      return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
    }
    function formatGroup(grouping, thousands) {
      return function(value2, width2) {
        var i = value2.length, t4 = [], j = 0, g = grouping[0], length2 = 0;
        while (i > 0 && g > 0) {
          if (length2 + g + 1 > width2)
            g = Math.max(1, width2 - length2);
          t4.push(value2.substring(i -= g, i + g));
          if ((length2 += g + 1) > width2)
            break;
          g = grouping[j = (j + 1) % grouping.length];
        }
        return t4.reverse().join(thousands);
      };
    }
    function formatNumerals(numerals) {
      return function(value2) {
        return value2.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }
    var re$2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match2 = re$2.exec(specifier)))
        throw new Error("invalid format: " + specifier);
      var match2;
      return new FormatSpecifier({
        fill: match2[1],
        align: match2[2],
        sign: match2[3],
        symbol: match2[4],
        zero: match2[5],
        width: match2[6],
        comma: match2[7],
        precision: match2[8] && match2[8].slice(1),
        trim: match2[9],
        type: match2[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
      this.align = specifier.align === void 0 ? ">" : specifier.align + "";
      this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === void 0 ? void 0 : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === void 0 ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    function formatTrim(s) {
      out:
        for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
          switch (s[i]) {
            case ".":
              i0 = i1 = i;
              break;
            case "0":
              if (i0 === 0)
                i0 = i;
              i1 = i;
              break;
            default:
              if (!+s[i])
                break out;
              if (i0 > 0)
                i0 = 0;
              break;
          }
        }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }
    var prefixExponent;
    function formatPrefixAuto(x2, p) {
      var d = formatDecimalParts(x2, p);
      if (!d)
        return x2 + "";
      var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
      return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
    }
    function formatRounded(x2, p) {
      var d = formatDecimalParts(x2, p);
      if (!d)
        return x2 + "";
      var coefficient = d[0], exponent2 = d[1];
      return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
    }
    const formatTypes = {
      "%": (x2, p) => (x2 * 100).toFixed(p),
      "b": (x2) => Math.round(x2).toString(2),
      "c": (x2) => x2 + "",
      "d": formatDecimal,
      "e": (x2, p) => x2.toExponential(p),
      "f": (x2, p) => x2.toFixed(p),
      "g": (x2, p) => x2.toPrecision(p),
      "o": (x2) => Math.round(x2).toString(8),
      "p": (x2, p) => formatRounded(x2 * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
      "x": (x2) => Math.round(x2).toString(16)
    };
    function identity$5(x2) {
      return x2;
    }
    var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$1(locale2) {
      var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$5 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$5 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill2 = specifier.fill, align2 = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
        if (type2 === "n")
          comma = true, type2 = "g";
        else if (!formatTypes[type2])
          precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
        if (zero2 || fill2 === "0" && align2 === "=")
          zero2 = true, fill2 = "0", align2 = "=";
        var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
        var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
        precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format2(value2) {
          var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
          if (type2 === "c") {
            valueSuffix = formatType(value2) + valueSuffix;
            value2 = "";
          } else {
            value2 = +value2;
            var valueNegative = value2 < 0 || 1 / value2 < 0;
            value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
            if (trim2)
              value2 = formatTrim(value2);
            if (valueNegative && +value2 === 0 && sign2 !== "+")
              valueNegative = false;
            valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
            valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
            if (maybeSuffix) {
              i = -1, n = value2.length;
              while (++i < n) {
                if (c2 = value2.charCodeAt(i), 48 > c2 || c2 > 57) {
                  valueSuffix = (c2 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
                  value2 = value2.slice(0, i);
                  break;
                }
              }
            }
          }
          if (comma && !zero2)
            value2 = group2(value2, Infinity);
          var length2 = valuePrefix.length + value2.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) : "";
          if (comma && zero2)
            value2 = group2(padding2 + value2, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
          switch (align2) {
            case "<":
              value2 = valuePrefix + value2 + valueSuffix + padding2;
              break;
            case "=":
              value2 = valuePrefix + padding2 + value2 + valueSuffix;
              break;
            case "^":
              value2 = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value2 + valueSuffix + padding2.slice(length2);
              break;
            default:
              value2 = padding2 + valuePrefix + value2 + valueSuffix;
              break;
          }
          return numerals(value2);
        }
        format2.toString = function() {
          return specifier + "";
        };
        return format2;
      }
      function formatPrefix2(specifier, value2) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
        return function(value3) {
          return f(k * value3) + prefix;
        };
      }
      return {
        format: newFormat,
        formatPrefix: formatPrefix2
      };
    }
    var locale$2;
    var format$3;
    var formatPrefix;
    defaultLocale$2({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale$2(definition2) {
      locale$2 = formatLocale$1(definition2);
      format$3 = locale$2.format;
      formatPrefix = locale$2.formatPrefix;
      return locale$2;
    }
    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }
    function precisionPrefix(step, value2) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
    }
    function precisionRound(step, max2) {
      step = Math.abs(step), max2 = Math.abs(max2) - step;
      return Math.max(0, exponent(max2) - exponent(step)) + 1;
    }
    var epsilon$3 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$2 = Math.PI;
    var halfPi$2 = pi$2 / 2;
    var quarterPi = pi$2 / 4;
    var tau$1 = pi$2 * 2;
    var degrees = 180 / pi$2;
    var radians = pi$2 / 180;
    var abs$2 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$2 = Math.cos;
    var ceil = Math.ceil;
    var exp$2 = Math.exp;
    var hypot = Math.hypot;
    var log$4 = Math.log;
    var pow$3 = Math.pow;
    var sin$2 = Math.sin;
    var sign$1 = Math.sign || function(x2) {
      return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
    };
    var sqrt$3 = Math.sqrt;
    var tan = Math.tan;
    function acos$1(x2) {
      return x2 > 1 ? 0 : x2 < -1 ? pi$2 : Math.acos(x2);
    }
    function asin$2(x2) {
      return x2 > 1 ? halfPi$2 : x2 < -1 ? -halfPi$2 : Math.asin(x2);
    }
    function noop$3() {
    }
    function streamGeometry(geometry, stream2) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream2);
      }
    }
    var streamObjectType = {
      Feature: function(object2, stream2) {
        streamGeometry(object2.geometry, stream2);
      },
      FeatureCollection: function(object2, stream2) {
        var features = object2.features, i = -1, n = features.length;
        while (++i < n)
          streamGeometry(features[i].geometry, stream2);
      }
    };
    var streamGeometryType = {
      Sphere: function(object2, stream2) {
        stream2.sphere();
      },
      Point: function(object2, stream2) {
        object2 = object2.coordinates;
        stream2.point(object2[0], object2[1], object2[2]);
      },
      MultiPoint: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
      },
      LineString: function(object2, stream2) {
        streamLine(object2.coordinates, stream2, 0);
      },
      MultiLineString: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamLine(coordinates[i], stream2, 0);
      },
      Polygon: function(object2, stream2) {
        streamPolygon(object2.coordinates, stream2);
      },
      MultiPolygon: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamPolygon(coordinates[i], stream2);
      },
      GeometryCollection: function(object2, stream2) {
        var geometries = object2.geometries, i = -1, n = geometries.length;
        while (++i < n)
          streamGeometry(geometries[i], stream2);
      }
    };
    function streamLine(coordinates, stream2, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream2.lineStart();
      while (++i < n)
        coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
      stream2.lineEnd();
    }
    function streamPolygon(coordinates, stream2) {
      var i = -1, n = coordinates.length;
      stream2.polygonStart();
      while (++i < n)
        streamLine(coordinates[i], stream2, 1);
      stream2.polygonEnd();
    }
    function geoStream(object2, stream2) {
      if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
        streamObjectType[object2.type](object2, stream2);
      } else {
        streamGeometry(object2, stream2);
      }
    }
    var areaRingSum$1 = new Adder();
    var areaSum$1 = new Adder(), lambda00$2, phi00$2, lambda0$1, cosPhi0, sinPhi0;
    var areaStream$1 = {
      point: noop$3,
      lineStart: noop$3,
      lineEnd: noop$3,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$3;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };
    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }
    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }
    function areaPointFirst$1(lambda, phi2) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi2;
      lambda *= radians, phi2 *= radians;
      lambda0$1 = lambda, cosPhi0 = cos$2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin$2(phi2);
    }
    function areaPoint$1(lambda, phi2) {
      lambda *= radians, phi2 *= radians;
      phi2 = phi2 / 2 + quarterPi;
      var dLambda = lambda - lambda0$1, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$2(phi2), sinPhi = sin$2(phi2), k = sinPhi0 * sinPhi, u2 = cosPhi0 * cosPhi + k * cos$2(adLambda), v = k * sdLambda * sin$2(adLambda);
      areaRingSum$1.add(atan2$1(v, u2));
      lambda0$1 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
    }
    function geoArea$1(object2) {
      areaSum$1 = new Adder();
      geoStream(object2, areaStream$1);
      return areaSum$1 * 2;
    }
    function spherical(cartesian2) {
      return [atan2$1(cartesian2[1], cartesian2[0]), asin$2(cartesian2[2])];
    }
    function cartesian(spherical2) {
      var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos$2(phi2);
      return [cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi2)];
    }
    function cartesianDot(a2, b2) {
      return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
    }
    function cartesianCross(a2, b2) {
      return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
    }
    function cartesianAddInPlace(a2, b2) {
      a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
    }
    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }
    var lambda0, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range$4;
    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0)
          lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$3)
          phi1 = 90;
        else if (deltaSum < -epsilon$3)
          phi0 = -90;
        range$4[0] = lambda0, range$4[1] = lambda1;
      },
      sphere: function() {
        lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };
    function boundsPoint$1(lambda, phi2) {
      ranges.push(range$4 = [lambda0 = lambda, lambda1 = lambda]);
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    function linePoint(lambda, phi2) {
      var p = cartesian([lambda * radians, phi2 * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs$2(delta) > 180;
        if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1)
            phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0)
            phi0 = phii;
        } else {
          if (phi2 < phi0)
            phi0 = phi2;
          if (phi2 > phi1)
            phi1 = phi2;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0, lambda) > angle(lambda0, lambda1))
              lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0, lambda1))
              lambda0 = lambda;
          }
        } else {
          if (lambda1 >= lambda0) {
            if (lambda < lambda0)
              lambda0 = lambda;
            if (lambda > lambda1)
              lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0, lambda) > angle(lambda0, lambda1))
                lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0, lambda1))
                lambda0 = lambda;
            }
          }
        }
      } else {
        ranges.push(range$4 = [lambda0 = lambda, lambda1 = lambda]);
      }
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
      p0 = p, lambda2 = lambda;
    }
    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }
    function boundsLineEnd() {
      range$4[0] = lambda0, range$4[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }
    function boundsRingPoint(lambda, phi2) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi2;
      }
      areaStream$1.point(lambda, phi2);
      linePoint(lambda, phi2);
    }
    function boundsRingStart() {
      areaStream$1.lineStart();
    }
    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$2(deltaSum) > epsilon$3)
        lambda0 = -(lambda1 = 180);
      range$4[0] = lambda0, range$4[1] = lambda1;
      p0 = null;
    }
    function angle(lambda02, lambda12) {
      return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
    }
    function rangeCompare(a2, b2) {
      return a2[0] - b2[0];
    }
    function rangeContains(range2, x2) {
      return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
    }
    function geoBounds$1(feature2) {
      var i, n, a2, b2, merged, deltaMax, delta;
      phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
      ranges = [];
      geoStream(feature2, boundsStream$2);
      if (n = ranges.length) {
        ranges.sort(rangeCompare);
        for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
          b2 = ranges[i];
          if (rangeContains(a2, b2[0]) || rangeContains(a2, b2[1])) {
            if (angle(a2[0], b2[1]) > angle(a2[0], a2[1]))
              a2[1] = b2[1];
            if (angle(b2[0], a2[1]) > angle(a2[0], a2[1]))
              a2[0] = b2[0];
          } else {
            merged.push(a2 = b2);
          }
        }
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b2, ++i) {
          b2 = merged[i];
          if ((delta = angle(a2[1], b2[0])) > deltaMax)
            deltaMax = delta, lambda0 = b2[0], lambda1 = a2[1];
        }
      }
      ranges = range$4 = null;
      return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
    }
    var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$2, Y2$2, Z2$1, lambda00, phi00, x0$4, y0$4, z0;
    var centroidStream$1 = {
      sphere: noop$3,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };
    function centroidPoint$1(lambda, phi2) {
      lambda *= radians, phi2 *= radians;
      var cosPhi = cos$2(phi2);
      centroidPointCartesian(cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi2));
    }
    function centroidPointCartesian(x2, y2, z) {
      ++W0;
      X0$1 += (x2 - X0$1) / W0;
      Y0$1 += (y2 - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }
    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }
    function centroidLinePointFirst(lambda, phi2) {
      lambda *= radians, phi2 *= radians;
      var cosPhi = cos$2(phi2);
      x0$4 = cosPhi * cos$2(lambda);
      y0$4 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi2);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }
    function centroidLinePoint(lambda, phi2) {
      lambda *= radians, phi2 *= radians;
      var cosPhi = cos$2(phi2), x2 = cosPhi * cos$2(lambda), y2 = cosPhi * sin$2(lambda), z = sin$2(phi2), w2 = atan2$1(sqrt$3((w2 = y0$4 * z - z0 * y2) * w2 + (w2 = z0 * x2 - x0$4 * z) * w2 + (w2 = x0$4 * y2 - y0$4 * x2) * w2), x0$4 * x2 + y0$4 * y2 + z0 * z);
      W1 += w2;
      X1$1 += w2 * (x0$4 + (x0$4 = x2));
      Y1$1 += w2 * (y0$4 + (y0$4 = y2));
      Z1$1 += w2 * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }
    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }
    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }
    function centroidRingPointFirst(lambda, phi2) {
      lambda00 = lambda, phi00 = phi2;
      lambda *= radians, phi2 *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$2(phi2);
      x0$4 = cosPhi * cos$2(lambda);
      y0$4 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi2);
      centroidPointCartesian(x0$4, y0$4, z0);
    }
    function centroidRingPoint(lambda, phi2) {
      lambda *= radians, phi2 *= radians;
      var cosPhi = cos$2(phi2), x2 = cosPhi * cos$2(lambda), y2 = cosPhi * sin$2(lambda), z = sin$2(phi2), cx = y0$4 * z - z0 * y2, cy = z0 * x2 - x0$4 * z, cz = x0$4 * y2 - y0$4 * x2, m2 = hypot(cx, cy, cz), w2 = asin$2(m2), v = m2 && -w2 / m2;
      X2$2.add(v * cx);
      Y2$2.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w2;
      X1$1 += w2 * (x0$4 + (x0$4 = x2));
      Y1$1 += w2 * (y0$4 + (y0$4 = y2));
      Z1$1 += w2 * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }
    function geoCentroid$1(object2) {
      W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = 0;
      X2$2 = new Adder();
      Y2$2 = new Adder();
      Z2$1 = new Adder();
      geoStream(object2, centroidStream$1);
      var x2 = +X2$2, y2 = +Y2$2, z = +Z2$1, m2 = hypot(x2, y2, z);
      if (m2 < epsilon2) {
        x2 = X1$1, y2 = Y1$1, z = Z1$1;
        if (W1 < epsilon$3)
          x2 = X0$1, y2 = Y0$1, z = Z0$1;
        m2 = hypot(x2, y2, z);
        if (m2 < epsilon2)
          return [NaN, NaN];
      }
      return [atan2$1(y2, x2) * degrees, asin$2(z / m2) * degrees];
    }
    function compose(a2, b2) {
      function compose2(x2, y2) {
        return x2 = a2(x2, y2), b2(x2[0], x2[1]);
      }
      if (a2.invert && b2.invert)
        compose2.invert = function(x2, y2) {
          return x2 = b2.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
        };
      return compose2;
    }
    function rotationIdentity(lambda, phi2) {
      if (abs$2(lambda) > pi$2)
        lambda -= Math.round(lambda / tau$1) * tau$1;
      return [lambda, phi2];
    }
    rotationIdentity.invert = rotationIdentity;
    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
    }
    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi2) {
        lambda += deltaLambda;
        if (abs$2(lambda) > pi$2)
          lambda -= Math.round(lambda / tau$1) * tau$1;
        return [lambda, phi2];
      };
    }
    function rotationLambda(deltaLambda) {
      var rotation2 = forwardRotationLambda(deltaLambda);
      rotation2.invert = forwardRotationLambda(-deltaLambda);
      return rotation2;
    }
    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$2(deltaPhi), sinDeltaPhi = sin$2(deltaPhi), cosDeltaGamma = cos$2(deltaGamma), sinDeltaGamma = sin$2(deltaGamma);
      function rotation2(lambda, phi2) {
        var cosPhi = cos$2(phi2), x2 = cos$2(lambda) * cosPhi, y2 = sin$2(lambda) * cosPhi, z = sin$2(phi2), k = z * cosDeltaPhi + x2 * sinDeltaPhi;
        return [
          atan2$1(y2 * cosDeltaGamma - k * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
          asin$2(k * cosDeltaGamma + y2 * sinDeltaGamma)
        ];
      }
      rotation2.invert = function(lambda, phi2) {
        var cosPhi = cos$2(phi2), x2 = cos$2(lambda) * cosPhi, y2 = sin$2(lambda) * cosPhi, z = sin$2(phi2), k = z * cosDeltaGamma - y2 * sinDeltaGamma;
        return [
          atan2$1(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k * sinDeltaPhi),
          asin$2(k * cosDeltaPhi - x2 * sinDeltaPhi)
        ];
      };
      return rotation2;
    }
    function rotation(rotate2) {
      rotate2 = rotateRadians(rotate2[0] * radians, rotate2[1] * radians, rotate2.length > 2 ? rotate2[2] * radians : 0);
      function forward2(coordinates) {
        coordinates = rotate2(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }
      forward2.invert = function(coordinates) {
        coordinates = rotate2.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };
      return forward2;
    }
    function circleStream(stream2, radius2, delta, direction, t02, t12) {
      if (!delta)
        return;
      var cosRadius = cos$2(radius2), sinRadius = sin$2(radius2), step = direction * delta;
      if (t02 == null) {
        t02 = radius2 + direction * tau$1;
        t12 = radius2 - step / 2;
      } else {
        t02 = circleRadius(cosRadius, t02);
        t12 = circleRadius(cosRadius, t12);
        if (direction > 0 ? t02 < t12 : t02 > t12)
          t02 += direction * tau$1;
      }
      for (var point2, t4 = t02; direction > 0 ? t4 > t12 : t4 < t12; t4 -= step) {
        point2 = spherical([cosRadius, -sinRadius * cos$2(t4), -sinRadius * sin$2(t4)]);
        stream2.point(point2[0], point2[1]);
      }
    }
    function circleRadius(cosRadius, point2) {
      point2 = cartesian(point2), point2[0] -= cosRadius;
      cartesianNormalizeInPlace(point2);
      var radius2 = acos$1(-point2[1]);
      return ((-point2[2] < 0 ? -radius2 : radius2) + tau$1 - epsilon$3) % tau$1;
    }
    function clipBuffer() {
      var lines = [], line2;
      return {
        point: function(x2, y2, m2) {
          line2.push([x2, y2, m2]);
        },
        lineStart: function() {
          lines.push(line2 = []);
        },
        lineEnd: noop$3,
        rejoin: function() {
          if (lines.length > 1)
            lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line2 = null;
          return result;
        }
      };
    }
    function pointEqual(a2, b2) {
      return abs$2(a2[0] - b2[0]) < epsilon$3 && abs$2(a2[1] - b2[1]) < epsilon$3;
    }
    function Intersection(point2, points2, other, entry2) {
      this.x = point2;
      this.z = points2;
      this.o = other;
      this.e = entry2;
      this.v = false;
      this.n = this.p = null;
    }
    function clipRejoin(segments2, compareIntersection2, startInside, interpolate2, stream2) {
      var subject = [], clip2 = [], i, n;
      segments2.forEach(function(segment) {
        if ((n2 = segment.length - 1) <= 0)
          return;
        var n2, p02 = segment[0], p1 = segment[n2], x2;
        if (pointEqual(p02, p1)) {
          if (!p02[2] && !p1[2]) {
            stream2.lineStart();
            for (i = 0; i < n2; ++i)
              stream2.point((p02 = segment[i])[0], p02[1]);
            stream2.lineEnd();
            return;
          }
          p1[0] += 2 * epsilon$3;
        }
        subject.push(x2 = new Intersection(p02, segment, null, true));
        clip2.push(x2.o = new Intersection(p02, null, x2, false));
        subject.push(x2 = new Intersection(p1, segment, null, false));
        clip2.push(x2.o = new Intersection(p1, null, x2, true));
      });
      if (!subject.length)
        return;
      clip2.sort(compareIntersection2);
      link(subject);
      link(clip2);
      for (i = 0, n = clip2.length; i < n; ++i) {
        clip2[i].e = startInside = !startInside;
      }
      var start2 = subject[0], points2, point2;
      while (1) {
        var current2 = start2, isSubject = true;
        while (current2.v)
          if ((current2 = current2.n) === start2)
            return;
        points2 = current2.z;
        stream2.lineStart();
        do {
          current2.v = current2.o.v = true;
          if (current2.e) {
            if (isSubject) {
              for (i = 0, n = points2.length; i < n; ++i)
                stream2.point((point2 = points2[i])[0], point2[1]);
            } else {
              interpolate2(current2.x, current2.n.x, 1, stream2);
            }
            current2 = current2.n;
          } else {
            if (isSubject) {
              points2 = current2.p.z;
              for (i = points2.length - 1; i >= 0; --i)
                stream2.point((point2 = points2[i])[0], point2[1]);
            } else {
              interpolate2(current2.x, current2.p.x, -1, stream2);
            }
            current2 = current2.p;
          }
          current2 = current2.o;
          points2 = current2.z;
          isSubject = !isSubject;
        } while (!current2.v);
        stream2.lineEnd();
      }
    }
    function link(array2) {
      if (!(n = array2.length))
        return;
      var n, i = 0, a2 = array2[0], b2;
      while (++i < n) {
        a2.n = b2 = array2[i];
        b2.p = a2;
        a2 = b2;
      }
      a2.n = b2 = array2[0];
      b2.p = a2;
    }
    function longitude(point2) {
      return abs$2(point2[0]) <= pi$2 ? point2[0] : sign$1(point2[0]) * ((abs$2(point2[0]) + pi$2) % tau$1 - pi$2);
    }
    function polygonContains(polygon, point2) {
      var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin$2(phi2), normal = [sin$2(lambda), -cos$2(lambda), 0], angle2 = 0, winding = 0;
      var sum2 = new Adder();
      if (sinPhi === 1)
        phi2 = halfPi$2 + epsilon$3;
      else if (sinPhi === -1)
        phi2 = -halfPi$2 - epsilon$3;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m2 = (ring = polygon[i]).length))
          continue;
        var ring, m2, point0 = ring[m2 - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin$2(phi02), cosPhi02 = cos$2(phi02);
        for (var j = 0; j < m2; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
          var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin$2(phi12), cosPhi1 = cos$2(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$2, k = sinPhi02 * sinPhi1;
          sum2.add(atan2$1(k * sign2 * sin$2(absDelta), cosPhi02 * cosPhi1 + k * cos$2(absDelta)));
          angle2 += antimeridian ? delta + sign2 * tau$1 : delta;
          if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
            var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc2);
            var intersection2 = cartesianCross(normal, arc2);
            cartesianNormalizeInPlace(intersection2);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$2(intersection2[2]);
            if (phi2 > phiArc || phi2 === phiArc && (arc2[0] || arc2[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }
      return (angle2 < -epsilon$3 || angle2 < epsilon$3 && sum2 < -epsilon2) ^ winding & 1;
    }
    function clip$3(pointVisible, clipLine2, interpolate2, start2) {
      return function(sink) {
        var line2 = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments2, ring;
        var clip2 = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart: function() {
            clip2.point = pointRing;
            clip2.lineStart = ringStart;
            clip2.lineEnd = ringEnd;
            segments2 = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip2.point = point2;
            clip2.lineStart = lineStart;
            clip2.lineEnd = lineEnd;
            segments2 = merge$3(segments2);
            var startInside = polygonContains(polygon, start2);
            if (segments2.length) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments2, compareIntersection, startInside, interpolate2, sink);
            } else if (startInside) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate2(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted)
              sink.polygonEnd(), polygonStarted = false;
            segments2 = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate2(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };
        function point2(lambda, phi2) {
          if (pointVisible(lambda, phi2))
            sink.point(lambda, phi2);
        }
        function pointLine(lambda, phi2) {
          line2.point(lambda, phi2);
        }
        function lineStart() {
          clip2.point = pointLine;
          line2.lineStart();
        }
        function lineEnd() {
          clip2.point = point2;
          line2.lineEnd();
        }
        function pointRing(lambda, phi2) {
          ring.push([lambda, phi2]);
          ringSink.point(lambda, phi2);
        }
        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }
        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();
          var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point3;
          ring.pop();
          polygon.push(ring);
          ring = null;
          if (!n)
            return;
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m2 = segment.length - 1) > 0) {
              if (!polygonStarted)
                sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m2; ++i)
                sink.point((point3 = segment[i])[0], point3[1]);
              sink.lineEnd();
            }
            return;
          }
          if (n > 1 && clean & 2)
            ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
          segments2.push(ringSegments.filter(validSegment));
        }
        return clip2;
      };
    }
    function validSegment(segment) {
      return segment.length > 1;
    }
    function compareIntersection(a2, b2) {
      return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi$2 - epsilon$3 : halfPi$2 - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi$2 - epsilon$3 : halfPi$2 - b2[1]);
    }
    const clipAntimeridian = clip$3(
      function() {
        return true;
      },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$2, -halfPi$2]
    );
    function clipAntimeridianLine(stream2) {
      var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
      return {
        lineStart: function() {
          stream2.lineStart();
          clean = 1;
        },
        point: function(lambda12, phi12) {
          var sign1 = lambda12 > 0 ? pi$2 : -pi$2, delta = abs$2(lambda12 - lambda02);
          if (abs$2(delta - pi$2) < epsilon$3) {
            stream2.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi$2 : -halfPi$2);
            stream2.point(sign0, phi02);
            stream2.lineEnd();
            stream2.lineStart();
            stream2.point(sign1, phi02);
            stream2.point(lambda12, phi02);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$2) {
            if (abs$2(lambda02 - sign0) < epsilon$3)
              lambda02 -= sign0 * epsilon$3;
            if (abs$2(lambda12 - sign1) < epsilon$3)
              lambda12 -= sign1 * epsilon$3;
            phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
            stream2.point(sign0, phi02);
            stream2.lineEnd();
            stream2.lineStart();
            stream2.point(sign1, phi02);
            clean = 0;
          }
          stream2.point(lambda02 = lambda12, phi02 = phi12);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream2.lineEnd();
          lambda02 = phi02 = NaN;
        },
        clean: function() {
          return 2 - clean;
        }
      };
    }
    function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
      var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin$2(lambda02 - lambda12);
      return abs$2(sinLambda0Lambda1) > epsilon$3 ? atan((sin$2(phi02) * (cosPhi1 = cos$2(phi12)) * sin$2(lambda12) - sin$2(phi12) * (cosPhi02 = cos$2(phi02)) * sin$2(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
    }
    function clipAntimeridianInterpolate(from, to, direction, stream2) {
      var phi2;
      if (from == null) {
        phi2 = direction * halfPi$2;
        stream2.point(-pi$2, phi2);
        stream2.point(0, phi2);
        stream2.point(pi$2, phi2);
        stream2.point(pi$2, 0);
        stream2.point(pi$2, -phi2);
        stream2.point(0, -phi2);
        stream2.point(-pi$2, -phi2);
        stream2.point(-pi$2, 0);
        stream2.point(-pi$2, phi2);
      } else if (abs$2(from[0] - to[0]) > epsilon$3) {
        var lambda = from[0] < to[0] ? pi$2 : -pi$2;
        phi2 = direction * lambda / 2;
        stream2.point(-lambda, phi2);
        stream2.point(0, phi2);
        stream2.point(lambda, phi2);
      } else {
        stream2.point(to[0], to[1]);
      }
    }
    function clipCircle(radius2) {
      var cr2 = cos$2(radius2), delta = 6 * radians, smallRadius = cr2 > 0, notHemisphere = abs$2(cr2) > epsilon$3;
      function interpolate2(from, to, direction, stream2) {
        circleStream(stream2, radius2, delta, direction, from, to);
      }
      function visible(lambda, phi2) {
        return cos$2(lambda) * cos$2(phi2) > cr2;
      }
      function clipLine2(stream2) {
        var point0, c0, v0, v00, clean;
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi2) {
            var point1 = [lambda, phi2], point2, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code2(lambda, phi2) : v ? code2(lambda + (lambda < 0 ? pi$2 : -pi$2), phi2) : 0;
            if (!point0 && (v00 = v0 = v))
              stream2.lineStart();
            if (v !== v0) {
              point2 = intersect2(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                stream2.lineStart();
                point2 = intersect2(point1, point0);
                stream2.point(point2[0], point2[1]);
              } else {
                point2 = intersect2(point0, point1);
                stream2.point(point2[0], point2[1], 2);
                stream2.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t4;
              if (!(c2 & c0) && (t4 = intersect2(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream2.lineStart();
                  stream2.point(t4[0][0], t4[0][1]);
                  stream2.point(t4[1][0], t4[1][1]);
                  stream2.lineEnd();
                } else {
                  stream2.point(t4[1][0], t4[1][1]);
                  stream2.lineEnd();
                  stream2.lineStart();
                  stream2.point(t4[0][0], t4[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream2.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c2;
          },
          lineEnd: function() {
            if (v0)
              stream2.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | (v00 && v0) << 1;
          }
        };
      }
      function intersect2(a2, b2, two) {
        var pa2 = cartesian(a2), pb = cartesian(b2);
        var n1 = [1, 0, 0], n2 = cartesianCross(pa2, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
        if (!determinant)
          return !two && a2;
        var c1 = cr2 * n2n2 / determinant, c2 = -cr2 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
        cartesianAddInPlace(A5, B2);
        var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t22 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
        if (t22 < 0)
          return;
        var t4 = sqrt$3(t22), q = cartesianScale(u2, (-w2 - t4) / uu);
        cartesianAddInPlace(q, A5);
        q = spherical(q);
        if (!two)
          return q;
        var lambda02 = a2[0], lambda12 = b2[0], phi02 = a2[1], phi12 = b2[1], z;
        if (lambda12 < lambda02)
          z = lambda02, lambda02 = lambda12, lambda12 = z;
        var delta2 = lambda12 - lambda02, polar = abs$2(delta2 - pi$2) < epsilon$3, meridian = polar || delta2 < epsilon$3;
        if (!polar && phi12 < phi02)
          z = phi02, phi02 = phi12, phi12 = z;
        if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs$2(q[0] - lambda02) < epsilon$3 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi$2 ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
          var q1 = cartesianScale(u2, (-w2 + t4) / uu);
          cartesianAddInPlace(q1, A5);
          return [q, spherical(q1)];
        }
      }
      function code2(lambda, phi2) {
        var r = smallRadius ? radius2 : pi$2 - radius2, code3 = 0;
        if (lambda < -r)
          code3 |= 1;
        else if (lambda > r)
          code3 |= 2;
        if (phi2 < -r)
          code3 |= 4;
        else if (phi2 > r)
          code3 |= 8;
        return code3;
      }
      return clip$3(visible, clipLine2, interpolate2, smallRadius ? [0, -radius2] : [-pi$2, radius2 - pi$2]);
    }
    function clipLine(a2, b2, x02, y02, x12, y12) {
      var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
      r = x02 - ax;
      if (!dx && r > 0)
        return;
      r /= dx;
      if (dx < 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      } else if (dx > 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      }
      r = x12 - ax;
      if (!dx && r < 0)
        return;
      r /= dx;
      if (dx < 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      } else if (dx > 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      }
      r = y02 - ay;
      if (!dy && r > 0)
        return;
      r /= dy;
      if (dy < 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      } else if (dy > 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      }
      r = y12 - ay;
      if (!dy && r < 0)
        return;
      r /= dy;
      if (dy < 0) {
        if (r > t12)
          return;
        if (r > t02)
          t02 = r;
      } else if (dy > 0) {
        if (r < t02)
          return;
        if (r < t12)
          t12 = r;
      }
      if (t02 > 0)
        a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
      if (t12 < 1)
        b2[0] = ax + t12 * dx, b2[1] = ay + t12 * dy;
      return true;
    }
    var clipMax = 1e9, clipMin = -clipMax;
    function clipRectangle(x02, y02, x12, y12) {
      function visible(x2, y2) {
        return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
      }
      function interpolate2(from, to, direction, stream2) {
        var a2 = 0, a1 = 0;
        if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
          do
            stream2.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
          while ((a2 = (a2 + direction + 4) % 4) !== a1);
        } else {
          stream2.point(to[0], to[1]);
        }
      }
      function corner(p, direction) {
        return abs$2(p[0] - x02) < epsilon$3 ? direction > 0 ? 0 : 3 : abs$2(p[0] - x12) < epsilon$3 ? direction > 0 ? 2 : 1 : abs$2(p[1] - y02) < epsilon$3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
      }
      function compareIntersection2(a2, b2) {
        return comparePoint(a2.x, b2.x);
      }
      function comparePoint(a2, b2) {
        var ca = corner(a2, 1), cb = corner(b2, 1);
        return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
      }
      return function(stream2) {
        var activeStream = stream2, bufferStream = clipBuffer(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
        var clipStream = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart,
          polygonEnd
        };
        function point2(x2, y2) {
          if (visible(x2, y2))
            activeStream.point(x2, y2);
        }
        function polygonInside() {
          var winding = 0;
          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m2; ++j) {
              a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
              if (a1 <= y12) {
                if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                  ++winding;
              } else {
                if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                  --winding;
              }
            }
          }
          return winding;
        }
        function polygonStart() {
          activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
        }
        function polygonEnd() {
          var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge$3(segments2)).length;
          if (cleanInside || visible2) {
            stream2.polygonStart();
            if (cleanInside) {
              stream2.lineStart();
              interpolate2(null, null, 1, stream2);
              stream2.lineEnd();
            }
            if (visible2) {
              clipRejoin(segments2, compareIntersection2, startInside, interpolate2, stream2);
            }
            stream2.polygonEnd();
          }
          activeStream = stream2, segments2 = polygon = ring = null;
        }
        function lineStart() {
          clipStream.point = linePoint2;
          if (polygon)
            polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }
        function lineEnd() {
          if (segments2) {
            linePoint2(x__, y__);
            if (v__ && v_)
              bufferStream.rejoin();
            segments2.push(bufferStream.result());
          }
          clipStream.point = point2;
          if (v_)
            activeStream.lineEnd();
        }
        function linePoint2(x2, y2) {
          var v = visible(x2, y2);
          if (polygon)
            ring.push([x2, y2]);
          if (first) {
            x__ = x2, y__ = y2, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x2, y2);
            }
          } else {
            if (v && v_)
              activeStream.point(x2, y2);
            else {
              var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
              if (clipLine(a2, b2, x02, y02, x12, y12)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a2[0], a2[1]);
                }
                activeStream.point(b2[0], b2[1]);
                if (!v)
                  activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x2, y2);
                clean = false;
              }
            }
          }
          x_ = x2, y_ = y2, v_ = v;
        }
        return clipStream;
      };
    }
    function graticuleX(y02, y12, dy) {
      var y2 = range$5(y02, y12 - epsilon$3, dy).concat(y12);
      return function(x2) {
        return y2.map(function(y3) {
          return [x2, y3];
        });
      };
    }
    function graticuleY(x02, x12, dx) {
      var x2 = range$5(x02, x12 - epsilon$3, dx).concat(x12);
      return function(y2) {
        return x2.map(function(x3) {
          return [x3, y2];
        });
      };
    }
    function graticule() {
      var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
      function graticule2() {
        return { type: "MultiLineString", coordinates: lines() };
      }
      function lines() {
        return range$5(ceil(X02 / DX) * DX, X12, DX).map(X3).concat(range$5(ceil(Y02 / DY) * DY, Y12, DY).map(Y3)).concat(range$5(ceil(x02 / dx) * dx, x12, dx).filter(function(x3) {
          return abs$2(x3 % DX) > epsilon$3;
        }).map(x2)).concat(range$5(ceil(y02 / dy) * dy, y12, dy).filter(function(y3) {
          return abs$2(y3 % DY) > epsilon$3;
        }).map(y2));
      }
      graticule2.lines = function() {
        return lines().map(function(coordinates) {
          return { type: "LineString", coordinates };
        });
      };
      graticule2.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X3(X02).concat(
              Y3(Y12).slice(1),
              X3(X12).reverse().slice(1),
              Y3(Y02).reverse().slice(1)
            )
          ]
        };
      };
      graticule2.extent = function(_) {
        if (!arguments.length)
          return graticule2.extentMinor();
        return graticule2.extentMajor(_).extentMinor(_);
      };
      graticule2.extentMajor = function(_) {
        if (!arguments.length)
          return [[X02, Y02], [X12, Y12]];
        X02 = +_[0][0], X12 = +_[1][0];
        Y02 = +_[0][1], Y12 = +_[1][1];
        if (X02 > X12)
          _ = X02, X02 = X12, X12 = _;
        if (Y02 > Y12)
          _ = Y02, Y02 = Y12, Y12 = _;
        return graticule2.precision(precision);
      };
      graticule2.extentMinor = function(_) {
        if (!arguments.length)
          return [[x02, y02], [x12, y12]];
        x02 = +_[0][0], x12 = +_[1][0];
        y02 = +_[0][1], y12 = +_[1][1];
        if (x02 > x12)
          _ = x02, x02 = x12, x12 = _;
        if (y02 > y12)
          _ = y02, y02 = y12, y12 = _;
        return graticule2.precision(precision);
      };
      graticule2.step = function(_) {
        if (!arguments.length)
          return graticule2.stepMinor();
        return graticule2.stepMajor(_).stepMinor(_);
      };
      graticule2.stepMajor = function(_) {
        if (!arguments.length)
          return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule2;
      };
      graticule2.stepMinor = function(_) {
        if (!arguments.length)
          return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule2;
      };
      graticule2.precision = function(_) {
        if (!arguments.length)
          return precision;
        precision = +_;
        x2 = graticuleX(y02, y12, 90);
        y2 = graticuleY(x02, x12, precision);
        X3 = graticuleX(Y02, Y12, 90);
        Y3 = graticuleY(X02, X12, precision);
        return graticule2;
      };
      return graticule2.extentMajor([[-180, -90 + epsilon$3], [180, 90 - epsilon$3]]).extentMinor([[-180, -80 - epsilon$3], [180, 80 + epsilon$3]]);
    }
    const identity$4 = (x2) => x2;
    var areaSum = new Adder(), areaRingSum = new Adder(), x00$2, y00$2, x0$3, y0$3;
    var areaStream = {
      point: noop$3,
      lineStart: noop$3,
      lineEnd: noop$3,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$3;
        areaSum.add(abs$2(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area2 = areaSum / 2;
        areaSum = new Adder();
        return area2;
      }
    };
    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }
    function areaPointFirst(x2, y2) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x2, y00$2 = y0$3 = y2;
    }
    function areaPoint(x2, y2) {
      areaRingSum.add(y0$3 * x2 - x0$3 * y2);
      x0$3 = x2, y0$3 = y2;
    }
    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }
    const pathArea = areaStream;
    var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$3,
      lineEnd: noop$3,
      polygonStart: noop$3,
      polygonEnd: noop$3,
      result: function() {
        var bounds2 = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds2;
      }
    };
    function boundsPoint(x2, y2) {
      if (x2 < x0$2)
        x0$2 = x2;
      if (x2 > x1)
        x1 = x2;
      if (y2 < y0$2)
        y0$2 = y2;
      if (y2 > y1)
        y1 = y2;
    }
    const boundsStream$1 = boundsStream;
    var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2$1 = 0, Y2$1 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2$1 / Z2, Y2$1 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
        X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2$1 = Y2$1 = Z2 = 0;
        return centroid;
      }
    };
    function centroidPoint(x2, y2) {
      X0 += x2;
      Y0 += y2;
      ++Z0;
    }
    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }
    function centroidPointFirstLine(x2, y2) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x2, y0$1 = y2);
    }
    function centroidPointLine(x2, y2) {
      var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$3(dx * dx + dy * dy);
      X1 += z * (x0$1 + x2) / 2;
      Y1 += z * (y0$1 + y2) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x2, y0$1 = y2);
    }
    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }
    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }
    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }
    function centroidPointFirstRing(x2, y2) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x2, y00$1 = y0$1 = y2);
    }
    function centroidPointRing(x2, y2) {
      var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$3(dx * dx + dy * dy);
      X1 += z * (x0$1 + x2) / 2;
      Y1 += z * (y0$1 + y2) / 2;
      Z1 += z;
      z = y0$1 * x2 - x0$1 * y2;
      X2$1 += z * (x0$1 + x2);
      Y2$1 += z * (y0$1 + y2);
      Z2 += z * 3;
      centroidPoint(x0$1 = x2, y0$1 = y2);
    }
    const pathCentroid = centroidStream;
    function PathContext(context2) {
      this._context = context2;
    }
    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x2, y2) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x2, y2);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x2, y2);
            break;
          }
          default: {
            this._context.moveTo(x2 + this._radius, y2);
            this._context.arc(x2, y2, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$3
    };
    var lengthSum = new Adder(), lengthRing, x00, y00, x0, y0;
    var lengthStream = {
      point: noop$3,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing)
          lengthPoint(x00, y00);
        lengthStream.point = noop$3;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length2 = +lengthSum;
        lengthSum = new Adder();
        return length2;
      }
    };
    function lengthPointFirst(x2, y2) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x2, y00 = y0 = y2;
    }
    function lengthPoint(x2, y2) {
      x0 -= x2, y0 -= y2;
      lengthSum.add(sqrt$3(x0 * x0 + y0 * y0));
      x0 = x2, y0 = y2;
    }
    const pathMeasure = lengthStream;
    let cacheDigits, cacheAppend, cacheRadius, cacheCircle;
    class PathString {
      constructor(digits) {
        this._append = digits == null ? append : appendRound(digits);
        this._radius = 4.5;
        this._ = "";
      }
      pointRadius(_) {
        this._radius = +_;
        return this;
      }
      polygonStart() {
        this._line = 0;
      }
      polygonEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line === 0)
          this._ += "Z";
        this._point = NaN;
      }
      point(x2, y2) {
        switch (this._point) {
          case 0: {
            this._append`M${x2},${y2}`;
            this._point = 1;
            break;
          }
          case 1: {
            this._append`L${x2},${y2}`;
            break;
          }
          default: {
            this._append`M${x2},${y2}`;
            if (this._radius !== cacheRadius || this._append !== cacheAppend) {
              const r = this._radius;
              const s = this._;
              this._ = "";
              this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
              cacheRadius = r;
              cacheAppend = this._append;
              cacheCircle = this._;
              this._ = s;
            }
            this._ += cacheCircle;
            break;
          }
        }
      }
      result() {
        const result = this._;
        this._ = "";
        return result.length ? result : null;
      }
    }
    function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound(digits) {
      const d = Math.floor(digits);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${digits}`);
      if (d > 15)
        return append;
      if (d !== cacheDigits) {
        const k = 10 ** d;
        cacheDigits = d;
        cacheAppend = function append2(strings) {
          let i = 1;
          this._ += strings[0];
          for (const j = strings.length; i < j; ++i) {
            this._ += Math.round(arguments[i] * k) / k + strings[i];
          }
        };
      }
      return cacheAppend;
    }
    function geoPath(projection2, context2) {
      let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
      function path2(object2) {
        if (object2) {
          if (typeof pointRadius === "function")
            contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object2, projectionStream(contextStream));
        }
        return contextStream.result();
      }
      path2.area = function(object2) {
        geoStream(object2, projectionStream(pathArea));
        return pathArea.result();
      };
      path2.measure = function(object2) {
        geoStream(object2, projectionStream(pathMeasure));
        return pathMeasure.result();
      };
      path2.bounds = function(object2) {
        geoStream(object2, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };
      path2.centroid = function(object2) {
        geoStream(object2, projectionStream(pathCentroid));
        return pathCentroid.result();
      };
      path2.projection = function(_) {
        if (!arguments.length)
          return projection2;
        projectionStream = _ == null ? (projection2 = null, identity$4) : (projection2 = _).stream;
        return path2;
      };
      path2.context = function(_) {
        if (!arguments.length)
          return context2;
        contextStream = _ == null ? (context2 = null, new PathString(digits)) : new PathContext(context2 = _);
        if (typeof pointRadius !== "function")
          contextStream.pointRadius(pointRadius);
        return path2;
      };
      path2.pointRadius = function(_) {
        if (!arguments.length)
          return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path2;
      };
      path2.digits = function(_) {
        if (!arguments.length)
          return digits;
        if (_ == null)
          digits = null;
        else {
          const d = Math.floor(_);
          if (!(d >= 0))
            throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        if (context2 === null)
          contextStream = new PathString(digits);
        return path2;
      };
      return path2.projection(projection2).digits(digits).context(context2);
    }
    function transformer$3(methods2) {
      return function(stream2) {
        var s = new TransformStream();
        for (var key2 in methods2)
          s[key2] = methods2[key2];
        s.stream = stream2;
        return s;
      };
    }
    function TransformStream() {
    }
    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x2, y2) {
        this.stream.point(x2, y2);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
    function fit$1(projection2, fitBounds, object2) {
      var clip2 = projection2.clipExtent && projection2.clipExtent();
      projection2.scale(150).translate([0, 0]);
      if (clip2 != null)
        projection2.clipExtent(null);
      geoStream(object2, projection2.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip2 != null)
        projection2.clipExtent(clip2);
      return projection2;
    }
    function fitExtent(projection2, extent2, object2) {
      return fit$1(projection2, function(b2) {
        var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x2 = +extent2[0][0] + (w2 - k * (b2[1][0] + b2[0][0])) / 2, y2 = +extent2[0][1] + (h2 - k * (b2[1][1] + b2[0][1])) / 2;
        projection2.scale(150 * k).translate([x2, y2]);
      }, object2);
    }
    function fitSize(projection2, size2, object2) {
      return fitExtent(projection2, [[0, 0], size2], object2);
    }
    function fitWidth(projection2, width2, object2) {
      return fit$1(projection2, function(b2) {
        var w2 = +width2, k = w2 / (b2[1][0] - b2[0][0]), x2 = (w2 - k * (b2[1][0] + b2[0][0])) / 2, y2 = -k * b2[0][1];
        projection2.scale(150 * k).translate([x2, y2]);
      }, object2);
    }
    function fitHeight(projection2, height2, object2) {
      return fit$1(projection2, function(b2) {
        var h2 = +height2, k = h2 / (b2[1][1] - b2[0][1]), x2 = -k * b2[0][0], y2 = (h2 - k * (b2[1][1] + b2[0][1])) / 2;
        projection2.scale(150 * k).translate([x2, y2]);
      }, object2);
    }
    var maxDepth = 16, cosMinDistance = cos$2(30 * radians);
    function resample(project2, delta2) {
      return +delta2 ? resample$1(project2, delta2) : resampleNone(project2);
    }
    function resampleNone(project2) {
      return transformer$3({
        point: function(x2, y2) {
          x2 = project2(x2, y2);
          this.stream.point(x2[0], x2[1]);
        }
      });
    }
    function resample$1(project2, delta2) {
      function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream2) {
        var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt$3(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin$2(c2 /= m2), lambda22 = abs$2(abs$2(c2) - 1) < epsilon$3 || abs$2(lambda02 - lambda12) < epsilon$3 ? (lambda02 + lambda12) / 2 : atan2$1(b2, a2), p = project2(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 || abs$2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
            resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a2 /= m2, b2 /= m2, c2, depth, stream2);
            stream2.point(x2, y2);
            resampleLineTo(x2, y2, lambda22, a2, b2, c2, x12, y12, lambda12, a1, b1, c1, depth, stream2);
          }
        }
      }
      return function(stream2) {
        var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
        var resampleStream = {
          point: point2,
          lineStart,
          lineEnd,
          polygonStart: function() {
            stream2.polygonStart();
            resampleStream.lineStart = ringStart;
          },
          polygonEnd: function() {
            stream2.polygonEnd();
            resampleStream.lineStart = lineStart;
          }
        };
        function point2(x2, y2) {
          x2 = project2(x2, y2);
          stream2.point(x2[0], x2[1]);
        }
        function lineStart() {
          x02 = NaN;
          resampleStream.point = linePoint2;
          stream2.lineStart();
        }
        function linePoint2(lambda, phi2) {
          var c2 = cartesian([lambda, phi2]), p = project2(lambda, phi2);
          resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream2);
          stream2.point(x02, y02);
        }
        function lineEnd() {
          resampleStream.point = point2;
          stream2.lineEnd();
        }
        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }
        function ringPoint(lambda, phi2) {
          linePoint2(lambda002 = lambda, phi2), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint2;
        }
        function ringEnd() {
          resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream2);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }
        return resampleStream;
      };
    }
    var transformRadians = transformer$3({
      point: function(x2, y2) {
        this.stream.point(x2 * radians, y2 * radians);
      }
    });
    function transformRotate(rotate2) {
      return transformer$3({
        point: function(x2, y2) {
          var r = rotate2(x2, y2);
          return this.stream.point(r[0], r[1]);
        }
      });
    }
    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform2(x2, y2) {
        x2 *= sx;
        y2 *= sy;
        return [dx + k * x2, dy - k * y2];
      }
      transform2.invert = function(x2, y2) {
        return [(x2 - dx) / k * sx, (dy - y2) / k * sy];
      };
      return transform2;
    }
    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha)
        return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$2(alpha), sinAlpha = sin$2(alpha), a2 = cosAlpha * k, b2 = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform2(x2, y2) {
        x2 *= sx;
        y2 *= sy;
        return [a2 * x2 - b2 * y2 + dx, dy - b2 * x2 - a2 * y2];
      }
      transform2.invert = function(x2, y2) {
        return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
      };
      return transform2;
    }
    function projection$1(project2) {
      return projectionMutator(function() {
        return project2;
      })();
    }
    function projectionMutator(projectAt) {
      var project2, k = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
      function projection2(point2) {
        return projectRotateTransform(point2[0] * radians, point2[1] * radians);
      }
      function invert2(point2) {
        point2 = projectRotateTransform.invert(point2[0], point2[1]);
        return point2 && [point2[0] * degrees, point2[1] * degrees];
      }
      projection2.stream = function(stream2) {
        return cache2 && cacheStream === stream2 ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream2)))));
      };
      projection2.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = void 0, reset2()) : preclip;
      };
      projection2.postclip = function(_) {
        return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
      };
      projection2.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset2()) : theta * degrees;
      };
      projection2.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity$4) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
      };
      projection2.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };
      projection2.translate = function(_) {
        return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
      };
      projection2.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi2 = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
      };
      projection2.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };
      projection2.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };
      projection2.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };
      projection2.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };
      projection2.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset2()) : sqrt$3(delta2);
      };
      projection2.fitExtent = function(extent2, object2) {
        return fitExtent(projection2, extent2, object2);
      };
      projection2.fitSize = function(size2, object2) {
        return fitSize(projection2, size2, object2);
      };
      projection2.fitWidth = function(width2, object2) {
        return fitWidth(projection2, width2, object2);
      };
      projection2.fitHeight = function(height2, object2) {
        return fitHeight(projection2, height2, object2);
      };
      function recenter() {
        var center2 = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k, x2 - center2[0], y2 - center2[1], sx, sy, alpha);
        rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project2, transform2);
        projectRotateTransform = compose(rotate2, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset2();
      }
      function reset2() {
        cache2 = cacheStream = null;
        return projection2;
      }
      return function() {
        project2 = projectAt.apply(this, arguments);
        projection2.invert = project2.invert && invert2;
        return recenter();
      };
    }
    function conicProjection(projectAt) {
      var phi02 = 0, phi12 = pi$2 / 3, m2 = projectionMutator(projectAt), p = m2(phi02, phi12);
      p.parallels = function(_) {
        return arguments.length ? m2(phi02 = _[0] * radians, phi12 = _[1] * radians) : [phi02 * degrees, phi12 * degrees];
      };
      return p;
    }
    function cylindricalEqualAreaRaw(phi02) {
      var cosPhi02 = cos$2(phi02);
      function forward2(lambda, phi2) {
        return [lambda * cosPhi02, sin$2(phi2) / cosPhi02];
      }
      forward2.invert = function(x2, y2) {
        return [x2 / cosPhi02, asin$2(y2 * cosPhi02)];
      };
      return forward2;
    }
    function conicEqualAreaRaw(y02, y12) {
      var sy0 = sin$2(y02), n = (sy0 + sin$2(y12)) / 2;
      if (abs$2(n) < epsilon$3)
        return cylindricalEqualAreaRaw(y02);
      var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$3(c2) / n;
      function project2(x2, y2) {
        var r = sqrt$3(c2 - 2 * n * sin$2(y2)) / n;
        return [r * sin$2(x2 *= n), r0 - r * cos$2(x2)];
      }
      project2.invert = function(x2, y2) {
        var r0y = r0 - y2, l = atan2$1(x2, abs$2(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$2 * sign$1(x2) * sign$1(r0y);
        return [l / n, asin$2((c2 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
      };
      return project2;
    }
    function geoConicEqualArea() {
      return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
    }
    function geoAlbers() {
      return geoConicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
    }
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x2, y2) {
          var i = -1;
          while (++i < n)
            streams[i].point(x2, y2);
        },
        sphere: function() {
          var i = -1;
          while (++i < n)
            streams[i].sphere();
        },
        lineStart: function() {
          var i = -1;
          while (++i < n)
            streams[i].lineStart();
        },
        lineEnd: function() {
          var i = -1;
          while (++i < n)
            streams[i].lineEnd();
        },
        polygonStart: function() {
          var i = -1;
          while (++i < n)
            streams[i].polygonStart();
        },
        polygonEnd: function() {
          var i = -1;
          while (++i < n)
            streams[i].polygonEnd();
        }
      };
    }
    function geoAlbersUsa() {
      var cache2, cacheStream, lower48 = geoAlbers(), lower48Point, alaska = geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x2, y2) {
        point2 = [x2, y2];
      } };
      function albersUsa(coordinates) {
        var x2 = coordinates[0], y2 = coordinates[1];
        return point2 = null, (lower48Point.point(x2, y2), point2) || (alaskaPoint.point(x2, y2), point2) || (hawaiiPoint.point(x2, y2), point2);
      }
      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(), t4 = lower48.translate(), x2 = (coordinates[0] - t4[0]) / k, y2 = (coordinates[1] - t4[1]) / k;
        return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates);
      };
      albersUsa.stream = function(stream2) {
        return cache2 && cacheStream === stream2 ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
      };
      albersUsa.precision = function(_) {
        if (!arguments.length)
          return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset2();
      };
      albersUsa.scale = function(_) {
        if (!arguments.length)
          return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };
      albersUsa.translate = function(_) {
        if (!arguments.length)
          return lower48.translate();
        var k = lower48.scale(), x2 = +_[0], y2 = +_[1];
        lower48Point = lower48.translate(_).clipExtent([[x2 - 0.455 * k, y2 - 0.238 * k], [x2 + 0.455 * k, y2 + 0.238 * k]]).stream(pointStream);
        alaskaPoint = alaska.translate([x2 - 0.307 * k, y2 + 0.201 * k]).clipExtent([[x2 - 0.425 * k + epsilon$3, y2 + 0.12 * k + epsilon$3], [x2 - 0.214 * k - epsilon$3, y2 + 0.234 * k - epsilon$3]]).stream(pointStream);
        hawaiiPoint = hawaii.translate([x2 - 0.205 * k, y2 + 0.212 * k]).clipExtent([[x2 - 0.214 * k + epsilon$3, y2 + 0.166 * k + epsilon$3], [x2 - 0.115 * k - epsilon$3, y2 + 0.234 * k - epsilon$3]]).stream(pointStream);
        return reset2();
      };
      albersUsa.fitExtent = function(extent2, object2) {
        return fitExtent(albersUsa, extent2, object2);
      };
      albersUsa.fitSize = function(size2, object2) {
        return fitSize(albersUsa, size2, object2);
      };
      albersUsa.fitWidth = function(width2, object2) {
        return fitWidth(albersUsa, width2, object2);
      };
      albersUsa.fitHeight = function(height2, object2) {
        return fitHeight(albersUsa, height2, object2);
      };
      function reset2() {
        cache2 = cacheStream = null;
        return albersUsa;
      }
      return albersUsa.scale(1070);
    }
    function azimuthalRaw(scale2) {
      return function(x2, y2) {
        var cx = cos$2(x2), cy = cos$2(y2), k = scale2(cx * cy);
        if (k === Infinity)
          return [2, 0];
        return [
          k * cy * sin$2(x2),
          k * sin$2(y2)
        ];
      };
    }
    function azimuthalInvert(angle2) {
      return function(x2, y2) {
        var z = sqrt$3(x2 * x2 + y2 * y2), c2 = angle2(z), sc = sin$2(c2), cc = cos$2(c2);
        return [
          atan2$1(x2 * sc, z * cc),
          asin$2(z && y2 * sc / z)
        ];
      };
    }
    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$3(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$2(z / 2);
    });
    function geoAzimuthalEqualArea() {
      return projection$1(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
    }
    var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
      return (c2 = acos$1(c2)) && c2 / sin$2(c2);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });
    function geoAzimuthalEquidistant() {
      return projection$1(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
    }
    function mercatorRaw(lambda, phi2) {
      return [lambda, log$4(tan((halfPi$2 + phi2) / 2))];
    }
    mercatorRaw.invert = function(x2, y2) {
      return [x2, 2 * atan(exp$2(y2)) - halfPi$2];
    };
    function geoMercator() {
      return mercatorProjection(mercatorRaw).scale(961 / tau$1);
    }
    function mercatorProjection(project2) {
      var m2 = projection$1(project2), center2 = m2.center, scale2 = m2.scale, translate2 = m2.translate, clipExtent = m2.clipExtent, x02 = null, y02, x12, y12;
      m2.scale = function(_) {
        return arguments.length ? (scale2(_), reclip()) : scale2();
      };
      m2.translate = function(_) {
        return arguments.length ? (translate2(_), reclip()) : translate2();
      };
      m2.center = function(_) {
        return arguments.length ? (center2(_), reclip()) : center2();
      };
      m2.clipExtent = function(_) {
        return arguments.length ? (_ == null ? x02 = y02 = x12 = y12 = null : (x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
      };
      function reclip() {
        var k = pi$2 * scale2(), t4 = m2(rotation(m2.rotate()).invert([0, 0]));
        return clipExtent(x02 == null ? [[t4[0] - k, t4[1] - k], [t4[0] + k, t4[1] + k]] : project2 === mercatorRaw ? [[Math.max(t4[0] - k, x02), y02], [Math.min(t4[0] + k, x12), y12]] : [[x02, Math.max(t4[1] - k, y02)], [x12, Math.min(t4[1] + k, y12)]]);
      }
      return reclip();
    }
    function tany(y2) {
      return tan((halfPi$2 + y2) / 2);
    }
    function conicConformalRaw(y02, y12) {
      var cy0 = cos$2(y02), n = y02 === y12 ? sin$2(y02) : log$4(cy0 / cos$2(y12)) / log$4(tany(y12) / tany(y02)), f = cy0 * pow$3(tany(y02), n) / n;
      if (!n)
        return mercatorRaw;
      function project2(x2, y2) {
        if (f > 0) {
          if (y2 < -halfPi$2 + epsilon$3)
            y2 = -halfPi$2 + epsilon$3;
        } else {
          if (y2 > halfPi$2 - epsilon$3)
            y2 = halfPi$2 - epsilon$3;
        }
        var r = f / pow$3(tany(y2), n);
        return [r * sin$2(n * x2), f - r * cos$2(n * x2)];
      }
      project2.invert = function(x2, y2) {
        var fy = f - y2, r = sign$1(n) * sqrt$3(x2 * x2 + fy * fy), l = atan2$1(x2, abs$2(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$2 * sign$1(x2) * sign$1(fy);
        return [l / n, 2 * atan(pow$3(f / r, 1 / n)) - halfPi$2];
      };
      return project2;
    }
    function geoConicConformal() {
      return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
    }
    function equirectangularRaw(lambda, phi2) {
      return [lambda, phi2];
    }
    equirectangularRaw.invert = equirectangularRaw;
    function geoEquirectangular() {
      return projection$1(equirectangularRaw).scale(152.63);
    }
    function conicEquidistantRaw(y02, y12) {
      var cy0 = cos$2(y02), n = y02 === y12 ? sin$2(y02) : (cy0 - cos$2(y12)) / (y12 - y02), g = cy0 / n + y02;
      if (abs$2(n) < epsilon$3)
        return equirectangularRaw;
      function project2(x2, y2) {
        var gy = g - y2, nx = n * x2;
        return [gy * sin$2(nx), g - gy * cos$2(nx)];
      }
      project2.invert = function(x2, y2) {
        var gy = g - y2, l = atan2$1(x2, abs$2(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$2 * sign$1(x2) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$3(x2 * x2 + gy * gy)];
      };
      return project2;
    }
    function geoConicEquidistant() {
      return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
    }
    var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$3(3) / 2, iterations = 12;
    function equalEarthRaw(lambda, phi2) {
      var l = asin$2(M * sin$2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }
    equalEarthRaw.invert = function(x2, y2) {
      var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$2(delta) < epsilon2)
          break;
      }
      return [
        M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$2(l),
        asin$2(sin$2(l) / M)
      ];
    };
    function geoEqualEarth() {
      return projection$1(equalEarthRaw).scale(177.158);
    }
    function gnomonicRaw(x2, y2) {
      var cy = cos$2(y2), k = cos$2(x2) * cy;
      return [cy * sin$2(x2) / k, sin$2(y2) / k];
    }
    gnomonicRaw.invert = azimuthalInvert(atan);
    function geoGnomonic() {
      return projection$1(gnomonicRaw).scale(144.049).clipAngle(60);
    }
    function geoIdentity() {
      var k = 1, tx2 = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa2, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer$3({
        point: function(x2, y2) {
          var p = projection2([x2, y2]);
          this.stream.point(p[0], p[1]);
        }
      }), postclip = identity$4, cache2, cacheStream;
      function reset2() {
        kx = k * sx;
        ky = k * sy;
        cache2 = cacheStream = null;
        return projection2;
      }
      function projection2(p) {
        var x2 = p[0] * kx, y2 = p[1] * ky;
        if (alpha) {
          var t4 = y2 * ca - x2 * sa2;
          x2 = x2 * ca + y2 * sa2;
          y2 = t4;
        }
        return [x2 + tx2, y2 + ty];
      }
      projection2.invert = function(p) {
        var x2 = p[0] - tx2, y2 = p[1] - ty;
        if (alpha) {
          var t4 = y2 * ca + x2 * sa2;
          x2 = x2 * ca - y2 * sa2;
          y2 = t4;
        }
        return [x2 / kx, y2 / ky];
      };
      projection2.stream = function(stream2) {
        return cache2 && cacheStream === stream2 ? cache2 : cache2 = transform2(postclip(cacheStream = stream2));
      };
      projection2.postclip = function(_) {
        return arguments.length ? (postclip = _, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
      };
      projection2.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity$4) : clipRectangle(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
      };
      projection2.scale = function(_) {
        return arguments.length ? (k = +_, reset2()) : k;
      };
      projection2.translate = function(_) {
        return arguments.length ? (tx2 = +_[0], ty = +_[1], reset2()) : [tx2, ty];
      };
      projection2.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa2 = sin$2(alpha), ca = cos$2(alpha), reset2()) : alpha * degrees;
      };
      projection2.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset2()) : sx < 0;
      };
      projection2.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset2()) : sy < 0;
      };
      projection2.fitExtent = function(extent2, object2) {
        return fitExtent(projection2, extent2, object2);
      };
      projection2.fitSize = function(size2, object2) {
        return fitSize(projection2, size2, object2);
      };
      projection2.fitWidth = function(width2, object2) {
        return fitWidth(projection2, width2, object2);
      };
      projection2.fitHeight = function(height2, object2) {
        return fitHeight(projection2, height2, object2);
      };
      return projection2;
    }
    function naturalEarth1Raw(lambda, phi2) {
      var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
      return [
        lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
        phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
      ];
    }
    naturalEarth1Raw.invert = function(x2, y2) {
      var phi2 = y2, i = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs$2(delta) > epsilon$3 && --i > 0);
      return [
        x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
    function geoNaturalEarth1() {
      return projection$1(naturalEarth1Raw).scale(175.295);
    }
    function orthographicRaw(x2, y2) {
      return [cos$2(y2) * sin$2(x2), sin$2(y2)];
    }
    orthographicRaw.invert = azimuthalInvert(asin$2);
    function geoOrthographic() {
      return projection$1(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$3);
    }
    function stereographicRaw(x2, y2) {
      var cy = cos$2(y2), k = 1 + cos$2(x2) * cy;
      return [cy * sin$2(x2) / k, sin$2(y2) / k];
    }
    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });
    function geoStereographic() {
      return projection$1(stereographicRaw).scale(250).clipAngle(142);
    }
    function transverseMercatorRaw(lambda, phi2) {
      return [log$4(tan((halfPi$2 + phi2) / 2)), -lambda];
    }
    transverseMercatorRaw.invert = function(x2, y2) {
      return [-y2, 2 * atan(exp$2(x2)) - halfPi$2];
    };
    function geoTransverseMercator() {
      var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate2 = m2.rotate;
      m2.center = function(_) {
        return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
      };
      m2.rotate = function(_) {
        return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
      };
      return rotate2([0, 0, 90]).scale(159.155);
    }
    function defaultSeparation$2(a2, b2) {
      return a2.parent === b2.parent ? 1 : 2;
    }
    function meanX(children2) {
      return children2.reduce(meanXReduce, 0) / children2.length;
    }
    function meanXReduce(x2, c2) {
      return x2 + c2.x;
    }
    function maxY(children2) {
      return 1 + children2.reduce(maxYReduce, 0);
    }
    function maxYReduce(y2, c2) {
      return Math.max(y2, c2.y);
    }
    function leafLeft(node) {
      var children2;
      while (children2 = node.children)
        node = children2[0];
      return node;
    }
    function leafRight(node) {
      var children2;
      while (children2 = node.children)
        node = children2[children2.length - 1];
      return node;
    }
    function cluster() {
      var separation = defaultSeparation$2, dx = 1, dy = 1, nodeSize = false;
      function cluster2(root2) {
        var previousNode, x2 = 0;
        root2.eachAfter(function(node) {
          var children2 = node.children;
          if (children2) {
            node.x = meanX(children2);
            node.y = maxY(children2);
          } else {
            node.x = previousNode ? x2 += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });
        var left2 = leafLeft(root2), right2 = leafRight(root2), x02 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
        return root2.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root2.x) * dx;
          node.y = (root2.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x02) / (x12 - x02) * dx;
          node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
        });
      }
      cluster2.separation = function(x2) {
        return arguments.length ? (separation = x2, cluster2) : separation;
      };
      cluster2.size = function(x2) {
        return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
      };
      cluster2.nodeSize = function(x2) {
        return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
      };
      return cluster2;
    }
    function count(node) {
      var sum2 = 0, children2 = node.children, i = children2 && children2.length;
      if (!i)
        sum2 = 1;
      else
        while (--i >= 0)
          sum2 += children2[i].value;
      node.value = sum2;
    }
    function node_count() {
      return this.eachAfter(count);
    }
    function node_each(callback, that) {
      let index2 = -1;
      for (const node of this) {
        callback.call(that, node, ++index2, this);
      }
      return this;
    }
    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children2, i, index2 = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index2, this);
        if (children2 = node.children) {
          for (i = children2.length - 1; i >= 0; --i) {
            nodes.push(children2[i]);
          }
        }
      }
      return this;
    }
    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next2 = [], children2, i, n, index2 = -1;
      while (node = nodes.pop()) {
        next2.push(node);
        if (children2 = node.children) {
          for (i = 0, n = children2.length; i < n; ++i) {
            nodes.push(children2[i]);
          }
        }
      }
      while (node = next2.pop()) {
        callback.call(that, node, ++index2, this);
      }
      return this;
    }
    function node_find(callback, that) {
      let index2 = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index2, this)) {
          return node;
        }
      }
    }
    function node_sum(value2) {
      return this.eachAfter(function(node) {
        var sum2 = +value2(node.data) || 0, children2 = node.children, i = children2 && children2.length;
        while (--i >= 0)
          sum2 += children2[i].value;
        node.value = sum2;
      });
    }
    function node_sort(compare2) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare2);
        }
      });
    }
    function node_path(end) {
      var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
      while (start2 !== ancestor) {
        start2 = start2.parent;
        nodes.push(start2);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }
    function leastCommonAncestor(a2, b2) {
      if (a2 === b2)
        return a2;
      var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
      a2 = aNodes.pop();
      b2 = bNodes.pop();
      while (a2 === b2) {
        c2 = a2;
        a2 = aNodes.pop();
        b2 = bNodes.pop();
      }
      return c2;
    }
    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }
    function node_descendants() {
      return Array.from(this);
    }
    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }
    function node_links() {
      var root2 = this, links = [];
      root2.each(function(node) {
        if (node !== root2) {
          links.push({ source: node.parent, target: node });
        }
      });
      return links;
    }
    function* node_iterator() {
      var node = this, current2, next2 = [node], children2, i, n;
      do {
        current2 = next2.reverse(), next2 = [];
        while (node = current2.pop()) {
          yield node;
          if (children2 = node.children) {
            for (i = 0, n = children2.length; i < n; ++i) {
              next2.push(children2[i]);
            }
          }
        }
      } while (next2.length);
    }
    function hierarchy(data2, children2) {
      if (data2 instanceof Map) {
        data2 = [void 0, data2];
        if (children2 === void 0)
          children2 = mapChildren;
      } else if (children2 === void 0) {
        children2 = objectChildren;
      }
      var root2 = new Node$3(data2), node, nodes = [root2], child, childs, i, n;
      while (node = nodes.pop()) {
        if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$3(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }
      return root2.eachBefore(computeHeight);
    }
    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }
    function objectChildren(d) {
      return d.children;
    }
    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }
    function copyData(node) {
      if (node.data.value !== void 0)
        node.value = node.data.value;
      node.data = node.data.data;
    }
    function computeHeight(node) {
      var height2 = 0;
      do
        node.height = height2;
      while ((node = node.parent) && node.height < ++height2);
    }
    function Node$3(data2) {
      this.data = data2;
      this.depth = this.height = 0;
      this.parent = null;
    }
    Node$3.prototype = hierarchy.prototype = {
      constructor: Node$3,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };
    function optional(f) {
      return f == null ? null : required(f);
    }
    function required(f) {
      if (typeof f !== "function")
        throw new Error();
      return f;
    }
    function constantZero() {
      return 0;
    }
    function constant$3(x2) {
      return function() {
        return x2;
      };
    }
    const a = 1664525;
    const c = 1013904223;
    const m = 4294967296;
    function lcg$1() {
      let s = 1;
      return () => (s = (a * s + c) % m) / m;
    }
    function array$4(x2) {
      return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
    }
    function shuffle(array2, random2) {
      let m2 = array2.length, t4, i;
      while (m2) {
        i = random2() * m2-- | 0;
        t4 = array2[m2];
        array2[m2] = array2[i];
        array2[i] = t4;
      }
      return array2;
    }
    function packEncloseRandom(circles, random2) {
      var i = 0, n = (circles = shuffle(Array.from(circles), random2)).length, B2 = [], p, e3;
      while (i < n) {
        p = circles[i];
        if (e3 && enclosesWeak(e3, p))
          ++i;
        else
          e3 = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
      }
      return e3;
    }
    function extendBasis(B2, p) {
      var i, j;
      if (enclosesWeakAll(p, B2))
        return [p];
      for (i = 0; i < B2.length; ++i) {
        if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
          return [B2[i], p];
        }
      }
      for (i = 0; i < B2.length - 1; ++i) {
        for (j = i + 1; j < B2.length; ++j) {
          if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
            return [B2[i], B2[j], p];
          }
        }
      }
      throw new Error();
    }
    function enclosesNot(a2, b2) {
      var dr = a2.r - b2.r, dx = b2.x - a2.x, dy = b2.y - a2.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }
    function enclosesWeak(a2, b2) {
      var dr = a2.r - b2.r + Math.max(a2.r, b2.r, 1) * 1e-9, dx = b2.x - a2.x, dy = b2.y - a2.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function enclosesWeakAll(a2, B2) {
      for (var i = 0; i < B2.length; ++i) {
        if (!enclosesWeak(a2, B2[i])) {
          return false;
        }
      }
      return true;
    }
    function encloseBasis(B2) {
      switch (B2.length) {
        case 1:
          return encloseBasis1(B2[0]);
        case 2:
          return encloseBasis2(B2[0], B2[1]);
        case 3:
          return encloseBasis3(B2[0], B2[1], B2[2]);
      }
    }
    function encloseBasis1(a2) {
      return {
        x: a2.x,
        y: a2.y,
        r: a2.r
      };
    }
    function encloseBasis2(a2, b2) {
      var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b2.x, y2 = b2.y, r2 = b2.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x12 + x2 + x21 / l * r21) / 2,
        y: (y12 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }
    function encloseBasis3(a2, b2, c2) {
      var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b2.x, y2 = b2.y, r2 = b2.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x12 - x2, a3 = x12 - x3, b22 = y12 - y2, b3 = y12 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C3)) / (2 * A5) : C3 / B2);
      return {
        x: x12 + xa + xb * r,
        y: y12 + ya + yb * r,
        r
      };
    }
    function place(b2, a2, c2) {
      var dx = b2.x - a2.x, x2, a22, dy = b2.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
      if (d2) {
        a22 = a2.r + c2.r, a22 *= a22;
        b22 = b2.r + c2.r, b22 *= b22;
        if (a22 > b22) {
          x2 = (d2 + b22 - a22) / (2 * d2);
          y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
          c2.x = b2.x - x2 * dx - y2 * dy;
          c2.y = b2.y - x2 * dy + y2 * dx;
        } else {
          x2 = (d2 + a22 - b22) / (2 * d2);
          y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
          c2.x = a2.x + x2 * dx - y2 * dy;
          c2.y = a2.y + x2 * dy + y2 * dx;
        }
      } else {
        c2.x = a2.x + c2.r;
        c2.y = a2.y;
      }
    }
    function intersects(a2, b2) {
      var dr = a2.r + b2.r - 1e-6, dx = b2.x - a2.x, dy = b2.y - a2.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function score(node) {
      var a2 = node._, b2 = node.next._, ab = a2.r + b2.r, dx = (a2.x * b2.r + b2.x * a2.r) / ab, dy = (a2.y * b2.r + b2.y * a2.r) / ab;
      return dx * dx + dy * dy;
    }
    function Node$2(circle2) {
      this._ = circle2;
      this.next = null;
      this.previous = null;
    }
    function packSiblingsRandom(circles, random2) {
      if (!(n = (circles = array$4(circles)).length))
        return 0;
      var a2, b2, c2, n, aa, ca, i, j, k, sj, sk;
      a2 = circles[0], a2.x = 0, a2.y = 0;
      if (!(n > 1))
        return a2.r;
      b2 = circles[1], a2.x = -b2.r, b2.x = a2.r, b2.y = 0;
      if (!(n > 2))
        return a2.r + b2.r;
      place(b2, a2, c2 = circles[2]);
      a2 = new Node$2(a2), b2 = new Node$2(b2), c2 = new Node$2(c2);
      a2.next = c2.previous = b2;
      b2.next = a2.previous = c2;
      c2.next = b2.previous = a2;
      pack:
        for (i = 3; i < n; ++i) {
          place(a2._, b2._, c2 = circles[i]), c2 = new Node$2(c2);
          j = b2.next, k = a2.previous, sj = b2._.r, sk = a2._.r;
          do {
            if (sj <= sk) {
              if (intersects(j._, c2._)) {
                b2 = j, a2.next = b2, b2.previous = a2, --i;
                continue pack;
              }
              sj += j._.r, j = j.next;
            } else {
              if (intersects(k._, c2._)) {
                a2 = k, a2.next = b2, b2.previous = a2, --i;
                continue pack;
              }
              sk += k._.r, k = k.previous;
            }
          } while (j !== k.next);
          c2.previous = a2, c2.next = b2, a2.next = b2.previous = b2 = c2;
          aa = score(a2);
          while ((c2 = c2.next) !== b2) {
            if ((ca = score(c2)) < aa) {
              a2 = c2, aa = ca;
            }
          }
          b2 = a2.next;
        }
      a2 = [b2._], c2 = b2;
      while ((c2 = c2.next) !== b2)
        a2.push(c2._);
      c2 = packEncloseRandom(a2, random2);
      for (i = 0; i < n; ++i)
        a2 = circles[i], a2.x -= c2.x, a2.y -= c2.y;
      return c2.r;
    }
    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }
    function pack() {
      var radius2 = null, dx = 1, dy = 1, padding2 = constantZero;
      function pack2(root2) {
        const random2 = lcg$1();
        root2.x = dx / 2, root2.y = dy / 2;
        if (radius2) {
          root2.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding2, 0.5, random2)).eachBefore(translateChild(1));
        } else {
          root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random2)).eachAfter(packChildrenRandom(padding2, root2.r / Math.min(dx, dy), random2)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
        }
        return root2;
      }
      pack2.radius = function(x2) {
        return arguments.length ? (radius2 = optional(x2), pack2) : radius2;
      };
      pack2.size = function(x2) {
        return arguments.length ? (dx = +x2[0], dy = +x2[1], pack2) : [dx, dy];
      };
      pack2.padding = function(x2) {
        return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$3(+x2), pack2) : padding2;
      };
      return pack2;
    }
    function radiusLeaf(radius2) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius2(node) || 0);
        }
      };
    }
    function packChildrenRandom(padding2, k, random2) {
      return function(node) {
        if (children2 = node.children) {
          var children2, i, n = children2.length, r = padding2(node) * k || 0, e3;
          if (r)
            for (i = 0; i < n; ++i)
              children2[i].r += r;
          e3 = packSiblingsRandom(children2, random2);
          if (r)
            for (i = 0; i < n; ++i)
              children2[i].r -= r;
          node.r = e3 + r;
        }
      };
    }
    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }
    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }
    function treemapDice(parent, x02, y02, x12, y12) {
      var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x12 - x02) / parent.value;
      while (++i < n) {
        node = nodes[i], node.y0 = y02, node.y1 = y12;
        node.x0 = x02, node.x1 = x02 += node.value * k;
      }
    }
    function partition$4() {
      var dx = 1, dy = 1, padding2 = 0, round2 = false;
      function partition2(root2) {
        var n = root2.height + 1;
        root2.x0 = root2.y0 = padding2;
        root2.x1 = dx;
        root2.y1 = dy / n;
        root2.eachBefore(positionNode(dy, n));
        if (round2)
          root2.eachBefore(roundNode);
        return root2;
      }
      function positionNode(dy2, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
          }
          var x02 = node.x0, y02 = node.y0, x12 = node.x1 - padding2, y12 = node.y1 - padding2;
          if (x12 < x02)
            x02 = x12 = (x02 + x12) / 2;
          if (y12 < y02)
            y02 = y12 = (y02 + y12) / 2;
          node.x0 = x02;
          node.y0 = y02;
          node.x1 = x12;
          node.y1 = y12;
        };
      }
      partition2.round = function(x2) {
        return arguments.length ? (round2 = !!x2, partition2) : round2;
      };
      partition2.size = function(x2) {
        return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
      };
      partition2.padding = function(x2) {
        return arguments.length ? (padding2 = +x2, partition2) : padding2;
      };
      return partition2;
    }
    var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
    function defaultId(d) {
      return d.id;
    }
    function defaultParentId(d) {
      return d.parentId;
    }
    function stratify() {
      var id2 = defaultId, parentId = defaultParentId, path2;
      function stratify2(data2) {
        var nodes = Array.from(data2), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
        if (path2 != null) {
          const I = nodes.map((d2, i2) => normalize$2(path2(d2, i2, data2)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i2 of P) {
            if (!S.has(i2)) {
              S.add(i2);
              I.push(i2);
              P.push(parentof(i2));
              nodes.push(imputed);
            }
          }
          currentId = (_, i2) => I[i2];
          currentParentId = (_, i2) => P[i2];
        }
        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$3(d);
          if ((nodeId = currentId(d, i, data2)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data2)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent)
              throw new Error("missing: " + nodeId);
            if (parent === ambiguous)
              throw new Error("ambiguous: " + nodeId);
            if (parent.children)
              parent.children.push(node);
            else
              parent.children = [node];
            node.parent = parent;
          } else {
            if (root2)
              throw new Error("multiple roots");
            root2 = node;
          }
        }
        if (!root2)
          throw new Error("no root");
        if (path2 != null) {
          while (root2.data === imputed && root2.children.length === 1) {
            root2 = root2.children[0], --n;
          }
          for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
            node = nodes[i2];
            if (node.data !== imputed)
              break;
            node.data = null;
          }
        }
        root2.parent = preroot;
        root2.eachBefore(function(node2) {
          node2.depth = node2.parent.depth + 1;
          --n;
        }).eachBefore(computeHeight);
        root2.parent = null;
        if (n > 0)
          throw new Error("cycle");
        return root2;
      }
      stratify2.id = function(x2) {
        return arguments.length ? (id2 = optional(x2), stratify2) : id2;
      };
      stratify2.parentId = function(x2) {
        return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
      };
      stratify2.path = function(x2) {
        return arguments.length ? (path2 = optional(x2), stratify2) : path2;
      };
      return stratify2;
    }
    function normalize$2(path2) {
      path2 = `${path2}`;
      let i = path2.length;
      if (slash(path2, i - 1) && !slash(path2, i - 2))
        path2 = path2.slice(0, -1);
      return path2[0] === "/" ? path2 : `/${path2}`;
    }
    function parentof(path2) {
      let i = path2.length;
      if (i < 2)
        return "";
      while (--i > 1)
        if (slash(path2, i))
          break;
      return path2.slice(0, i);
    }
    function slash(path2, i) {
      if (path2[i] === "/") {
        let k = 0;
        while (i > 0 && path2[--i] === "\\")
          ++k;
        if ((k & 1) === 0)
          return true;
      }
      return false;
    }
    function defaultSeparation$1(a2, b2) {
      return a2.parent === b2.parent ? 1 : 2;
    }
    function nextLeft(v) {
      var children2 = v.children;
      return children2 ? children2[0] : v.t;
    }
    function nextRight(v) {
      var children2 = v.children;
      return children2 ? children2[children2.length - 1] : v.t;
    }
    function moveSubtree(wm, wp, shift2) {
      var change2 = shift2 / (wp.i - wm.i);
      wp.c -= change2;
      wp.s += shift2;
      wm.c += change2;
      wp.z += shift2;
      wp.m += shift2;
    }
    function executeShifts(v) {
      var shift2 = 0, change2 = 0, children2 = v.children, i = children2.length, w2;
      while (--i >= 0) {
        w2 = children2[i];
        w2.z += shift2;
        w2.m += shift2;
        shift2 += w2.s + (change2 += w2.c);
      }
    }
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null;
      this.a = this;
      this.z = 0;
      this.m = 0;
      this.c = 0;
      this.s = 0;
      this.t = null;
      this.i = i;
    }
    TreeNode.prototype = Object.create(Node$3.prototype);
    function treeRoot(root2) {
      var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n;
      while (node = nodes.pop()) {
        if (children2 = node._.children) {
          node.children = new Array(n = children2.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
            child.parent = node;
          }
        }
      }
      (tree2.parent = new TreeNode(null, 0)).children = [tree2];
      return tree2;
    }
    function tree$1() {
      var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;
      function tree2(root2) {
        var t4 = treeRoot(root2);
        t4.eachAfter(firstWalk), t4.parent.m = -t4.z;
        t4.eachBefore(secondWalk);
        if (nodeSize)
          root2.eachBefore(sizeNode);
        else {
          var left2 = root2, right2 = root2, bottom2 = root2;
          root2.eachBefore(function(node) {
            if (node.x < left2.x)
              left2 = node;
            if (node.x > right2.x)
              right2 = node;
            if (node.depth > bottom2.depth)
              bottom2 = node;
          });
          var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx2 = s - left2.x, kx = dx / (right2.x + s + tx2), ky = dy / (bottom2.depth || 1);
          root2.eachBefore(function(node) {
            node.x = (node.x + tx2) * kx;
            node.y = node.depth * ky;
          });
        }
        return root2;
      }
      function firstWalk(v) {
        var children2 = v.children, siblings = v.parent.children, w2 = v.i ? siblings[v.i - 1] : null;
        if (children2) {
          executeShifts(v);
          var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
          if (w2) {
            v.z = w2.z + separation(v._, w2._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w2) {
          v.z = w2.z + separation(v._, w2._);
        }
        v.parent.A = apportion(v, w2, v.parent.A || siblings[0]);
      }
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }
      function apportion(v, w2, ancestor) {
        if (w2) {
          var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift2;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift2 = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift2 > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift2);
              sip += shift2;
              sop += shift2;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }
      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }
      tree2.separation = function(x2) {
        return arguments.length ? (separation = x2, tree2) : separation;
      };
      tree2.size = function(x2) {
        return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
      };
      tree2.nodeSize = function(x2) {
        return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
      };
      return tree2;
    }
    function treemapSlice(parent, x02, y02, x12, y12) {
      var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y12 - y02) / parent.value;
      while (++i < n) {
        node = nodes[i], node.x0 = x02, node.x1 = x12;
        node.y0 = y02, node.y1 = y02 += node.value * k;
      }
    }
    var phi = (1 + Math.sqrt(5)) / 2;
    function squarifyRatio(ratio, parent, x02, y02, x12, y12) {
      var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
      while (i0 < n) {
        dx = x12 - x02, dy = y12 - y02;
        do
          sumValue = nodes[i1++].value;
        while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue)
            minValue = nodeValue;
          if (nodeValue > maxValue)
            maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) {
            sumValue -= nodeValue;
            break;
          }
          minRatio = newRatio;
        }
        rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
        if (row.dice)
          treemapDice(row, x02, y02, x12, value2 ? y02 += dy * sumValue / value2 : y12);
        else
          treemapSlice(row, x02, y02, value2 ? x02 += dx * sumValue / value2 : x12, y12);
        value2 -= sumValue, i0 = i1;
      }
      return rows;
    }
    const treemapSquarify = function custom2(ratio) {
      function squarify(parent, x02, y02, x12, y12) {
        squarifyRatio(ratio, parent, x02, y02, x12, y12);
      }
      squarify.ratio = function(x2) {
        return custom2((x2 = +x2) > 1 ? x2 : 1);
      };
      return squarify;
    }(phi);
    function treemap() {
      var tile = treemapSquarify, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner2 = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
      function treemap2(root2) {
        root2.x0 = root2.y0 = 0;
        root2.x1 = dx;
        root2.y1 = dy;
        root2.eachBefore(positionNode);
        paddingStack = [0];
        if (round2)
          root2.eachBefore(roundNode);
        return root2;
      }
      function positionNode(node) {
        var p = paddingStack[node.depth], x02 = node.x0 + p, y02 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
        if (x12 < x02)
          x02 = x12 = (x02 + x12) / 2;
        if (y12 < y02)
          y02 = y12 = (y02 + y12) / 2;
        node.x0 = x02;
        node.y0 = y02;
        node.x1 = x12;
        node.y1 = y12;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner2(node) / 2;
          x02 += paddingLeft(node) - p;
          y02 += paddingTop(node) - p;
          x12 -= paddingRight(node) - p;
          y12 -= paddingBottom(node) - p;
          if (x12 < x02)
            x02 = x12 = (x02 + x12) / 2;
          if (y12 < y02)
            y02 = y12 = (y02 + y12) / 2;
          tile(node, x02, y02, x12, y12);
        }
      }
      treemap2.round = function(x2) {
        return arguments.length ? (round2 = !!x2, treemap2) : round2;
      };
      treemap2.size = function(x2) {
        return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap2) : [dx, dy];
      };
      treemap2.tile = function(x2) {
        return arguments.length ? (tile = required(x2), treemap2) : tile;
      };
      treemap2.padding = function(x2) {
        return arguments.length ? treemap2.paddingInner(x2).paddingOuter(x2) : treemap2.paddingInner();
      };
      treemap2.paddingInner = function(x2) {
        return arguments.length ? (paddingInner2 = typeof x2 === "function" ? x2 : constant$3(+x2), treemap2) : paddingInner2;
      };
      treemap2.paddingOuter = function(x2) {
        return arguments.length ? treemap2.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap2.paddingTop();
      };
      treemap2.paddingTop = function(x2) {
        return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$3(+x2), treemap2) : paddingTop;
      };
      treemap2.paddingRight = function(x2) {
        return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$3(+x2), treemap2) : paddingRight;
      };
      treemap2.paddingBottom = function(x2) {
        return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$3(+x2), treemap2) : paddingBottom;
      };
      treemap2.paddingLeft = function(x2) {
        return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$3(+x2), treemap2) : paddingLeft;
      };
      return treemap2;
    }
    function treemapBinary(parent, x02, y02, x12, y12) {
      var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
      for (sums[0] = sum2 = i = 0; i < n; ++i) {
        sums[i + 1] = sum2 += nodes[i].value;
      }
      partition2(0, n, parent.value, x02, y02, x12, y12);
      function partition2(i2, j, value2, x03, y03, x13, y13) {
        if (i2 >= j - 1) {
          var node = nodes[i2];
          node.x0 = x03, node.y0 = y03;
          node.x1 = x13, node.y1 = y13;
          return;
        }
        var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget)
            k = mid + 1;
          else
            hi = mid;
        }
        if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
          --k;
        var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
        if (x13 - x03 > y13 - y03) {
          var xk = value2 ? (x03 * valueRight + x13 * valueLeft) / value2 : x13;
          partition2(i2, k, valueLeft, x03, y03, xk, y13);
          partition2(k, j, valueRight, xk, y03, x13, y13);
        } else {
          var yk = value2 ? (y03 * valueRight + y13 * valueLeft) / value2 : y13;
          partition2(i2, k, valueLeft, x03, y03, x13, yk);
          partition2(k, j, valueRight, x03, yk, x13, y13);
        }
      }
    }
    function treemapSliceDice(parent, x02, y02, x12, y12) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x02, y02, x12, y12);
    }
    const treemapResquarify = function custom2(ratio) {
      function resquarify(parent, x02, y02, x12, y12) {
        if ((rows = parent._squarify) && rows.ratio === ratio) {
          var rows, row, nodes, i, j = -1, n, m2 = rows.length, value2 = parent.value;
          while (++j < m2) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i)
              row.value += nodes[i].value;
            if (row.dice)
              treemapDice(row, x02, y02, x12, value2 ? y02 += (y12 - y02) * row.value / value2 : y12);
            else
              treemapSlice(row, x02, y02, value2 ? x02 += (x12 - x02) * row.value / value2 : x12, y12);
            value2 -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x02, y02, x12, y12);
          rows.ratio = ratio;
        }
      }
      resquarify.ratio = function(x2) {
        return custom2((x2 = +x2) > 1 ? x2 : 1);
      };
      return resquarify;
    }(phi);
    function initRange(domain2, range2) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(domain2);
          break;
        default:
          this.range(range2).domain(domain2);
          break;
      }
      return this;
    }
    function initInterpolator(domain2, interpolator) {
      switch (arguments.length) {
        case 0:
          break;
        case 1: {
          if (typeof domain2 === "function")
            this.interpolator(domain2);
          else
            this.range(domain2);
          break;
        }
        default: {
          this.domain(domain2);
          if (typeof interpolator === "function")
            this.interpolator(interpolator);
          else
            this.range(interpolator);
          break;
        }
      }
      return this;
    }
    const implicit = Symbol("implicit");
    function ordinal() {
      var index2 = new InternMap(), domain2 = [], range2 = [], unknown = implicit;
      function scale2(d) {
        let i = index2.get(d);
        if (i === void 0) {
          if (unknown !== implicit)
            return unknown;
          index2.set(d, i = domain2.push(d) - 1);
        }
        return range2[i % range2.length];
      }
      scale2.domain = function(_) {
        if (!arguments.length)
          return domain2.slice();
        domain2 = [], index2 = new InternMap();
        for (const value2 of _) {
          if (index2.has(value2))
            continue;
          index2.set(value2, domain2.push(value2) - 1);
        }
        return scale2;
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), scale2) : range2.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return ordinal(domain2, range2).unknown(unknown);
      };
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function band$1() {
      var scale2 = ordinal().unknown(void 0), domain2 = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
      delete scale2.unknown;
      function rescale() {
        var n = domain2().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop2 = reverse2 ? r0 : r1;
        step = (stop2 - start2) / Math.max(1, n - paddingInner2 + paddingOuter2 * 2);
        if (round2)
          step = Math.floor(step);
        start2 += (stop2 - start2 - step * (n - paddingInner2)) * align2;
        bandwidth2 = step * (1 - paddingInner2);
        if (round2)
          start2 = Math.round(start2), bandwidth2 = Math.round(bandwidth2);
        var values2 = range$5(n).map(function(i) {
          return start2 + step * i;
        });
        return ordinalRange(reverse2 ? values2.reverse() : values2);
      }
      scale2.domain = function(_) {
        return arguments.length ? (domain2(_), rescale()) : domain2();
      };
      scale2.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };
      scale2.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
      };
      scale2.bandwidth = function() {
        return bandwidth2;
      };
      scale2.step = function() {
        return step;
      };
      scale2.round = function(_) {
        return arguments.length ? (round2 = !!_, rescale()) : round2;
      };
      scale2.padding = function(_) {
        return arguments.length ? (paddingInner2 = Math.min(1, paddingOuter2 = +_), rescale()) : paddingInner2;
      };
      scale2.paddingInner = function(_) {
        return arguments.length ? (paddingInner2 = Math.min(1, _), rescale()) : paddingInner2;
      };
      scale2.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter2 = +_, rescale()) : paddingOuter2;
      };
      scale2.align = function(_) {
        return arguments.length ? (align2 = Math.max(0, Math.min(1, _)), rescale()) : align2;
      };
      scale2.copy = function() {
        return band$1(domain2(), [r0, r1]).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
      };
      return initRange.apply(rescale(), arguments);
    }
    function constants$1(x2) {
      return function() {
        return x2;
      };
    }
    function number$5(x2) {
      return +x2;
    }
    var unit = [0, 1];
    function identity$3(x2) {
      return x2;
    }
    function normalize$1(a2, b2) {
      return (b2 -= a2 = +a2) ? function(x2) {
        return (x2 - a2) / b2;
      } : constants$1(isNaN(b2) ? NaN : 0.5);
    }
    function clamper(a2, b2) {
      var t4;
      if (a2 > b2)
        t4 = a2, a2 = b2, b2 = t4;
      return function(x2) {
        return Math.max(a2, Math.min(b2, x2));
      };
    }
    function bimap(domain2, range2, interpolate2) {
      var d0 = domain2[0], d1 = domain2[1], r0 = range2[0], r1 = range2[1];
      if (d1 < d0)
        d0 = normalize$1(d1, d0), r0 = interpolate2(r1, r0);
      else
        d0 = normalize$1(d0, d1), r0 = interpolate2(r0, r1);
      return function(x2) {
        return r0(d0(x2));
      };
    }
    function polymap(domain2, range2, interpolate2) {
      var j = Math.min(domain2.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
      if (domain2[j] < domain2[0]) {
        domain2 = domain2.slice().reverse();
        range2 = range2.slice().reverse();
      }
      while (++i < j) {
        d[i] = normalize$1(domain2[i], domain2[i + 1]);
        r[i] = interpolate2(range2[i], range2[i + 1]);
      }
      return function(x2) {
        var i2 = bisect$1(domain2, x2, 1, j) - 1;
        return r[i2](d[i2](x2));
      };
    }
    function copy$2(source2, target2) {
      return target2.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
    }
    function transformer$2() {
      var domain2 = unit, range2 = unit, interpolate2 = interpolate$1$1, transform2, untransform, unknown, clamp2 = identity$3, piecewise2, output2, input;
      function rescale() {
        var n = Math.min(domain2.length, range2.length);
        if (clamp2 !== identity$3)
          clamp2 = clamper(domain2[0], domain2[n - 1]);
        piecewise2 = n > 2 ? polymap : bimap;
        output2 = input = null;
        return scale2;
      }
      function scale2(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : (output2 || (output2 = piecewise2(domain2.map(transform2), range2, interpolate2)))(transform2(clamp2(x2)));
      }
      scale2.invert = function(y2) {
        return clamp2(untransform((input || (input = piecewise2(range2, domain2.map(transform2), interpolateNumber)))(y2)));
      };
      scale2.domain = function(_) {
        return arguments.length ? (domain2 = Array.from(_, number$5), rescale()) : domain2.slice();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale2.rangeRound = function(_) {
        return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
      };
      scale2.clamp = function(_) {
        return arguments.length ? (clamp2 = _ ? true : identity$3, rescale()) : clamp2 !== identity$3;
      };
      scale2.interpolate = function(_) {
        return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      return function(t4, u2) {
        transform2 = t4, untransform = u2;
        return rescale();
      };
    }
    function continuous$1() {
      return transformer$2()(identity$3, identity$3);
    }
    function tickFormat$1(start2, stop2, count2, specifier) {
      var step = tickStep(start2, stop2, count2), precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value2 = Math.max(Math.abs(start2), Math.abs(stop2));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2)))
            specifier.precision = precision;
          return formatPrefix(specifier, value2);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop2)))))
            specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
            specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format$3(specifier);
    }
    function linearish(scale2) {
      var domain2 = scale2.domain;
      scale2.ticks = function(count2) {
        var d = domain2();
        return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
      };
      scale2.tickFormat = function(count2, specifier) {
        var d = domain2();
        return tickFormat$1(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
      };
      scale2.nice = function(count2) {
        if (count2 == null)
          count2 = 10;
        var d = domain2();
        var i0 = 0;
        var i1 = d.length - 1;
        var start2 = d[i0];
        var stop2 = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop2 < start2) {
          step = start2, start2 = stop2, stop2 = step;
          step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
          step = tickIncrement(start2, stop2, count2);
          if (step === prestep) {
            d[i0] = start2;
            d[i1] = stop2;
            return domain2(d);
          } else if (step > 0) {
            start2 = Math.floor(start2 / step) * step;
            stop2 = Math.ceil(stop2 / step) * step;
          } else if (step < 0) {
            start2 = Math.ceil(start2 * step) / step;
            stop2 = Math.floor(stop2 * step) / step;
          } else {
            break;
          }
          prestep = step;
        }
        return scale2;
      };
      return scale2;
    }
    function linear$1() {
      var scale2 = continuous$1();
      scale2.copy = function() {
        return copy$2(scale2, linear$1());
      };
      initRange.apply(scale2, arguments);
      return linearish(scale2);
    }
    function identity$2(domain2) {
      var unknown;
      function scale2(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
      }
      scale2.invert = scale2;
      scale2.domain = scale2.range = function(_) {
        return arguments.length ? (domain2 = Array.from(_, number$5), scale2) : domain2.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return identity$2(domain2).unknown(unknown);
      };
      domain2 = arguments.length ? Array.from(domain2, number$5) : [0, 1];
      return linearish(scale2);
    }
    function nice$1(domain2, interval2) {
      domain2 = domain2.slice();
      var i0 = 0, i1 = domain2.length - 1, x02 = domain2[i0], x12 = domain2[i1], t4;
      if (x12 < x02) {
        t4 = i0, i0 = i1, i1 = t4;
        t4 = x02, x02 = x12, x12 = t4;
      }
      domain2[i0] = interval2.floor(x02);
      domain2[i1] = interval2.ceil(x12);
      return domain2;
    }
    function transformLog(x2) {
      return Math.log(x2);
    }
    function transformExp(x2) {
      return Math.exp(x2);
    }
    function transformLogn(x2) {
      return -Math.log(-x2);
    }
    function transformExpn(x2) {
      return -Math.exp(-x2);
    }
    function pow10(x2) {
      return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
    }
    function powp(base2) {
      return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : (x2) => Math.pow(base2, x2);
    }
    function logp(base2) {
      return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), (x2) => Math.log(x2) / base2);
    }
    function reflect(f) {
      return (x2, k) => -f(-x2, k);
    }
    function loggish(transform2) {
      const scale2 = transform2(transformLog, transformExp);
      const domain2 = scale2.domain;
      let base2 = 10;
      let logs;
      let pows;
      function rescale() {
        logs = logp(base2), pows = powp(base2);
        if (domain2()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform2(transformLogn, transformExpn);
        } else {
          transform2(transformLog, transformExp);
        }
        return scale2;
      }
      scale2.base = function(_) {
        return arguments.length ? (base2 = +_, rescale()) : base2;
      };
      scale2.domain = function(_) {
        return arguments.length ? (domain2(_), rescale()) : domain2();
      };
      scale2.ticks = (count2) => {
        const d = domain2();
        let u2 = d[0];
        let v = d[d.length - 1];
        const r = v < u2;
        if (r)
          [u2, v] = [v, u2];
        let i = logs(u2);
        let j = logs(v);
        let k;
        let t4;
        const n = count2 == null ? 10 : +count2;
        let z = [];
        if (!(base2 % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u2 > 0)
            for (; i <= j; ++i) {
              for (k = 1; k < base2; ++k) {
                t4 = i < 0 ? k / pows(-i) : k * pows(i);
                if (t4 < u2)
                  continue;
                if (t4 > v)
                  break;
                z.push(t4);
              }
            }
          else
            for (; i <= j; ++i) {
              for (k = base2 - 1; k >= 1; --k) {
                t4 = i > 0 ? k / pows(-i) : k * pows(i);
                if (t4 < u2)
                  continue;
                if (t4 > v)
                  break;
                z.push(t4);
              }
            }
          if (z.length * 2 < n)
            z = ticks(u2, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };
      scale2.tickFormat = (count2, specifier) => {
        if (count2 == null)
          count2 = 10;
        if (specifier == null)
          specifier = base2 === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base2 % 1) && (specifier = formatSpecifier(specifier)).precision == null)
            specifier.trim = true;
          specifier = format$3(specifier);
        }
        if (count2 === Infinity)
          return specifier;
        const k = Math.max(1, base2 * count2 / scale2.ticks().length);
        return (d) => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base2 < base2 - 0.5)
            i *= base2;
          return i <= k ? specifier(d) : "";
        };
      };
      scale2.nice = () => {
        return domain2(nice$1(domain2(), {
          floor: (x2) => pows(Math.floor(logs(x2))),
          ceil: (x2) => pows(Math.ceil(logs(x2)))
        }));
      };
      return scale2;
    }
    function log$3() {
      const scale2 = loggish(transformer$2()).domain([1, 10]);
      scale2.copy = () => copy$2(scale2, log$3()).base(scale2.base());
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function transformSymlog(c2) {
      return function(x2) {
        return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
      };
    }
    function transformSymexp(c2) {
      return function(x2) {
        return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
      };
    }
    function symlogish(transform2) {
      var c2 = 1, scale2 = transform2(transformSymlog(c2), transformSymexp(c2));
      scale2.constant = function(_) {
        return arguments.length ? transform2(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
      };
      return linearish(scale2);
    }
    function symlog$1() {
      var scale2 = symlogish(transformer$2());
      scale2.copy = function() {
        return copy$2(scale2, symlog$1()).constant(scale2.constant());
      };
      return initRange.apply(scale2, arguments);
    }
    function transformPow(exponent2) {
      return function(x2) {
        return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
      };
    }
    function transformSqrt(x2) {
      return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
    }
    function transformSquare(x2) {
      return x2 < 0 ? -x2 * x2 : x2 * x2;
    }
    function powish(transform2) {
      var scale2 = transform2(identity$3, identity$3), exponent2 = 1;
      function rescale() {
        return exponent2 === 1 ? transform2(identity$3, identity$3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
      }
      scale2.exponent = function(_) {
        return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
      };
      return linearish(scale2);
    }
    function pow$2() {
      var scale2 = powish(transformer$2());
      scale2.copy = function() {
        return copy$2(scale2, pow$2()).exponent(scale2.exponent());
      };
      initRange.apply(scale2, arguments);
      return scale2;
    }
    function sqrt$2() {
      return pow$2.apply(null, arguments).exponent(0.5);
    }
    function quantile() {
      var domain2 = [], range2 = [], thresholds = [], unknown;
      function rescale() {
        var i = 0, n = Math.max(1, range2.length);
        thresholds = new Array(n - 1);
        while (++i < n)
          thresholds[i - 1] = quantileSorted(domain2, i / n);
        return scale2;
      }
      function scale2(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisect$1(thresholds, x2)];
      }
      scale2.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain2[0],
          i < thresholds.length ? thresholds[i] : domain2[domain2.length - 1]
        ];
      };
      scale2.domain = function(_) {
        if (!arguments.length)
          return domain2.slice();
        domain2 = [];
        for (let d of _)
          if (d != null && !isNaN(d = +d))
            domain2.push(d);
        domain2.sort(ascending$3);
        return rescale();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.quantiles = function() {
        return thresholds.slice();
      };
      scale2.copy = function() {
        return quantile().domain(domain2).range(range2).unknown(unknown);
      };
      return initRange.apply(scale2, arguments);
    }
    function quantize$1() {
      var x02 = 0, x12 = 1, n = 1, domain2 = [0.5], range2 = [0, 1], unknown;
      function scale2(x2) {
        return x2 != null && x2 <= x2 ? range2[bisect$1(domain2, x2, 0, n)] : unknown;
      }
      function rescale() {
        var i = -1;
        domain2 = new Array(n);
        while (++i < n)
          domain2[i] = ((i + 1) * x12 - (i - n) * x02) / (n + 1);
        return scale2;
      }
      scale2.domain = function(_) {
        return arguments.length ? ([x02, x12] = _, x02 = +x02, x12 = +x12, rescale()) : [x02, x12];
      };
      scale2.range = function(_) {
        return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
      };
      scale2.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return i < 0 ? [NaN, NaN] : i < 1 ? [x02, domain2[0]] : i >= n ? [domain2[n - 1], x12] : [domain2[i - 1], domain2[i]];
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : scale2;
      };
      scale2.thresholds = function() {
        return domain2.slice();
      };
      scale2.copy = function() {
        return quantize$1().domain([x02, x12]).range(range2).unknown(unknown);
      };
      return initRange.apply(linearish(scale2), arguments);
    }
    function threshold() {
      var domain2 = [0.5], range2 = [0, 1], unknown, n = 1;
      function scale2(x2) {
        return x2 != null && x2 <= x2 ? range2[bisect$1(domain2, x2, 0, n)] : unknown;
      }
      scale2.domain = function(_) {
        return arguments.length ? (domain2 = Array.from(_), n = Math.min(domain2.length, range2.length - 1), scale2) : domain2.slice();
      };
      scale2.range = function(_) {
        return arguments.length ? (range2 = Array.from(_), n = Math.min(domain2.length, range2.length - 1), scale2) : range2.slice();
      };
      scale2.invertExtent = function(y2) {
        var i = range2.indexOf(y2);
        return [domain2[i - 1], domain2[i]];
      };
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      scale2.copy = function() {
        return threshold().domain(domain2).range(range2).unknown(unknown);
      };
      return initRange.apply(scale2, arguments);
    }
    const t0$1 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
    function timeInterval$1(floori, offseti, count2, field2) {
      function interval2(date2) {
        return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
      }
      interval2.floor = (date2) => {
        return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
      };
      interval2.ceil = (date2) => {
        return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
      };
      interval2.round = (date2) => {
        const d0 = interval2(date2), d1 = interval2.ceil(date2);
        return date2 - d0 < d1 - date2 ? d0 : d1;
      };
      interval2.offset = (date2, step) => {
        return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
      };
      interval2.range = (start2, stop2, step) => {
        const range2 = [];
        start2 = interval2.ceil(start2);
        step = step == null ? 1 : Math.floor(step);
        if (!(start2 < stop2) || !(step > 0))
          return range2;
        let previous;
        do
          range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
        while (previous < start2 && start2 < stop2);
        return range2;
      };
      interval2.filter = (test2) => {
        return timeInterval$1((date2) => {
          if (date2 >= date2)
            while (floori(date2), !test2(date2))
              date2.setTime(date2 - 1);
        }, (date2, step) => {
          if (date2 >= date2) {
            if (step < 0)
              while (++step <= 0) {
                while (offseti(date2, -1), !test2(date2)) {
                }
              }
            else
              while (--step >= 0) {
                while (offseti(date2, 1), !test2(date2)) {
                }
              }
          }
        });
      };
      if (count2) {
        interval2.count = (start2, end) => {
          t0$1.setTime(+start2), t1.setTime(+end);
          floori(t0$1), floori(t1);
          return Math.floor(count2(t0$1, t1));
        };
        interval2.every = (step) => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
        };
      }
      return interval2;
    }
    const millisecond = timeInterval$1(() => {
    }, (date2, step) => {
      date2.setTime(+date2 + step);
    }, (start2, end) => {
      return end - start2;
    });
    millisecond.every = (k) => {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0))
        return null;
      if (!(k > 1))
        return millisecond;
      return timeInterval$1((date2) => {
        date2.setTime(Math.floor(date2 / k) * k);
      }, (date2, step) => {
        date2.setTime(+date2 + step * k);
      }, (start2, end) => {
        return (end - start2) / k;
      });
    };
    millisecond.range;
    const durationSecond$1 = 1e3;
    const durationMinute$1 = durationSecond$1 * 60;
    const durationHour$1 = durationMinute$1 * 60;
    const durationDay$1 = durationHour$1 * 24;
    const durationWeek$1 = durationDay$1 * 7;
    const durationMonth$1 = durationDay$1 * 30;
    const durationYear$1 = durationDay$1 * 365;
    const second = timeInterval$1((date2) => {
      date2.setTime(date2 - date2.getMilliseconds());
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationSecond$1);
    }, (start2, end) => {
      return (end - start2) / durationSecond$1;
    }, (date2) => {
      return date2.getUTCSeconds();
    });
    second.range;
    const timeMinute = timeInterval$1((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute$1);
    }, (start2, end) => {
      return (end - start2) / durationMinute$1;
    }, (date2) => {
      return date2.getMinutes();
    });
    timeMinute.range;
    const utcMinute = timeInterval$1((date2) => {
      date2.setUTCSeconds(0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationMinute$1);
    }, (start2, end) => {
      return (end - start2) / durationMinute$1;
    }, (date2) => {
      return date2.getUTCMinutes();
    });
    utcMinute.range;
    const timeHour = timeInterval$1((date2) => {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1 - date2.getMinutes() * durationMinute$1);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour$1);
    }, (start2, end) => {
      return (end - start2) / durationHour$1;
    }, (date2) => {
      return date2.getHours();
    });
    timeHour.range;
    const utcHour = timeInterval$1((date2) => {
      date2.setUTCMinutes(0, 0, 0);
    }, (date2, step) => {
      date2.setTime(+date2 + step * durationHour$1);
    }, (start2, end) => {
      return (end - start2) / durationHour$1;
    }, (date2) => {
      return date2.getUTCHours();
    });
    utcHour.range;
    const timeDay = timeInterval$1(
      (date2) => date2.setHours(0, 0, 0, 0),
      (date2, step) => date2.setDate(date2.getDate() + step),
      (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationDay$1,
      (date2) => date2.getDate() - 1
    );
    timeDay.range;
    const utcDay = timeInterval$1((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end) => {
      return (end - start2) / durationDay$1;
    }, (date2) => {
      return date2.getUTCDate() - 1;
    });
    utcDay.range;
    const unixDay = timeInterval$1((date2) => {
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, (start2, end) => {
      return (end - start2) / durationDay$1;
    }, (date2) => {
      return Math.floor(date2 / durationDay$1);
    });
    unixDay.range;
    function timeWeekday(i) {
      return timeInterval$1((date2) => {
        date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setDate(date2.getDate() + step * 7);
      }, (start2, end) => {
        return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
      });
    }
    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);
    timeSunday.range;
    timeMonday.range;
    timeTuesday.range;
    timeWednesday.range;
    timeThursday.range;
    timeFriday.range;
    timeSaturday.range;
    function utcWeekday(i) {
      return timeInterval$1((date2) => {
        date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCDate(date2.getUTCDate() + step * 7);
      }, (start2, end) => {
        return (end - start2) / durationWeek$1;
      });
    }
    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);
    utcSunday.range;
    utcMonday.range;
    utcTuesday.range;
    utcWednesday.range;
    utcThursday.range;
    utcFriday.range;
    utcSaturday.range;
    const timeMonth = timeInterval$1((date2) => {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setMonth(date2.getMonth() + step);
    }, (start2, end) => {
      return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
    }, (date2) => {
      return date2.getMonth();
    });
    timeMonth.range;
    const utcMonth = timeInterval$1((date2) => {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, (start2, end) => {
      return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
    }, (date2) => {
      return date2.getUTCMonth();
    });
    utcMonth.range;
    const timeYear = timeInterval$1((date2) => {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step);
    }, (start2, end) => {
      return end.getFullYear() - start2.getFullYear();
    }, (date2) => {
      return date2.getFullYear();
    });
    timeYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval$1((date2) => {
        date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setFullYear(date2.getFullYear() + step * k);
      });
    };
    timeYear.range;
    const utcYear = timeInterval$1((date2) => {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, (start2, end) => {
      return end.getUTCFullYear() - start2.getUTCFullYear();
    }, (date2) => {
      return date2.getUTCFullYear();
    });
    utcYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval$1((date2) => {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, (date2, step) => {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
      });
    };
    utcYear.range;
    function ticker(year, month, week2, day, hour, minute) {
      const tickIntervals = [
        [second, 1, durationSecond$1],
        [second, 5, 5 * durationSecond$1],
        [second, 15, 15 * durationSecond$1],
        [second, 30, 30 * durationSecond$1],
        [minute, 1, durationMinute$1],
        [minute, 5, 5 * durationMinute$1],
        [minute, 15, 15 * durationMinute$1],
        [minute, 30, 30 * durationMinute$1],
        [hour, 1, durationHour$1],
        [hour, 3, 3 * durationHour$1],
        [hour, 6, 6 * durationHour$1],
        [hour, 12, 12 * durationHour$1],
        [day, 1, durationDay$1],
        [day, 2, 2 * durationDay$1],
        [week2, 1, durationWeek$1],
        [month, 1, durationMonth$1],
        [month, 3, 3 * durationMonth$1],
        [year, 1, durationYear$1]
      ];
      function ticks2(start2, stop2, count2) {
        const reverse2 = stop2 < start2;
        if (reverse2)
          [start2, stop2] = [stop2, start2];
        const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop2, count2);
        const ticks3 = interval2 ? interval2.range(start2, +stop2 + 1) : [];
        return reverse2 ? ticks3.reverse() : ticks3;
      }
      function tickInterval(start2, stop2, count2) {
        const target2 = Math.abs(stop2 - start2) / count2;
        const i = bisector(([, , step2]) => step2).right(tickIntervals, target2);
        if (i === tickIntervals.length)
          return year.every(tickStep(start2 / durationYear$1, stop2 / durationYear$1, count2));
        if (i === 0)
          return millisecond.every(Math.max(tickStep(start2, stop2, count2), 1));
        const [t4, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
        return t4.every(step);
      }
      return [ticks2, tickInterval];
    }
    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
    function localDate$1(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date2.setFullYear(d.y);
        return date2;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate$1(d) {
      if (0 <= d.y && d.y < 100) {
        var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date2.setUTCFullYear(d.y);
        return date2;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y2, m2, d) {
      return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale(locale2) {
      var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
      var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
      var formats2 = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };
      formats2.x = newFormat(locale_date, formats2);
      formats2.X = newFormat(locale_time, formats2);
      formats2.c = newFormat(locale_dateTime, formats2);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);
      function newFormat(specifier, formats3) {
        return function(date2) {
          var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
          if (!(date2 instanceof Date))
            date2 = /* @__PURE__ */ new Date(+date2);
          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
                c2 = specifier.charAt(++i);
              else
                pad2 = c2 === "e" ? " " : "0";
              if (format2 = formats3[c2])
                c2 = format2(date2, pad2);
              string.push(c2);
              j = i + 1;
            }
          }
          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }
      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week2, day;
          if (i != string.length)
            return null;
          if ("Q" in d)
            return new Date(d.Q);
          if ("s" in d)
            return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
          if (Z && !("Z" in d))
            d.Z = 0;
          if ("p" in d)
            d.H = d.H % 12 + d.p * 12;
          if (d.m === void 0)
            d.m = "q" in d ? d.q : 0;
          if ("V" in d) {
            if (d.V < 1 || d.V > 53)
              return null;
            if (!("w" in d))
              d.w = 1;
            if ("Z" in d) {
              week2 = utcDate$1(newDate(d.y, 0, 1)), day = week2.getUTCDay();
              week2 = day > 4 || day === 0 ? utcMonday.ceil(week2) : utcMonday(week2);
              week2 = utcDay.offset(week2, (d.V - 1) * 7);
              d.y = week2.getUTCFullYear();
              d.m = week2.getUTCMonth();
              d.d = week2.getUTCDate() + (d.w + 6) % 7;
            } else {
              week2 = localDate$1(newDate(d.y, 0, 1)), day = week2.getDay();
              week2 = day > 4 || day === 0 ? timeMonday.ceil(week2) : timeMonday(week2);
              week2 = timeDay.offset(week2, (d.V - 1) * 7);
              d.y = week2.getFullYear();
              d.m = week2.getMonth();
              d.d = week2.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d))
              d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate$1(newDate(d.y, 0, 1)).getUTCDay() : localDate$1(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate$1(d);
          }
          return localDate$1(d);
        };
      }
      function parseSpecifier(d, specifier, string, j) {
        var i = 0, n = specifier.length, m2 = string.length, c2, parse2;
        while (i < n) {
          if (j >= m2)
            return -1;
          c2 = specifier.charCodeAt(i++);
          if (c2 === 37) {
            c2 = specifier.charAt(i++);
            parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
            if (!parse2 || (j = parse2(d, string, j)) < 0)
              return -1;
          } else if (c2 != string.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }
      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }
      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }
      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }
      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }
      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }
      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }
      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }
      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }
      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }
      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }
      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }
      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }
      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }
      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }
      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats2);
          f.toString = function() {
            return specifier;
          };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() {
            return specifier;
          };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() {
            return specifier;
          };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() {
            return specifier;
          };
          return p;
        }
      };
    }
    var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad$1(value2, fill2, width2) {
      var sign2 = value2 < 0 ? "-" : "", string = (sign2 ? -value2 : value2) + "", length2 = string.length;
      return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill2) + string : string);
    }
    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
      return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
    }
    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
    }
    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
    }
    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth(d, p) {
      return pad$1(d.getDate(), p, 2);
    }
    function formatHour24(d, p) {
      return pad$1(d.getHours(), p, 2);
    }
    function formatHour12(d, p) {
      return pad$1(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear(d, p) {
      return pad$1(1 + timeDay.count(timeYear(d), d), p, 3);
    }
    function formatMilliseconds(d, p) {
      return pad$1(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }
    function formatMonthNumber(d, p) {
      return pad$1(d.getMonth() + 1, p, 2);
    }
    function formatMinutes(d, p) {
      return pad$1(d.getMinutes(), p, 2);
    }
    function formatSeconds(d, p) {
      return pad$1(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p) {
      return pad$1(timeSunday.count(timeYear(d) - 1, d), p, 2);
    }
    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    }
    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad$1(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }
    function formatWeekNumberMonday(d, p) {
      return pad$1(timeMonday.count(timeYear(d) - 1, d), p, 2);
    }
    function formatYear(d, p) {
      return pad$1(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO(d, p) {
      d = dISO(d);
      return pad$1(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear(d, p) {
      return pad$1(d.getFullYear() % 1e4, p, 4);
    }
    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
      return pad$1(d.getFullYear() % 1e4, p, 4);
    }
    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad$1(z / 60 | 0, "0", 2) + pad$1(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p) {
      return pad$1(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24(d, p) {
      return pad$1(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12(d, p) {
      return pad$1(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear(d, p) {
      return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
    }
    function formatUTCMilliseconds(d, p) {
      return pad$1(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }
    function formatUTCMonthNumber(d, p) {
      return pad$1(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes(d, p) {
      return pad$1(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds(d, p) {
      return pad$1(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p) {
      return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }
    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p) {
      return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }
    function formatUTCYear(d, p) {
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear(d, p) {
      return pad$1(d.getUTCFullYear() % 1e4, p, 4);
    }
    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad$1(d.getUTCFullYear() % 1e4, p, 4);
    }
    function formatUTCZone() {
      return "+0000";
    }
    function formatLiteralPercent() {
      return "%";
    }
    function formatUnixTimestamp(d) {
      return +d;
    }
    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1e3);
    }
    var locale$1;
    var timeFormat$2;
    var timeParse$1;
    var utcFormat$1;
    var utcParse$1;
    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$1(definition2) {
      locale$1 = formatLocale(definition2);
      timeFormat$2 = locale$1.format;
      timeParse$1 = locale$1.parse;
      utcFormat$1 = locale$1.utcFormat;
      utcParse$1 = locale$1.utcParse;
      return locale$1;
    }
    function date(t4) {
      return new Date(t4);
    }
    function number$4(t4) {
      return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
    }
    function calendar(ticks2, tickInterval, year, month, week2, day, hour, minute, second2, format2) {
      var scale2 = continuous$1(), invert2 = scale2.invert, domain2 = scale2.domain;
      var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
      function tickFormat2(date2) {
        return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week2(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
      }
      scale2.invert = function(y2) {
        return new Date(invert2(y2));
      };
      scale2.domain = function(_) {
        return arguments.length ? domain2(Array.from(_, number$4)) : domain2().map(date);
      };
      scale2.ticks = function(interval2) {
        var d = domain2();
        return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
      };
      scale2.tickFormat = function(count2, specifier) {
        return specifier == null ? tickFormat2 : format2(specifier);
      };
      scale2.nice = function(interval2) {
        var d = domain2();
        if (!interval2 || typeof interval2.range !== "function")
          interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
        return interval2 ? domain2(nice$1(d, interval2)) : scale2;
      };
      scale2.copy = function() {
        return copy$2(scale2, calendar(ticks2, tickInterval, year, month, week2, day, hour, minute, second2, format2));
      };
      return scale2;
    }
    function time$1() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat$2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
    }
    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat$1).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
    }
    function transformer$1() {
      var x02 = 0, x12 = 1, t02, t12, k10, transform2, interpolator = identity$3, clamp2 = false, unknown;
      function scale2(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
      }
      scale2.domain = function(_) {
        return arguments.length ? ([x02, x12] = _, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale2) : [x02, x12];
      };
      scale2.clamp = function(_) {
        return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
      };
      scale2.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale2) : interpolator;
      };
      function range2(interpolate2) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale2) : [interpolator(0), interpolator(1)];
        };
      }
      scale2.range = range2(interpolate$1$1);
      scale2.rangeRound = range2(interpolateRound);
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      return function(t4) {
        transform2 = t4, t02 = t4(x02), t12 = t4(x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
        return scale2;
      };
    }
    function copy$1(source2, target2) {
      return target2.domain(source2.domain()).interpolator(source2.interpolator()).clamp(source2.clamp()).unknown(source2.unknown());
    }
    function sequential() {
      var scale2 = linearish(transformer$1()(identity$3));
      scale2.copy = function() {
        return copy$1(scale2, sequential());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function sequentialLog() {
      var scale2 = loggish(transformer$1()).domain([1, 10]);
      scale2.copy = function() {
        return copy$1(scale2, sequentialLog()).base(scale2.base());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function sequentialSymlog() {
      var scale2 = symlogish(transformer$1());
      scale2.copy = function() {
        return copy$1(scale2, sequentialSymlog()).constant(scale2.constant());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function sequentialPow() {
      var scale2 = powish(transformer$1());
      scale2.copy = function() {
        return copy$1(scale2, sequentialPow()).exponent(scale2.exponent());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }
    function transformer() {
      var x02 = 0, x12 = 0.5, x2 = 1, s = 1, t02, t12, t22, k10, k21, interpolator = identity$3, transform2, clamp2 = false, unknown;
      function scale2(x3) {
        return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t12) * (s * x3 < s * t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
      }
      scale2.domain = function(_) {
        return arguments.length ? ([x02, x12, x2] = _, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), t22 = transform2(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s = t12 < t02 ? -1 : 1, scale2) : [x02, x12, x2];
      };
      scale2.clamp = function(_) {
        return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
      };
      scale2.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale2) : interpolator;
      };
      function range2(interpolate2) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }
      scale2.range = range2(interpolate$1$1);
      scale2.rangeRound = range2(interpolateRound);
      scale2.unknown = function(_) {
        return arguments.length ? (unknown = _, scale2) : unknown;
      };
      return function(t4) {
        transform2 = t4, t02 = t4(x02), t12 = t4(x12), t22 = t4(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s = t12 < t02 ? -1 : 1;
        return scale2;
      };
    }
    function diverging() {
      var scale2 = linearish(transformer()(identity$3));
      scale2.copy = function() {
        return copy$1(scale2, diverging());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingLog() {
      var scale2 = loggish(transformer()).domain([0.1, 1, 10]);
      scale2.copy = function() {
        return copy$1(scale2, divergingLog()).base(scale2.base());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingSymlog() {
      var scale2 = symlogish(transformer());
      scale2.copy = function() {
        return copy$1(scale2, divergingSymlog()).constant(scale2.constant());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingPow() {
      var scale2 = powish(transformer());
      scale2.copy = function() {
        return copy$1(scale2, divergingPow()).exponent(scale2.exponent());
      };
      return initInterpolator.apply(scale2, arguments);
    }
    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }
    function constant$2(x2) {
      return function constant2() {
        return x2;
      };
    }
    const abs$1 = Math.abs;
    const atan2 = Math.atan2;
    const cos$1 = Math.cos;
    const max$1 = Math.max;
    const min$1 = Math.min;
    const sin$1 = Math.sin;
    const sqrt$1 = Math.sqrt;
    const epsilon$2 = 1e-12;
    const pi$1 = Math.PI;
    const halfPi$1 = pi$1 / 2;
    const tau = 2 * pi$1;
    function acos(x2) {
      return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
    }
    function asin$1(x2) {
      return x2 >= 1 ? halfPi$1 : x2 <= -1 ? -halfPi$1 : Math.asin(x2);
    }
    function withPath(shape2) {
      let digits = 3;
      shape2.digits = function(_) {
        if (!arguments.length)
          return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0))
            throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape2;
      };
      return () => new Path$1(digits);
    }
    function arcInnerRadius(d) {
      return d.innerRadius;
    }
    function arcOuterRadius(d) {
      return d.outerRadius;
    }
    function arcStartAngle(d) {
      return d.startAngle;
    }
    function arcEndAngle(d) {
      return d.endAngle;
    }
    function arcPadAngle(d) {
      return d && d.padAngle;
    }
    function intersect$3(x02, y02, x12, y12, x2, y2, x3, y3) {
      var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t4 = y32 * x10 - x32 * y10;
      if (t4 * t4 < epsilon$2)
        return;
      t4 = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t4;
      return [x02 + t4 * x10, y02 + t4 * y10];
    }
    function cornerTangents(x02, y02, x12, y12, r1, rc, cw2) {
      var x01 = x02 - x12, y01 = y02 - y12, lo = (cw2 ? rc : -rc) / sqrt$1(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$1(max$1(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
        cx0 = cx1, cy0 = cy1;
      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }
    function arc$2$1() {
      var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context2 = null, path2 = withPath(arc2);
      function arc2() {
        var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$1, a1 = endAngle.apply(this, arguments) - halfPi$1, da = abs$1(a1 - a0), cw2 = a1 > a0;
        if (!context2)
          context2 = buffer = path2();
        if (r1 < r0)
          r = r1, r1 = r0, r0 = r;
        if (!(r1 > epsilon$2))
          context2.moveTo(0, 0);
        else if (da > tau - epsilon$2) {
          context2.moveTo(r1 * cos$1(a0), r1 * sin$1(a0));
          context2.arc(0, 0, r1, a0, a1, !cw2);
          if (r0 > epsilon$2) {
            context2.moveTo(r0 * cos$1(a1), r0 * sin$1(a1));
            context2.arc(0, 0, r0, a1, a0, cw2);
          }
        } else {
          var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)), rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
          if (rp > epsilon$2) {
            var p02 = asin$1(rp / r0 * sin$1(ap)), p1 = asin$1(rp / r1 * sin$1(ap));
            if ((da0 -= p02 * 2) > epsilon$2)
              p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
            else
              da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$2)
              p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
            else
              da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }
          var x01 = r1 * cos$1(a01), y01 = r1 * sin$1(a01), x10 = r0 * cos$1(a10), y10 = r0 * sin$1(a10);
          if (rc > epsilon$2) {
            var x11 = r1 * cos$1(a11), y11 = r1 * sin$1(a11), x002 = r0 * cos$1(a00), y002 = r0 * sin$1(a00), oc;
            if (da < pi$1) {
              if (oc = intersect$3(x01, y01, x002, y002, x11, y11, x10, y10)) {
                var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin$1(acos((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2), lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = min$1(rc, (r0 - lc) / (kc - 1));
                rc1 = min$1(rc, (r1 - lc) / (kc + 1));
              } else {
                rc0 = rc1 = 0;
              }
            }
          }
          if (!(da1 > epsilon$2))
            context2.moveTo(x01, y01);
          else if (rc1 > epsilon$2) {
            t02 = cornerTangents(x002, y002, x01, y01, r1, rc1, cw2);
            t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
            context2.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
            if (rc1 < rc)
              context2.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
            else {
              context2.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
              context2.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
              context2.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
            }
          } else
            context2.moveTo(x01, y01), context2.arc(0, 0, r1, a01, a11, !cw2);
          if (!(r0 > epsilon$2) || !(da0 > epsilon$2))
            context2.lineTo(x10, y10);
          else if (rc0 > epsilon$2) {
            t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
            t12 = cornerTangents(x01, y01, x002, y002, r0, -rc0, cw2);
            context2.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
            if (rc0 < rc)
              context2.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
            else {
              context2.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
              context2.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
              context2.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
            }
          } else
            context2.arc(0, 0, r0, a10, a00, cw2);
        }
        context2.closePath();
        if (buffer)
          return context2 = null, buffer + "" || null;
      }
      arc2.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
        return [cos$1(a2) * r, sin$1(a2) * r];
      };
      arc2.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : innerRadius;
      };
      arc2.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : outerRadius;
      };
      arc2.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : cornerRadius;
      };
      arc2.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc2) : padRadius;
      };
      arc2.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : startAngle;
      };
      arc2.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : endAngle;
      };
      arc2.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : padAngle;
      };
      arc2.context = function(_) {
        return arguments.length ? (context2 = _ == null ? null : _, arc2) : context2;
      };
      return arc2;
    }
    function array$3(x2) {
      return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
    }
    function Linear$1(context2) {
      this._context = context2;
    }
    Linear$1.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x2, y2);
            break;
        }
      }
    };
    function curveLinear(context2) {
      return new Linear$1(context2);
    }
    function x$1(p) {
      return p[0];
    }
    function y$1(p) {
      return p[1];
    }
    function line$2$1(x2, y2) {
      var defined2 = constant$2(true), context2 = null, curve2 = curveLinear, output2 = null, path2 = withPath(line2);
      x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$1 : constant$2(x2);
      y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$1 : constant$2(y2);
      function line2(data2) {
        var i, n = (data2 = array$3(data2)).length, d, defined0 = false, buffer;
        if (context2 == null)
          output2 = curve2(buffer = path2());
        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
            if (defined0 = !defined0)
              output2.lineStart();
            else
              output2.lineEnd();
          }
          if (defined0)
            output2.point(+x2(d, i, data2), +y2(d, i, data2));
        }
        if (buffer)
          return output2 = null, buffer + "" || null;
      }
      line2.x = function(_) {
        return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$2(+_), line2) : x2;
      };
      line2.y = function(_) {
        return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$2(+_), line2) : y2;
      };
      line2.defined = function(_) {
        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$2(!!_), line2) : defined2;
      };
      line2.curve = function(_) {
        return arguments.length ? (curve2 = _, context2 != null && (output2 = curve2(context2)), line2) : curve2;
      };
      line2.context = function(_) {
        return arguments.length ? (_ == null ? context2 = output2 = null : output2 = curve2(context2 = _), line2) : context2;
      };
      return line2;
    }
    function area$2$1(x02, y02, y12) {
      var x12 = null, defined2 = constant$2(true), context2 = null, curve2 = curveLinear, output2 = null, path2 = withPath(area2);
      x02 = typeof x02 === "function" ? x02 : x02 === void 0 ? x$1 : constant$2(+x02);
      y02 = typeof y02 === "function" ? y02 : y02 === void 0 ? constant$2(0) : constant$2(+y02);
      y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y$1 : constant$2(+y12);
      function area2(data2) {
        var i, j, k, n = (data2 = array$3(data2)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
        if (context2 == null)
          output2 = curve2(buffer = path2());
        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output2.areaStart();
              output2.lineStart();
            } else {
              output2.lineEnd();
              output2.lineStart();
              for (k = i - 1; k >= j; --k) {
                output2.point(x0z[k], y0z[k]);
              }
              output2.lineEnd();
              output2.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x02(d, i, data2), y0z[i] = +y02(d, i, data2);
            output2.point(x12 ? +x12(d, i, data2) : x0z[i], y12 ? +y12(d, i, data2) : y0z[i]);
          }
        }
        if (buffer)
          return output2 = null, buffer + "" || null;
      }
      function arealine() {
        return line$2$1().defined(defined2).curve(curve2).context(context2);
      }
      area2.x = function(_) {
        return arguments.length ? (x02 = typeof _ === "function" ? _ : constant$2(+_), x12 = null, area2) : x02;
      };
      area2.x0 = function(_) {
        return arguments.length ? (x02 = typeof _ === "function" ? _ : constant$2(+_), area2) : x02;
      };
      area2.x1 = function(_) {
        return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area2) : x12;
      };
      area2.y = function(_) {
        return arguments.length ? (y02 = typeof _ === "function" ? _ : constant$2(+_), y12 = null, area2) : y02;
      };
      area2.y0 = function(_) {
        return arguments.length ? (y02 = typeof _ === "function" ? _ : constant$2(+_), area2) : y02;
      };
      area2.y1 = function(_) {
        return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area2) : y12;
      };
      area2.lineX0 = area2.lineY0 = function() {
        return arealine().x(x02).y(y02);
      };
      area2.lineY1 = function() {
        return arealine().x(x02).y(y12);
      };
      area2.lineX1 = function() {
        return arealine().x(x12).y(y02);
      };
      area2.defined = function(_) {
        return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant$2(!!_), area2) : defined2;
      };
      area2.curve = function(_) {
        return arguments.length ? (curve2 = _, context2 != null && (output2 = curve2(context2)), area2) : curve2;
      };
      area2.context = function(_) {
        return arguments.length ? (_ == null ? context2 = output2 = null : output2 = curve2(context2 = _), area2) : context2;
      };
      return area2;
    }
    const circle$1 = {
      draw(context2, size2) {
        const r = sqrt$1(size2 / pi$1);
        context2.moveTo(r, 0);
        context2.arc(0, 0, r, 0, tau);
      }
    };
    function Symbol$1(type2, size2) {
      let context2 = null, path2 = withPath(symbol2);
      type2 = typeof type2 === "function" ? type2 : constant$2(type2 || circle$1);
      size2 = typeof size2 === "function" ? size2 : constant$2(size2 === void 0 ? 64 : +size2);
      function symbol2() {
        let buffer;
        if (!context2)
          context2 = buffer = path2();
        type2.apply(this, arguments).draw(context2, +size2.apply(this, arguments));
        if (buffer)
          return context2 = null, buffer + "" || null;
      }
      symbol2.type = function(_) {
        return arguments.length ? (type2 = typeof _ === "function" ? _ : constant$2(_), symbol2) : type2;
      };
      symbol2.size = function(_) {
        return arguments.length ? (size2 = typeof _ === "function" ? _ : constant$2(+_), symbol2) : size2;
      };
      symbol2.context = function(_) {
        return arguments.length ? (context2 = _ == null ? null : _, symbol2) : context2;
      };
      return symbol2;
    }
    function noop$2() {
    }
    function point$7(that, x2, y2) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x2) / 6,
        (that._y0 + 4 * that._y1 + y2) / 6
      );
    }
    function Basis(context2) {
      this._context = context2;
    }
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point$7(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point$7(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasis(context2) {
      return new Basis(context2);
    }
    function BasisClosed(context2) {
      this._context = context2;
    }
    BasisClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x2, this._y2 = y2;
            break;
          case 1:
            this._point = 2;
            this._x3 = x2, this._y3 = y2;
            break;
          case 2:
            this._point = 3;
            this._x4 = x2, this._y4 = y2;
            this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
            break;
          default:
            point$7(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasisClosed(context2) {
      return new BasisClosed(context2);
    }
    function BasisOpen(context2) {
      this._context = context2;
    }
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
            this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
            break;
          case 3:
            this._point = 4;
          default:
            point$7(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    function curveBasisOpen(context2) {
      return new BasisOpen(context2);
    }
    function Bundle(context2, beta) {
      this._basis = new Basis(context2);
      this._beta = beta;
    }
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, j = x2.length - 1;
        if (j > 0) {
          var x02 = x2[0], y02 = y2[0], dx = x2[j] - x02, dy = y2[j] - y02, i = -1, t4;
          while (++i <= j) {
            t4 = i / j;
            this._basis.point(
              this._beta * x2[i] + (1 - this._beta) * (x02 + t4 * dx),
              this._beta * y2[i] + (1 - this._beta) * (y02 + t4 * dy)
            );
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
    const curveBundle = function custom2(beta) {
      function bundle2(context2) {
        return beta === 1 ? new Basis(context2) : new Bundle(context2, beta);
      }
      bundle2.beta = function(beta2) {
        return custom2(+beta2);
      };
      return bundle2;
    }(0.85);
    function point$6(that, x2, y2) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x2),
        that._y2 + that._k * (that._y1 - y2),
        that._x2,
        that._y2
      );
    }
    function Cardinal(context2, tension) {
      this._context = context2;
      this._k = (1 - tension) / 6;
    }
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point$6(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            this._x1 = x2, this._y1 = y2;
            break;
          case 2:
            this._point = 3;
          default:
            point$6(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCardinal = function custom2(tension) {
      function cardinal(context2) {
        return new Cardinal(context2, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
    function CardinalClosed(context2, tension) {
      this._context = context2;
      this._k = (1 - tension) / 6;
    }
    CardinalClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point$6(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCardinalClosed = function custom2(tension) {
      function cardinal(context2) {
        return new CardinalClosed(context2, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
    function CardinalOpen(context2, tension) {
      this._context = context2;
      this._k = (1 - tension) / 6;
    }
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point$6(this, x2, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCardinalOpen = function custom2(tension) {
      function cardinal(context2) {
        return new CardinalOpen(context2, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
    function point$5(that, x2, y2) {
      var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
      if (that._l01_a > epsilon$2) {
        var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }
      if (that._l23_a > epsilon$2) {
        var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2;
        y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
      }
      that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
    }
    function CatmullRom(context2, alpha) {
      this._context = context2;
      this._alpha = alpha;
    }
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point$5(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCatmullRom = function custom2(alpha) {
      function catmullRom(context2) {
        return alpha ? new CatmullRom(context2, alpha) : new Cardinal(context2, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom2(+alpha2);
      };
      return catmullRom;
    }(0.5);
    function CatmullRomClosed(context2, alpha) {
      this._context = context2;
      this._alpha = alpha;
    }
    CatmullRomClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x2, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x2, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x2, this._y5 = y2;
            break;
          default:
            point$5(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCatmullRomClosed = function custom2(alpha) {
      function catmullRom(context2) {
        return alpha ? new CatmullRomClosed(context2, alpha) : new CardinalClosed(context2, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom2(+alpha2);
      };
      return catmullRom;
    }(0.5);
    function CatmullRomOpen(context2, alpha) {
      this._context = context2;
      this._alpha = alpha;
    }
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x2, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point$5(this, x2, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    const curveCatmullRomOpen = function custom2(alpha) {
      function catmullRom(context2) {
        return alpha ? new CatmullRomOpen(context2, alpha) : new CardinalOpen(context2, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom2(+alpha2);
      };
      return catmullRom;
    }(0.5);
    function LinearClosed(context2) {
      this._context = context2;
    }
    LinearClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        if (this._point)
          this._context.lineTo(x2, y2);
        else
          this._point = 1, this._context.moveTo(x2, y2);
      }
    };
    function curveLinearClosed(context2) {
      return new LinearClosed(context2);
    }
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    function slope2(that, t4) {
      var h2 = that._x1 - that._x0;
      return h2 ? (3 * (that._y1 - that._y0) / h2 - t4) / 2 : t4;
    }
    function point$4(that, t02, t12) {
      var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
      that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
    }
    function MonotoneX(context2) {
      this._context = context2;
    }
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point$4(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        var t12 = NaN;
        x2 = +x2, y2 = +y2;
        if (x2 === this._x1 && y2 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point$4(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
            break;
          default:
            point$4(this, this._t0, t12 = slope3(this, x2, y2));
            break;
        }
        this._x0 = this._x1, this._x1 = x2;
        this._y0 = this._y1, this._y1 = y2;
        this._t0 = t12;
      }
    };
    function MonotoneY(context2) {
      this._context = new ReflectContext(context2);
    }
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
      MonotoneX.prototype.point.call(this, y2, x2);
    };
    function ReflectContext(context2) {
      this._context = context2;
    }
    ReflectContext.prototype = {
      moveTo: function(x2, y2) {
        this._context.moveTo(y2, x2);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x2, y2) {
        this._context.lineTo(y2, x2);
      },
      bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
        this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
      }
    };
    function monotoneX(context2) {
      return new MonotoneX(context2);
    }
    function monotoneY(context2) {
      return new MonotoneY(context2);
    }
    function Natural(context2) {
      this._context = context2;
    }
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x2 = this._x, y2 = this._y, n = x2.length;
        if (n) {
          this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
          if (n === 2) {
            this._context.lineTo(x2[1], y2[1]);
          } else {
            var px2 = controlPoints(x2), py2 = controlPoints(y2);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px2[0][i0], py2[0][i0], px2[1][i0], py2[1][i0], x2[i1], y2[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x2, y2) {
        this._x.push(+x2);
        this._y.push(+y2);
      }
    };
    function controlPoints(x2) {
      var i, n = x2.length - 1, m2, a2 = new Array(n), b2 = new Array(n), r = new Array(n);
      a2[0] = 0, b2[0] = 2, r[0] = x2[0] + 2 * x2[1];
      for (i = 1; i < n - 1; ++i)
        a2[i] = 1, b2[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
      a2[n - 1] = 2, b2[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
      for (i = 1; i < n; ++i)
        m2 = a2[i] / b2[i - 1], b2[i] -= m2, r[i] -= m2 * r[i - 1];
      a2[n - 1] = r[n - 1] / b2[n - 1];
      for (i = n - 2; i >= 0; --i)
        a2[i] = (r[i] - a2[i + 1]) / b2[i];
      b2[n - 1] = (x2[n] + a2[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i)
        b2[i] = 2 * x2[i + 1] - a2[i + 1];
      return [a2, b2];
    }
    function curveNatural(context2) {
      return new Natural(context2);
    }
    function Step(context2, t4) {
      this._context = context2;
      this._t = t4;
    }
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y2);
              this._context.lineTo(x2, y2);
            } else {
              var x12 = this._x * (1 - this._t) + x2 * this._t;
              this._context.lineTo(x12, this._y);
              this._context.lineTo(x12, y2);
            }
            break;
          }
        }
        this._x = x2, this._y = y2;
      }
    };
    function curveStep(context2) {
      return new Step(context2, 0.5);
    }
    function stepBefore(context2) {
      return new Step(context2, 0);
    }
    function stepAfter(context2) {
      return new Step(context2, 1);
    }
    function Transform$1(k, x2, y2) {
      this.k = k;
      this.x = x2;
      this.y = y2;
    }
    Transform$1.prototype = {
      constructor: Transform$1,
      scale: function(k) {
        return k === 1 ? this : new Transform$1(this.k * k, this.x, this.y);
      },
      translate: function(x2, y2) {
        return x2 === 0 & y2 === 0 ? this : new Transform$1(this.k, this.x + this.k * x2, this.y + this.k * y2);
      },
      apply: function(point2) {
        return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
      },
      applyX: function(x2) {
        return x2 * this.k + this.x;
      },
      applyY: function(y2) {
        return y2 * this.k + this.y;
      },
      invert: function(location2) {
        return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
      },
      invertX: function(x2) {
        return (x2 - this.x) / this.k;
      },
      invertY: function(y2) {
        return (y2 - this.y) / this.k;
      },
      rescaleX: function(x2) {
        return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
      },
      rescaleY: function(y2) {
        return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    Transform$1.prototype;
    const kde$1 = (ds, bandwidth2, kernelFunction, numPoints) => {
      const [minX, maxX] = extent$1(ds);
      const spanX = maxX - minX;
      const step = spanX / (numPoints - 1);
      const normalizeX = (x2) => (x2 - minX) / spanX;
      const xValues = Array.from({ length: numPoints }, (_, i) => minX + i * step);
      const kdeValues = xValues.map((x2) => {
        const sum2 = ds.reduce((prev2, current2) => {
          const diffN = (x2 - current2) / bandwidth2;
          return prev2 + kernelFunction(diffN);
        }, 0);
        return 1 / (ds.length * bandwidth2) * sum2;
      });
      const domainY = extent$1(kdeValues);
      const normalizeY = linear$1().domain(domainY).range([0, 1]);
      return {
        kdeValues: xValues.map((x2, i) => [
          normalizeX(x2),
          normalizeY(kdeValues[i])
        ]),
        domainY,
        domainX: [0, 1]
      };
    };
    const kdeEpanechnikov = (k) => (v) => Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
    function create_if_block$8(ctx) {
      let p;
      let t4;
      return {
        c() {
          p = element$2("p");
          t4 = text$3(
            /*name*/
            ctx[1]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
          append$2(p, t4);
        },
        p(ctx2, dirty) {
          if (dirty & /*name*/
          2)
            set_data(
              t4,
              /*name*/
              ctx2[1]
            );
        },
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }
    function create_fragment$h(ctx) {
      let div1;
      let div0;
      let t02;
      let p;
      let span0;
      let t1_value = (
        /*valueDisplay*/
        ctx[2](
          /*value*/
          ctx[0]
        ) + ""
      );
      let t12;
      let t22;
      let span4;
      let span2;
      let span1;
      let t32;
      let span3;
      let mounted;
      let dispose;
      let if_block = (
        /*name*/
        ctx[1] != "" && create_if_block$8(ctx)
      );
      let p_levels = [
        /*$labelRoot*/
        ctx[4],
        {
          class: "mb-0.5 font-medium text-magnum-900"
        },
        { "data-melt-part": "root" }
      ];
      let p_data = {};
      for (let i = 0; i < p_levels.length; i += 1) {
        p_data = assign(p_data, p_levels[i]);
      }
      let span1_levels = [
        /*$range*/
        ctx[6],
        { class: "h-[3px] bg-black" }
      ];
      let span_data_1 = {};
      for (let i = 0; i < span1_levels.length; i += 1) {
        span_data_1 = assign(span_data_1, span1_levels[i]);
      }
      let span3_levels = [
        /*__MELTUI_BUILDER_0__*/
        ctx[3],
        {
          class: "h-5 w-5 rounded-full bg-black focus:ring-4 focus:!ring-black/40"
        }
      ];
      let span_data = {};
      for (let i = 0; i < span3_levels.length; i += 1) {
        span_data = assign(span_data, span3_levels[i]);
      }
      let span4_levels = [
        /*$root*/
        ctx[5],
        {
          class: "p-3 relative flex h-[20px] w-full items-center"
        }
      ];
      let span_data_3 = {};
      for (let i = 0; i < span4_levels.length; i += 1) {
        span_data_3 = assign(span_data_3, span4_levels[i]);
      }
      return {
        c() {
          div1 = element$2("div");
          div0 = element$2("div");
          if (if_block)
            if_block.c();
          t02 = space();
          p = element$2("p");
          span0 = element$2("span");
          t12 = text$3(t1_value);
          t22 = space();
          span4 = element$2("span");
          span2 = element$2("span");
          span1 = element$2("span");
          t32 = space();
          span3 = element$2("span");
          attr$6(span0, "class", "relative top-1");
          set_attributes(p, p_data);
          set_attributes(span1, span_data_1);
          attr$6(span2, "class", "pl-3 pr-3 h-[3px] w-full bg-black/40");
          set_attributes(span3, span_data);
          set_attributes(span4, span_data_3);
          attr$6(div0, "class", "flex flex-col items-start justify-center");
          attr$6(div1, "class", "p-3 shadow-sm");
        },
        m(target2, anchor2) {
          insert$2(target2, div1, anchor2);
          append$2(div1, div0);
          if (if_block)
            if_block.m(div0, null);
          append$2(div0, t02);
          append$2(div0, p);
          append$2(p, span0);
          append$2(span0, t12);
          append$2(div0, t22);
          append$2(div0, span4);
          append$2(span4, span2);
          append$2(span2, span1);
          append$2(span4, t32);
          append$2(span4, span3);
          if (!mounted) {
            dispose = [
              action_destroyer(
                /*$labelRoot*/
                ctx[4].action(p)
              ),
              action_destroyer(
                /*$range*/
                ctx[6].action(span1)
              ),
              action_destroyer(
                /*__MELTUI_BUILDER_0__*/
                ctx[3].action(span3)
              ),
              action_destroyer(
                /*$root*/
                ctx[5].action(span4)
              )
            ];
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          if (
            /*name*/
            ctx2[1] != ""
          ) {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block$8(ctx2);
              if_block.c();
              if_block.m(div0, t02);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*valueDisplay, value*/
          5 && t1_value !== (t1_value = /*valueDisplay*/
          ctx2[2](
            /*value*/
            ctx2[0]
          ) + ""))
            set_data(t12, t1_value);
          set_attributes(p, p_data = get_spread_update(p_levels, [
            dirty & /*$labelRoot*/
            16 && /*$labelRoot*/
            ctx2[4],
            {
              class: "mb-0.5 font-medium text-magnum-900"
            },
            { "data-melt-part": "root" }
          ]));
          set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [dirty & /*$range*/
          64 && /*$range*/
          ctx2[6], { class: "h-[3px] bg-black" }]));
          set_attributes(span3, span_data = get_spread_update(span3_levels, [
            dirty & /*__MELTUI_BUILDER_0__*/
            8 && /*__MELTUI_BUILDER_0__*/
            ctx2[3],
            {
              class: "h-5 w-5 rounded-full bg-black focus:ring-4 focus:!ring-black/40"
            }
          ]));
          set_attributes(span4, span_data_3 = get_spread_update(span4_levels, [
            dirty & /*$root*/
            32 && /*$root*/
            ctx2[5],
            {
              class: "p-3 relative flex h-[20px] w-full items-center"
            }
          ]));
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block)
            if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$g($$self, $$props, $$invalidate) {
      let __MELTUI_BUILDER_0__;
      let $thumbs;
      let $labelRoot;
      let $root;
      let $range;
      let { name: name2 = "" } = $$props;
      let { min: min2 = 0 } = $$props;
      let { max: max2 = 100 } = $$props;
      let { step = 1 } = $$props;
      let { value: value2 = 10 } = $$props;
      let { valueDisplay = (v) => v.toString() } = $$props;
      const valueWritableArray = writable([value2]);
      valueWritableArray.subscribe((v) => $$invalidate(0, value2 = v[0]));
      const { elements: { root: root2, range: range2, thumbs } } = createSlider({
        min: min2,
        max: max2,
        step,
        dir: "ltr",
        value: valueWritableArray
      });
      component_subscribe($$self, root2, (value3) => $$invalidate(5, $root = value3));
      component_subscribe($$self, range2, (value3) => $$invalidate(6, $range = value3));
      component_subscribe($$self, thumbs, (value3) => $$invalidate(14, $thumbs = value3));
      const label2 = createLabel();
      const labelRoot = label2.elements.root;
      component_subscribe($$self, labelRoot, (value3) => $$invalidate(4, $labelRoot = value3));
      $$self.$$set = ($$props2) => {
        if ("name" in $$props2)
          $$invalidate(1, name2 = $$props2.name);
        if ("min" in $$props2)
          $$invalidate(11, min2 = $$props2.min);
        if ("max" in $$props2)
          $$invalidate(12, max2 = $$props2.max);
        if ("step" in $$props2)
          $$invalidate(13, step = $$props2.step);
        if ("value" in $$props2)
          $$invalidate(0, value2 = $$props2.value);
        if ("valueDisplay" in $$props2)
          $$invalidate(2, valueDisplay = $$props2.valueDisplay);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*$thumbs*/
        16384) {
          $$invalidate(3, __MELTUI_BUILDER_0__ = $thumbs[0]);
        }
      };
      return [
        value2,
        name2,
        valueDisplay,
        __MELTUI_BUILDER_0__,
        $labelRoot,
        $root,
        $range,
        root2,
        range2,
        thumbs,
        labelRoot,
        min2,
        max2,
        step,
        $thumbs
      ];
    }
    class Slider extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$g, create_fragment$h, safe_not_equal, {
          name: 1,
          min: 11,
          max: 12,
          step: 13,
          value: 0,
          valueDisplay: 2
        });
      }
    }
    function create_if_block_1$4(ctx) {
      let g;
      let g_transform_value;
      return {
        c() {
          g = svg_element("g");
          attr$6(g, "transform", g_transform_value = `translate(0,${/*height*/
          ctx[2]})`);
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          ctx[15](g);
        },
        p(ctx2, dirty) {
          if (dirty & /*height*/
          4 && g_transform_value !== (g_transform_value = `translate(0,${/*height*/
          ctx2[2]})`)) {
            attr$6(g, "transform", g_transform_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          ctx[15](null);
        }
      };
    }
    function create_if_block$7(ctx) {
      let g;
      return {
        c() {
          g = svg_element("g");
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          ctx[16](g);
        },
        p: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          ctx[16](null);
        }
      };
    }
    function create_fragment$g(ctx) {
      let g;
      let if_block0_anchor;
      let if_block0 = (
        /*showAxisX*/
        ctx[0] && create_if_block_1$4(ctx)
      );
      let if_block1 = (
        /*showAxisY*/
        ctx[1] && create_if_block$7(ctx)
      );
      return {
        c() {
          g = svg_element("g");
          if (if_block0)
            if_block0.c();
          if_block0_anchor = empty$1();
          if (if_block1)
            if_block1.c();
          attr$6(
            g,
            "transform",
            /*transformOuterGroup*/
            ctx[5]()
          );
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          if (if_block0)
            if_block0.m(g, null);
          append$2(g, if_block0_anchor);
          if (if_block1)
            if_block1.m(g, null);
        },
        p(ctx2, [dirty]) {
          if (
            /*showAxisX*/
            ctx2[0]
          ) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_1$4(ctx2);
              if_block0.c();
              if_block0.m(g, if_block0_anchor);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (
            /*showAxisY*/
            ctx2[1]
          ) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block$7(ctx2);
              if_block1.c();
              if_block1.m(g, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
        }
      };
    }
    function instance$f($$self, $$props, $$invalidate) {
      let { offsetX = 0 } = $$props;
      let { offsetY = 0 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { domainY } = $$props;
      let { domainX } = $$props;
      let { ticksY = 8 } = $$props;
      let { formatY = ".0%" } = $$props;
      let { ticksX = 8 } = $$props;
      let { formatX = ".3d" } = $$props;
      let axisXContainer;
      let axisYContainer;
      const renderAxisX = () => {
        if (!axisXContainer)
          return;
        const scaleX = linear$1().domain(domainX).range([0, width2]);
        const axis2 = axisBottom(scaleX);
        axis2.ticks(ticksX, formatX);
        select$1(axisXContainer).call(axis2);
      };
      const renderAxisY = () => {
        if (!axisYContainer)
          return;
        const scaleY2 = linear$1().domain(domainY).range([height2, 0]);
        const axis2 = axisLeft(scaleY2);
        axis2.ticks(ticksY, formatY);
        select$1(axisYContainer).call(axis2);
      };
      afterUpdate(() => {
        renderAxisX();
        renderAxisY();
      });
      const transformOuterGroup = () => {
        if (offsetX === 0 && offsetY === 0)
          return "";
        return `translate(${offsetX ? offsetX : 0}, ${offsetY ? offsetY : 0})`;
      };
      function g_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          axisXContainer = $$value;
          $$invalidate(3, axisXContainer);
        });
      }
      function g_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          axisYContainer = $$value;
          $$invalidate(4, axisYContainer);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("offsetX" in $$props2)
          $$invalidate(6, offsetX = $$props2.offsetX);
        if ("offsetY" in $$props2)
          $$invalidate(7, offsetY = $$props2.offsetY);
        if ("showAxisX" in $$props2)
          $$invalidate(0, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(1, showAxisY = $$props2.showAxisY);
        if ("width" in $$props2)
          $$invalidate(8, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(2, height2 = $$props2.height);
        if ("domainY" in $$props2)
          $$invalidate(9, domainY = $$props2.domainY);
        if ("domainX" in $$props2)
          $$invalidate(10, domainX = $$props2.domainX);
        if ("ticksY" in $$props2)
          $$invalidate(11, ticksY = $$props2.ticksY);
        if ("formatY" in $$props2)
          $$invalidate(12, formatY = $$props2.formatY);
        if ("ticksX" in $$props2)
          $$invalidate(13, ticksX = $$props2.ticksX);
        if ("formatX" in $$props2)
          $$invalidate(14, formatX = $$props2.formatX);
      };
      return [
        showAxisX,
        showAxisY,
        height2,
        axisXContainer,
        axisYContainer,
        transformOuterGroup,
        offsetX,
        offsetY,
        width2,
        domainY,
        domainX,
        ticksY,
        formatY,
        ticksX,
        formatX,
        g_binding,
        g_binding_1
      ];
    }
    class SingleAxisLayer extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$f, create_fragment$g, safe_not_equal, {
          offsetX: 6,
          offsetY: 7,
          showAxisX: 0,
          showAxisY: 1,
          width: 8,
          height: 2,
          domainY: 9,
          domainX: 10,
          ticksY: 11,
          formatY: 12,
          ticksX: 13,
          formatX: 14
        });
      }
    }
    function get_each_context$7(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list2[i];
      return child_ctx;
    }
    function create_each_block$7(ctx) {
      let path2;
      let path_d_value;
      let g0;
      let text_1;
      let t_value = (
        /*chart*/
        ctx[18].label + ""
      );
      let t4;
      let g0_transform_value;
      let g1;
      let line0;
      let line0_y__value;
      let line0_y__value_1;
      let line1;
      let line1_x__value_1;
      let line1_y__value;
      let line1_y__value_1;
      let line2;
      let line2_y__value;
      let line2_y__value_1;
      let path_levels = [
        {
          d: path_d_value = /*chart*/
          ctx[18].pathString
        },
        Object.values(
          /*style*/
          ctx[3]
        )[0],
        { stroke: "white" },
        { "stroke-width": "4px" }
      ];
      let path_data = {};
      for (let i = 0; i < path_levels.length; i += 1) {
        path_data = assign(path_data, path_levels[i]);
      }
      return {
        c() {
          path2 = svg_element("path");
          g0 = svg_element("g");
          text_1 = svg_element("text");
          t4 = text$3(t_value);
          g1 = svg_element("g");
          line0 = svg_element("line");
          line1 = svg_element("line");
          line2 = svg_element("line");
          set_svg_attributes(path2, path_data);
          attr$6(text_1, "text-anchor", "end");
          attr$6(text_1, "dominant-baseline", "text-after-edge");
          attr$6(g0, "transform", g0_transform_value = `translate(${-8},${/*chart*/
          ctx[18].y1 - 5})`);
          attr$6(line0, "x", 0);
          attr$6(line0, "y1", line0_y__value = /*chart*/
          ctx[18].y0 + 20);
          attr$6(line0, "y2", line0_y__value_1 = /*chart*/
          ctx[18].y1);
          attr$6(line1, "x2", -30);
          attr$6(line1, "x1", line1_x__value_1 = /*width*/
          ctx[4] - /*axisMarginLeft*/
          ctx[1]);
          attr$6(line1, "y1", line1_y__value = /*chart*/
          ctx[18].y1);
          attr$6(line1, "y2", line1_y__value_1 = /*chart*/
          ctx[18].y1);
          attr$6(line2, "x2", -3);
          attr$6(line2, "x1", 3);
          attr$6(line2, "y1", line2_y__value = /*chart*/
          ctx[18].y0 + 20);
          attr$6(line2, "y2", line2_y__value_1 = /*chart*/
          ctx[18].y0 + 20);
          attr$6(g1, "stroke", "black");
          attr$6(g1, "stroke-dasharray", 1);
        },
        m(target2, anchor2) {
          insert$2(target2, path2, anchor2);
          insert$2(target2, g0, anchor2);
          append$2(g0, text_1);
          append$2(text_1, t4);
          insert$2(target2, g1, anchor2);
          append$2(g1, line0);
          append$2(g1, line1);
          append$2(g1, line2);
        },
        p(ctx2, dirty) {
          set_svg_attributes(path2, path_data = get_spread_update(path_levels, [
            dirty & /*ridgelineCharts*/
            1024 && path_d_value !== (path_d_value = /*chart*/
            ctx2[18].pathString) && { d: path_d_value },
            dirty & /*style*/
            8 && Object.values(
              /*style*/
              ctx2[3]
            )[0],
            { stroke: "white" },
            { "stroke-width": "4px" }
          ]));
          if (dirty & /*ridgelineCharts*/
          1024 && t_value !== (t_value = /*chart*/
          ctx2[18].label + ""))
            set_data(t4, t_value);
          if (dirty & /*ridgelineCharts*/
          1024 && g0_transform_value !== (g0_transform_value = `translate(${-8},${/*chart*/
          ctx2[18].y1 - 5})`)) {
            attr$6(g0, "transform", g0_transform_value);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line0_y__value !== (line0_y__value = /*chart*/
          ctx2[18].y0 + 20)) {
            attr$6(line0, "y1", line0_y__value);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line0_y__value_1 !== (line0_y__value_1 = /*chart*/
          ctx2[18].y1)) {
            attr$6(line0, "y2", line0_y__value_1);
          }
          if (dirty & /*width, axisMarginLeft*/
          18 && line1_x__value_1 !== (line1_x__value_1 = /*width*/
          ctx2[4] - /*axisMarginLeft*/
          ctx2[1])) {
            attr$6(line1, "x1", line1_x__value_1);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line1_y__value !== (line1_y__value = /*chart*/
          ctx2[18].y1)) {
            attr$6(line1, "y1", line1_y__value);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line1_y__value_1 !== (line1_y__value_1 = /*chart*/
          ctx2[18].y1)) {
            attr$6(line1, "y2", line1_y__value_1);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line2_y__value !== (line2_y__value = /*chart*/
          ctx2[18].y0 + 20)) {
            attr$6(line2, "y1", line2_y__value);
          }
          if (dirty & /*ridgelineCharts*/
          1024 && line2_y__value_1 !== (line2_y__value_1 = /*chart*/
          ctx2[18].y0 + 20)) {
            attr$6(line2, "y2", line2_y__value_1);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(path2);
            detach(g0);
            detach(g1);
          }
        }
      };
    }
    function create_fragment$f(ctx) {
      let div;
      let slider0;
      let updating_value;
      let t02;
      let slider1;
      let updating_value_1;
      let t12;
      let slider2;
      let updating_value_2;
      let t22;
      let slider3;
      let updating_value_3;
      let portal_action;
      let t32;
      let svg;
      let g1;
      let g0;
      let text0;
      let t4;
      let text1;
      let t5;
      let text1_transform_value;
      let g1_transform_value;
      let g2;
      let singleaxislayer;
      let g2_transform_value;
      let current2;
      let mounted;
      let dispose;
      function slider0_value_binding(value2) {
        ctx[14](value2);
      }
      let slider0_props = {
        min: 0,
        max: 50,
        step: 1,
        valueDisplay: func$7
      };
      if (
        /*overlap*/
        ctx[9] !== void 0
      ) {
        slider0_props.value = /*overlap*/
        ctx[9];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[15](value2);
      }
      let slider1_props = {
        min: 0.01,
        max: 2,
        step: 0.01,
        valueDisplay: func_1$6
      };
      if (
        /*kernelK*/
        ctx[6] !== void 0
      ) {
        slider1_props.value = /*kernelK*/
        ctx[6];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[16](value2);
      }
      let slider2_props = {
        min: 0.01,
        max: 2,
        step: 0.01,
        valueDisplay: func_2$6
      };
      if (
        /*bandwidth*/
        ctx[7] !== void 0
      ) {
        slider2_props.value = /*bandwidth*/
        ctx[7];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      function slider3_value_binding(value2) {
        ctx[17](value2);
      }
      let slider3_props = {
        min: 2,
        max: 100,
        step: 1,
        valueDisplay: func_3$4
      };
      if (
        /*numPoints*/
        ctx[8] !== void 0
      ) {
        slider3_props.value = /*numPoints*/
        ctx[8];
      }
      slider3 = new Slider({ props: slider3_props });
      binding_callbacks.push(() => bind$2(slider3, "value", slider3_value_binding));
      let each_value = ensure_array_like(
        /*ridgelineCharts*/
        ctx[10]().areas.reverse()
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
      }
      singleaxislayer = new SingleAxisLayer({
        props: {
          width: (
            /*width*/
            ctx[4] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[5] - /*axisMarginBottom*/
            ctx[2]
          ),
          domainX: (
            /*ridgelineCharts*/
            ctx[10]().sharedDomainX
          ),
          domainY: (
            /*ridgelineCharts*/
            ctx[10]().sharedDomainY
          ),
          formatY: ".0",
          ticksY: 14,
          ticksX: 15,
          formatX: ".2f",
          showAxisY: false
        }
      });
      return {
        c() {
          div = element$2("div");
          create_component(slider0.$$.fragment);
          t02 = space();
          create_component(slider1.$$.fragment);
          t12 = space();
          create_component(slider2.$$.fragment);
          t22 = space();
          create_component(slider3.$$.fragment);
          t32 = space();
          svg = svg_element("svg");
          g1 = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          g0 = svg_element("g");
          text0 = svg_element("text");
          t4 = text$3("KDE");
          text1 = svg_element("text");
          t5 = text$3("Value");
          g2 = svg_element("g");
          create_component(singleaxislayer.$$.fragment);
          attr$6(text0, "text-anchor", "middle");
          attr$6(text0, "dominant-baseline", "alphabetic");
          attr$6(text0, "transform", `translate(${0},${marginTop$4})`);
          attr$6(text1, "text-anchor", "end");
          attr$6(text1, "dominant-baseline", "hanging");
          attr$6(text1, "transform", text1_transform_value = `translate(${/*width*/
          ctx[4] - /*axisMarginLeft*/
          ctx[1]},${/*height*/
          ctx[5] - /*axisMarginBottom*/
          ctx[2] + 24})`);
          attr$6(g1, "transform", g1_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},0)`);
          attr$6(g2, "transform", g2_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},0)`);
          attr$6(svg, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          mount_component(slider0, div, null);
          append$2(div, t02);
          mount_component(slider1, div, null);
          append$2(div, t12);
          mount_component(slider2, div, null);
          append$2(div, t22);
          mount_component(slider3, div, null);
          insert$2(target2, t32, anchor2);
          insert$2(target2, svg, anchor2);
          append$2(svg, g1);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g1, null);
            }
          }
          append$2(g1, g0);
          append$2(g0, text0);
          append$2(text0, t4);
          append$2(g0, text1);
          append$2(text1, t5);
          append$2(svg, g2);
          mount_component(singleaxislayer, g2, null);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          const slider0_changes = {};
          if (!updating_value && dirty & /*overlap*/
          512) {
            updating_value = true;
            slider0_changes.value = /*overlap*/
            ctx2[9];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty & /*kernelK*/
          64) {
            updating_value_1 = true;
            slider1_changes.value = /*kernelK*/
            ctx2[6];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_2 && dirty & /*bandwidth*/
          128) {
            updating_value_2 = true;
            slider2_changes.value = /*bandwidth*/
            ctx2[7];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider2.$set(slider2_changes);
          const slider3_changes = {};
          if (!updating_value_3 && dirty & /*numPoints*/
          256) {
            updating_value_3 = true;
            slider3_changes.value = /*numPoints*/
            ctx2[8];
            add_flush_callback(() => updating_value_3 = false);
          }
          slider3.$set(slider3_changes);
          if (portal_action && is_function(portal_action.update) && dirty & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
          if (dirty & /*ridgelineCharts, width, axisMarginLeft, Object, style*/
          1050) {
            each_value = ensure_array_like(
              /*ridgelineCharts*/
              ctx2[10]().areas.reverse()
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$7(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$7(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(g1, g0);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
          if (!current2 || dirty & /*width, axisMarginLeft, height, axisMarginBottom*/
          54 && text1_transform_value !== (text1_transform_value = `translate(${/*width*/
          ctx2[4] - /*axisMarginLeft*/
          ctx2[1]},${/*height*/
          ctx2[5] - /*axisMarginBottom*/
          ctx2[2] + 24})`)) {
            attr$6(text1, "transform", text1_transform_value);
          }
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && g1_transform_value !== (g1_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},0)`)) {
            attr$6(g1, "transform", g1_transform_value);
          }
          const singleaxislayer_changes = {};
          if (dirty & /*width, axisMarginLeft*/
          18)
            singleaxislayer_changes.width = /*width*/
            ctx2[4] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty & /*height, axisMarginBottom*/
          36)
            singleaxislayer_changes.height = /*height*/
            ctx2[5] - /*axisMarginBottom*/
            ctx2[2];
          if (dirty & /*ridgelineCharts*/
          1024)
            singleaxislayer_changes.domainX = /*ridgelineCharts*/
            ctx2[10]().sharedDomainX;
          if (dirty & /*ridgelineCharts*/
          1024)
            singleaxislayer_changes.domainY = /*ridgelineCharts*/
            ctx2[10]().sharedDomainY;
          singleaxislayer.$set(singleaxislayer_changes);
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && g2_transform_value !== (g2_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},0)`)) {
            attr$6(g2, "transform", g2_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          transition_in(slider3.$$.fragment, local);
          transition_in(singleaxislayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          transition_out(slider3.$$.fragment, local);
          transition_out(singleaxislayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
            detach(t32);
            detach(svg);
          }
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          destroy_component(slider3);
          destroy_each(each_blocks, detaching);
          destroy_component(singleaxislayer);
          mounted = false;
          dispose();
        }
      };
    }
    const marginTop$4 = 30;
    const func$7 = (v) => `Overlap: ${v}px`;
    const func_1$6 = (v) => `k: ${v}`;
    const func_2$6 = (v) => `KDE Bandwidth: ${v}`;
    const func_3$4 = (v) => `Number of points: ${v}`;
    function instance$e($$self, $$props, $$invalidate) {
      let ridgelineCharts;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 60 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let kernelK = 0.3;
      let bandwidth2 = 1.1;
      let numPoints = 50;
      let overlap = 20;
      function slider0_value_binding(value2) {
        overlap = value2;
        $$invalidate(9, overlap);
      }
      function slider1_value_binding(value2) {
        kernelK = value2;
        $$invalidate(6, kernelK);
      }
      function slider2_value_binding(value2) {
        bandwidth2 = value2;
        $$invalidate(7, bandwidth2);
      }
      function slider3_value_binding(value2) {
        numPoints = value2;
        $$invalidate(8, numPoints);
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(11, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(12, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(13, data2 = $$props2.data);
        if ("style" in $$props2)
          $$invalidate(3, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(4, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(5, height2 = $$props2.height);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*data, bandwidth, kernelK, numPoints, height, overlap, axisMarginBottom, width, axisMarginLeft*/
        9206) {
          $$invalidate(10, ridgelineCharts = () => {
            const ensembles = new Set(data2.map((d) => d.ensemble_id));
            const experiment_id = data2[0].experiment;
            const experiment = getLoadedExperiments()[experiment_id];
            const sortedEnsembles = experiment.sortedEnsembles().filter((d) => ensembles.has(d.id));
            const kdeInfos = sortedEnsembles.map((ens) => {
              const valuesForEnsemble = data2.filter((d) => d.ensemble_id === ens.id).map((d) => d.values);
              return {
                ...kde$1(valuesForEnsemble, bandwidth2, kdeEpanechnikov(kernelK), numPoints),
                ensemble: ens.id
              };
            });
            const sharedDomainY = [
              Math.min(...kdeInfos.map((d) => d.domainY[0])),
              Math.max(...kdeInfos.map((d) => d.domainY[1]))
            ];
            const sharedDomainX = [
              Math.min(...kdeInfos.map((d) => d.domainX[0])),
              Math.max(...kdeInfos.map((d) => d.domainX[1]))
            ];
            const allocatedHeight = height2 - overlap - axisMarginBottom;
            const heightPerArea = allocatedHeight / sortedEnsembles.length;
            const scaleName2y1 = band$1().domain(sortedEnsembles.map((d) => d.name)).range([allocatedHeight, 0]).padding(0).align(0);
            const scaleYNormalizedToShared = linear$1().domain([0, 1]).range(sharedDomainY);
            const scaleXNormalizedToShared = linear$1().domain([0, 1]).range(sharedDomainX);
            const scaleXSharedToViewport = linear$1().domain(sharedDomainX).range([0, width2 - axisMarginLeft]);
            const points2 = [];
            for (let iteration = 0; iteration < sortedEnsembles.length; ++iteration) {
              const ens = sortedEnsembles[iteration];
              const y12 = scaleName2y1(ens.name);
              const lineInfo = kdeInfos[iteration];
              const scaleY2 = linear$1().domain(sharedDomainY).range([y12 + heightPerArea, y12 - overlap]);
              const areaGenerator = area$2$1().x((d) => scaleXSharedToViewport(scaleXNormalizedToShared(d[0]))).y1((d) => scaleY2(scaleYNormalizedToShared(d[1]))).y0(y12 + heightPerArea + overlap).curve(curveBasis);
              const pathString = areaGenerator(lineInfo.kdeValues);
              points2.push({
                pathString,
                ensemble: ens.id,
                label: `Iter ${ens.iteration}`,
                iteration: ens.iteration,
                x0: 0,
                y0: y12 + overlap,
                y1: y12 + overlap + heightPerArea,
                domainY: sharedDomainY,
                domainX: sharedDomainX,
                height: heightPerArea,
                rect: {
                  x0: 0,
                  y1: y12,
                  y0: y12 - heightPerArea,
                  x1: width2 - axisMarginLeft
                }
              });
            }
            return {
              areas: points2,
              sharedDomainX,
              sharedDomainY
            };
          });
        }
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        style2,
        width2,
        height2,
        kernelK,
        bandwidth2,
        numPoints,
        overlap,
        ridgelineCharts,
        showAxisX,
        showAxisY,
        data2,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding,
        slider3_value_binding
      ];
    }
    class ParameterKDERidgelines extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$e, create_fragment$f, safe_not_equal, {
          localControlsDivSelector: 0,
          axisMarginLeft: 1,
          axisMarginBottom: 2,
          showAxisX: 11,
          showAxisY: 12,
          data: 13,
          style: 3,
          width: 4,
          height: 5
        });
      }
    }
    function create_fragment$e(ctx) {
      let g;
      let path2;
      let path_d_value;
      let path_levels = [
        /*style*/
        ctx[0],
        { d: path_d_value = /*compute*/
        ctx[1]() }
      ];
      let path_data = {};
      for (let i = 0; i < path_levels.length; i += 1) {
        path_data = assign(path_data, path_levels[i]);
      }
      return {
        c() {
          g = svg_element("g");
          path2 = svg_element("path");
          set_svg_attributes(path2, path_data);
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          append$2(g, path2);
        },
        p(ctx2, [dirty]) {
          set_svg_attributes(path2, path_data = get_spread_update(path_levels, [
            dirty & /*style*/
            1 && /*style*/
            ctx2[0],
            dirty & /*compute*/
            2 && path_d_value !== (path_d_value = /*compute*/
            ctx2[1]()) && { d: path_d_value }
          ]));
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
        }
      };
    }
    function instance$d($$self, $$props, $$invalidate) {
      let compute;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { domainY } = $$props;
      let { domainX } = $$props;
      let { sharedDomainX } = $$props;
      let { sharedDomainY } = $$props;
      let { points: points2 } = $$props;
      let { realization } = $$props;
      let { style: style2 } = $$props;
      $$self.$$set = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(2, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(3, height2 = $$props2.height);
        if ("domainY" in $$props2)
          $$invalidate(4, domainY = $$props2.domainY);
        if ("domainX" in $$props2)
          $$invalidate(5, domainX = $$props2.domainX);
        if ("sharedDomainX" in $$props2)
          $$invalidate(6, sharedDomainX = $$props2.sharedDomainX);
        if ("sharedDomainY" in $$props2)
          $$invalidate(7, sharedDomainY = $$props2.sharedDomainY);
        if ("points" in $$props2)
          $$invalidate(8, points2 = $$props2.points);
        if ("realization" in $$props2)
          $$invalidate(9, realization = $$props2.realization);
        if ("style" in $$props2)
          $$invalidate(0, style2 = $$props2.style);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*sharedDomainX, width, sharedDomainY, height, points*/
        460) {
          $$invalidate(1, compute = () => {
            const scaleXNormalizedToShared = linear$1().domain([0, 1]).range(sharedDomainX);
            const scaleXSharedToViewport = linear$1().domain(sharedDomainX).range([0, width2]);
            const scaleYNormalizedToShared = linear$1().domain([0, 1]).range(sharedDomainY);
            const scaleYSharedToViewport = linear$1().domain(sharedDomainY).range([height2, 0]);
            const scaleX = (x2) => scaleXSharedToViewport(scaleXNormalizedToShared(x2));
            const scaleY2 = (y2) => scaleYSharedToViewport(scaleYNormalizedToShared(y2));
            const lineGenerator = area$2$1().x((d) => scaleX(d[0])).y1((d) => scaleY2(d[1])).y0((d) => scaleY2(0)).curve(curveBasis);
            const lineDataString = lineGenerator(points2);
            if (!lineDataString) {
              throw new Error("Failed to create line from data");
            }
            return lineDataString;
          });
        }
      };
      return [
        style2,
        compute,
        width2,
        height2,
        domainY,
        domainX,
        sharedDomainX,
        sharedDomainY,
        points2,
        realization
      ];
    }
    class AreaLayer extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$d, create_fragment$e, safe_not_equal, {
          width: 2,
          height: 3,
          domainY: 4,
          domainX: 5,
          sharedDomainX: 6,
          sharedDomainY: 7,
          points: 8,
          realization: 9,
          style: 0
        });
      }
    }
    function get_each_context$6(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list2[i];
      return child_ctx;
    }
    function create_if_block$6(ctx) {
      let g;
      let singleaxislayer;
      let g_transform_value;
      let current2;
      singleaxislayer = new SingleAxisLayer({
        props: {
          width: (
            /*width*/
            ctx[6] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[7] - /*axisMarginBottom*/
            ctx[2] - marginTop$3
          ),
          domainX: (
            /*kdeCharts*/
            ctx[12]().sharedDomainX
          ),
          domainY: (
            /*kdeCharts*/
            ctx[12]().sharedDomainY
          ),
          formatY: ".0",
          ticksY: 14,
          ticksX: 15,
          formatX: ".1f"
        }
      });
      return {
        c() {
          g = svg_element("g");
          create_component(singleaxislayer.$$.fragment);
          attr$6(g, "transform", g_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$3})`);
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          mount_component(singleaxislayer, g, null);
          current2 = true;
        },
        p(ctx2, dirty) {
          const singleaxislayer_changes = {};
          if (dirty & /*width, axisMarginLeft*/
          66)
            singleaxislayer_changes.width = /*width*/
            ctx2[6] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty & /*height, axisMarginBottom*/
          132)
            singleaxislayer_changes.height = /*height*/
            ctx2[7] - /*axisMarginBottom*/
            ctx2[2] - marginTop$3;
          if (dirty & /*kdeCharts*/
          4096)
            singleaxislayer_changes.domainX = /*kdeCharts*/
            ctx2[12]().sharedDomainX;
          if (dirty & /*kdeCharts*/
          4096)
            singleaxislayer_changes.domainY = /*kdeCharts*/
            ctx2[12]().sharedDomainY;
          singleaxislayer.$set(singleaxislayer_changes);
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && g_transform_value !== (g_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$3})`)) {
            attr$6(g, "transform", g_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(singleaxislayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(singleaxislayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          destroy_component(singleaxislayer);
        }
      };
    }
    function create_each_block$6(ctx) {
      let arealayer;
      let current2;
      arealayer = new AreaLayer({
        props: {
          width: (
            /*width*/
            ctx[6] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[7] - /*axisMarginBottom*/
            ctx[2] - marginTop$3
          ),
          domainX: (
            /*chart*/
            ctx[18].domainX
          ),
          domainY: (
            /*chart*/
            ctx[18].domainY
          ),
          sharedDomainX: (
            /*kdeCharts*/
            ctx[12]().sharedDomainX
          ),
          sharedDomainY: (
            /*kdeCharts*/
            ctx[12]().sharedDomainY
          ),
          points: (
            /*chart*/
            ctx[18].points
          ),
          style: {
            .../*style*/
            ctx[5][
              /*chart*/
              ctx[18].ensemble
            ],
            ...{
              opacity: (
                /*opacity*/
                (ctx[11] / 100).toString()
              )
            },
            stroke: "black"
          },
          realization: (
            /*chart*/
            ctx[18].ensemble
          )
        }
      });
      return {
        c() {
          create_component(arealayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(arealayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const arealayer_changes = {};
          if (dirty & /*width, axisMarginLeft*/
          66)
            arealayer_changes.width = /*width*/
            ctx2[6] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty & /*height, axisMarginBottom*/
          132)
            arealayer_changes.height = /*height*/
            ctx2[7] - /*axisMarginBottom*/
            ctx2[2] - marginTop$3;
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.domainX = /*chart*/
            ctx2[18].domainX;
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.domainY = /*chart*/
            ctx2[18].domainY;
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.sharedDomainX = /*kdeCharts*/
            ctx2[12]().sharedDomainX;
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.sharedDomainY = /*kdeCharts*/
            ctx2[12]().sharedDomainY;
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.points = /*chart*/
            ctx2[18].points;
          if (dirty & /*style, kdeCharts, opacity*/
          6176)
            arealayer_changes.style = {
              .../*style*/
              ctx2[5][
                /*chart*/
                ctx2[18].ensemble
              ],
              ...{
                opacity: (
                  /*opacity*/
                  (ctx2[11] / 100).toString()
                )
              },
              stroke: "black"
            };
          if (dirty & /*kdeCharts*/
          4096)
            arealayer_changes.realization = /*chart*/
            ctx2[18].ensemble;
          arealayer.$set(arealayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(arealayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(arealayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(arealayer, detaching);
        }
      };
    }
    function create_fragment$d(ctx) {
      let div;
      let slider0;
      let updating_value;
      let t02;
      let slider1;
      let updating_value_1;
      let t12;
      let slider2;
      let updating_value_2;
      let t22;
      let slider3;
      let updating_value_3;
      let portal_action;
      let t32;
      let svg;
      let g0;
      let g0_transform_value;
      let g1;
      let text0;
      let t4;
      let text0_transform_value;
      let text1;
      let t5;
      let text1_transform_value;
      let current2;
      let mounted;
      let dispose;
      function slider0_value_binding(value2) {
        ctx[14](value2);
      }
      let slider0_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func$6
      };
      if (
        /*opacity*/
        ctx[11] !== void 0
      ) {
        slider0_props.value = /*opacity*/
        ctx[11];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[15](value2);
      }
      let slider1_props = {
        min: 0.01,
        max: 2,
        step: 0.01,
        valueDisplay: func_1$5
      };
      if (
        /*kernelK*/
        ctx[8] !== void 0
      ) {
        slider1_props.value = /*kernelK*/
        ctx[8];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[16](value2);
      }
      let slider2_props = {
        min: 0.01,
        max: 2,
        step: 0.01,
        valueDisplay: func_2$5
      };
      if (
        /*bandwidth*/
        ctx[9] !== void 0
      ) {
        slider2_props.value = /*bandwidth*/
        ctx[9];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      function slider3_value_binding(value2) {
        ctx[17](value2);
      }
      let slider3_props = {
        min: 2,
        max: 100,
        step: 1,
        valueDisplay: func_3$3
      };
      if (
        /*numPoints*/
        ctx[10] !== void 0
      ) {
        slider3_props.value = /*numPoints*/
        ctx[10];
      }
      slider3 = new Slider({ props: slider3_props });
      binding_callbacks.push(() => bind$2(slider3, "value", slider3_value_binding));
      let if_block = (
        /*showAxisX*/
        (ctx[3] || /*showAxisY*/
        ctx[4]) && create_if_block$6(ctx)
      );
      let each_value = ensure_array_like(
        /*kdeCharts*/
        ctx[12]().lines
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      return {
        c() {
          div = element$2("div");
          create_component(slider0.$$.fragment);
          t02 = space();
          create_component(slider1.$$.fragment);
          t12 = space();
          create_component(slider2.$$.fragment);
          t22 = space();
          create_component(slider3.$$.fragment);
          t32 = space();
          svg = svg_element("svg");
          if (if_block)
            if_block.c();
          g0 = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          g1 = svg_element("g");
          text0 = svg_element("text");
          t4 = text$3("KDE");
          text1 = svg_element("text");
          t5 = text$3("Value");
          attr$6(g0, "transform", g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$3})`);
          attr$6(text0, "text-anchor", "middle");
          attr$6(text0, "dominant-baseline", "alphabetic");
          attr$6(text0, "transform", text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$3 - 10})`);
          attr$6(text1, "text-anchor", "end");
          attr$6(text1, "dominant-baseline", "hanging");
          attr$6(text1, "transform", text1_transform_value = `translate(${/*width*/
          ctx[6]},${/*height*/
          ctx[7] - /*axisMarginBottom*/
          ctx[2] + 20})`);
          attr$6(svg, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          mount_component(slider0, div, null);
          append$2(div, t02);
          mount_component(slider1, div, null);
          append$2(div, t12);
          mount_component(slider2, div, null);
          append$2(div, t22);
          mount_component(slider3, div, null);
          insert$2(target2, t32, anchor2);
          insert$2(target2, svg, anchor2);
          if (if_block)
            if_block.m(svg, null);
          append$2(svg, g0);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g0, null);
            }
          }
          append$2(svg, g1);
          append$2(g1, text0);
          append$2(text0, t4);
          append$2(g1, text1);
          append$2(text1, t5);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          const slider0_changes = {};
          if (!updating_value && dirty & /*opacity*/
          2048) {
            updating_value = true;
            slider0_changes.value = /*opacity*/
            ctx2[11];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty & /*kernelK*/
          256) {
            updating_value_1 = true;
            slider1_changes.value = /*kernelK*/
            ctx2[8];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_2 && dirty & /*bandwidth*/
          512) {
            updating_value_2 = true;
            slider2_changes.value = /*bandwidth*/
            ctx2[9];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider2.$set(slider2_changes);
          const slider3_changes = {};
          if (!updating_value_3 && dirty & /*numPoints*/
          1024) {
            updating_value_3 = true;
            slider3_changes.value = /*numPoints*/
            ctx2[10];
            add_flush_callback(() => updating_value_3 = false);
          }
          slider3.$set(slider3_changes);
          if (portal_action && is_function(portal_action.update) && dirty & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
          if (
            /*showAxisX*/
            ctx2[3] || /*showAxisY*/
            ctx2[4]
          ) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & /*showAxisX, showAxisY*/
              24) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(svg, g0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
          if (dirty & /*width, axisMarginLeft, height, axisMarginBottom, marginTop, kdeCharts, style, opacity*/
          6374) {
            each_value = ensure_array_like(
              /*kdeCharts*/
              ctx2[12]().lines
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$6(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$6(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(g0, null);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && g0_transform_value !== (g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$3})`)) {
            attr$6(g0, "transform", g0_transform_value);
          }
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && text0_transform_value !== (text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$3 - 10})`)) {
            attr$6(text0, "transform", text0_transform_value);
          }
          if (!current2 || dirty & /*width, height, axisMarginBottom*/
          196 && text1_transform_value !== (text1_transform_value = `translate(${/*width*/
          ctx2[6]},${/*height*/
          ctx2[7] - /*axisMarginBottom*/
          ctx2[2] + 20})`)) {
            attr$6(text1, "transform", text1_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          transition_in(slider3.$$.fragment, local);
          transition_in(if_block);
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          transition_out(slider3.$$.fragment, local);
          transition_out(if_block);
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
            detach(t32);
            detach(svg);
          }
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          destroy_component(slider3);
          if (if_block)
            if_block.d();
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
    }
    const marginTop$3 = 30;
    const func$6 = (v) => `Opacity: ${v}`;
    const func_1$5 = (v) => `k: ${v}`;
    const func_2$5 = (v) => `KDE Bandwidth: ${v}`;
    const func_3$3 = (v) => `Number of points: ${v}`;
    function instance$c($$self, $$props, $$invalidate) {
      let kdeCharts;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let kernelK = 0.3;
      let bandwidth2 = 1.1;
      let numPoints = 50;
      let opacity2 = 80;
      function slider0_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(11, opacity2);
      }
      function slider1_value_binding(value2) {
        kernelK = value2;
        $$invalidate(8, kernelK);
      }
      function slider2_value_binding(value2) {
        bandwidth2 = value2;
        $$invalidate(9, bandwidth2);
      }
      function slider3_value_binding(value2) {
        numPoints = value2;
        $$invalidate(10, numPoints);
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(3, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(4, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(13, data2 = $$props2.data);
        if ("style" in $$props2)
          $$invalidate(5, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(6, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(7, height2 = $$props2.height);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*data, bandwidth, kernelK, numPoints*/
        9984) {
          $$invalidate(12, kdeCharts = () => {
            const distinctEnsembles = [...new Set(data2.map((d) => d.ensemble_id).values()).values()];
            const kdeInfosPerEnsemble = distinctEnsembles.map((ensemble) => ({
              ensemble,
              values: data2.filter((d) => d.ensemble_id === ensemble).map((d) => d.values)
            })).map(({ ensemble, values: values2 }) => ({
              ensemble,
              info: kde$1(values2, bandwidth2, kdeEpanechnikov(kernelK), numPoints)
            }));
            const sharedDomainY = [
              Math.min(...kdeInfosPerEnsemble.map((d) => d.info.domainY[0])),
              Math.max(...kdeInfosPerEnsemble.map((d) => d.info.domainY[1]))
            ];
            const sharedDomainX = [
              Math.min(...kdeInfosPerEnsemble.map((d) => d.info.domainX[0])),
              Math.max(...kdeInfosPerEnsemble.map((d) => d.info.domainX[1]))
            ];
            const lines = kdeInfosPerEnsemble.map((d) => ({
              points: d.info.kdeValues,
              domainX: d.info.domainX,
              domainY: d.info.domainY,
              ensemble: d.ensemble
            }));
            return { lines, sharedDomainY, sharedDomainX };
          });
        }
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        style2,
        width2,
        height2,
        kernelK,
        bandwidth2,
        numPoints,
        opacity2,
        kdeCharts,
        data2,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding,
        slider3_value_binding
      ];
    }
    class ParameterKDEArea extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$c, create_fragment$d, safe_not_equal, {
          localControlsDivSelector: 0,
          axisMarginLeft: 1,
          axisMarginBottom: 2,
          showAxisX: 3,
          showAxisY: 4,
          data: 13,
          style: 5,
          width: 6,
          height: 7
        });
      }
    }
    function get_each_context$5(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[13] = list2[i];
      return child_ctx;
    }
    function create_each_block$5(ctx) {
      let g;
      let line0;
      let line0_x__value;
      let line0_x__value_1;
      let line0_y__value;
      let line0_y__value_1;
      let line0_stroke_width_value;
      let line1;
      let line1_x__value;
      let line1_x__value_1;
      let line1_y__value;
      let line1_y__value_1;
      let line1_stroke_width_value;
      let circle2;
      let circle_cx_value;
      let circle_cy_value;
      let circle_r_value;
      let line2;
      let line2_x__value;
      let line2_x__value_1;
      let line2_y__value;
      let line2_y__value_1;
      let line2_stroke_width_value;
      return {
        c() {
          g = svg_element("g");
          line0 = svg_element("line");
          line1 = svg_element("line");
          circle2 = svg_element("circle");
          line2 = svg_element("line");
          attr$6(line0, "stroke-linecap", "round");
          attr$6(line0, "x1", line0_x__value = /*s*/
          ctx[13].cx - /*weight*/
          ctx[1]);
          attr$6(line0, "x2", line0_x__value_1 = /*s*/
          ctx[13].cx + /*weight*/
          ctx[1]);
          attr$6(line0, "y1", line0_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymax
          ));
          attr$6(line0, "y2", line0_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymax
          ));
          attr$6(line0, "stroke-width", line0_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line0,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(line1, "x1", line1_x__value = /*s*/
          ctx[13].cx);
          attr$6(line1, "x2", line1_x__value_1 = /*s*/
          ctx[13].cx);
          attr$6(line1, "y1", line1_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymax
          ));
          attr$6(line1, "y2", line1_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymin
          ));
          attr$6(line1, "stroke-width", line1_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line1,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(circle2, "cx", circle_cx_value = /*s*/
          ctx[13].cx);
          attr$6(circle2, "cy", circle_cy_value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].cy
          ));
          attr$6(circle2, "r", circle_r_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            circle2,
            "fill",
            /*color*/
            ctx[0]
          );
          attr$6(line2, "stroke-linecap", "round");
          attr$6(line2, "x1", line2_x__value = /*s*/
          ctx[13].cx - /*weight*/
          ctx[1]);
          attr$6(line2, "x2", line2_x__value_1 = /*s*/
          ctx[13].cx + /*weight*/
          ctx[1]);
          attr$6(line2, "y1", line2_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymin
          ));
          attr$6(line2, "y2", line2_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[13].ymin
          ));
          attr$6(line2, "stroke-width", line2_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line2,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(
            g,
            "opacity",
            /*opacity*/
            ctx[2]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          append$2(g, line0);
          append$2(g, line1);
          append$2(g, circle2);
          append$2(g, line2);
        },
        p(ctx2, dirty) {
          if (dirty & /*observationsShapes, weight*/
          10 && line0_x__value !== (line0_x__value = /*s*/
          ctx2[13].cx - /*weight*/
          ctx2[1])) {
            attr$6(line0, "x1", line0_x__value);
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line0_x__value_1 !== (line0_x__value_1 = /*s*/
          ctx2[13].cx + /*weight*/
          ctx2[1])) {
            attr$6(line0, "x2", line0_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line0_y__value !== (line0_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymax
          ))) {
            attr$6(line0, "y1", line0_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line0_y__value_1 !== (line0_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymax
          ))) {
            attr$6(line0, "y2", line0_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line0_stroke_width_value !== (line0_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line0, "stroke-width", line0_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line0,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes*/
          8 && line1_x__value !== (line1_x__value = /*s*/
          ctx2[13].cx)) {
            attr$6(line1, "x1", line1_x__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_x__value_1 !== (line1_x__value_1 = /*s*/
          ctx2[13].cx)) {
            attr$6(line1, "x2", line1_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_y__value !== (line1_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymax
          ))) {
            attr$6(line1, "y1", line1_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_y__value_1 !== (line1_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymin
          ))) {
            attr$6(line1, "y2", line1_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line1_stroke_width_value !== (line1_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line1, "stroke-width", line1_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line1,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes*/
          8 && circle_cx_value !== (circle_cx_value = /*s*/
          ctx2[13].cx)) {
            attr$6(circle2, "cx", circle_cx_value);
          }
          if (dirty & /*observationsShapes*/
          8 && circle_cy_value !== (circle_cy_value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].cy
          ))) {
            attr$6(circle2, "cy", circle_cy_value);
          }
          if (dirty & /*weight*/
          2 && circle_r_value !== (circle_r_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(circle2, "r", circle_r_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              circle2,
              "fill",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line2_x__value !== (line2_x__value = /*s*/
          ctx2[13].cx - /*weight*/
          ctx2[1])) {
            attr$6(line2, "x1", line2_x__value);
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line2_x__value_1 !== (line2_x__value_1 = /*s*/
          ctx2[13].cx + /*weight*/
          ctx2[1])) {
            attr$6(line2, "x2", line2_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line2_y__value !== (line2_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymin
          ))) {
            attr$6(line2, "y1", line2_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line2_y__value_1 !== (line2_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[13].ymin
          ))) {
            attr$6(line2, "y2", line2_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line2_stroke_width_value !== (line2_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line2, "stroke-width", line2_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line2,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*opacity*/
          4) {
            attr$6(
              g,
              "opacity",
              /*opacity*/
              ctx2[2]
            );
          }
        },
        d(detaching) {
          if (detaching) {
            detach(g);
          }
        }
      };
    }
    function create_fragment$c(ctx) {
      let g;
      let each_value = ensure_array_like(
        /*observationsShapes*/
        ctx[3]()
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
      }
      return {
        c() {
          g = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g, null);
            }
          }
        },
        p(ctx2, [dirty]) {
          if (dirty & /*opacity, observationsShapes, weight, clampY, color*/
          31) {
            each_value = ensure_array_like(
              /*observationsShapes*/
              ctx2[3]()
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$5(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$5(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(g, null);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function instance$b($$self, $$props, $$invalidate) {
      let observationsShapes;
      let { observationsData } = $$props;
      let { domainX } = $$props;
      let { domainY } = $$props;
      let { timeAttrs } = $$props;
      let { x0: x02 } = $$props;
      let { x1: x12 } = $$props;
      let { y0: y02 } = $$props;
      let { y1: y12 } = $$props;
      let { color: color2 } = $$props;
      let { weight } = $$props;
      let { opacity: opacity2 } = $$props;
      const clampY = (y2) => Math.max(Math.min(y2, y12), y02);
      $$self.$$set = ($$props2) => {
        if ("observationsData" in $$props2)
          $$invalidate(5, observationsData = $$props2.observationsData);
        if ("domainX" in $$props2)
          $$invalidate(6, domainX = $$props2.domainX);
        if ("domainY" in $$props2)
          $$invalidate(7, domainY = $$props2.domainY);
        if ("timeAttrs" in $$props2)
          $$invalidate(8, timeAttrs = $$props2.timeAttrs);
        if ("x0" in $$props2)
          $$invalidate(9, x02 = $$props2.x0);
        if ("x1" in $$props2)
          $$invalidate(10, x12 = $$props2.x1);
        if ("y0" in $$props2)
          $$invalidate(11, y02 = $$props2.y0);
        if ("y1" in $$props2)
          $$invalidate(12, y12 = $$props2.y1);
        if ("color" in $$props2)
          $$invalidate(0, color2 = $$props2.color);
        if ("weight" in $$props2)
          $$invalidate(1, weight = $$props2.weight);
        if ("opacity" in $$props2)
          $$invalidate(2, opacity2 = $$props2.opacity);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*timeAttrs, observationsData, domainX, x0, x1, domainY, y1, y0*/
        8160) {
          $$invalidate(3, observationsShapes = () => {
            const startDate = new Date(timeAttrs.units.split("days since ")[1]);
            const daysBetween = (from, to) => {
              const fromMillis = from.getTime();
              const toMillis = to.getTime();
              return Math.round((toMillis - fromMillis) / (1e3 * 60 * 60 * 24));
            };
            const observationsWithOffsetTimes = observationsData.map((o) => ({
              ...o,
              time: daysBetween(startDate, new Date(o.time))
            }));
            const scaleX = linear$1().domain(domainX).range([x02, x12]);
            const scaleY2 = linear$1().domain(domainY).range([y12, y02]);
            return observationsWithOffsetTimes.map((o) => ({
              cx: scaleX(o.time),
              cy: scaleY2(o.observations),
              ymin: scaleY2(o.observations - o.std),
              ymax: scaleY2(o.observations + o.std)
            }));
          });
        }
      };
      return [
        color2,
        weight,
        opacity2,
        observationsShapes,
        clampY,
        observationsData,
        domainX,
        domainY,
        timeAttrs,
        x02,
        x12,
        y02,
        y12
      ];
    }
    class SummaryObservationsLayer extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$b, create_fragment$c, safe_not_equal, {
          observationsData: 5,
          domainX: 6,
          domainY: 7,
          timeAttrs: 8,
          x0: 9,
          x1: 10,
          y0: 11,
          y1: 12,
          color: 0,
          weight: 1,
          opacity: 2
        });
      }
    }
    function create_else_block$2(ctx) {
      let icon;
      let current2;
      icon = new Icon({ props: { name: "checkbox_outline" } });
      return {
        c() {
          create_component(icon.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(icon, target2, anchor2);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(icon, detaching);
        }
      };
    }
    function create_if_block$5(ctx) {
      let icon;
      let current2;
      icon = new Icon({ props: { name: "checkbox" } });
      return {
        c() {
          create_component(icon.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(icon, target2, anchor2);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(icon, detaching);
        }
      };
    }
    function create_fragment$b(ctx) {
      let form2;
      let div;
      let label_1;
      let t02;
      let t12;
      let button;
      let current_block_type_index;
      let if_block;
      let t22;
      let input_1;
      let current2;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$5, create_else_block$2];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (
          /*$isChecked*/
          ctx2[2]
        )
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let input_1_levels = [
        /*$input*/
        ctx[3]
      ];
      let input_data = {};
      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_data = assign(input_data, input_1_levels[i]);
      }
      let button_levels = [
        /*$root*/
        ctx[1],
        {
          class: "flex appearance-none items-center justify-center rounded-lg bg-white text-magnum-600 shadow square-7 hover:opacity-75"
        },
        { id: "checkbox" }
      ];
      let button_data = {};
      for (let i = 0; i < button_levels.length; i += 1) {
        button_data = assign(button_data, button_levels[i]);
      }
      return {
        c() {
          form2 = element$2("form");
          div = element$2("div");
          label_1 = element$2("label");
          t02 = text$3(
            /*label*/
            ctx[0]
          );
          t12 = space();
          button = element$2("button");
          if_block.c();
          t22 = space();
          input_1 = element$2("input");
          attr$6(label_1, "class", "select-none pr-4 font-medium text-magnum-900");
          attr$6(label_1, "for", "checkbox");
          set_attributes(input_1, input_data);
          set_attributes(button, button_data);
          attr$6(div, "class", "flex justify-end items-center w-full p-3");
        },
        m(target2, anchor2) {
          insert$2(target2, form2, anchor2);
          append$2(form2, div);
          append$2(div, label_1);
          append$2(label_1, t02);
          append$2(div, t12);
          append$2(div, button);
          if_blocks[current_block_type_index].m(button, null);
          append$2(button, t22);
          append$2(button, input_1);
          if (input_1.autofocus)
            input_1.focus();
          if (button.autofocus)
            button.focus();
          current2 = true;
          if (!mounted) {
            dispose = [
              action_destroyer(
                /*$input*/
                ctx[3].action(input_1)
              ),
              action_destroyer(
                /*$root*/
                ctx[1].action(button)
              )
            ];
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          if (!current2 || dirty & /*label*/
          1)
            set_data(
              t02,
              /*label*/
              ctx2[0]
            );
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index !== previous_block_index) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            }
            transition_in(if_block, 1);
            if_block.m(button, t22);
          }
          set_attributes(input_1, input_data = get_spread_update(input_1_levels, [dirty & /*$input*/
          8 && /*$input*/
          ctx2[3]]));
          set_attributes(button, button_data = get_spread_update(button_levels, [
            dirty & /*$root*/
            2 && /*$root*/
            ctx2[1],
            {
              class: "flex appearance-none items-center justify-center rounded-lg bg-white text-magnum-600 shadow square-7 hover:opacity-75"
            },
            { id: "checkbox" }
          ]));
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block);
          current2 = true;
        },
        o(local) {
          transition_out(if_block);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(form2);
          }
          if_blocks[current_block_type_index].d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$a($$self, $$props, $$invalidate) {
      let $root;
      let $isChecked;
      let $input;
      let { checked = false } = $$props;
      let { label: label2 = "some checkbox label" } = $$props;
      const { elements: { root: root2, input }, helpers: { isChecked, isIndeterminate } } = createCheckbox({
        defaultChecked: checked,
        onCheckedChange: ({ next: next2 }) => {
          $$invalidate(7, checked = !!next2);
          return next2;
        }
      });
      component_subscribe($$self, root2, (value2) => $$invalidate(1, $root = value2));
      component_subscribe($$self, input, (value2) => $$invalidate(3, $input = value2));
      component_subscribe($$self, isChecked, (value2) => $$invalidate(2, $isChecked = value2));
      $$self.$$set = ($$props2) => {
        if ("checked" in $$props2)
          $$invalidate(7, checked = $$props2.checked);
        if ("label" in $$props2)
          $$invalidate(0, label2 = $$props2.label);
      };
      return [label2, $root, $isChecked, $input, root2, input, isChecked, checked];
    }
    class Checkbox extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$a, create_fragment$b, safe_not_equal, { checked: 7, label: 0 });
      }
    }
    function create_fragment$a(ctx) {
      let g;
      let path2;
      let path_d_value;
      let path_levels = [
        { class: "fill-none" },
        /*style*/
        ctx[0],
        { d: path_d_value = /*compute*/
        ctx[1]() }
      ];
      let path_data = {};
      for (let i = 0; i < path_levels.length; i += 1) {
        path_data = assign(path_data, path_levels[i]);
      }
      return {
        c() {
          g = svg_element("g");
          path2 = svg_element("path");
          set_svg_attributes(path2, path_data);
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          append$2(g, path2);
        },
        p(ctx2, [dirty]) {
          set_svg_attributes(path2, path_data = get_spread_update(path_levels, [
            { class: "fill-none" },
            dirty & /*style*/
            1 && /*style*/
            ctx2[0],
            dirty & /*compute*/
            2 && path_d_value !== (path_d_value = /*compute*/
            ctx2[1]()) && { d: path_d_value }
          ]));
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
        }
      };
    }
    function instance$9($$self, $$props, $$invalidate) {
      let compute;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { domainY } = $$props;
      let { domainX } = $$props;
      let { points: points2 } = $$props;
      let { realization } = $$props;
      let { style: style2 } = $$props;
      $$self.$$set = ($$props2) => {
        if ("width" in $$props2)
          $$invalidate(2, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(3, height2 = $$props2.height);
        if ("domainY" in $$props2)
          $$invalidate(4, domainY = $$props2.domainY);
        if ("domainX" in $$props2)
          $$invalidate(5, domainX = $$props2.domainX);
        if ("points" in $$props2)
          $$invalidate(6, points2 = $$props2.points);
        if ("realization" in $$props2)
          $$invalidate(7, realization = $$props2.realization);
        if ("style" in $$props2)
          $$invalidate(0, style2 = $$props2.style);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*domainX, width, domainY, height, points*/
        124) {
          $$invalidate(1, compute = () => {
            const scaleX = linear$1().domain(domainX).range([0, width2]);
            const scaleY2 = linear$1().domain(domainY).range([height2, 0]);
            const lineGenerator = line$2$1().x((d) => scaleX(d[0])).y((d) => scaleY2(d[1]));
            const lineDataString = lineGenerator(points2);
            if (!lineDataString) {
              throw new Error("Failed to create line from data");
            }
            return lineDataString;
          });
        }
      };
      return [style2, compute, width2, height2, domainY, domainX, points2, realization];
    }
    class LineLayer extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$9, create_fragment$a, safe_not_equal, {
          width: 2,
          height: 3,
          domainY: 4,
          domainX: 5,
          points: 6,
          realization: 7,
          style: 0
        });
      }
    }
    function get_each_context$4(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[33] = list2[i];
      child_ctx[35] = i;
      return child_ctx;
    }
    function create_if_block_6(ctx) {
      let checkbox2;
      let updating_checked;
      let current2;
      function checkbox_checked_binding(value2) {
        ctx[24](value2);
      }
      let checkbox_props = { label: "Show history?" };
      if (
        /*showHistory*/
        ctx[12] !== void 0
      ) {
        checkbox_props.checked = /*showHistory*/
        ctx[12];
      }
      checkbox2 = new Checkbox({ props: checkbox_props });
      binding_callbacks.push(() => bind$2(checkbox2, "checked", checkbox_checked_binding));
      return {
        c() {
          create_component(checkbox2.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(checkbox2, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const checkbox_changes = {};
          if (!updating_checked && dirty[0] & /*showHistory*/
          4096) {
            updating_checked = true;
            checkbox_changes.checked = /*showHistory*/
            ctx2[12];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox2.$set(checkbox_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(checkbox2.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(checkbox2.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(checkbox2, detaching);
        }
      };
    }
    function create_if_block_5(ctx) {
      let checkbox2;
      let updating_checked;
      let current2;
      function checkbox_checked_binding_1(value2) {
        ctx[25](value2);
      }
      let checkbox_props = { label: "Show observations?" };
      if (
        /*showObservations*/
        ctx[13] !== void 0
      ) {
        checkbox_props.checked = /*showObservations*/
        ctx[13];
      }
      checkbox2 = new Checkbox({ props: checkbox_props });
      binding_callbacks.push(() => bind$2(checkbox2, "checked", checkbox_checked_binding_1));
      return {
        c() {
          create_component(checkbox2.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(checkbox2, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const checkbox_changes = {};
          if (!updating_checked && dirty[0] & /*showObservations*/
          8192) {
            updating_checked = true;
            checkbox_changes.checked = /*showObservations*/
            ctx2[13];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox2.$set(checkbox_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(checkbox2.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(checkbox2.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(checkbox2, detaching);
        }
      };
    }
    function create_if_block_4(ctx) {
      let slider0;
      let updating_value;
      let t4;
      let slider1;
      let updating_value_1;
      let current2;
      function slider0_value_binding_1(value2) {
        ctx[29](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 6,
        step: 0.5,
        valueDisplay: func_3$2
      };
      if (
        /*observationWeight*/
        ctx[14] !== void 0
      ) {
        slider0_props.value = /*observationWeight*/
        ctx[14];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding_1));
      function slider1_value_binding_1(value2) {
        ctx[30](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_4$2
      };
      if (
        /*observationOpacity*/
        ctx[15] !== void 0
      ) {
        slider1_props.value = /*observationOpacity*/
        ctx[15];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding_1));
      return {
        c() {
          create_component(slider0.$$.fragment);
          t4 = space();
          create_component(slider1.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(slider0, target2, anchor2);
          insert$2(target2, t4, anchor2);
          mount_component(slider1, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const slider0_changes = {};
          if (!updating_value && dirty[0] & /*observationWeight*/
          16384) {
            updating_value = true;
            slider0_changes.value = /*observationWeight*/
            ctx2[14];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty[0] & /*observationOpacity*/
          32768) {
            updating_value_1 = true;
            slider1_changes.value = /*observationOpacity*/
            ctx2[15];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
          destroy_component(slider0, detaching);
          destroy_component(slider1, detaching);
        }
      };
    }
    function create_if_block_3$2(ctx) {
      let slider0;
      let updating_value;
      let t4;
      let slider1;
      let updating_value_1;
      let current2;
      function slider0_value_binding_2(value2) {
        ctx[31](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 30,
        step: 0.5,
        valueDisplay: func_5$2
      };
      if (
        /*historyWeight*/
        ctx[16] !== void 0
      ) {
        slider0_props.value = /*historyWeight*/
        ctx[16];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding_2));
      function slider1_value_binding_2(value2) {
        ctx[32](value2);
      }
      let slider1_props = {
        min: 0,
        max: 40,
        step: 1,
        valueDisplay: func_6
      };
      if (
        /*historyDasharray*/
        ctx[17] !== void 0
      ) {
        slider1_props.value = /*historyDasharray*/
        ctx[17];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding_2));
      return {
        c() {
          create_component(slider0.$$.fragment);
          t4 = space();
          create_component(slider1.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(slider0, target2, anchor2);
          insert$2(target2, t4, anchor2);
          mount_component(slider1, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const slider0_changes = {};
          if (!updating_value && dirty[0] & /*historyWeight*/
          65536) {
            updating_value = true;
            slider0_changes.value = /*historyWeight*/
            ctx2[16];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty[0] & /*historyDasharray*/
          131072) {
            updating_value_1 = true;
            slider1_changes.value = /*historyDasharray*/
            ctx2[17];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
          destroy_component(slider0, detaching);
          destroy_component(slider1, detaching);
        }
      };
    }
    function create_if_block_2$2(ctx) {
      let g0;
      let singleaxislayer;
      let g0_transform_value;
      let g1;
      let text0;
      let t02;
      let text0_transform_value;
      let text1;
      let t12;
      let text1_transform_value;
      let current2;
      singleaxislayer = new SingleAxisLayer({
        props: {
          width: (
            /*width*/
            ctx[9] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[10] - /*axisMarginBottom*/
            ctx[2] - marginTop$2
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[21]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[22]()
          ),
          formatY: ".2f"
        }
      });
      return {
        c() {
          g0 = svg_element("g");
          create_component(singleaxislayer.$$.fragment);
          g1 = svg_element("g");
          text0 = svg_element("text");
          t02 = text$3(
            /*keyword*/
            ctx[11]
          );
          text1 = svg_element("text");
          t12 = text$3("Time");
          attr$6(g0, "transform", g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$2})`);
          attr$6(text0, "text-anchor", "middle");
          attr$6(text0, "dominant-baseline", "alphabetic");
          attr$6(text0, "transform", text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$2 - 10})`);
          attr$6(text1, "text-anchor", "end");
          attr$6(text1, "dominant-baseline", "hanging");
          attr$6(text1, "transform", text1_transform_value = `translate(${/*width*/
          ctx[9]},${/*height*/
          ctx[10] - /*axisMarginBottom*/
          ctx[2] + 10})`);
        },
        m(target2, anchor2) {
          insert$2(target2, g0, anchor2);
          mount_component(singleaxislayer, g0, null);
          insert$2(target2, g1, anchor2);
          append$2(g1, text0);
          append$2(text0, t02);
          append$2(g1, text1);
          append$2(text1, t12);
          current2 = true;
        },
        p(ctx2, dirty) {
          const singleaxislayer_changes = {};
          if (dirty[0] & /*width, axisMarginLeft*/
          514)
            singleaxislayer_changes.width = /*width*/
            ctx2[9] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          1028)
            singleaxislayer_changes.height = /*height*/
            ctx2[10] - /*axisMarginBottom*/
            ctx2[2] - marginTop$2;
          if (dirty[0] & /*sharedDomainX*/
          2097152)
            singleaxislayer_changes.domainX = /*sharedDomainX*/
            ctx2[21]();
          if (dirty[0] & /*sharedDomainY*/
          4194304)
            singleaxislayer_changes.domainY = /*sharedDomainY*/
            ctx2[22]();
          singleaxislayer.$set(singleaxislayer_changes);
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && g0_transform_value !== (g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$2})`)) {
            attr$6(g0, "transform", g0_transform_value);
          }
          if (!current2 || dirty[0] & /*keyword*/
          2048)
            set_data(
              t02,
              /*keyword*/
              ctx2[11]
            );
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && text0_transform_value !== (text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$2 - 10})`)) {
            attr$6(text0, "transform", text0_transform_value);
          }
          if (!current2 || dirty[0] & /*width, height, axisMarginBottom*/
          1540 && text1_transform_value !== (text1_transform_value = `translate(${/*width*/
          ctx2[9]},${/*height*/
          ctx2[10] - /*axisMarginBottom*/
          ctx2[2] + 10})`)) {
            attr$6(text1, "transform", text1_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(singleaxislayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(singleaxislayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(g0);
            detach(g1);
          }
          destroy_component(singleaxislayer);
        }
      };
    }
    function create_each_block$4(ctx) {
      let linelayer;
      let current2;
      linelayer = new LineLayer({
        props: {
          width: (
            /*width*/
            ctx[9] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[10] - /*axisMarginBottom*/
            ctx[2] - marginTop$2
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[21]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[22]()
          ),
          points: (
            /*chart*/
            ctx[33].points
          ),
          realization: (
            /*chart*/
            ctx[33].realization
          ),
          style: {
            .../*style*/
            ctx[8][
              /*chart*/
              ctx[33].ensemble
            ],
            "stroke-linecap": "round",
            "stroke-dashoffset": `${/*i*/
            ctx[35] * dashoffsetMultiplier$1}px`,
            "stroke-dasharray": (
              /*dasharray*/
              ctx[19].toString()
            ),
            "stroke-width": (
              /*weight*/
              ctx[18].toString()
            ),
            opacity: (
              /*opacity*/
              (ctx[20] / 100).toString()
            )
          }
        }
      });
      return {
        c() {
          create_component(linelayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(linelayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const linelayer_changes = {};
          if (dirty[0] & /*width, axisMarginLeft*/
          514)
            linelayer_changes.width = /*width*/
            ctx2[9] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          1028)
            linelayer_changes.height = /*height*/
            ctx2[10] - /*axisMarginBottom*/
            ctx2[2] - marginTop$2;
          if (dirty[0] & /*sharedDomainX*/
          2097152)
            linelayer_changes.domainX = /*sharedDomainX*/
            ctx2[21]();
          if (dirty[0] & /*sharedDomainY*/
          4194304)
            linelayer_changes.domainY = /*sharedDomainY*/
            ctx2[22]();
          if (dirty[0] & /*data*/
          32)
            linelayer_changes.points = /*chart*/
            ctx2[33].points;
          if (dirty[0] & /*data*/
          32)
            linelayer_changes.realization = /*chart*/
            ctx2[33].realization;
          if (dirty[0] & /*style, data, dasharray, weight, opacity*/
          1835296)
            linelayer_changes.style = {
              .../*style*/
              ctx2[8][
                /*chart*/
                ctx2[33].ensemble
              ],
              "stroke-linecap": "round",
              "stroke-dashoffset": `${/*i*/
              ctx2[35] * dashoffsetMultiplier$1}px`,
              "stroke-dasharray": (
                /*dasharray*/
                ctx2[19].toString()
              ),
              "stroke-width": (
                /*weight*/
                ctx2[18].toString()
              ),
              opacity: (
                /*opacity*/
                (ctx2[20] / 100).toString()
              )
            };
          linelayer.$set(linelayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(linelayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(linelayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(linelayer, detaching);
        }
      };
    }
    function create_if_block_1$3(ctx) {
      let linelayer;
      let current2;
      linelayer = new LineLayer({
        props: {
          width: (
            /*width*/
            ctx[9] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[10] - /*axisMarginBottom*/
            ctx[2] - marginTop$2
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[21]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[22]()
          ),
          points: (
            /*historyData*/
            ctx[6].data[0].points
          ),
          realization: (
            /*historyData*/
            ctx[6].data[0].realization
          ),
          style: {
            "stroke-linecap": "round",
            stroke: (
              /*style*/
              ctx[8].annotationColors[0]
            ),
            "stroke-dasharray": (
              /*historyDasharray*/
              ctx[17].toString()
            ),
            "stroke-width": (
              /*historyWeight*/
              ctx[16].toString()
            ),
            opacity: "1"
          }
        }
      });
      return {
        c() {
          create_component(linelayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(linelayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const linelayer_changes = {};
          if (dirty[0] & /*width, axisMarginLeft*/
          514)
            linelayer_changes.width = /*width*/
            ctx2[9] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          1028)
            linelayer_changes.height = /*height*/
            ctx2[10] - /*axisMarginBottom*/
            ctx2[2] - marginTop$2;
          if (dirty[0] & /*sharedDomainX*/
          2097152)
            linelayer_changes.domainX = /*sharedDomainX*/
            ctx2[21]();
          if (dirty[0] & /*sharedDomainY*/
          4194304)
            linelayer_changes.domainY = /*sharedDomainY*/
            ctx2[22]();
          if (dirty[0] & /*historyData*/
          64)
            linelayer_changes.points = /*historyData*/
            ctx2[6].data[0].points;
          if (dirty[0] & /*historyData*/
          64)
            linelayer_changes.realization = /*historyData*/
            ctx2[6].data[0].realization;
          if (dirty[0] & /*style, historyDasharray, historyWeight*/
          196864)
            linelayer_changes.style = {
              "stroke-linecap": "round",
              stroke: (
                /*style*/
                ctx2[8].annotationColors[0]
              ),
              "stroke-dasharray": (
                /*historyDasharray*/
                ctx2[17].toString()
              ),
              "stroke-width": (
                /*historyWeight*/
                ctx2[16].toString()
              ),
              opacity: "1"
            };
          linelayer.$set(linelayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(linelayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(linelayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(linelayer, detaching);
        }
      };
    }
    function create_if_block$4(ctx) {
      let summaryobservationslayer;
      let current2;
      summaryobservationslayer = new SummaryObservationsLayer({
        props: {
          observationsData: (
            /*observationsData*/
            ctx[7]
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[21]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[22]()
          ),
          timeAttrs: (
            /*data*/
            ctx[5][0].timeAttrs
          ),
          x0: 0,
          x1: (
            /*width*/
            ctx[9] - /*axisMarginLeft*/
            ctx[1]
          ),
          y0: 0,
          y1: (
            /*height*/
            ctx[10] - /*axisMarginBottom*/
            ctx[2] - marginTop$2
          ),
          color: (
            /*style*/
            ctx[8].annotationColors[1]
          ),
          opacity: (
            /*observationOpacity*/
            ctx[15] / 100
          ),
          weight: (
            /*observationWeight*/
            ctx[14]
          )
        }
      });
      return {
        c() {
          create_component(summaryobservationslayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(summaryobservationslayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const summaryobservationslayer_changes = {};
          if (dirty[0] & /*observationsData*/
          128)
            summaryobservationslayer_changes.observationsData = /*observationsData*/
            ctx2[7];
          if (dirty[0] & /*sharedDomainX*/
          2097152)
            summaryobservationslayer_changes.domainX = /*sharedDomainX*/
            ctx2[21]();
          if (dirty[0] & /*sharedDomainY*/
          4194304)
            summaryobservationslayer_changes.domainY = /*sharedDomainY*/
            ctx2[22]();
          if (dirty[0] & /*data*/
          32)
            summaryobservationslayer_changes.timeAttrs = /*data*/
            ctx2[5][0].timeAttrs;
          if (dirty[0] & /*width, axisMarginLeft*/
          514)
            summaryobservationslayer_changes.x1 = /*width*/
            ctx2[9] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          1028)
            summaryobservationslayer_changes.y1 = /*height*/
            ctx2[10] - /*axisMarginBottom*/
            ctx2[2] - marginTop$2;
          if (dirty[0] & /*style*/
          256)
            summaryobservationslayer_changes.color = /*style*/
            ctx2[8].annotationColors[1];
          if (dirty[0] & /*observationOpacity*/
          32768)
            summaryobservationslayer_changes.opacity = /*observationOpacity*/
            ctx2[15] / 100;
          if (dirty[0] & /*observationWeight*/
          16384)
            summaryobservationslayer_changes.weight = /*observationWeight*/
            ctx2[14];
          summaryobservationslayer.$set(summaryobservationslayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(summaryobservationslayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(summaryobservationslayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(summaryobservationslayer, detaching);
        }
      };
    }
    function create_fragment$9(ctx) {
      let div;
      let t02;
      let t12;
      let slider0;
      let updating_value;
      let t22;
      let slider1;
      let updating_value_1;
      let t32;
      let slider2;
      let updating_value_2;
      let t4;
      let t5;
      let portal_action;
      let t6;
      let svg;
      let g;
      let each_1_anchor;
      let if_block5_anchor;
      let g_transform_value;
      let current2;
      let mounted;
      let dispose;
      let if_block0 = !!/*historyData*/
      ctx[6] && create_if_block_6(ctx);
      let if_block1 = !!/*observationsData*/
      ctx[7] && create_if_block_5(ctx);
      function slider0_value_binding(value2) {
        ctx[26](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 30,
        step: 0.5,
        valueDisplay: func$5
      };
      if (
        /*weight*/
        ctx[18] !== void 0
      ) {
        slider0_props.value = /*weight*/
        ctx[18];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[27](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_1$4
      };
      if (
        /*opacity*/
        ctx[20] !== void 0
      ) {
        slider1_props.value = /*opacity*/
        ctx[20];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[28](value2);
      }
      let slider2_props = {
        min: 0,
        max: 10,
        step: 1,
        valueDisplay: func_2$4
      };
      if (
        /*dasharray*/
        ctx[19] !== void 0
      ) {
        slider2_props.value = /*dasharray*/
        ctx[19];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      let if_block2 = (
        /*showObservations*/
        ctx[13] && create_if_block_4(ctx)
      );
      let if_block3 = (
        /*showHistory*/
        ctx[12] && create_if_block_3$2(ctx)
      );
      let if_block4 = (
        /*showAxisX*/
        (ctx[3] || /*showAxisY*/
        ctx[4]) && create_if_block_2$2(ctx)
      );
      let each_value = ensure_array_like(
        /*data*/
        ctx[5]
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      let if_block5 = (
        /*showHistory*/
        ctx[12] && create_if_block_1$3(ctx)
      );
      let if_block6 = (
        /*showObservations*/
        ctx[13] && create_if_block$4(ctx)
      );
      return {
        c() {
          div = element$2("div");
          if (if_block0)
            if_block0.c();
          t02 = space();
          if (if_block1)
            if_block1.c();
          t12 = space();
          create_component(slider0.$$.fragment);
          t22 = space();
          create_component(slider1.$$.fragment);
          t32 = space();
          create_component(slider2.$$.fragment);
          t4 = space();
          if (if_block2)
            if_block2.c();
          t5 = space();
          if (if_block3)
            if_block3.c();
          t6 = space();
          svg = svg_element("svg");
          if (if_block4)
            if_block4.c();
          g = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty$1();
          if (if_block5)
            if_block5.c();
          if_block5_anchor = empty$1();
          if (if_block6)
            if_block6.c();
          attr$6(g, "transform", g_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$2})`);
          attr$6(svg, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          if (if_block0)
            if_block0.m(div, null);
          append$2(div, t02);
          if (if_block1)
            if_block1.m(div, null);
          append$2(div, t12);
          mount_component(slider0, div, null);
          append$2(div, t22);
          mount_component(slider1, div, null);
          append$2(div, t32);
          mount_component(slider2, div, null);
          append$2(div, t4);
          if (if_block2)
            if_block2.m(div, null);
          append$2(div, t5);
          if (if_block3)
            if_block3.m(div, null);
          insert$2(target2, t6, anchor2);
          insert$2(target2, svg, anchor2);
          if (if_block4)
            if_block4.m(svg, null);
          append$2(svg, g);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g, null);
            }
          }
          append$2(g, each_1_anchor);
          if (if_block5)
            if_block5.m(g, null);
          append$2(g, if_block5_anchor);
          if (if_block6)
            if_block6.m(g, null);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          if (!!/*historyData*/
          ctx2[6]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              if (dirty[0] & /*historyData*/
              64) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_6(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t02);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (!!/*observationsData*/
          ctx2[7]) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & /*observationsData*/
              128) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_5(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t12);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          const slider0_changes = {};
          if (!updating_value && dirty[0] & /*weight*/
          262144) {
            updating_value = true;
            slider0_changes.value = /*weight*/
            ctx2[18];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty[0] & /*opacity*/
          1048576) {
            updating_value_1 = true;
            slider1_changes.value = /*opacity*/
            ctx2[20];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_2 && dirty[0] & /*dasharray*/
          524288) {
            updating_value_2 = true;
            slider2_changes.value = /*dasharray*/
            ctx2[19];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider2.$set(slider2_changes);
          if (
            /*showObservations*/
            ctx2[13]
          ) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & /*showObservations*/
              8192) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_4(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t5);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (
            /*showHistory*/
            ctx2[12]
          ) {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & /*showHistory*/
              4096) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_3$2(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if (portal_action && is_function(portal_action.update) && dirty[0] & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
          if (
            /*showAxisX*/
            ctx2[3] || /*showAxisY*/
            ctx2[4]
          ) {
            if (if_block4) {
              if_block4.p(ctx2, dirty);
              if (dirty[0] & /*showAxisX, showAxisY*/
              24) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_2$2(ctx2);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(svg, g);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
          if (dirty[0] & /*width, axisMarginLeft, height, axisMarginBottom, sharedDomainX, sharedDomainY, data, style, dasharray, weight, opacity*/
          8128294) {
            each_value = ensure_array_like(
              /*data*/
              ctx2[5]
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(g, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
          if (
            /*showHistory*/
            ctx2[12]
          ) {
            if (if_block5) {
              if_block5.p(ctx2, dirty);
              if (dirty[0] & /*showHistory*/
              4096) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block_1$3(ctx2);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(g, if_block5_anchor);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }
          if (
            /*showObservations*/
            ctx2[13]
          ) {
            if (if_block6) {
              if_block6.p(ctx2, dirty);
              if (dirty[0] & /*showObservations*/
              8192) {
                transition_in(if_block6, 1);
              }
            } else {
              if_block6 = create_if_block$4(ctx2);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(g, null);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && g_transform_value !== (g_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$2})`)) {
            attr$6(g, "transform", g_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          transition_in(if_block5);
          transition_in(if_block6);
          current2 = true;
        },
        o(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          transition_out(if_block5);
          transition_out(if_block6);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
            detach(t6);
            detach(svg);
          }
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          if (if_block2)
            if_block2.d();
          if (if_block3)
            if_block3.d();
          if (if_block4)
            if_block4.d();
          destroy_each(each_blocks, detaching);
          if (if_block5)
            if_block5.d();
          if (if_block6)
            if_block6.d();
          mounted = false;
          dispose();
        }
      };
    }
    let dashoffsetMultiplier$1 = 1;
    const marginTop$2 = 30;
    const func$5 = (v) => `Series weight: ${v}px`;
    const func_1$4 = (v) => `Global series opacity: ${v}%`;
    const func_2$4 = (v) => `Series stipled by ${v}px`;
    const func_3$2 = (v) => `Observations weight: ${v}px`;
    const func_4$2 = (v) => `Observations opacity: ${v}%`;
    const func_5$2 = (v) => `History weight: ${v}px`;
    const func_6 = (v) => `Hstory stipled by ${v}px`;
    function instance$8($$self, $$props, $$invalidate) {
      let sharedDomainY;
      let sharedDomainX;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { historyData } = $$props;
      let { observationsData } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { keyword } = $$props;
      let { spec } = $$props;
      let showHistory = true;
      let showObservations = true;
      let observationWeight = 4;
      let observationOpacity = 100;
      let historyWeight = 4;
      let historyDasharray = 10;
      let weight = 0.5;
      let dasharray = 0;
      let opacity2 = 100;
      function checkbox_checked_binding(value2) {
        showHistory = value2;
        $$invalidate(12, showHistory);
      }
      function checkbox_checked_binding_1(value2) {
        showObservations = value2;
        $$invalidate(13, showObservations);
      }
      function slider0_value_binding(value2) {
        weight = value2;
        $$invalidate(18, weight);
      }
      function slider1_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(20, opacity2);
      }
      function slider2_value_binding(value2) {
        dasharray = value2;
        $$invalidate(19, dasharray);
      }
      function slider0_value_binding_1(value2) {
        observationWeight = value2;
        $$invalidate(14, observationWeight);
      }
      function slider1_value_binding_1(value2) {
        observationOpacity = value2;
        $$invalidate(15, observationOpacity);
      }
      function slider0_value_binding_2(value2) {
        historyWeight = value2;
        $$invalidate(16, historyWeight);
      }
      function slider1_value_binding_2(value2) {
        historyDasharray = value2;
        $$invalidate(17, historyDasharray);
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(3, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(4, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(5, data2 = $$props2.data);
        if ("historyData" in $$props2)
          $$invalidate(6, historyData = $$props2.historyData);
        if ("observationsData" in $$props2)
          $$invalidate(7, observationsData = $$props2.observationsData);
        if ("style" in $$props2)
          $$invalidate(8, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(9, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(10, height2 = $$props2.height);
        if ("keyword" in $$props2)
          $$invalidate(11, keyword = $$props2.keyword);
        if ("spec" in $$props2)
          $$invalidate(23, spec = $$props2.spec);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*data, showHistory, historyData*/
        4192) {
          $$invalidate(22, sharedDomainY = () => {
            const yDomains = data2.map((c2) => c2.domainY);
            if (showHistory) {
              yDomains.push(...historyData.data.map((hd) => hd.domainY));
            }
            return [
              Math.min(...yDomains.map((d) => d[0])),
              Math.max(...yDomains.map((d) => d[1]))
            ];
          });
        }
        if ($$self.$$.dirty[0] & /*data, showHistory, historyData*/
        4192) {
          $$invalidate(21, sharedDomainX = () => {
            const xDomains = data2.map((c2) => c2.domainX);
            if (showHistory) {
              xDomains.push(...historyData.data.map((hd) => hd.domainX));
            }
            return [
              Math.min(...xDomains.map((d) => d[0])),
              Math.max(...xDomains.map((d) => d[1]))
            ];
          });
        }
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        data2,
        historyData,
        observationsData,
        style2,
        width2,
        height2,
        keyword,
        showHistory,
        showObservations,
        observationWeight,
        observationOpacity,
        historyWeight,
        historyDasharray,
        weight,
        dasharray,
        opacity2,
        sharedDomainX,
        sharedDomainY,
        spec,
        checkbox_checked_binding,
        checkbox_checked_binding_1,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding,
        slider0_value_binding_1,
        slider1_value_binding_1,
        slider0_value_binding_2,
        slider1_value_binding_2
      ];
    }
    class SummaryLines extends SvelteComponent {
      constructor(options) {
        super();
        init$2(
          this,
          options,
          instance$8,
          create_fragment$9,
          safe_not_equal,
          {
            localControlsDivSelector: 0,
            axisMarginLeft: 1,
            axisMarginBottom: 2,
            showAxisX: 3,
            showAxisY: 4,
            data: 5,
            historyData: 6,
            observationsData: 7,
            style: 8,
            width: 9,
            height: 10,
            keyword: 11,
            spec: 23
          },
          null,
          [-1, -1]
        );
      }
    }
    function create_fragment$8(ctx) {
      let div0;
      let slider0;
      let updating_value;
      let t02;
      let slider1;
      let updating_value_1;
      let t12;
      let combobox;
      let updating_value_2;
      let portal_action;
      let t22;
      let div1;
      let current2;
      let mounted;
      let dispose;
      function slider0_value_binding(value2) {
        ctx[14](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 4,
        step: 0.5,
        valueDisplay: func$4
      };
      if (
        /*thickness*/
        ctx[4] !== void 0
      ) {
        slider0_props.value = /*thickness*/
        ctx[4];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[15](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_1$3
      };
      if (
        /*opacity*/
        ctx[2] !== void 0
      ) {
        slider1_props.value = /*opacity*/
        ctx[2];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function combobox_value_binding(value2) {
        ctx[16](value2);
      }
      let combobox_props = {
        options: [
          { label: "solid", value: "solid" },
          { label: "dash dot", value: "dashdot" },
          { label: "dash", value: "dash" }
        ]
      };
      if (
        /*dash*/
        ctx[3] !== void 0
      ) {
        combobox_props.value = /*dash*/
        ctx[3];
      }
      combobox = new Combobox({ props: combobox_props });
      binding_callbacks.push(() => bind$2(combobox, "value", combobox_value_binding));
      return {
        c() {
          div0 = element$2("div");
          create_component(slider0.$$.fragment);
          t02 = space();
          create_component(slider1.$$.fragment);
          t12 = space();
          create_component(combobox.$$.fragment);
          t22 = space();
          div1 = element$2("div");
          attr$6(div1, "class", "w-full h-full");
        },
        m(target2, anchor2) {
          insert$2(target2, div0, anchor2);
          mount_component(slider0, div0, null);
          append$2(div0, t02);
          mount_component(slider1, div0, null);
          append$2(div0, t12);
          mount_component(combobox, div0, null);
          insert$2(target2, t22, anchor2);
          insert$2(target2, div1, anchor2);
          ctx[17](div1);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div0,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          const slider0_changes = {};
          if (!updating_value && dirty & /*thickness*/
          16) {
            updating_value = true;
            slider0_changes.value = /*thickness*/
            ctx2[4];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty & /*opacity*/
          4) {
            updating_value_1 = true;
            slider1_changes.value = /*opacity*/
            ctx2[2];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
          const combobox_changes = {};
          if (!updating_value_2 && dirty & /*dash*/
          8) {
            updating_value_2 = true;
            combobox_changes.value = /*dash*/
            ctx2[3];
            add_flush_callback(() => updating_value_2 = false);
          }
          combobox.$set(combobox_changes);
          if (portal_action && is_function(portal_action.update) && dirty & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(combobox.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(combobox.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div0);
            detach(t22);
            detach(div1);
          }
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(combobox);
          ctx[17](null);
          mounted = false;
          dispose();
        }
      };
    }
    const func$4 = (v) => `Line thickness: ${v}px`;
    const func_1$3 = (v) => `Global line opacity: ${v}%`;
    function instance$7($$self, $$props, $$invalidate) {
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { spec } = $$props;
      let target2 = null;
      let opacity2 = 100;
      let dash = "solid";
      let thickness = 0.5;
      function slider0_value_binding(value2) {
        thickness = value2;
        $$invalidate(4, thickness);
      }
      function slider1_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(2, opacity2);
      }
      function combobox_value_binding(value2) {
        dash = value2;
        $$invalidate(3, dash);
      }
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          target2 = $$value;
          $$invalidate(1, target2);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(5, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(6, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(7, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(8, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(9, data2 = $$props2.data);
        if ("style" in $$props2)
          $$invalidate(10, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(11, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(12, height2 = $$props2.height);
        if ("spec" in $$props2)
          $$invalidate(13, spec = $$props2.spec);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*target, data, style, thickness, dash, opacity*/
        1566) {
          {
            if (target2) {
              const traces = data2.map((d) => ({
                x: d.points.map((p) => p[0]),
                y: d.points.map((p) => p[1]),
                type: "scatter",
                line: {
                  color: style2[d.ensemble].stroke,
                  width: thickness,
                  dash
                },
                opacity: (style2[d.ensemble].opacity || 1) * (opacity2 / 100)
              }));
              Plotly.newPlot(target2, traces);
            }
          }
        }
      };
      return [
        localControlsDivSelector,
        target2,
        opacity2,
        dash,
        thickness,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        data2,
        style2,
        width2,
        height2,
        spec,
        slider0_value_binding,
        slider1_value_binding,
        combobox_value_binding,
        div1_binding
      ];
    }
    class SummaryLinesPlotly extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$7, create_fragment$8, safe_not_equal, {
          localControlsDivSelector: 0,
          axisMarginLeft: 5,
          axisMarginBottom: 6,
          showAxisX: 7,
          showAxisY: 8,
          data: 9,
          style: 10,
          width: 11,
          height: 12,
          spec: 13
        });
      }
    }
    function get_each_context$3(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list2[i];
      child_ctx[20] = i;
      return child_ctx;
    }
    function get_each_context_1(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[21] = list2[i];
      child_ctx[20] = i;
      return child_ctx;
    }
    function create_if_block$3(ctx) {
      let singleaxislayer;
      let current2;
      singleaxislayer = new SingleAxisLayer({
        props: {
          width: (
            /*data*/
            ctx[9].axis.width
          ),
          height: (
            /*data*/
            ctx[9].axis.height
          ),
          domainX: (
            /*computeSharedDomainX*/
            ctx[10]()
          ),
          domainY: (
            /*computeSharedDomainY*/
            ctx[11]()
          ),
          formatY: ".2f"
        }
      });
      return {
        c() {
          create_component(singleaxislayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(singleaxislayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const singleaxislayer_changes = {};
          if (dirty & /*sections*/
          32768)
            singleaxislayer_changes.width = /*data*/
            ctx2[9].axis.width;
          if (dirty & /*sections*/
          32768)
            singleaxislayer_changes.height = /*data*/
            ctx2[9].axis.height;
          if (dirty & /*computeSharedDomainX*/
          1024)
            singleaxislayer_changes.domainX = /*computeSharedDomainX*/
            ctx2[10]();
          if (dirty & /*computeSharedDomainY*/
          2048)
            singleaxislayer_changes.domainY = /*computeSharedDomainY*/
            ctx2[11]();
          singleaxislayer.$set(singleaxislayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(singleaxislayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(singleaxislayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(singleaxislayer, detaching);
        }
      };
    }
    function create_each_block_1(ctx) {
      let path2;
      let path_d_value;
      let path_levels = [
        {
          d: path_d_value = /*chart*/
          ctx[21].lineData
        },
        {
          ...Object.values(
            /*style*/
            ctx[5]
          )[0],
          "stroke-dasharray": (
            /*dasharray*/
            ctx[13].toString()
          ),
          "stroke-width": (
            /*thickness*/
            ctx[14].toString()
          ),
          fill: "none",
          opacity: (
            /*opacity*/
            ctx[12] / 100
          )
        }
      ];
      let path_data = {};
      for (let i = 0; i < path_levels.length; i += 1) {
        path_data = assign(path_data, path_levels[i]);
      }
      return {
        c() {
          path2 = svg_element("path");
          set_svg_attributes(path2, path_data);
        },
        m(target2, anchor2) {
          insert$2(target2, path2, anchor2);
        },
        p(ctx2, dirty) {
          set_svg_attributes(path2, path_data = get_spread_update(path_levels, [
            dirty & /*sections*/
            32768 && path_d_value !== (path_d_value = /*chart*/
            ctx2[21].lineData) && { d: path_d_value },
            dirty & /*style, dasharray, thickness, opacity*/
            28704 && {
              ...Object.values(
                /*style*/
                ctx2[5]
              )[0],
              "stroke-dasharray": (
                /*dasharray*/
                ctx2[13].toString()
              ),
              "stroke-width": (
                /*thickness*/
                ctx2[14].toString()
              ),
              fill: "none",
              opacity: (
                /*opacity*/
                ctx2[12] / 100
              )
            }
          ]));
        },
        d(detaching) {
          if (detaching) {
            detach(path2);
          }
        }
      };
    }
    function create_each_block$3(ctx) {
      let g2;
      let g1;
      let g0;
      let text_1;
      let t_value = (
        /*data*/
        ctx[9].axis.label + ""
      );
      let t4;
      let g0_transform_value;
      let g1_transform_value;
      let g2_transform_value;
      let current2;
      let if_block = (
        /*showAxisX*/
        (ctx[3] || /*showAxisY*/
        ctx[4]) && create_if_block$3(ctx)
      );
      let each_value_1 = ensure_array_like(
        /*data*/
        ctx[9].lines
      );
      let each_blocks = [];
      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }
      return {
        c() {
          g2 = svg_element("g");
          g1 = svg_element("g");
          if (if_block)
            if_block.c();
          g0 = svg_element("g");
          text_1 = svg_element("text");
          t4 = text$3(t_value);
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          attr$6(text_1, "enable-background", "true");
          attr$6(text_1, "dominant-baseline", "alphabetic");
          attr$6(text_1, "text-anchor", "end");
          attr$6(g0, "transform", g0_transform_value = `translate(${/*data*/
          ctx[9].axis.labelX},${/*data*/
          ctx[9].axis.labelY})`);
          attr$6(g1, "transform", g1_transform_value = `translate(${0},${/*data*/
          ctx[9].axis.offsetY})`);
          attr$6(g2, "transform", g2_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},0)`);
        },
        m(target2, anchor2) {
          insert$2(target2, g2, anchor2);
          append$2(g2, g1);
          if (if_block)
            if_block.m(g1, null);
          append$2(g1, g0);
          append$2(g0, text_1);
          append$2(text_1, t4);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g2, null);
            }
          }
          current2 = true;
        },
        p(ctx2, dirty) {
          if (
            /*showAxisX*/
            ctx2[3] || /*showAxisY*/
            ctx2[4]
          ) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & /*showAxisX, showAxisY*/
              24) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$3(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(g1, g0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
          if ((!current2 || dirty & /*sections*/
          32768) && t_value !== (t_value = /*data*/
          ctx2[9].axis.label + ""))
            set_data(t4, t_value);
          if (!current2 || dirty & /*sections*/
          32768 && g0_transform_value !== (g0_transform_value = `translate(${/*data*/
          ctx2[9].axis.labelX},${/*data*/
          ctx2[9].axis.labelY})`)) {
            attr$6(g0, "transform", g0_transform_value);
          }
          if (!current2 || dirty & /*sections*/
          32768 && g1_transform_value !== (g1_transform_value = `translate(${0},${/*data*/
          ctx2[9].axis.offsetY})`)) {
            attr$6(g1, "transform", g1_transform_value);
          }
          if (dirty & /*sections, Object, style, dasharray, thickness, opacity*/
          61472) {
            each_value_1 = ensure_array_like(
              /*data*/
              ctx2[9].lines
            );
            let i;
            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1(ctx2, each_value_1, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(g2, null);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value_1.length;
          }
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && g2_transform_value !== (g2_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},0)`)) {
            attr$6(g2, "transform", g2_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block);
          current2 = true;
        },
        o(local) {
          transition_out(if_block);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(g2);
          }
          if (if_block)
            if_block.d();
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function create_fragment$7(ctx) {
      let div;
      let slider0;
      let updating_value;
      let t02;
      let slider1;
      let updating_value_1;
      let t12;
      let slider2;
      let updating_value_2;
      let portal_action;
      let t22;
      let svg;
      let g;
      let text0;
      let t32;
      let text0_transform_value;
      let text1;
      let t4;
      let text1_transform_value;
      let current2;
      let mounted;
      let dispose;
      function slider0_value_binding(value2) {
        ctx[16](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 40,
        step: 0.5,
        valueDisplay: func$3
      };
      if (
        /*thickness*/
        ctx[14] !== void 0
      ) {
        slider0_props.value = /*thickness*/
        ctx[14];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[17](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_1$2
      };
      if (
        /*opacity*/
        ctx[12] !== void 0
      ) {
        slider1_props.value = /*opacity*/
        ctx[12];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[18](value2);
      }
      let slider2_props = {
        min: 0,
        max: 10,
        step: 1,
        valueDisplay: func_2$3
      };
      if (
        /*dasharray*/
        ctx[13] !== void 0
      ) {
        slider2_props.value = /*dasharray*/
        ctx[13];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      let each_value = ensure_array_like(
        /*sections*/
        ctx[15]()
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      return {
        c() {
          div = element$2("div");
          create_component(slider0.$$.fragment);
          t02 = space();
          create_component(slider1.$$.fragment);
          t12 = space();
          create_component(slider2.$$.fragment);
          t22 = space();
          svg = svg_element("svg");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          g = svg_element("g");
          text0 = svg_element("text");
          t32 = text$3(
            /*keyword*/
            ctx[8]
          );
          text1 = svg_element("text");
          t4 = text$3("Time");
          attr$6(text0, "text-anchor", "middle");
          attr$6(text0, "dominant-baseline", "alphabetic");
          attr$6(text0, "transform", text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop$1 - 10})`);
          attr$6(text1, "text-anchor", "end");
          attr$6(text1, "dominant-baseline", "hanging");
          attr$6(text1, "transform", text1_transform_value = `translate(${/*width*/
          ctx[6]},${/*height*/
          ctx[7] - /*axisMarginBottom*/
          ctx[2] + 10})`);
          attr$6(svg, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          mount_component(slider0, div, null);
          append$2(div, t02);
          mount_component(slider1, div, null);
          append$2(div, t12);
          mount_component(slider2, div, null);
          insert$2(target2, t22, anchor2);
          insert$2(target2, svg, anchor2);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(svg, null);
            }
          }
          append$2(svg, g);
          append$2(g, text0);
          append$2(text0, t32);
          append$2(g, text1);
          append$2(text1, t4);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          const slider0_changes = {};
          if (!updating_value && dirty & /*thickness*/
          16384) {
            updating_value = true;
            slider0_changes.value = /*thickness*/
            ctx2[14];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty & /*opacity*/
          4096) {
            updating_value_1 = true;
            slider1_changes.value = /*opacity*/
            ctx2[12];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_2 && dirty & /*dasharray*/
          8192) {
            updating_value_2 = true;
            slider2_changes.value = /*dasharray*/
            ctx2[13];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider2.$set(slider2_changes);
          if (portal_action && is_function(portal_action.update) && dirty & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
          if (dirty & /*axisMarginLeft, sections, Object, style, dasharray, thickness, opacity, computeSharedDomainX, computeSharedDomainY, showAxisX, showAxisY*/
          64570) {
            each_value = ensure_array_like(
              /*sections*/
              ctx2[15]()
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$3(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$3(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(svg, g);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
          if (!current2 || dirty & /*keyword*/
          256)
            set_data(
              t32,
              /*keyword*/
              ctx2[8]
            );
          if (!current2 || dirty & /*axisMarginLeft*/
          2 && text0_transform_value !== (text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop$1 - 10})`)) {
            attr$6(text0, "transform", text0_transform_value);
          }
          if (!current2 || dirty & /*width, height, axisMarginBottom*/
          196 && text1_transform_value !== (text1_transform_value = `translate(${/*width*/
          ctx2[6]},${/*height*/
          ctx2[7] - /*axisMarginBottom*/
          ctx2[2] + 10})`)) {
            attr$6(text1, "transform", text1_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
            detach(t22);
            detach(svg);
          }
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
    }
    const marginTop$1 = 10;
    const func$3 = (v) => `Line thickness: ${v}px`;
    const func_1$2 = (v) => `Global line opacity: ${v}%`;
    const func_2$3 = (v) => `Stipled by ${v}px`;
    function instance$6($$self, $$props, $$invalidate) {
      let sections;
      let computeSharedDomainY;
      let computeSharedDomainX;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { keyword } = $$props;
      let opacity2 = 100;
      let dasharray = 0;
      let thickness = 0.5;
      function slider0_value_binding(value2) {
        thickness = value2;
        $$invalidate(14, thickness);
      }
      function slider1_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(12, opacity2);
      }
      function slider2_value_binding(value2) {
        dasharray = value2;
        $$invalidate(13, dasharray);
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(3, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(4, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(9, data2 = $$props2.data);
        if ("style" in $$props2)
          $$invalidate(5, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(6, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(7, height2 = $$props2.height);
        if ("keyword" in $$props2)
          $$invalidate(8, keyword = $$props2.keyword);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*data*/
        512) {
          $$invalidate(11, computeSharedDomainY = () => {
            const yDomains = data2.map((c2) => c2.domainY);
            return [
              Math.min(...yDomains.map((d) => d[0])),
              Math.max(...yDomains.map((d) => d[1]))
            ];
          });
        }
        if ($$self.$$.dirty & /*data*/
        512) {
          $$invalidate(10, computeSharedDomainX = () => {
            const xDomains = data2.map((c2) => c2.domainX);
            return [
              Math.min(...xDomains.map((d) => d[0])),
              Math.max(...xDomains.map((d) => d[1]))
            ];
          });
        }
        if ($$self.$$.dirty & /*data, computeSharedDomainY, computeSharedDomainX, width, axisMarginLeft, height, axisMarginBottom*/
        3782) {
          $$invalidate(15, sections = () => {
            const ensembles = new Set(data2.map((d) => d.ensemble));
            const ensId = data2[0].ensemble;
            const experiment = Object.values(getLoadedExperiments()).find((e3) => ensId in e3.ensembles);
            const sortedEnsembles = experiment.sortedEnsembles().filter((d) => ensembles.has(d.id));
            const sharedDomainY = computeSharedDomainY();
            const sharedDomainX = computeSharedDomainX();
            const scaleX = linear$1().domain(sharedDomainX).range([0, width2 - axisMarginLeft]);
            let sectionMargin = 50;
            const allocatedHeight = height2 - axisMarginBottom - sectionMargin * (sortedEnsembles.length - 1) - marginTop$1;
            let y12 = height2 - axisMarginBottom;
            let sectionHeight = allocatedHeight / sortedEnsembles.length;
            return sortedEnsembles.map((ens, i) => {
              const dataForEnsemble = data2.filter((d) => d.ensemble === ens.id);
              const scaleY2 = linear$1().domain(sharedDomainY).range([y12, y12 - sectionHeight]);
              const lineGenerator = line$2$1().x((d) => scaleX(d[0])).y((d) => scaleY2(d[1]));
              const info2 = {
                lines: dataForEnsemble.map((d) => {
                  return { lineData: lineGenerator(d.points), ...d };
                }),
                axis: {
                  offsetY: y12 - sectionHeight,
                  width: width2 - axisMarginLeft,
                  height: sectionHeight,
                  domainX: sharedDomainX,
                  domainY: sharedDomainY,
                  label: `Iter ${i}`,
                  labelX: -8,
                  labelY: sectionHeight + 20
                }
              };
              y12 -= sectionHeight + sectionMargin;
              return info2;
            });
          });
        }
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        style2,
        width2,
        height2,
        keyword,
        data2,
        computeSharedDomainX,
        computeSharedDomainY,
        opacity2,
        dasharray,
        thickness,
        sections,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding
      ];
    }
    class SummaryLinesStacked extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$6, create_fragment$7, safe_not_equal, {
          localControlsDivSelector: 0,
          axisMarginLeft: 1,
          axisMarginBottom: 2,
          showAxisX: 3,
          showAxisY: 4,
          data: 9,
          style: 5,
          width: 6,
          height: 7,
          keyword: 8
        });
      }
    }
    function get_each_context$2(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[12] = list2[i];
      return child_ctx;
    }
    function create_each_block$2(ctx) {
      let g;
      let line0;
      let line0_x__value;
      let line0_x__value_1;
      let line0_y__value;
      let line0_y__value_1;
      let line0_stroke_width_value;
      let line1;
      let line1_x__value;
      let line1_x__value_1;
      let line1_y__value;
      let line1_y__value_1;
      let line1_stroke_width_value;
      let circle2;
      let circle_cx_value;
      let circle_cy_value;
      let circle_r_value;
      let line2;
      let line2_x__value;
      let line2_x__value_1;
      let line2_y__value;
      let line2_y__value_1;
      let line2_stroke_width_value;
      return {
        c() {
          g = svg_element("g");
          line0 = svg_element("line");
          line1 = svg_element("line");
          circle2 = svg_element("circle");
          line2 = svg_element("line");
          attr$6(line0, "stroke-linecap", "round");
          attr$6(line0, "x1", line0_x__value = /*s*/
          ctx[12].cx - /*weight*/
          ctx[1]);
          attr$6(line0, "x2", line0_x__value_1 = /*s*/
          ctx[12].cx + /*weight*/
          ctx[1]);
          attr$6(line0, "y1", line0_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymax
          ));
          attr$6(line0, "y2", line0_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymax
          ));
          attr$6(line0, "stroke-width", line0_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line0,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(line1, "x1", line1_x__value = /*s*/
          ctx[12].cx);
          attr$6(line1, "x2", line1_x__value_1 = /*s*/
          ctx[12].cx);
          attr$6(line1, "y1", line1_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymax
          ));
          attr$6(line1, "y2", line1_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymin
          ));
          attr$6(line1, "stroke-width", line1_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line1,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(circle2, "cx", circle_cx_value = /*s*/
          ctx[12].cx);
          attr$6(circle2, "cy", circle_cy_value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].cy
          ));
          attr$6(circle2, "r", circle_r_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            circle2,
            "fill",
            /*color*/
            ctx[0]
          );
          attr$6(line2, "stroke-linecap", "round");
          attr$6(line2, "x1", line2_x__value = /*s*/
          ctx[12].cx - /*weight*/
          ctx[1]);
          attr$6(line2, "x2", line2_x__value_1 = /*s*/
          ctx[12].cx + /*weight*/
          ctx[1]);
          attr$6(line2, "y1", line2_y__value = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymin
          ));
          attr$6(line2, "y2", line2_y__value_1 = /*clampY*/
          ctx[4](
            /*s*/
            ctx[12].ymin
          ));
          attr$6(line2, "stroke-width", line2_stroke_width_value = /*weight*/
          ctx[1] / 2);
          attr$6(
            line2,
            "stroke",
            /*color*/
            ctx[0]
          );
          attr$6(
            g,
            "opacity",
            /*opacity*/
            ctx[2]
          );
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          append$2(g, line0);
          append$2(g, line1);
          append$2(g, circle2);
          append$2(g, line2);
        },
        p(ctx2, dirty) {
          if (dirty & /*observationsShapes, weight*/
          10 && line0_x__value !== (line0_x__value = /*s*/
          ctx2[12].cx - /*weight*/
          ctx2[1])) {
            attr$6(line0, "x1", line0_x__value);
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line0_x__value_1 !== (line0_x__value_1 = /*s*/
          ctx2[12].cx + /*weight*/
          ctx2[1])) {
            attr$6(line0, "x2", line0_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line0_y__value !== (line0_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymax
          ))) {
            attr$6(line0, "y1", line0_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line0_y__value_1 !== (line0_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymax
          ))) {
            attr$6(line0, "y2", line0_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line0_stroke_width_value !== (line0_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line0, "stroke-width", line0_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line0,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes*/
          8 && line1_x__value !== (line1_x__value = /*s*/
          ctx2[12].cx)) {
            attr$6(line1, "x1", line1_x__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_x__value_1 !== (line1_x__value_1 = /*s*/
          ctx2[12].cx)) {
            attr$6(line1, "x2", line1_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_y__value !== (line1_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymax
          ))) {
            attr$6(line1, "y1", line1_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line1_y__value_1 !== (line1_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymin
          ))) {
            attr$6(line1, "y2", line1_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line1_stroke_width_value !== (line1_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line1, "stroke-width", line1_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line1,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes*/
          8 && circle_cx_value !== (circle_cx_value = /*s*/
          ctx2[12].cx)) {
            attr$6(circle2, "cx", circle_cx_value);
          }
          if (dirty & /*observationsShapes*/
          8 && circle_cy_value !== (circle_cy_value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].cy
          ))) {
            attr$6(circle2, "cy", circle_cy_value);
          }
          if (dirty & /*weight*/
          2 && circle_r_value !== (circle_r_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(circle2, "r", circle_r_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              circle2,
              "fill",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line2_x__value !== (line2_x__value = /*s*/
          ctx2[12].cx - /*weight*/
          ctx2[1])) {
            attr$6(line2, "x1", line2_x__value);
          }
          if (dirty & /*observationsShapes, weight*/
          10 && line2_x__value_1 !== (line2_x__value_1 = /*s*/
          ctx2[12].cx + /*weight*/
          ctx2[1])) {
            attr$6(line2, "x2", line2_x__value_1);
          }
          if (dirty & /*observationsShapes*/
          8 && line2_y__value !== (line2_y__value = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymin
          ))) {
            attr$6(line2, "y1", line2_y__value);
          }
          if (dirty & /*observationsShapes*/
          8 && line2_y__value_1 !== (line2_y__value_1 = /*clampY*/
          ctx2[4](
            /*s*/
            ctx2[12].ymin
          ))) {
            attr$6(line2, "y2", line2_y__value_1);
          }
          if (dirty & /*weight*/
          2 && line2_stroke_width_value !== (line2_stroke_width_value = /*weight*/
          ctx2[1] / 2)) {
            attr$6(line2, "stroke-width", line2_stroke_width_value);
          }
          if (dirty & /*color*/
          1) {
            attr$6(
              line2,
              "stroke",
              /*color*/
              ctx2[0]
            );
          }
          if (dirty & /*opacity*/
          4) {
            attr$6(
              g,
              "opacity",
              /*opacity*/
              ctx2[2]
            );
          }
        },
        d(detaching) {
          if (detaching) {
            detach(g);
          }
        }
      };
    }
    function create_fragment$6(ctx) {
      let g;
      let each_value = ensure_array_like(
        /*observationsShapes*/
        ctx[3]()
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
      }
      return {
        c() {
          g = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
        },
        m(target2, anchor2) {
          insert$2(target2, g, anchor2);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g, null);
            }
          }
        },
        p(ctx2, [dirty]) {
          if (dirty & /*opacity, observationsShapes, weight, clampY, color*/
          31) {
            each_value = ensure_array_like(
              /*observationsShapes*/
              ctx2[3]()
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$2(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(g, null);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(g);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function instance$5($$self, $$props, $$invalidate) {
      let observationsShapes;
      let { observationsData } = $$props;
      let { domainX } = $$props;
      let { domainY } = $$props;
      let { x0: x02 } = $$props;
      let { x1: x12 } = $$props;
      let { y0: y02 } = $$props;
      let { y1: y12 } = $$props;
      let { color: color2 } = $$props;
      let { weight } = $$props;
      let { opacity: opacity2 } = $$props;
      const clampY = (y2) => Math.max(Math.min(y2, y12), y02);
      $$self.$$set = ($$props2) => {
        if ("observationsData" in $$props2)
          $$invalidate(5, observationsData = $$props2.observationsData);
        if ("domainX" in $$props2)
          $$invalidate(6, domainX = $$props2.domainX);
        if ("domainY" in $$props2)
          $$invalidate(7, domainY = $$props2.domainY);
        if ("x0" in $$props2)
          $$invalidate(8, x02 = $$props2.x0);
        if ("x1" in $$props2)
          $$invalidate(9, x12 = $$props2.x1);
        if ("y0" in $$props2)
          $$invalidate(10, y02 = $$props2.y0);
        if ("y1" in $$props2)
          $$invalidate(11, y12 = $$props2.y1);
        if ("color" in $$props2)
          $$invalidate(0, color2 = $$props2.color);
        if ("weight" in $$props2)
          $$invalidate(1, weight = $$props2.weight);
        if ("opacity" in $$props2)
          $$invalidate(2, opacity2 = $$props2.opacity);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*domainX, x0, x1, domainY, y1, y0, observationsData*/
        4064) {
          $$invalidate(3, observationsShapes = () => {
            const scaleX = linear$1().domain(domainX).range([x02, x12]);
            const scaleY2 = linear$1().domain(domainY).range([y12, y02]);
            return observationsData.map((o) => ({
              cx: scaleX(o.index),
              cy: scaleY2(o.observations),
              ymin: scaleY2(o.observations - o.std),
              ymax: scaleY2(o.observations + o.std)
            }));
          });
        }
      };
      return [
        color2,
        weight,
        opacity2,
        observationsShapes,
        clampY,
        observationsData,
        domainX,
        domainY,
        x02,
        x12,
        y02,
        y12
      ];
    }
    class GeneralObservationsLayer extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$5, create_fragment$6, safe_not_equal, {
          observationsData: 5,
          domainX: 6,
          domainY: 7,
          x0: 8,
          x1: 9,
          y0: 10,
          y1: 11,
          color: 0,
          weight: 1,
          opacity: 2
        });
      }
    }
    function get_each_context$1(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[31] = list2[i];
      child_ctx[33] = i;
      return child_ctx;
    }
    function create_else_block$1(ctx) {
      let p;
      return {
        c() {
          p = element$2("p");
          p.textContent = "No observations found";
          attr$6(p, "class", "text-gray-500 w-full text-right");
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
        },
        p: noop$6,
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }
    function create_if_block_3$1(ctx) {
      let checkbox2;
      let updating_checked;
      let current2;
      function checkbox_checked_binding(value2) {
        ctx[25](value2);
      }
      let checkbox_props = {
        label: `Show ${/*observationsForSelectedReportSteps*/
        ctx[17].length} observations?`
      };
      if (
        /*showObservations*/
        ctx[11] !== void 0
      ) {
        checkbox_props.checked = /*showObservations*/
        ctx[11];
      }
      checkbox2 = new Checkbox({ props: checkbox_props });
      binding_callbacks.push(() => bind$2(checkbox2, "checked", checkbox_checked_binding));
      return {
        c() {
          create_component(checkbox2.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(checkbox2, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const checkbox_changes = {};
          if (dirty[0] & /*observationsForSelectedReportSteps*/
          131072)
            checkbox_changes.label = `Show ${/*observationsForSelectedReportSteps*/
            ctx2[17].length} observations?`;
          if (!updating_checked && dirty[0] & /*showObservations*/
          2048) {
            updating_checked = true;
            checkbox_changes.checked = /*showObservations*/
            ctx2[11];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox2.$set(checkbox_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(checkbox2.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(checkbox2.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(checkbox2, detaching);
        }
      };
    }
    function create_if_block_2$1(ctx) {
      let slider0;
      let updating_value;
      let t4;
      let slider1;
      let updating_value_1;
      let current2;
      function slider0_value_binding_1(value2) {
        ctx[29](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 20,
        step: 0.5,
        valueDisplay: func_3$1
      };
      if (
        /*observationWeight*/
        ctx[12] !== void 0
      ) {
        slider0_props.value = /*observationWeight*/
        ctx[12];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding_1));
      function slider1_value_binding_1(value2) {
        ctx[30](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_4$1
      };
      if (
        /*observationOpacity*/
        ctx[13] !== void 0
      ) {
        slider1_props.value = /*observationOpacity*/
        ctx[13];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding_1));
      return {
        c() {
          create_component(slider0.$$.fragment);
          t4 = space();
          create_component(slider1.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(slider0, target2, anchor2);
          insert$2(target2, t4, anchor2);
          mount_component(slider1, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const slider0_changes = {};
          if (!updating_value && dirty[0] & /*observationWeight*/
          4096) {
            updating_value = true;
            slider0_changes.value = /*observationWeight*/
            ctx2[12];
            add_flush_callback(() => updating_value = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_1 && dirty[0] & /*observationOpacity*/
          8192) {
            updating_value_1 = true;
            slider1_changes.value = /*observationOpacity*/
            ctx2[13];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider1.$set(slider1_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
          destroy_component(slider0, detaching);
          destroy_component(slider1, detaching);
        }
      };
    }
    function create_if_block_1$2(ctx) {
      let g0;
      let singleaxislayer;
      let g0_transform_value;
      let g1;
      let text0;
      let t02;
      let text0_transform_value;
      let text1;
      let t12;
      let text1_transform_value;
      let current2;
      singleaxislayer = new SingleAxisLayer({
        props: {
          width: (
            /*width*/
            ctx[7] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[8] - /*axisMarginBottom*/
            ctx[2] - marginTop
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[19]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[20]()
          ),
          formatY: ".2f"
        }
      });
      return {
        c() {
          g0 = svg_element("g");
          create_component(singleaxislayer.$$.fragment);
          g1 = svg_element("g");
          text0 = svg_element("text");
          t02 = text$3(
            /*keyword*/
            ctx[9]
          );
          text1 = svg_element("text");
          t12 = text$3("Index");
          attr$6(g0, "transform", g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop})`);
          attr$6(text0, "text-anchor", "middle");
          attr$6(text0, "dominant-baseline", "alphabetic");
          attr$6(text0, "transform", text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop - 10})`);
          attr$6(text1, "text-anchor", "end");
          attr$6(text1, "dominant-baseline", "hanging");
          attr$6(text1, "transform", text1_transform_value = `translate(${/*width*/
          ctx[7]},${/*height*/
          ctx[8] - /*axisMarginBottom*/
          ctx[2] + 20})`);
        },
        m(target2, anchor2) {
          insert$2(target2, g0, anchor2);
          mount_component(singleaxislayer, g0, null);
          insert$2(target2, g1, anchor2);
          append$2(g1, text0);
          append$2(text0, t02);
          append$2(g1, text1);
          append$2(text1, t12);
          current2 = true;
        },
        p(ctx2, dirty) {
          const singleaxislayer_changes = {};
          if (dirty[0] & /*width, axisMarginLeft*/
          130)
            singleaxislayer_changes.width = /*width*/
            ctx2[7] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          260)
            singleaxislayer_changes.height = /*height*/
            ctx2[8] - /*axisMarginBottom*/
            ctx2[2] - marginTop;
          if (dirty[0] & /*sharedDomainX*/
          524288)
            singleaxislayer_changes.domainX = /*sharedDomainX*/
            ctx2[19]();
          if (dirty[0] & /*sharedDomainY*/
          1048576)
            singleaxislayer_changes.domainY = /*sharedDomainY*/
            ctx2[20]();
          singleaxislayer.$set(singleaxislayer_changes);
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && g0_transform_value !== (g0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop})`)) {
            attr$6(g0, "transform", g0_transform_value);
          }
          if (!current2 || dirty[0] & /*keyword*/
          512)
            set_data(
              t02,
              /*keyword*/
              ctx2[9]
            );
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && text0_transform_value !== (text0_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop - 10})`)) {
            attr$6(text0, "transform", text0_transform_value);
          }
          if (!current2 || dirty[0] & /*width, height, axisMarginBottom*/
          388 && text1_transform_value !== (text1_transform_value = `translate(${/*width*/
          ctx2[7]},${/*height*/
          ctx2[8] - /*axisMarginBottom*/
          ctx2[2] + 20})`)) {
            attr$6(text1, "transform", text1_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(singleaxislayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(singleaxislayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(g0);
            detach(g1);
          }
          destroy_component(singleaxislayer);
        }
      };
    }
    function create_each_block$1(ctx) {
      let linelayer;
      let current2;
      linelayer = new LineLayer({
        props: {
          width: (
            /*width*/
            ctx[7] - /*axisMarginLeft*/
            ctx[1]
          ),
          height: (
            /*height*/
            ctx[8] - /*axisMarginBottom*/
            ctx[2] - marginTop
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[19]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[20]()
          ),
          points: (
            /*chart*/
            ctx[31].values.map(func_5$1)
          ),
          realization: (
            /*chart*/
            ctx[31].realization
          ),
          style: {
            .../*style*/
            ctx[6][
              /*chart*/
              ctx[31].ensemble_id
            ],
            "stroke-linecap": "round",
            "stroke-dashoffset": `${/*i*/
            ctx[33] * dashoffsetMultiplier}px`,
            "stroke-dasharray": (
              /*dasharray*/
              ctx[15].toString()
            ),
            "stroke-width": (
              /*weight*/
              ctx[14].toString()
            ),
            opacity: (
              /*opacity*/
              (ctx[16] / 100).toString()
            )
          }
        }
      });
      return {
        c() {
          create_component(linelayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(linelayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const linelayer_changes = {};
          if (dirty[0] & /*width, axisMarginLeft*/
          130)
            linelayer_changes.width = /*width*/
            ctx2[7] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          260)
            linelayer_changes.height = /*height*/
            ctx2[8] - /*axisMarginBottom*/
            ctx2[2] - marginTop;
          if (dirty[0] & /*sharedDomainX*/
          524288)
            linelayer_changes.domainX = /*sharedDomainX*/
            ctx2[19]();
          if (dirty[0] & /*sharedDomainY*/
          1048576)
            linelayer_changes.domainY = /*sharedDomainY*/
            ctx2[20]();
          if (dirty[0] & /*dataForSelectedReportSteps*/
          262144)
            linelayer_changes.points = /*chart*/
            ctx2[31].values.map(func_5$1);
          if (dirty[0] & /*dataForSelectedReportSteps*/
          262144)
            linelayer_changes.realization = /*chart*/
            ctx2[31].realization;
          if (dirty[0] & /*style, dataForSelectedReportSteps, dasharray, weight, opacity*/
          376896)
            linelayer_changes.style = {
              .../*style*/
              ctx2[6][
                /*chart*/
                ctx2[31].ensemble_id
              ],
              "stroke-linecap": "round",
              "stroke-dashoffset": `${/*i*/
              ctx2[33] * dashoffsetMultiplier}px`,
              "stroke-dasharray": (
                /*dasharray*/
                ctx2[15].toString()
              ),
              "stroke-width": (
                /*weight*/
                ctx2[14].toString()
              ),
              opacity: (
                /*opacity*/
                (ctx2[16] / 100).toString()
              )
            };
          linelayer.$set(linelayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(linelayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(linelayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(linelayer, detaching);
        }
      };
    }
    function create_if_block$2(ctx) {
      let generalobservationslayer;
      let current2;
      generalobservationslayer = new GeneralObservationsLayer({
        props: {
          observationsData: (
            /*observationsForSelectedReportSteps*/
            ctx[17]
          ),
          domainX: (
            /*sharedDomainX*/
            ctx[19]()
          ),
          domainY: (
            /*sharedDomainY*/
            ctx[20]()
          ),
          x0: 0,
          x1: (
            /*width*/
            ctx[7] - /*axisMarginLeft*/
            ctx[1]
          ),
          y0: 0,
          y1: (
            /*height*/
            ctx[8] - /*axisMarginBottom*/
            ctx[2] - marginTop
          ),
          color: (
            /*style*/
            ctx[6].annotationColors[1]
          ),
          opacity: (
            /*observationOpacity*/
            ctx[13] / 100
          ),
          weight: (
            /*observationWeight*/
            ctx[12]
          )
        }
      });
      return {
        c() {
          create_component(generalobservationslayer.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(generalobservationslayer, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const generalobservationslayer_changes = {};
          if (dirty[0] & /*observationsForSelectedReportSteps*/
          131072)
            generalobservationslayer_changes.observationsData = /*observationsForSelectedReportSteps*/
            ctx2[17];
          if (dirty[0] & /*sharedDomainX*/
          524288)
            generalobservationslayer_changes.domainX = /*sharedDomainX*/
            ctx2[19]();
          if (dirty[0] & /*sharedDomainY*/
          1048576)
            generalobservationslayer_changes.domainY = /*sharedDomainY*/
            ctx2[20]();
          if (dirty[0] & /*width, axisMarginLeft*/
          130)
            generalobservationslayer_changes.x1 = /*width*/
            ctx2[7] - /*axisMarginLeft*/
            ctx2[1];
          if (dirty[0] & /*height, axisMarginBottom*/
          260)
            generalobservationslayer_changes.y1 = /*height*/
            ctx2[8] - /*axisMarginBottom*/
            ctx2[2] - marginTop;
          if (dirty[0] & /*style*/
          64)
            generalobservationslayer_changes.color = /*style*/
            ctx2[6].annotationColors[1];
          if (dirty[0] & /*observationOpacity*/
          8192)
            generalobservationslayer_changes.opacity = /*observationOpacity*/
            ctx2[13] / 100;
          if (dirty[0] & /*observationWeight*/
          4096)
            generalobservationslayer_changes.weight = /*observationWeight*/
            ctx2[12];
          generalobservationslayer.$set(generalobservationslayer_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(generalobservationslayer.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(generalobservationslayer.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(generalobservationslayer, detaching);
        }
      };
    }
    function create_fragment$5(ctx) {
      let div;
      let combobox;
      let updating_value;
      let t02;
      let br2;
      let t12;
      let current_block_type_index;
      let if_block0;
      let t22;
      let slider0;
      let updating_value_1;
      let t32;
      let slider1;
      let updating_value_2;
      let t4;
      let slider2;
      let updating_value_3;
      let t5;
      let portal_action;
      let t6;
      let svg;
      let g;
      let each_1_anchor;
      let g_transform_value;
      let current2;
      let mounted;
      let dispose;
      function combobox_value_binding(value2) {
        ctx[23](value2);
      }
      let combobox_props = {
        label: "Report steps",
        placeholder: "Select report steps",
        options: (
          /*availableReportSteps*/
          ctx[21]()
        ),
        multiselect: true,
        maxChipContainerWidth: "300px"
      };
      if (
        /*activeReportSteps*/
        ctx[10] !== void 0
      ) {
        combobox_props.value = /*activeReportSteps*/
        ctx[10];
      }
      combobox = new Combobox({ props: combobox_props });
      binding_callbacks.push(() => bind$2(combobox, "value", combobox_value_binding));
      combobox.$on(
        "change",
        /*change_handler*/
        ctx[24]
      );
      const if_block_creators = [create_if_block_3$1, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (!!/*observationsData*/
        ctx2[5] && /*observationsData*/
        ctx2[5].length > 0)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      function slider0_value_binding(value2) {
        ctx[26](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 30,
        step: 0.5,
        valueDisplay: func$2
      };
      if (
        /*weight*/
        ctx[14] !== void 0
      ) {
        slider0_props.value = /*weight*/
        ctx[14];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[27](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_1$1
      };
      if (
        /*opacity*/
        ctx[16] !== void 0
      ) {
        slider1_props.value = /*opacity*/
        ctx[16];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[28](value2);
      }
      let slider2_props = {
        min: 0,
        max: 10,
        step: 1,
        valueDisplay: func_2$2
      };
      if (
        /*dasharray*/
        ctx[15] !== void 0
      ) {
        slider2_props.value = /*dasharray*/
        ctx[15];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      let if_block1 = (
        /*showObservations*/
        ctx[11] && create_if_block_2$1(ctx)
      );
      let if_block2 = (
        /*showAxisX*/
        (ctx[3] || /*showAxisY*/
        ctx[4]) && create_if_block_1$2(ctx)
      );
      let each_value = ensure_array_like(
        /*dataForSelectedReportSteps*/
        ctx[18]
      );
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      let if_block3 = (
        /*showObservations*/
        ctx[11] && create_if_block$2(ctx)
      );
      return {
        c() {
          div = element$2("div");
          create_component(combobox.$$.fragment);
          t02 = space();
          br2 = element$2("br");
          t12 = space();
          if_block0.c();
          t22 = space();
          create_component(slider0.$$.fragment);
          t32 = space();
          create_component(slider1.$$.fragment);
          t4 = space();
          create_component(slider2.$$.fragment);
          t5 = space();
          if (if_block1)
            if_block1.c();
          t6 = space();
          svg = svg_element("svg");
          if (if_block2)
            if_block2.c();
          g = svg_element("g");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty$1();
          if (if_block3)
            if_block3.c();
          attr$6(g, "transform", g_transform_value = `translate(${/*axisMarginLeft*/
          ctx[1]},${marginTop})`);
          attr$6(svg, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          mount_component(combobox, div, null);
          append$2(div, t02);
          append$2(div, br2);
          append$2(div, t12);
          if_blocks[current_block_type_index].m(div, null);
          append$2(div, t22);
          mount_component(slider0, div, null);
          append$2(div, t32);
          mount_component(slider1, div, null);
          append$2(div, t4);
          mount_component(slider2, div, null);
          append$2(div, t5);
          if (if_block1)
            if_block1.m(div, null);
          insert$2(target2, t6, anchor2);
          insert$2(target2, svg, anchor2);
          if (if_block2)
            if_block2.m(svg, null);
          append$2(svg, g);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(g, null);
            }
          }
          append$2(g, each_1_anchor);
          if (if_block3)
            if_block3.m(g, null);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          const combobox_changes = {};
          if (!updating_value && dirty[0] & /*activeReportSteps*/
          1024) {
            updating_value = true;
            combobox_changes.value = /*activeReportSteps*/
            ctx2[10];
            add_flush_callback(() => updating_value = false);
          }
          combobox.$set(combobox_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];
            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block0.c();
            } else {
              if_block0.p(ctx2, dirty);
            }
            transition_in(if_block0, 1);
            if_block0.m(div, t22);
          }
          const slider0_changes = {};
          if (!updating_value_1 && dirty[0] & /*weight*/
          16384) {
            updating_value_1 = true;
            slider0_changes.value = /*weight*/
            ctx2[14];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_2 && dirty[0] & /*opacity*/
          65536) {
            updating_value_2 = true;
            slider1_changes.value = /*opacity*/
            ctx2[16];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_3 && dirty[0] & /*dasharray*/
          32768) {
            updating_value_3 = true;
            slider2_changes.value = /*dasharray*/
            ctx2[15];
            add_flush_callback(() => updating_value_3 = false);
          }
          slider2.$set(slider2_changes);
          if (
            /*showObservations*/
            ctx2[11]
          ) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & /*showObservations*/
              2048) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$1(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (portal_action && is_function(portal_action.update) && dirty[0] & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
          if (
            /*showAxisX*/
            ctx2[3] || /*showAxisY*/
            ctx2[4]
          ) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & /*showAxisX, showAxisY*/
              24) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$2(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(svg, g);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (dirty[0] & /*width, axisMarginLeft, height, axisMarginBottom, sharedDomainX, sharedDomainY, dataForSelectedReportSteps, style, dasharray, weight, opacity*/
          1950150) {
            each_value = ensure_array_like(
              /*dataForSelectedReportSteps*/
              ctx2[18]
            );
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$1(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$1(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(g, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
          if (
            /*showObservations*/
            ctx2[11]
          ) {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & /*showObservations*/
              2048) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$2(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(g, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if (!current2 || dirty[0] & /*axisMarginLeft*/
          2 && g_transform_value !== (g_transform_value = `translate(${/*axisMarginLeft*/
          ctx2[1]},${marginTop})`)) {
            attr$6(g, "transform", g_transform_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(combobox.$$.fragment, local);
          transition_in(if_block0);
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          transition_in(if_block3);
          current2 = true;
        },
        o(local) {
          transition_out(combobox.$$.fragment, local);
          transition_out(if_block0);
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          transition_out(if_block3);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
            detach(t6);
            detach(svg);
          }
          destroy_component(combobox);
          if_blocks[current_block_type_index].d();
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          if (if_block1)
            if_block1.d();
          if (if_block2)
            if_block2.d();
          destroy_each(each_blocks, detaching);
          if (if_block3)
            if_block3.d();
          mounted = false;
          dispose();
        }
      };
    }
    let dashoffsetMultiplier = 1;
    const marginTop = 30;
    const func$2 = (v) => `Line weight: ${v}px`;
    const func_1$1 = (v) => `Global line opacity: ${v}%`;
    const func_2$2 = (v) => `Series stipled by ${v}px`;
    const func_3$1 = (v) => `Observations weight: ${v}px`;
    const func_4$1 = (v) => `Observations opacity: ${v}%`;
    const func_5$1 = (v, i) => [i, v];
    function instance$4($$self, $$props, $$invalidate) {
      let sharedDomainY;
      let sharedDomainX;
      let dataForSelectedReportSteps;
      let observationsForSelectedReportSteps;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { observationsData } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { keyword } = $$props;
      let showObservations = false;
      let activeReportSteps = [data2[0].report_step.toString()];
      let observationWeight = 4;
      let observationOpacity = 100;
      let weight = 0.5;
      let dasharray = 0;
      let opacity2 = 100;
      function availableReportSteps() {
        const { experiment } = data2[0];
        const exp2 = getLoadedExperiments()[experiment];
        const entry2 = exp2.responses.gen_data.find((gd) => gd.name === keyword);
        const { report_steps } = entry2;
        return report_steps.map((rs) => ({
          label: `${Math.trunc(rs)}`,
          value: Math.trunc(rs).toString()
        }));
      }
      function combobox_value_binding(value2) {
        activeReportSteps = value2;
        $$invalidate(10, activeReportSteps);
      }
      const change_handler = (e3) => {
        activeReportSteps.sort((a2, b2) => +a2 - +b2);
      };
      function checkbox_checked_binding(value2) {
        showObservations = value2;
        $$invalidate(11, showObservations);
      }
      function slider0_value_binding(value2) {
        weight = value2;
        $$invalidate(14, weight);
      }
      function slider1_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(16, opacity2);
      }
      function slider2_value_binding(value2) {
        dasharray = value2;
        $$invalidate(15, dasharray);
      }
      function slider0_value_binding_1(value2) {
        observationWeight = value2;
        $$invalidate(12, observationWeight);
      }
      function slider1_value_binding_1(value2) {
        observationOpacity = value2;
        $$invalidate(13, observationOpacity);
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(3, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(4, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(22, data2 = $$props2.data);
        if ("observationsData" in $$props2)
          $$invalidate(5, observationsData = $$props2.observationsData);
        if ("style" in $$props2)
          $$invalidate(6, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(7, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(8, height2 = $$props2.height);
        if ("keyword" in $$props2)
          $$invalidate(9, keyword = $$props2.keyword);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*data*/
        4194304) {
          $$invalidate(20, sharedDomainY = () => {
            const yMin = Math.min(...data2.map((c2) => c2.domain[0]));
            const yMax = Math.max(...data2.map((c2) => c2.domain[1]));
            return [yMin, yMax];
          });
        }
        if ($$self.$$.dirty[0] & /*data*/
        4194304) {
          $$invalidate(19, sharedDomainX = () => [0, data2[0].values.length - 1]);
        }
        if ($$self.$$.dirty[0] & /*data, activeReportSteps*/
        4195328) {
          $$invalidate(18, dataForSelectedReportSteps = data2.filter((d) => activeReportSteps.includes(d.report_step.toString())));
        }
        if ($$self.$$.dirty[0] & /*observationsData, activeReportSteps*/
        1056) {
          $$invalidate(17, observationsForSelectedReportSteps = observationsData.filter((d) => activeReportSteps.includes(d.report_step.toString())));
        }
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        observationsData,
        style2,
        width2,
        height2,
        keyword,
        activeReportSteps,
        showObservations,
        observationWeight,
        observationOpacity,
        weight,
        dasharray,
        opacity2,
        observationsForSelectedReportSteps,
        dataForSelectedReportSteps,
        sharedDomainX,
        sharedDomainY,
        availableReportSteps,
        data2,
        combobox_value_binding,
        change_handler,
        checkbox_checked_binding,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding,
        slider0_value_binding_1,
        slider1_value_binding_1
      ];
    }
    class GenDataLines extends SvelteComponent {
      constructor(options) {
        super();
        init$2(
          this,
          options,
          instance$4,
          create_fragment$5,
          safe_not_equal,
          {
            localControlsDivSelector: 0,
            axisMarginLeft: 1,
            axisMarginBottom: 2,
            showAxisX: 3,
            showAxisY: 4,
            data: 22,
            observationsData: 5,
            style: 6,
            width: 7,
            height: 8,
            keyword: 9
          },
          null,
          [-1, -1]
        );
      }
    }
    /*!
     * https://github.com/Starcounter-Jack/JSON-Patch
     * (c) 2017-2022 Joachim Wester
     * MIT licensed
     */
    var __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (b3.hasOwnProperty(p))
              d2[p] = b3[p];
        };
        return extendStatics(d, b2);
      };
      return function(d, b2) {
        extendStatics(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwnProperty(obj, key2) {
      return _hasOwnProperty.call(obj, key2);
    }
    function _objectKeys(obj) {
      if (Array.isArray(obj)) {
        var keys_1 = new Array(obj.length);
        for (var k = 0; k < keys_1.length; k++) {
          keys_1[k] = "" + k;
        }
        return keys_1;
      }
      if (Object.keys) {
        return Object.keys(obj);
      }
      var keys2 = [];
      for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
          keys2.push(i);
        }
      }
      return keys2;
    }
    function _deepClone(obj) {
      switch (typeof obj) {
        case "object":
          return JSON.parse(JSON.stringify(obj));
        case "undefined":
          return null;
        default:
          return obj;
      }
    }
    function isInteger$1(str) {
      var i = 0;
      var len = str.length;
      var charCode;
      while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
          i++;
          continue;
        }
        return false;
      }
      return true;
    }
    function escapePathComponent(path2) {
      if (path2.indexOf("/") === -1 && path2.indexOf("~") === -1)
        return path2;
      return path2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapePathComponent(path2) {
      return path2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function hasUndefined(obj) {
      if (obj === void 0) {
        return true;
      }
      if (obj) {
        if (Array.isArray(obj)) {
          for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
            if (hasUndefined(obj[i_1])) {
              return true;
            }
          }
        } else if (typeof obj === "object") {
          var objKeys = _objectKeys(obj);
          var objKeysLength = objKeys.length;
          for (var i = 0; i < objKeysLength; i++) {
            if (hasUndefined(obj[objKeys[i]])) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function patchErrorMessageFormatter(message, args) {
      var messageParts = [message];
      for (var key2 in args) {
        var value2 = typeof args[key2] === "object" ? JSON.stringify(args[key2], null, 2) : args[key2];
        if (typeof value2 !== "undefined") {
          messageParts.push(key2 + ": " + value2);
        }
      }
      return messageParts.join("\n");
    }
    var PatchError = (
      /** @class */
      function(_super) {
        __extends(PatchError2, _super);
        function PatchError2(message, name2, index2, operation, tree2) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name2, index: index2, operation, tree: tree2 })) || this;
          _this.name = name2;
          _this.index = index2;
          _this.operation = operation;
          _this.tree = tree2;
          Object.setPrototypeOf(_this, _newTarget.prototype);
          _this.message = patchErrorMessageFormatter(message, { name: name2, index: index2, operation, tree: tree2 });
          return _this;
        }
        return PatchError2;
      }(Error)
    );
    var JsonPatchError = PatchError;
    var deepClone = _deepClone;
    var objOps = {
      add: function(obj, key2, document2) {
        obj[key2] = this.value;
        return { newDocument: document2 };
      },
      remove: function(obj, key2, document2) {
        var removed = obj[key2];
        delete obj[key2];
        return { newDocument: document2, removed };
      },
      replace: function(obj, key2, document2) {
        var removed = obj[key2];
        obj[key2] = this.value;
        return { newDocument: document2, removed };
      },
      move: function(obj, key2, document2) {
        var removed = getValueByPointer(document2, this.path);
        if (removed) {
          removed = _deepClone(removed);
        }
        var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
        applyOperation(document2, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document2, removed };
      },
      copy: function(obj, key2, document2) {
        var valueToCopy = getValueByPointer(document2, this.from);
        applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
        return { newDocument: document2 };
      },
      test: function(obj, key2, document2) {
        return { newDocument: document2, test: _areEquals(obj[key2], this.value) };
      },
      _get: function(obj, key2, document2) {
        this.value = obj[key2];
        return { newDocument: document2 };
      }
    };
    var arrOps = {
      add: function(arr, i, document2) {
        if (isInteger$1(i)) {
          arr.splice(i, 0, this.value);
        } else {
          arr[i] = this.value;
        }
        return { newDocument: document2, index: i };
      },
      remove: function(arr, i, document2) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document2, removed: removedList[0] };
      },
      replace: function(arr, i, document2) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document2, removed };
      },
      move: objOps.move,
      copy: objOps.copy,
      test: objOps.test,
      _get: objOps._get
    };
    function getValueByPointer(document2, pointer) {
      if (pointer == "") {
        return document2;
      }
      var getOriginalDestination = { op: "_get", path: pointer };
      applyOperation(document2, getOriginalDestination);
      return getOriginalDestination.value;
    }
    function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index2) {
      if (validateOperation === void 0) {
        validateOperation = false;
      }
      if (mutateDocument === void 0) {
        mutateDocument = true;
      }
      if (banPrototypeModifications === void 0) {
        banPrototypeModifications = true;
      }
      if (index2 === void 0) {
        index2 = 0;
      }
      if (validateOperation) {
        if (typeof validateOperation == "function") {
          validateOperation(operation, 0, document2, operation.path);
        } else {
          validator(operation, 0);
        }
      }
      if (operation.path === "") {
        var returnValue = { newDocument: document2 };
        if (operation.op === "add") {
          returnValue.newDocument = operation.value;
          return returnValue;
        } else if (operation.op === "replace") {
          returnValue.newDocument = operation.value;
          returnValue.removed = document2;
          return returnValue;
        } else if (operation.op === "move" || operation.op === "copy") {
          returnValue.newDocument = getValueByPointer(document2, operation.from);
          if (operation.op === "move") {
            returnValue.removed = document2;
          }
          return returnValue;
        } else if (operation.op === "test") {
          returnValue.test = _areEquals(document2, operation.value);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
          }
          returnValue.newDocument = document2;
          return returnValue;
        } else if (operation.op === "remove") {
          returnValue.removed = document2;
          returnValue.newDocument = null;
          return returnValue;
        } else if (operation.op === "_get") {
          operation.value = document2;
          return returnValue;
        } else {
          if (validateOperation) {
            throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
          } else {
            return returnValue;
          }
        }
      } else {
        if (!mutateDocument) {
          document2 = _deepClone(document2);
        }
        var path2 = operation.path || "";
        var keys2 = path2.split("/");
        var obj = document2;
        var t4 = 1;
        var len = keys2.length;
        var existingPathFragment = void 0;
        var key2 = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == "function") {
          validateFunction = validateOperation;
        } else {
          validateFunction = validator;
        }
        while (true) {
          key2 = keys2[t4];
          if (key2 && key2.indexOf("~") != -1) {
            key2 = unescapePathComponent(key2);
          }
          if (banPrototypeModifications && (key2 == "__proto__" || key2 == "prototype" && t4 > 0 && keys2[t4 - 1] == "constructor")) {
            throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
          }
          if (validateOperation) {
            if (existingPathFragment === void 0) {
              if (obj[key2] === void 0) {
                existingPathFragment = keys2.slice(0, t4).join("/");
              } else if (t4 == len - 1) {
                existingPathFragment = operation.path;
              }
              if (existingPathFragment !== void 0) {
                validateFunction(operation, 0, document2, existingPathFragment);
              }
            }
          }
          t4++;
          if (Array.isArray(obj)) {
            if (key2 === "-") {
              key2 = obj.length;
            } else {
              if (validateOperation && !isInteger$1(key2)) {
                throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document2);
              } else if (isInteger$1(key2)) {
                key2 = ~~key2;
              }
            }
            if (t4 >= len) {
              if (validateOperation && operation.op === "add" && key2 > obj.length) {
                throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document2);
              }
              var returnValue = arrOps[operation.op].call(operation, obj, key2, document2);
              if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
              }
              return returnValue;
            }
          } else {
            if (t4 >= len) {
              var returnValue = objOps[operation.op].call(operation, obj, key2, document2);
              if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
              }
              return returnValue;
            }
          }
          obj = obj[key2];
          if (validateOperation && t4 < len && (!obj || typeof obj !== "object")) {
            throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
          }
        }
      }
    }
    function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
      if (mutateDocument === void 0) {
        mutateDocument = true;
      }
      if (banPrototypeModifications === void 0) {
        banPrototypeModifications = true;
      }
      if (validateOperation) {
        if (!Array.isArray(patch2)) {
          throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        }
      }
      if (!mutateDocument) {
        document2 = _deepClone(document2);
      }
      var results = new Array(patch2.length);
      for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
        results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
        document2 = results[i].newDocument;
      }
      results.newDocument = document2;
      return results;
    }
    function applyReducer(document2, operation, index2) {
      var operationResult = applyOperation(document2, operation);
      if (operationResult.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
      }
      return operationResult.newDocument;
    }
    function validator(operation, index2, document2, existingPathFragment) {
      if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document2);
      } else if (!objOps[operation.op]) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
      } else if (typeof operation.path !== "string") {
        throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document2);
      } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
        throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document2);
      } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
        throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document2);
      } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
        throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document2);
      } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
        throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document2);
      } else if (document2) {
        if (operation.op == "add") {
          var pathLen = operation.path.split("/").length;
          var existingPathLen = existingPathFragment.split("/").length;
          if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
            throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document2);
          }
        } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
          if (operation.path !== existingPathFragment) {
            throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
          }
        } else if (operation.op === "move" || operation.op === "copy") {
          var existingValue = { op: "_get", path: operation.from, value: void 0 };
          var error2 = validate([existingValue], document2);
          if (error2 && error2.name === "OPERATION_PATH_UNRESOLVABLE") {
            throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document2);
          }
        }
      }
    }
    function validate(sequence2, document2, externalValidator) {
      try {
        if (!Array.isArray(sequence2)) {
          throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        }
        if (document2) {
          applyPatch(_deepClone(document2), _deepClone(sequence2), externalValidator || true);
        } else {
          externalValidator = externalValidator || validator;
          for (var i = 0; i < sequence2.length; i++) {
            externalValidator(sequence2[i], i, document2, void 0);
          }
        }
      } catch (e3) {
        if (e3 instanceof JsonPatchError) {
          return e3;
        } else {
          throw e3;
        }
      }
    }
    function _areEquals(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        var arrA = Array.isArray(a2), arrB = Array.isArray(b2), i, length2, key2;
        if (arrA && arrB) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!_areEquals(a2[i], b2[i]))
              return false;
          return true;
        }
        if (arrA != arrB)
          return false;
        var keys2 = Object.keys(a2);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!b2.hasOwnProperty(keys2[i]))
            return false;
        for (i = length2; i-- !== 0; ) {
          key2 = keys2[i];
          if (!_areEquals(a2[key2], b2[key2]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    }
    const core = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      JsonPatchError,
      _areEquals,
      applyOperation,
      applyPatch,
      applyReducer,
      deepClone,
      getValueByPointer,
      validate,
      validator
    }, Symbol.toStringTag, { value: "Module" }));
    /*!
     * https://github.com/Starcounter-Jack/JSON-Patch
     * (c) 2017-2021 Joachim Wester
     * MIT license
     */
    var beforeDict = /* @__PURE__ */ new WeakMap();
    var Mirror = (
      /** @class */
      /* @__PURE__ */ function() {
        function Mirror2(obj) {
          this.observers = /* @__PURE__ */ new Map();
          this.obj = obj;
        }
        return Mirror2;
      }()
    );
    var ObserverInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function ObserverInfo2(callback, observer) {
          this.callback = callback;
          this.observer = observer;
        }
        return ObserverInfo2;
      }()
    );
    function getMirror(obj) {
      return beforeDict.get(obj);
    }
    function getObserverFromMirror(mirror, callback) {
      return mirror.observers.get(callback);
    }
    function removeObserverFromMirror(mirror, observer) {
      mirror.observers.delete(observer.callback);
    }
    function unobserve(root2, observer) {
      observer.unobserve();
    }
    function observe(obj, callback) {
      var patches = [];
      var observer;
      var mirror = getMirror(obj);
      if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
      } else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
      }
      if (observer) {
        return observer;
      }
      observer = {};
      mirror.value = _deepClone(obj);
      if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function() {
          generate$1(observer);
        };
        var fastCheck = function() {
          clearTimeout(observer.next);
          observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== "undefined") {
          window.addEventListener("mouseup", fastCheck);
          window.addEventListener("keyup", fastCheck);
          window.addEventListener("mousedown", fastCheck);
          window.addEventListener("keydown", fastCheck);
          window.addEventListener("change", fastCheck);
        }
      }
      observer.patches = patches;
      observer.object = obj;
      observer.unobserve = function() {
        generate$1(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== "undefined") {
          window.removeEventListener("mouseup", fastCheck);
          window.removeEventListener("keyup", fastCheck);
          window.removeEventListener("mousedown", fastCheck);
          window.removeEventListener("keydown", fastCheck);
          window.removeEventListener("change", fastCheck);
        }
      };
      mirror.observers.set(callback, new ObserverInfo(callback, observer));
      return observer;
    }
    function generate$1(observer, invertible) {
      if (invertible === void 0) {
        invertible = false;
      }
      var mirror = beforeDict.get(observer.object);
      _generate(mirror.value, observer.object, observer.patches, "", invertible);
      if (observer.patches.length) {
        applyPatch(mirror.value, observer.patches);
      }
      var temp2 = observer.patches;
      if (temp2.length > 0) {
        observer.patches = [];
        if (observer.callback) {
          observer.callback(temp2);
        }
      }
      return temp2;
    }
    function _generate(mirror, obj, patches, path2, invertible) {
      if (obj === mirror) {
        return;
      }
      if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
      }
      var newKeys = _objectKeys(obj);
      var oldKeys = _objectKeys(mirror);
      var deleted = false;
      for (var t4 = oldKeys.length - 1; t4 >= 0; t4--) {
        var key2 = oldKeys[t4];
        var oldVal = mirror[key2];
        if (hasOwnProperty(obj, key2) && !(obj[key2] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
          var newVal = obj[key2];
          if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
            _generate(oldVal, newVal, patches, path2 + "/" + escapePathComponent(key2), invertible);
          } else {
            if (oldVal !== newVal) {
              if (invertible) {
                patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
              }
              patches.push({ op: "replace", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(newVal) });
            }
          }
        } else if (Array.isArray(mirror) === Array.isArray(obj)) {
          if (invertible) {
            patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(oldVal) });
          }
          patches.push({ op: "remove", path: path2 + "/" + escapePathComponent(key2) });
          deleted = true;
        } else {
          if (invertible) {
            patches.push({ op: "test", path: path2, value: mirror });
          }
          patches.push({ op: "replace", path: path2, value: obj });
        }
      }
      if (!deleted && newKeys.length == oldKeys.length) {
        return;
      }
      for (var t4 = 0; t4 < newKeys.length; t4++) {
        var key2 = newKeys[t4];
        if (!hasOwnProperty(mirror, key2) && obj[key2] !== void 0) {
          patches.push({ op: "add", path: path2 + "/" + escapePathComponent(key2), value: _deepClone(obj[key2]) });
        }
      }
    }
    function compare$9(tree1, tree2, invertible) {
      if (invertible === void 0) {
        invertible = false;
      }
      var patches = [];
      _generate(tree1, tree2, patches, "", invertible);
      return patches;
    }
    const duplex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      compare: compare$9,
      generate: generate$1,
      observe,
      unobserve
    }, Symbol.toStringTag, { value: "Module" }));
    Object.assign({}, core, duplex, {
      JsonPatchError: PatchError,
      deepClone: _deepClone,
      escapePathComponent,
      unescapePathComponent
    });
    function getDefaultExportFromCjs$1(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    var jsonStringifyPrettyCompact = function stringify2(passedObj, options) {
      var indent, maxLength, replacer2;
      options = options || {};
      indent = JSON.stringify(
        [1],
        void 0,
        options.indent === void 0 ? 2 : options.indent
      ).slice(2, -3);
      maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
      replacer2 = options.replacer;
      return function _stringify(obj, currentIndent, reserved) {
        var end, index2, items, key2, keyPart, keys2, length2, nextIndent, prettified, start2, string, value2;
        if (obj && typeof obj.toJSON === "function") {
          obj = obj.toJSON();
        }
        string = JSON.stringify(obj, replacer2);
        if (string === void 0) {
          return string;
        }
        length2 = maxLength - currentIndent.length - reserved;
        if (string.length <= length2) {
          prettified = string.replace(
            stringOrChar,
            function(match2, stringLiteral) {
              return stringLiteral || match2 + " ";
            }
          );
          if (prettified.length <= length2) {
            return prettified;
          }
        }
        if (replacer2 != null) {
          obj = JSON.parse(string);
          replacer2 = void 0;
        }
        if (typeof obj === "object" && obj !== null) {
          nextIndent = currentIndent + indent;
          items = [];
          index2 = 0;
          if (Array.isArray(obj)) {
            start2 = "[";
            end = "]";
            length2 = obj.length;
            for (; index2 < length2; index2++) {
              items.push(
                _stringify(obj[index2], nextIndent, index2 === length2 - 1 ? 0 : 1) || "null"
              );
            }
          } else {
            start2 = "{";
            end = "}";
            keys2 = Object.keys(obj);
            length2 = keys2.length;
            for (; index2 < length2; index2++) {
              key2 = keys2[index2];
              keyPart = JSON.stringify(key2) + ": ";
              value2 = _stringify(
                obj[key2],
                nextIndent,
                keyPart.length + (index2 === length2 - 1 ? 0 : 1)
              );
              if (value2 !== void 0) {
                items.push(keyPart + value2);
              }
            }
          }
          if (items.length > 0) {
            return [start2, indent + items.join(",\n" + nextIndent), end].join(
              "\n" + currentIndent
            );
          }
        }
        return string;
      }(passedObj, "", 0);
    };
    const stringify$2 = /* @__PURE__ */ getDefaultExportFromCjs$1(jsonStringifyPrettyCompact);
    function accessor(fn, fields, name2) {
      fn.fields = fields || [];
      fn.fname = name2;
      return fn;
    }
    function accessorName(fn) {
      return fn == null ? null : fn.fname;
    }
    function accessorFields(fn) {
      return fn == null ? null : fn.fields;
    }
    function getter$1(path2) {
      return path2.length === 1 ? get1(path2[0]) : getN(path2);
    }
    const get1 = (field2) => function(obj) {
      return obj[field2];
    };
    const getN = (path2) => {
      const len = path2.length;
      return function(obj) {
        for (let i = 0; i < len; ++i) {
          obj = obj[path2[i]];
        }
        return obj;
      };
    };
    function error(message) {
      throw Error(message);
    }
    function splitAccessPath(p) {
      const path2 = [], n = p.length;
      let q = null, b2 = 0, s = "", i, j, c2;
      p = p + "";
      function push2() {
        path2.push(s + p.substring(i, j));
        s = "";
        i = j + 1;
      }
      for (i = j = 0; j < n; ++j) {
        c2 = p[j];
        if (c2 === "\\") {
          s += p.substring(i, j++);
          i = j;
        } else if (c2 === q) {
          push2();
          q = null;
          b2 = -1;
        } else if (q) {
          continue;
        } else if (i === b2 && c2 === '"') {
          i = j + 1;
          q = c2;
        } else if (i === b2 && c2 === "'") {
          i = j + 1;
          q = c2;
        } else if (c2 === "." && !b2) {
          if (j > i) {
            push2();
          } else {
            i = j + 1;
          }
        } else if (c2 === "[") {
          if (j > i)
            push2();
          b2 = i = j + 1;
        } else if (c2 === "]") {
          if (!b2)
            error("Access path missing open bracket: " + p);
          if (b2 > 0)
            push2();
          b2 = 0;
          i = j + 1;
        }
      }
      if (b2)
        error("Access path missing closing bracket: " + p);
      if (q)
        error("Access path missing closing quote: " + p);
      if (j > i) {
        j++;
        push2();
      }
      return path2;
    }
    function field$1(field2, name2, opt) {
      const path2 = splitAccessPath(field2);
      field2 = path2.length === 1 ? path2[0] : field2;
      return accessor((opt && opt.get || getter$1)(path2), [field2], name2 || field2);
    }
    const id = field$1("id");
    const identity$1 = accessor((_) => _, [], "identity");
    const zero$2 = accessor(() => 0, [], "zero");
    const one$1 = accessor(() => 1, [], "one");
    const truthy = accessor(() => true, [], "true");
    const falsy = accessor(() => false, [], "false");
    function log$1$1(method2, level, input) {
      const args = [level].concat([].slice.call(input));
      console[method2].apply(console, args);
    }
    const None$2 = 0;
    const Error$1 = 1;
    const Warn = 2;
    const Info = 3;
    const Debug = 4;
    function logger(_, method2) {
      let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : log$1$1;
      let level = _ || None$2;
      return {
        level(_2) {
          if (arguments.length) {
            level = +_2;
            return this;
          } else {
            return level;
          }
        },
        error() {
          if (level >= Error$1)
            handler(method2 || "error", "ERROR", arguments);
          return this;
        },
        warn() {
          if (level >= Warn)
            handler(method2 || "warn", "WARN", arguments);
          return this;
        },
        info() {
          if (level >= Info)
            handler(method2 || "log", "INFO", arguments);
          return this;
        },
        debug() {
          if (level >= Debug)
            handler(method2 || "log", "DEBUG", arguments);
          return this;
        }
      };
    }
    var isArray = Array.isArray;
    function isObject(_) {
      return _ === Object(_);
    }
    const isLegalKey = (key2) => key2 !== "__proto__";
    function mergeConfig() {
      for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
        configs[_key] = arguments[_key];
      }
      return configs.reduce((out, source2) => {
        for (const key2 in source2) {
          if (key2 === "signals") {
            out.signals = mergeNamed(out.signals, source2.signals);
          } else {
            const r = key2 === "legend" ? {
              layout: 1
            } : key2 === "style" ? true : null;
            writeConfig(out, key2, source2[key2], r);
          }
        }
        return out;
      }, {});
    }
    function writeConfig(output2, key2, value2, recurse2) {
      if (!isLegalKey(key2))
        return;
      let k, o;
      if (isObject(value2) && !isArray(value2)) {
        o = isObject(output2[key2]) ? output2[key2] : output2[key2] = {};
        for (k in value2) {
          if (recurse2 && (recurse2 === true || recurse2[k])) {
            writeConfig(o, k, value2[k]);
          } else if (isLegalKey(k)) {
            o[k] = value2[k];
          }
        }
      } else {
        output2[key2] = value2;
      }
    }
    function mergeNamed(a2, b2) {
      if (a2 == null)
        return b2;
      const map2 = {}, out = [];
      function add2(_) {
        if (!map2[_.name]) {
          map2[_.name] = 1;
          out.push(_);
        }
      }
      b2.forEach(add2);
      a2.forEach(add2);
      return out;
    }
    function peek$1(array2) {
      return array2[array2.length - 1];
    }
    function toNumber(_) {
      return _ == null || _ === "" ? null : +_;
    }
    const exp$1 = (sign2) => (x2) => sign2 * Math.exp(x2);
    const log$2 = (sign2) => (x2) => Math.log(sign2 * x2);
    const symlog = (c2) => (x2) => Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
    const symexp = (c2) => (x2) => Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
    const pow$1 = (exponent2) => (x2) => x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
    function pan(domain2, delta, lift, ground) {
      const d0 = lift(domain2[0]), d1 = lift(peek$1(domain2)), dd = (d1 - d0) * delta;
      return [ground(d0 - dd), ground(d1 - dd)];
    }
    function panLinear(domain2, delta) {
      return pan(domain2, delta, toNumber, identity$1);
    }
    function panLog(domain2, delta) {
      var sign2 = Math.sign(domain2[0]);
      return pan(domain2, delta, log$2(sign2), exp$1(sign2));
    }
    function panPow(domain2, delta, exponent2) {
      return pan(domain2, delta, pow$1(exponent2), pow$1(1 / exponent2));
    }
    function panSymlog(domain2, delta, constant2) {
      return pan(domain2, delta, symlog(constant2), symexp(constant2));
    }
    function zoom$1(domain2, anchor2, scale2, lift, ground) {
      const d0 = lift(domain2[0]), d1 = lift(peek$1(domain2)), da = anchor2 != null ? lift(anchor2) : (d0 + d1) / 2;
      return [ground(da + (d0 - da) * scale2), ground(da + (d1 - da) * scale2)];
    }
    function zoomLinear(domain2, anchor2, scale2) {
      return zoom$1(domain2, anchor2, scale2, toNumber, identity$1);
    }
    function zoomLog(domain2, anchor2, scale2) {
      const sign2 = Math.sign(domain2[0]);
      return zoom$1(domain2, anchor2, scale2, log$2(sign2), exp$1(sign2));
    }
    function zoomPow(domain2, anchor2, scale2, exponent2) {
      return zoom$1(domain2, anchor2, scale2, pow$1(exponent2), pow$1(1 / exponent2));
    }
    function zoomSymlog(domain2, anchor2, scale2, constant2) {
      return zoom$1(domain2, anchor2, scale2, symlog(constant2), symexp(constant2));
    }
    function quarter(date2) {
      return 1 + ~~(new Date(date2).getMonth() / 3);
    }
    function utcquarter(date2) {
      return 1 + ~~(new Date(date2).getUTCMonth() / 3);
    }
    function array$2(_) {
      return _ != null ? isArray(_) ? _ : [_] : [];
    }
    function clampRange(range2, min2, max2) {
      let lo = range2[0], hi = range2[1], span2;
      if (hi < lo) {
        span2 = hi;
        hi = lo;
        lo = span2;
      }
      span2 = hi - lo;
      return span2 >= max2 - min2 ? [min2, max2] : [lo = Math.min(Math.max(lo, min2), max2 - span2), lo + span2];
    }
    function isFunction(_) {
      return typeof _ === "function";
    }
    const DESCENDING = "descending";
    function compare$8(fields, orders, opt) {
      opt = opt || {};
      orders = array$2(orders) || [];
      const ord = [], get2 = [], fmap = {}, gen = opt.comparator || comparator$1;
      array$2(fields).forEach((f, i) => {
        if (f == null)
          return;
        ord.push(orders[i] === DESCENDING ? -1 : 1);
        get2.push(f = isFunction(f) ? f : field$1(f, null, opt));
        (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
      });
      return get2.length === 0 ? null : accessor(gen(get2, ord), Object.keys(fmap));
    }
    const ascending$1 = (u2, v) => (u2 < v || u2 == null) && v != null ? -1 : (u2 > v || v == null) && u2 != null ? 1 : (v = v instanceof Date ? +v : v, u2 = u2 instanceof Date ? +u2 : u2) !== u2 && v === v ? -1 : v !== v && u2 === u2 ? 1 : 0;
    const comparator$1 = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
    const compare1 = (field2, order) => function(a2, b2) {
      return ascending$1(field2(a2), field2(b2)) * order;
    };
    const compareN = (fields, orders, n) => {
      orders.push(0);
      return function(a2, b2) {
        let f, c2 = 0, i = -1;
        while (c2 === 0 && ++i < n) {
          f = fields[i];
          c2 = ascending$1(f(a2), f(b2));
        }
        return c2 * orders[i];
      };
    };
    function constant$1(_) {
      return isFunction(_) ? _ : () => _;
    }
    function debounce(delay2, handler) {
      let tid;
      return (e3) => {
        if (tid)
          clearTimeout(tid);
        tid = setTimeout(() => (handler(e3), tid = null), delay2);
      };
    }
    function extend(_) {
      for (let x2, k, i = 1, len = arguments.length; i < len; ++i) {
        x2 = arguments[i];
        for (k in x2) {
          _[k] = x2[k];
        }
      }
      return _;
    }
    function extent(array2, f) {
      let i = 0, n, v, min2, max2;
      if (array2 && (n = array2.length)) {
        if (f == null) {
          for (v = array2[i]; i < n && (v == null || v !== v); v = array2[++i])
            ;
          min2 = max2 = v;
          for (; i < n; ++i) {
            v = array2[i];
            if (v != null) {
              if (v < min2)
                min2 = v;
              if (v > max2)
                max2 = v;
            }
          }
        } else {
          for (v = f(array2[i]); i < n && (v == null || v !== v); v = f(array2[++i]))
            ;
          min2 = max2 = v;
          for (; i < n; ++i) {
            v = f(array2[i]);
            if (v != null) {
              if (v < min2)
                min2 = v;
              if (v > max2)
                max2 = v;
            }
          }
        }
      }
      return [min2, max2];
    }
    function extentIndex(array2, f) {
      const n = array2.length;
      let i = -1, a2, b2, c2, u2, v;
      if (f == null) {
        while (++i < n) {
          b2 = array2[i];
          if (b2 != null && b2 >= b2) {
            a2 = c2 = b2;
            break;
          }
        }
        if (i === n)
          return [-1, -1];
        u2 = v = i;
        while (++i < n) {
          b2 = array2[i];
          if (b2 != null) {
            if (a2 > b2) {
              a2 = b2;
              u2 = i;
            }
            if (c2 < b2) {
              c2 = b2;
              v = i;
            }
          }
        }
      } else {
        while (++i < n) {
          b2 = f(array2[i], i, array2);
          if (b2 != null && b2 >= b2) {
            a2 = c2 = b2;
            break;
          }
        }
        if (i === n)
          return [-1, -1];
        u2 = v = i;
        while (++i < n) {
          b2 = f(array2[i], i, array2);
          if (b2 != null) {
            if (a2 > b2) {
              a2 = b2;
              u2 = i;
            }
            if (c2 < b2) {
              c2 = b2;
              v = i;
            }
          }
        }
      }
      return [u2, v];
    }
    const hop = Object.prototype.hasOwnProperty;
    function has$1(object2, property2) {
      return hop.call(object2, property2);
    }
    const NULL = {};
    function fastmap(input) {
      let obj = {}, test2;
      function has$1$1(key2) {
        return has$1(obj, key2) && obj[key2] !== NULL;
      }
      const map2 = {
        size: 0,
        empty: 0,
        object: obj,
        has: has$1$1,
        get(key2) {
          return has$1$1(key2) ? obj[key2] : void 0;
        },
        set(key2, value2) {
          if (!has$1$1(key2)) {
            ++map2.size;
            if (obj[key2] === NULL)
              --map2.empty;
          }
          obj[key2] = value2;
          return this;
        },
        delete(key2) {
          if (has$1$1(key2)) {
            --map2.size;
            ++map2.empty;
            obj[key2] = NULL;
          }
          return this;
        },
        clear() {
          map2.size = map2.empty = 0;
          map2.object = obj = {};
        },
        test(_) {
          if (arguments.length) {
            test2 = _;
            return map2;
          } else {
            return test2;
          }
        },
        clean() {
          const next2 = {};
          let size2 = 0;
          for (const key2 in obj) {
            const value2 = obj[key2];
            if (value2 !== NULL && (!test2 || !test2(value2))) {
              next2[key2] = value2;
              ++size2;
            }
          }
          map2.size = size2;
          map2.empty = 0;
          map2.object = obj = next2;
        }
      };
      if (input)
        Object.keys(input).forEach((key2) => {
          map2.set(key2, input[key2]);
        });
      return map2;
    }
    function flush(range2, value2, threshold2, left2, right2, center2) {
      if (!threshold2 && threshold2 !== 0)
        return center2;
      const t4 = +threshold2;
      let a2 = range2[0], b2 = peek$1(range2), l;
      if (b2 < a2) {
        l = a2;
        a2 = b2;
        b2 = l;
      }
      l = Math.abs(value2 - a2);
      const r = Math.abs(b2 - value2);
      return l < r && l <= t4 ? left2 : r <= t4 ? right2 : center2;
    }
    function inherits(child, parent, members) {
      const proto = child.prototype = Object.create(parent.prototype);
      Object.defineProperty(proto, "constructor", {
        value: child,
        writable: true,
        enumerable: true,
        configurable: true
      });
      return extend(proto, members);
    }
    function inrange(value2, range2, left2, right2) {
      let r0 = range2[0], r1 = range2[range2.length - 1], t4;
      if (r0 > r1) {
        t4 = r0;
        r0 = r1;
        r1 = t4;
      }
      left2 = left2 === void 0 || left2;
      right2 = right2 === void 0 || right2;
      return (left2 ? r0 <= value2 : r0 < value2) && (right2 ? value2 <= r1 : value2 < r1);
    }
    function isBoolean$2(_) {
      return typeof _ === "boolean";
    }
    function isDate$1(_) {
      return Object.prototype.toString.call(_) === "[object Date]";
    }
    function isIterable(_) {
      return _ && isFunction(_[Symbol.iterator]);
    }
    function isNumber$1(_) {
      return typeof _ === "number";
    }
    function isRegExp(_) {
      return Object.prototype.toString.call(_) === "[object RegExp]";
    }
    function isString(_) {
      return typeof _ === "string";
    }
    function key(fields, flat, opt) {
      if (fields) {
        fields = flat ? array$2(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array$2(fields);
      }
      const len = fields && fields.length, gen = opt && opt.get || getter$1, map2 = (f) => gen(flat ? [f] : splitAccessPath(f));
      let fn;
      if (!len) {
        fn = function() {
          return "";
        };
      } else if (len === 1) {
        const get2 = map2(fields[0]);
        fn = function(_) {
          return "" + get2(_);
        };
      } else {
        const get2 = fields.map(map2);
        fn = function(_) {
          let s = "" + get2[0](_), i = 0;
          while (++i < len)
            s += "|" + get2[i](_);
          return s;
        };
      }
      return accessor(fn, fields, "key");
    }
    function lerp(array2, frac) {
      const lo = array2[0], hi = peek$1(array2), f = +frac;
      return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
    }
    const DEFAULT_MAX_SIZE = 1e4;
    function lruCache$1(maxsize) {
      maxsize = +maxsize || DEFAULT_MAX_SIZE;
      let curr, prev2, size2;
      const clear2 = () => {
        curr = {};
        prev2 = {};
        size2 = 0;
      };
      const update2 = (key2, value2) => {
        if (++size2 > maxsize) {
          prev2 = curr;
          curr = {};
          size2 = 1;
        }
        return curr[key2] = value2;
      };
      clear2();
      return {
        clear: clear2,
        has: (key2) => has$1(curr, key2) || has$1(prev2, key2),
        get: (key2) => has$1(curr, key2) ? curr[key2] : has$1(prev2, key2) ? update2(key2, prev2[key2]) : void 0,
        set: (key2, value2) => has$1(curr, key2) ? curr[key2] = value2 : update2(key2, value2)
      };
    }
    function merge$2(compare2, array0, array1, output2) {
      const n0 = array0.length, n1 = array1.length;
      if (!n1)
        return array0;
      if (!n0)
        return array1;
      const merged = output2 || new array0.constructor(n0 + n1);
      let i0 = 0, i1 = 0, i = 0;
      for (; i0 < n0 && i1 < n1; ++i) {
        merged[i] = compare2(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
      }
      for (; i0 < n0; ++i0, ++i) {
        merged[i] = array0[i0];
      }
      for (; i1 < n1; ++i1, ++i) {
        merged[i] = array1[i1];
      }
      return merged;
    }
    function repeat(str, reps) {
      let s = "";
      while (--reps >= 0)
        s += str;
      return s;
    }
    function pad(str, length2, padchar, align2) {
      const c2 = padchar || " ", s = str + "", n = length2 - s.length;
      return n <= 0 ? s : align2 === "left" ? repeat(c2, n) + s : align2 === "center" ? repeat(c2, ~~(n / 2)) + s + repeat(c2, Math.ceil(n / 2)) : s + repeat(c2, n);
    }
    function span(array2) {
      return array2 && peek$1(array2) - array2[0] || 0;
    }
    function $(x2) {
      return isArray(x2) ? "[" + x2.map($) + "]" : isObject(x2) || isString(x2) ? (
        // Output valid JSON and JS source strings.
        // See http://timelessrepo.com/json-isnt-a-javascript-subset
        JSON.stringify(x2).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
      ) : x2;
    }
    function toBoolean(_) {
      return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
    }
    const defaultParser = (_) => isNumber$1(_) ? _ : isDate$1(_) ? _ : Date.parse(_);
    function toDate(_, parser2) {
      parser2 = parser2 || defaultParser;
      return _ == null || _ === "" ? null : parser2(_);
    }
    function toString(_) {
      return _ == null || _ === "" ? null : _ + "";
    }
    function toSet(_) {
      const s = {}, n = _.length;
      for (let i = 0; i < n; ++i)
        s[_[i]] = true;
      return s;
    }
    function truncate$1(str, length2, align2, ellipsis) {
      const e3 = ellipsis != null ? ellipsis : "", s = str + "", n = s.length, l = Math.max(0, length2 - e3.length);
      return n <= length2 ? s : align2 === "left" ? e3 + s.slice(n - l) : align2 === "center" ? s.slice(0, Math.ceil(l / 2)) + e3 + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e3;
    }
    function visitArray(array2, filter2, visitor) {
      if (array2) {
        if (filter2) {
          const n = array2.length;
          for (let i = 0; i < n; ++i) {
            const t4 = filter2(array2[i]);
            if (t4)
              visitor(t4, i, array2);
          }
        } else {
          array2.forEach(visitor);
        }
      }
    }
    function identity(x2) {
      return x2;
    }
    function transform$3(transform2) {
      if (transform2 == null)
        return identity;
      var x02, y02, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
      return function(input, i) {
        if (!i)
          x02 = y02 = 0;
        var j = 2, n = input.length, output2 = new Array(n);
        output2[0] = (x02 += input[0]) * kx + dx;
        output2[1] = (y02 += input[1]) * ky + dy;
        while (j < n)
          output2[j] = input[j], ++j;
        return output2;
      };
    }
    function reverse$2(array2, n) {
      var t4, j = array2.length, i = j - n;
      while (i < --j)
        t4 = array2[i], array2[i++] = array2[j], array2[j] = t4;
    }
    function feature(topology, o) {
      if (typeof o === "string")
        o = topology.objects[o];
      return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
        return feature$1(topology, o2);
      }) } : feature$1(topology, o);
    }
    function feature$1(topology, o) {
      var id2 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
      return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
    }
    function object(topology, o) {
      var transformPoint = transform$3(topology.transform), arcs = topology.arcs;
      function arc2(i, points2) {
        if (points2.length)
          points2.pop();
        for (var a2 = arcs[i < 0 ? ~i : i], k = 0, n = a2.length; k < n; ++k) {
          points2.push(transformPoint(a2[k], k));
        }
        if (i < 0)
          reverse$2(points2, n);
      }
      function point2(p) {
        return transformPoint(p);
      }
      function line2(arcs2) {
        var points2 = [];
        for (var i = 0, n = arcs2.length; i < n; ++i)
          arc2(arcs2[i], points2);
        if (points2.length < 2)
          points2.push(points2[0]);
        return points2;
      }
      function ring(arcs2) {
        var points2 = line2(arcs2);
        while (points2.length < 4)
          points2.push(points2[0]);
        return points2;
      }
      function polygon(arcs2) {
        return arcs2.map(ring);
      }
      function geometry(o2) {
        var type2 = o2.type, coordinates;
        switch (type2) {
          case "GeometryCollection":
            return { type: type2, geometries: o2.geometries.map(geometry) };
          case "Point":
            coordinates = point2(o2.coordinates);
            break;
          case "MultiPoint":
            coordinates = o2.coordinates.map(point2);
            break;
          case "LineString":
            coordinates = line2(o2.arcs);
            break;
          case "MultiLineString":
            coordinates = o2.arcs.map(line2);
            break;
          case "Polygon":
            coordinates = polygon(o2.arcs);
            break;
          case "MultiPolygon":
            coordinates = o2.arcs.map(polygon);
            break;
          default:
            return null;
        }
        return { type: type2, coordinates };
      }
      return geometry(o);
    }
    function stitch(topology, arcs) {
      var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
      arcs.forEach(function(i, j) {
        var arc2 = topology.arcs[i < 0 ? ~i : i], t4;
        if (arc2.length < 3 && !arc2[1][0] && !arc2[1][1]) {
          t4 = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t4;
        }
      });
      arcs.forEach(function(i) {
        var e3 = ends(i), start2 = e3[0], end = e3[1], f, g;
        if (f = fragmentByEnd[start2]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start2;
          if (g = fragmentByEnd[start2]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start2] = fragmentByEnd[f.end = end] = f;
        }
      });
      function ends(i) {
        var arc2 = topology.arcs[i < 0 ? ~i : i], p02 = arc2[0], p1;
        if (topology.transform)
          p1 = [0, 0], arc2.forEach(function(dp) {
            p1[0] += dp[0], p1[1] += dp[1];
          });
        else
          p1 = arc2[arc2.length - 1];
        return i < 0 ? [p1, p02] : [p02, p1];
      }
      function flush2(fragmentByEnd2, fragmentByStart2) {
        for (var k in fragmentByEnd2) {
          var f = fragmentByEnd2[k];
          delete fragmentByStart2[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function(i) {
            stitchedArcs[i < 0 ? ~i : i] = 1;
          });
          fragments.push(f);
        }
      }
      flush2(fragmentByEnd, fragmentByStart);
      flush2(fragmentByStart, fragmentByEnd);
      arcs.forEach(function(i) {
        if (!stitchedArcs[i < 0 ? ~i : i])
          fragments.push([i]);
      });
      return fragments;
    }
    function mesh(topology) {
      return object(topology, meshArcs.apply(this, arguments));
    }
    function meshArcs(topology, object2, filter2) {
      var arcs, i, n;
      if (arguments.length > 1)
        arcs = extractArcs(topology, object2, filter2);
      else
        for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
          arcs[i] = i;
      return { type: "MultiLineString", arcs: stitch(topology, arcs) };
    }
    function extractArcs(topology, object2, filter2) {
      var arcs = [], geomsByArc = [], geom;
      function extract0(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
      }
      function extract1(arcs2) {
        arcs2.forEach(extract0);
      }
      function extract2(arcs2) {
        arcs2.forEach(extract1);
      }
      function extract3(arcs2) {
        arcs2.forEach(extract2);
      }
      function geometry(o) {
        switch (geom = o, o.type) {
          case "GeometryCollection":
            o.geometries.forEach(geometry);
            break;
          case "LineString":
            extract1(o.arcs);
            break;
          case "MultiLineString":
          case "Polygon":
            extract2(o.arcs);
            break;
          case "MultiPolygon":
            extract3(o.arcs);
            break;
        }
      }
      geometry(object2);
      geomsByArc.forEach(filter2 == null ? function(geoms) {
        arcs.push(geoms[0].i);
      } : function(geoms) {
        if (filter2(geoms[0].g, geoms[geoms.length - 1].g))
          arcs.push(geoms[0].i);
      });
      return arcs;
    }
    const YEAR = "year";
    const QUARTER = "quarter";
    const MONTH = "month";
    const WEEK = "week";
    const DATE = "date";
    const DAY = "day";
    const DAYOFYEAR = "dayofyear";
    const HOURS = "hours";
    const MINUTES = "minutes";
    const SECONDS = "seconds";
    const MILLISECONDS = "milliseconds";
    const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
    const UNITS = TIME_UNITS.reduce((o, u2, i) => (o[u2] = 1 + i, o), {});
    function timeUnits(units) {
      const u2 = array$2(units).slice(), m2 = {};
      if (!u2.length)
        error("Missing time unit.");
      u2.forEach((unit2) => {
        if (has$1(UNITS, unit2)) {
          m2[unit2] = 1;
        } else {
          error(`Invalid time unit: ${unit2}.`);
        }
      });
      const numTypes = (m2[WEEK] || m2[DAY] ? 1 : 0) + (m2[QUARTER] || m2[MONTH] || m2[DATE] ? 1 : 0) + (m2[DAYOFYEAR] ? 1 : 0);
      if (numTypes > 1) {
        error(`Incompatible time units: ${units}`);
      }
      u2.sort((a2, b2) => UNITS[a2] - UNITS[b2]);
      return u2;
    }
    const defaultSpecifiers = {
      [YEAR]: "%Y ",
      [QUARTER]: "Q%q ",
      [MONTH]: "%b ",
      [DATE]: "%d ",
      [WEEK]: "W%U ",
      [DAY]: "%a ",
      [DAYOFYEAR]: "%j ",
      [HOURS]: "%H:00",
      [MINUTES]: "00:%M",
      [SECONDS]: ":%S",
      [MILLISECONDS]: ".%L",
      [`${YEAR}-${MONTH}`]: "%Y-%m ",
      [`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
      [`${HOURS}-${MINUTES}`]: "%H:%M"
    };
    function timeUnitSpecifier(units, specifiers) {
      const s = extend({}, defaultSpecifiers, specifiers), u2 = timeUnits(units), n = u2.length;
      let fmt = "", start2 = 0, end, key2;
      for (start2 = 0; start2 < n; ) {
        for (end = u2.length; end > start2; --end) {
          key2 = u2.slice(start2, end).join("-");
          if (s[key2] != null) {
            fmt += s[key2];
            start2 = end;
            break;
          }
        }
      }
      return fmt.trim();
    }
    const t0 = /* @__PURE__ */ new Date();
    function localYear(y2) {
      t0.setFullYear(y2);
      t0.setMonth(0);
      t0.setDate(1);
      t0.setHours(0, 0, 0, 0);
      return t0;
    }
    function dayofyear(d) {
      return localDayOfYear(new Date(d));
    }
    function week(d) {
      return localWeekNum(new Date(d));
    }
    function localDayOfYear(d) {
      return timeDay.count(localYear(d.getFullYear()) - 1, d);
    }
    function localWeekNum(d) {
      return timeSunday.count(localYear(d.getFullYear()) - 1, d);
    }
    function localFirst(y2) {
      return localYear(y2).getDay();
    }
    function localDate(y2, m2, d, H, M2, S, L) {
      if (0 <= y2 && y2 < 100) {
        const date2 = new Date(-1, m2, d, H, M2, S, L);
        date2.setFullYear(y2);
        return date2;
      }
      return new Date(y2, m2, d, H, M2, S, L);
    }
    function utcdayofyear(d) {
      return utcDayOfYear(new Date(d));
    }
    function utcweek(d) {
      return utcWeekNum(new Date(d));
    }
    function utcDayOfYear(d) {
      const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
      return utcDay.count(y2 - 1, d);
    }
    function utcWeekNum(d) {
      const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
      return utcSunday.count(y2 - 1, d);
    }
    function utcFirst(y2) {
      t0.setTime(Date.UTC(y2, 0, 1));
      return t0.getUTCDay();
    }
    function utcDate(y2, m2, d, H, M2, S, L) {
      if (0 <= y2 && y2 < 100) {
        const date2 = new Date(Date.UTC(-1, m2, d, H, M2, S, L));
        date2.setUTCFullYear(d.y);
        return date2;
      }
      return new Date(Date.UTC(y2, m2, d, H, M2, S, L));
    }
    function floor(units, step, get2, inv, newDate2) {
      const s = step || 1, b2 = peek$1(units), _ = (unit2, p, key2) => {
        key2 = key2 || unit2;
        return getUnit(get2[key2], inv[key2], unit2 === b2 && s, p);
      };
      const t4 = /* @__PURE__ */ new Date(), u2 = toSet(units), y2 = u2[YEAR] ? _(YEAR) : constant$1(2012), m2 = u2[MONTH] ? _(MONTH) : u2[QUARTER] ? _(QUARTER) : zero$2, d = u2[WEEK] && u2[DAY] ? _(DAY, 1, WEEK + DAY) : u2[WEEK] ? _(WEEK, 1) : u2[DAY] ? _(DAY, 1) : u2[DATE] ? _(DATE, 1) : u2[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one$1, H = u2[HOURS] ? _(HOURS) : zero$2, M2 = u2[MINUTES] ? _(MINUTES) : zero$2, S = u2[SECONDS] ? _(SECONDS) : zero$2, L = u2[MILLISECONDS] ? _(MILLISECONDS) : zero$2;
      return function(v) {
        t4.setTime(+v);
        const year = y2(t4);
        return newDate2(year, m2(t4), d(t4, year), H(t4), M2(t4), S(t4), L(t4));
      };
    }
    function getUnit(f, inv, step, phase) {
      const u2 = step <= 1 ? f : phase ? (d, y2) => phase + step * Math.floor((f(d, y2) - phase) / step) : (d, y2) => step * Math.floor(f(d, y2) / step);
      return inv ? (d, y2) => inv(u2(d, y2), y2) : u2;
    }
    function weekday(week2, day, firstDay) {
      return day + week2 * 7 - (firstDay + 6) % 7;
    }
    const localGet = {
      [YEAR]: (d) => d.getFullYear(),
      [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
      [MONTH]: (d) => d.getMonth(),
      [DATE]: (d) => d.getDate(),
      [HOURS]: (d) => d.getHours(),
      [MINUTES]: (d) => d.getMinutes(),
      [SECONDS]: (d) => d.getSeconds(),
      [MILLISECONDS]: (d) => d.getMilliseconds(),
      [DAYOFYEAR]: (d) => localDayOfYear(d),
      [WEEK]: (d) => localWeekNum(d),
      [WEEK + DAY]: (d, y2) => weekday(localWeekNum(d), d.getDay(), localFirst(y2)),
      [DAY]: (d, y2) => weekday(1, d.getDay(), localFirst(y2))
    };
    const localInv = {
      [QUARTER]: (q) => 3 * q,
      [WEEK]: (w2, y2) => weekday(w2, 0, localFirst(y2))
    };
    function timeFloor(units, step) {
      return floor(units, step || 1, localGet, localInv, localDate);
    }
    const utcGet = {
      [YEAR]: (d) => d.getUTCFullYear(),
      [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
      [MONTH]: (d) => d.getUTCMonth(),
      [DATE]: (d) => d.getUTCDate(),
      [HOURS]: (d) => d.getUTCHours(),
      [MINUTES]: (d) => d.getUTCMinutes(),
      [SECONDS]: (d) => d.getUTCSeconds(),
      [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
      [DAYOFYEAR]: (d) => utcDayOfYear(d),
      [WEEK]: (d) => utcWeekNum(d),
      [DAY]: (d, y2) => weekday(1, d.getUTCDay(), utcFirst(y2)),
      [WEEK + DAY]: (d, y2) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y2))
    };
    const utcInv = {
      [QUARTER]: (q) => 3 * q,
      [WEEK]: (w2, y2) => weekday(w2, 0, utcFirst(y2))
    };
    function utcFloor(units, step) {
      return floor(units, step || 1, utcGet, utcInv, utcDate);
    }
    const timeIntervals = {
      [YEAR]: timeYear,
      [QUARTER]: timeMonth.every(3),
      [MONTH]: timeMonth,
      [WEEK]: timeSunday,
      [DATE]: timeDay,
      [DAY]: timeDay,
      [DAYOFYEAR]: timeDay,
      [HOURS]: timeHour,
      [MINUTES]: timeMinute,
      [SECONDS]: second,
      [MILLISECONDS]: millisecond
    };
    const utcIntervals = {
      [YEAR]: utcYear,
      [QUARTER]: utcMonth.every(3),
      [MONTH]: utcMonth,
      [WEEK]: utcSunday,
      [DATE]: utcDay,
      [DAY]: utcDay,
      [DAYOFYEAR]: utcDay,
      [HOURS]: utcHour,
      [MINUTES]: utcMinute,
      [SECONDS]: second,
      [MILLISECONDS]: millisecond
    };
    function timeInterval(unit2) {
      return timeIntervals[unit2];
    }
    function utcInterval(unit2) {
      return utcIntervals[unit2];
    }
    function offset$3(ival, date2, step) {
      return ival ? ival.offset(date2, step) : void 0;
    }
    function timeOffset(unit2, date2, step) {
      return offset$3(timeInterval(unit2), date2, step);
    }
    function utcOffset(unit2, date2, step) {
      return offset$3(utcInterval(unit2), date2, step);
    }
    function sequence$1(ival, start2, stop2, step) {
      return ival ? ival.range(start2, stop2, step) : void 0;
    }
    function timeSequence(unit2, start2, stop2, step) {
      return sequence$1(timeInterval(unit2), start2, stop2, step);
    }
    function utcSequence(unit2, start2, stop2, step) {
      return sequence$1(utcInterval(unit2), start2, stop2, step);
    }
    const durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
    const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS], Seconds = Milli.slice(0, -1), Minutes = Seconds.slice(0, -1), Hours = Minutes.slice(0, -1), Day = Hours.slice(0, -1), Week = [YEAR, WEEK], Month = [YEAR, MONTH], Year = [YEAR];
    const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
    function bin$2(opt) {
      const ext = opt.extent, max2 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max2;
      let i = bisector((i2) => i2[2]).right(intervals, target2), units, step;
      if (i === intervals.length) {
        units = Year, step = tickStep(ext[0] / durationYear, ext[1] / durationYear, max2);
      } else if (i) {
        i = intervals[target2 / intervals[i - 1][2] < intervals[i][2] / target2 ? i - 1 : i];
        units = i[0];
        step = i[1];
      } else {
        units = Milli;
        step = Math.max(tickStep(ext[0], ext[1], max2), 1);
      }
      return {
        units,
        step
      };
    }
    function memoize(method2) {
      const cache2 = {};
      return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
    }
    function trimZeroes(numberFormat2, decimalChar) {
      return (x2) => {
        const str = numberFormat2(x2), dec = str.indexOf(decimalChar);
        if (dec < 0)
          return str;
        let idx = rightmostDigit(str, dec);
        const end = idx < str.length ? str.slice(idx) : "";
        while (--idx > dec)
          if (str[idx] !== "0") {
            ++idx;
            break;
          }
        return str.slice(0, idx) + end;
      };
    }
    function rightmostDigit(str, dec) {
      let i = str.lastIndexOf("e"), c2;
      if (i > 0)
        return i;
      for (i = str.length; --i > dec; ) {
        c2 = str.charCodeAt(i);
        if (c2 >= 48 && c2 <= 57)
          return i + 1;
      }
    }
    function numberLocale(locale2) {
      const format2 = memoize(locale2.format), formatPrefix2 = locale2.formatPrefix;
      return {
        format: format2,
        formatPrefix: formatPrefix2,
        formatFloat(spec) {
          const s = formatSpecifier(spec || ",");
          if (s.precision == null) {
            s.precision = 12;
            switch (s.type) {
              case "%":
                s.precision -= 2;
                break;
              case "e":
                s.precision -= 1;
                break;
            }
            return trimZeroes(
              format2(s),
              // number format
              format2(".1f")(1)[1]
              // decimal point character
            );
          } else {
            return format2(s);
          }
        },
        formatSpan(start2, stop2, count2, specifier) {
          specifier = formatSpecifier(specifier == null ? ",f" : specifier);
          const step = tickStep(start2, stop2, count2), value2 = Math.max(Math.abs(start2), Math.abs(stop2));
          let precision;
          if (specifier.precision == null) {
            switch (specifier.type) {
              case "s": {
                if (!isNaN(precision = precisionPrefix(step, value2))) {
                  specifier.precision = precision;
                }
                return formatPrefix2(specifier, value2);
              }
              case "":
              case "e":
              case "g":
              case "p":
              case "r": {
                if (!isNaN(precision = precisionRound(step, value2))) {
                  specifier.precision = precision - (specifier.type === "e");
                }
                break;
              }
              case "f":
              case "%": {
                if (!isNaN(precision = precisionFixed(step))) {
                  specifier.precision = precision - (specifier.type === "%") * 2;
                }
                break;
              }
            }
          }
          return format2(specifier);
        }
      };
    }
    let defaultNumberLocale;
    resetNumberFormatDefaultLocale();
    function resetNumberFormatDefaultLocale() {
      return defaultNumberLocale = numberLocale({
        format: format$3,
        formatPrefix
      });
    }
    function numberFormatLocale(definition2) {
      return numberLocale(formatLocale$1(definition2));
    }
    function numberFormatDefaultLocale(definition2) {
      return arguments.length ? defaultNumberLocale = numberFormatLocale(definition2) : defaultNumberLocale;
    }
    function timeMultiFormat(format2, interval2, spec) {
      spec = spec || {};
      if (!isObject(spec)) {
        error(`Invalid time multi-format specifier: ${spec}`);
      }
      const second2 = interval2(SECONDS), minute = interval2(MINUTES), hour = interval2(HOURS), day = interval2(DATE), week2 = interval2(WEEK), month = interval2(MONTH), quarter2 = interval2(QUARTER), year = interval2(YEAR), L = format2(spec[MILLISECONDS] || ".%L"), S = format2(spec[SECONDS] || ":%S"), M2 = format2(spec[MINUTES] || "%I:%M"), H = format2(spec[HOURS] || "%I %p"), d = format2(spec[DATE] || spec[DAY] || "%a %d"), w2 = format2(spec[WEEK] || "%b %d"), m2 = format2(spec[MONTH] || "%B"), q = format2(spec[QUARTER] || "%B"), y2 = format2(spec[YEAR] || "%Y");
      return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week2(date2) < date2 ? d : w2 : year(date2) < date2 ? quarter2(date2) < date2 ? m2 : q : y2)(date2);
    }
    function timeLocale(locale2) {
      const timeFormat2 = memoize(locale2.format), utcFormat2 = memoize(locale2.utcFormat);
      return {
        timeFormat: (spec) => isString(spec) ? timeFormat2(spec) : timeMultiFormat(timeFormat2, timeInterval, spec),
        utcFormat: (spec) => isString(spec) ? utcFormat2(spec) : timeMultiFormat(utcFormat2, utcInterval, spec),
        timeParse: memoize(locale2.parse),
        utcParse: memoize(locale2.utcParse)
      };
    }
    let defaultTimeLocale;
    resetTimeFormatDefaultLocale();
    function resetTimeFormatDefaultLocale() {
      return defaultTimeLocale = timeLocale({
        format: timeFormat$2,
        parse: timeParse$1,
        utcFormat: utcFormat$1,
        utcParse: utcParse$1
      });
    }
    function timeFormatLocale(definition2) {
      return timeLocale(formatLocale(definition2));
    }
    function timeFormatDefaultLocale(definition2) {
      return arguments.length ? defaultTimeLocale = timeFormatLocale(definition2) : defaultTimeLocale;
    }
    const createLocale = (number2, time2) => extend({}, number2, time2);
    function locale(numberSpec, timeSpec) {
      const number2 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
      const time2 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
      return createLocale(number2, time2);
    }
    function defaultLocale(numberSpec, timeSpec) {
      const args = arguments.length;
      if (args && args !== 2) {
        error("defaultLocale expects either zero or two arguments.");
      }
      return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
    }
    function resetDefaultLocale() {
      resetNumberFormatDefaultLocale();
      resetTimeFormatDefaultLocale();
      return defaultLocale();
    }
    const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
    const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
    const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
    const fileProtocol = "file://";
    function loaderFactory(fetch2, fs) {
      return (options) => ({
        options: options || {},
        sanitize,
        load: load$1,
        fileAccess: !!fs,
        file: fileLoader(fs),
        http: httpLoader(fetch2)
      });
    }
    async function load$1(uri, options) {
      const opt = await this.sanitize(uri, options), url = opt.href;
      return opt.localFile ? this.file(url) : this.http(url, options);
    }
    async function sanitize(uri, options) {
      options = extend({}, this.options, options);
      const fileAccess = this.fileAccess, result = {
        href: null
      };
      let isFile, loadFile, base2;
      const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
      if (uri == null || typeof uri !== "string" || !isAllowed) {
        error("Sanitize failure, invalid URI: " + $(uri));
      }
      const hasProtocol = protocol_re.test(uri);
      if ((base2 = options.baseURL) && !hasProtocol) {
        if (!uri.startsWith("/") && !base2.endsWith("/")) {
          uri = "/" + uri;
        }
        uri = base2 + uri;
      }
      loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
      if (isFile) {
        uri = uri.slice(fileProtocol.length);
      } else if (uri.startsWith("//")) {
        if (options.defaultProtocol === "file") {
          uri = uri.slice(2);
          loadFile = true;
        } else {
          uri = (options.defaultProtocol || "http") + ":" + uri;
        }
      }
      Object.defineProperty(result, "localFile", {
        value: !!loadFile
      });
      result.href = uri;
      if (options.target) {
        result.target = options.target + "";
      }
      if (options.rel) {
        result.rel = options.rel + "";
      }
      if (options.context === "image" && options.crossOrigin) {
        result.crossOrigin = options.crossOrigin + "";
      }
      return result;
    }
    function fileLoader(fs) {
      return fs ? (filename) => new Promise((accept, reject) => {
        fs.readFile(filename, (error2, data2) => {
          if (error2)
            reject(error2);
          else
            accept(data2);
        });
      }) : fileReject;
    }
    async function fileReject() {
      error("No file system access.");
    }
    function httpLoader(fetch2) {
      return fetch2 ? async function(url, options) {
        const opt = extend({}, this.options.http, options), type2 = options && options.response, response = await fetch2(url, opt);
        return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type2]) ? response[type2]() : response.text();
      } : httpReject;
    }
    async function httpReject() {
      error("No HTTP fetch method available.");
    }
    const isValid = (_) => _ != null && _ === _;
    const isBoolean$1 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
    const isDate = (_) => !Number.isNaN(Date.parse(_));
    const isNumber = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
    const isInteger = (_) => isNumber(_) && Number.isInteger(+_);
    const typeParsers = {
      boolean: toBoolean,
      integer: toNumber,
      number: toNumber,
      date: toDate,
      string: toString,
      unknown: identity$1
    };
    const typeTests = [isBoolean$1, isInteger, isNumber, isDate];
    const typeList = ["boolean", "integer", "number", "date"];
    function inferType(values2, field2) {
      if (!values2 || !values2.length)
        return "unknown";
      const n = values2.length, m2 = typeTests.length, a2 = typeTests.map((_, i) => i + 1);
      for (let i = 0, t4 = 0, j, value2; i < n; ++i) {
        value2 = field2 ? values2[i][field2] : values2[i];
        for (j = 0; j < m2; ++j) {
          if (a2[j] && isValid(value2) && !typeTests[j](value2)) {
            a2[j] = 0;
            ++t4;
            if (t4 === typeTests.length)
              return "string";
          }
        }
      }
      return typeList[a2.reduce((u2, v) => u2 === 0 ? v : u2, 0) - 1];
    }
    function inferTypes(data2, fields) {
      return fields.reduce((types2, field2) => {
        types2[field2] = inferType(data2, field2);
        return types2;
      }, {});
    }
    function delimitedFormat(delimiter) {
      const parse2 = function(data2, format2) {
        const delim = {
          delimiter
        };
        return dsv(data2, format2 ? extend(format2, delim) : delim);
      };
      parse2.responseType = "text";
      return parse2;
    }
    function dsv(data2, format2) {
      if (format2.header) {
        data2 = format2.header.map($).join(format2.delimiter) + "\n" + data2;
      }
      return dsvFormat(format2.delimiter).parse(data2 + "");
    }
    dsv.responseType = "text";
    function isBuffer(_) {
      return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
    }
    function json(data2, format2) {
      const prop = format2 && format2.property ? field$1(format2.property) : identity$1;
      return isObject(data2) && !isBuffer(data2) ? parseJSON(prop(data2), format2) : prop(JSON.parse(data2));
    }
    json.responseType = "json";
    function parseJSON(data2, format2) {
      if (!isArray(data2) && isIterable(data2)) {
        data2 = [...data2];
      }
      return format2 && format2.copy ? JSON.parse(JSON.stringify(data2)) : data2;
    }
    const filters = {
      interior: (a2, b2) => a2 !== b2,
      exterior: (a2, b2) => a2 === b2
    };
    function topojson(data2, format2) {
      let method2, object2, property2, filter2;
      data2 = json(data2, format2);
      if (format2 && format2.feature) {
        method2 = feature;
        property2 = format2.feature;
      } else if (format2 && format2.mesh) {
        method2 = mesh;
        property2 = format2.mesh;
        filter2 = filters[format2.filter];
      } else {
        error("Missing TopoJSON feature or mesh parameter.");
      }
      object2 = (object2 = data2.objects[property2]) ? method2(data2, object2, filter2) : error("Invalid TopoJSON object: " + property2);
      return object2 && object2.features || [object2];
    }
    topojson.responseType = "json";
    const format$2 = {
      dsv,
      csv: delimitedFormat(","),
      tsv: delimitedFormat("	"),
      json,
      topojson
    };
    function formats$1(name2, reader) {
      if (arguments.length > 1) {
        format$2[name2] = reader;
        return this;
      } else {
        return has$1(format$2, name2) ? format$2[name2] : null;
      }
    }
    function responseType(type2) {
      const f = formats$1(type2);
      return f && f.responseType || "text";
    }
    function read(data2, schema, timeParser, utcParser) {
      schema = schema || {};
      const reader = formats$1(schema.type || "json");
      if (!reader)
        error("Unknown data format type: " + schema.type);
      data2 = reader(data2, schema);
      if (schema.parse)
        parse$6(data2, schema.parse, timeParser, utcParser);
      if (has$1(data2, "columns"))
        delete data2.columns;
      return data2;
    }
    function parse$6(data2, types2, timeParser, utcParser) {
      if (!data2.length)
        return;
      const locale2 = timeFormatDefaultLocale();
      timeParser = timeParser || locale2.timeParse;
      utcParser = utcParser || locale2.utcParse;
      let fields = data2.columns || Object.keys(data2[0]), datum2, field2, i, j, n, m2;
      if (types2 === "auto")
        types2 = inferTypes(data2, fields);
      fields = Object.keys(types2);
      const parsers = fields.map((field3) => {
        const type2 = types2[field3];
        let parts, pattern;
        if (type2 && (type2.startsWith("date:") || type2.startsWith("utc:"))) {
          parts = type2.split(/:(.+)?/, 2);
          pattern = parts[1];
          if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
            pattern = pattern.slice(1, -1);
          }
          const parse2 = parts[0] === "utc" ? utcParser : timeParser;
          return parse2(pattern);
        }
        if (!typeParsers[type2]) {
          throw Error("Illegal format pattern: " + field3 + ":" + type2);
        }
        return typeParsers[type2];
      });
      for (i = 0, n = data2.length, m2 = fields.length; i < n; ++i) {
        datum2 = data2[i];
        for (j = 0; j < m2; ++j) {
          field2 = fields[j];
          datum2[field2] = parsers[j](datum2[field2]);
        }
      }
    }
    const loader = loaderFactory(
      typeof fetch !== "undefined" && fetch,
      // use built-in fetch API
      null
      // no file system access
    );
    function UniqueList(idFunc) {
      const $2 = idFunc || identity$1, list2 = [], ids = {};
      list2.add = (_) => {
        const id2 = $2(_);
        if (!ids[id2]) {
          ids[id2] = 1;
          list2.push(_);
        }
        return list2;
      };
      list2.remove = (_) => {
        const id2 = $2(_);
        if (ids[id2]) {
          ids[id2] = 0;
          const idx = list2.indexOf(_);
          if (idx >= 0)
            list2.splice(idx, 1);
        }
        return list2;
      };
      return list2;
    }
    async function asyncCallback(df, callback) {
      try {
        await callback(df);
      } catch (err) {
        df.error(err);
      }
    }
    const TUPLE_ID_KEY = Symbol("vega_id");
    let TUPLE_ID = 1;
    function isTuple(t4) {
      return !!(t4 && tupleid(t4));
    }
    function tupleid(t4) {
      return t4[TUPLE_ID_KEY];
    }
    function setid(t4, id2) {
      t4[TUPLE_ID_KEY] = id2;
      return t4;
    }
    function ingest$1(datum2) {
      const t4 = datum2 === Object(datum2) ? datum2 : {
        data: datum2
      };
      return tupleid(t4) ? t4 : setid(t4, TUPLE_ID++);
    }
    function derive(t4) {
      return rederive(t4, ingest$1({}));
    }
    function rederive(t4, d) {
      for (const k in t4)
        d[k] = t4[k];
      return d;
    }
    function replace$1(t4, d) {
      return setid(d, tupleid(t4));
    }
    function stableCompare(cmp2, f) {
      return !cmp2 ? null : f ? (a2, b2) => cmp2(a2, b2) || tupleid(f(a2)) - tupleid(f(b2)) : (a2, b2) => cmp2(a2, b2) || tupleid(a2) - tupleid(b2);
    }
    function isChangeSet(v) {
      return v && v.constructor === changeset;
    }
    function changeset() {
      const add2 = [], rem2 = [], mod = [], remp = [], modp = [];
      let clean = null, reflow2 = false;
      return {
        constructor: changeset,
        insert(t4) {
          const d = array$2(t4), n = d.length;
          for (let i = 0; i < n; ++i)
            add2.push(d[i]);
          return this;
        },
        remove(t4) {
          const a2 = isFunction(t4) ? remp : rem2, d = array$2(t4), n = d.length;
          for (let i = 0; i < n; ++i)
            a2.push(d[i]);
          return this;
        },
        modify(t4, field2, value2) {
          const m2 = {
            field: field2,
            value: constant$1(value2)
          };
          if (isFunction(t4)) {
            m2.filter = t4;
            modp.push(m2);
          } else {
            m2.tuple = t4;
            mod.push(m2);
          }
          return this;
        },
        encode(t4, set2) {
          if (isFunction(t4))
            modp.push({
              filter: t4,
              field: set2
            });
          else
            mod.push({
              tuple: t4,
              field: set2
            });
          return this;
        },
        clean(value2) {
          clean = value2;
          return this;
        },
        reflow() {
          reflow2 = true;
          return this;
        },
        pulse(pulse2, tuples) {
          const cur = {}, out = {};
          let i, n, m2, f, t4, id2;
          for (i = 0, n = tuples.length; i < n; ++i) {
            cur[tupleid(tuples[i])] = 1;
          }
          for (i = 0, n = rem2.length; i < n; ++i) {
            t4 = rem2[i];
            cur[tupleid(t4)] = -1;
          }
          for (i = 0, n = remp.length; i < n; ++i) {
            f = remp[i];
            tuples.forEach((t5) => {
              if (f(t5))
                cur[tupleid(t5)] = -1;
            });
          }
          for (i = 0, n = add2.length; i < n; ++i) {
            t4 = add2[i];
            id2 = tupleid(t4);
            if (cur[id2]) {
              cur[id2] = 1;
            } else {
              pulse2.add.push(ingest$1(add2[i]));
            }
          }
          for (i = 0, n = tuples.length; i < n; ++i) {
            t4 = tuples[i];
            if (cur[tupleid(t4)] < 0)
              pulse2.rem.push(t4);
          }
          function modify2(t5, f2, v) {
            if (v) {
              t5[f2] = v(t5);
            } else {
              pulse2.encode = f2;
            }
            if (!reflow2)
              out[tupleid(t5)] = t5;
          }
          for (i = 0, n = mod.length; i < n; ++i) {
            m2 = mod[i];
            t4 = m2.tuple;
            f = m2.field;
            id2 = cur[tupleid(t4)];
            if (id2 > 0) {
              modify2(t4, f, m2.value);
              pulse2.modifies(f);
            }
          }
          for (i = 0, n = modp.length; i < n; ++i) {
            m2 = modp[i];
            f = m2.filter;
            tuples.forEach((t5) => {
              if (f(t5) && cur[tupleid(t5)] > 0) {
                modify2(t5, m2.field, m2.value);
              }
            });
            pulse2.modifies(m2.field);
          }
          if (reflow2) {
            pulse2.mod = rem2.length || remp.length ? tuples.filter((t5) => cur[tupleid(t5)] > 0) : tuples.slice();
          } else {
            for (id2 in out)
              pulse2.mod.push(out[id2]);
          }
          if (clean || clean == null && (rem2.length || remp.length)) {
            pulse2.clean(true);
          }
          return pulse2;
        }
      };
    }
    const CACHE$1 = "_:mod:_";
    function Parameters() {
      Object.defineProperty(this, CACHE$1, {
        writable: true,
        value: {}
      });
    }
    Parameters.prototype = {
      /**
       * Set a parameter value. If the parameter value changes, the parameter
       * will be recorded as modified.
       * @param {string} name - The parameter name.
       * @param {number} index - The index into an array-value parameter. Ignored if
       *   the argument is undefined, null or less than zero.
       * @param {*} value - The parameter value to set.
       * @param {boolean} [force=false] - If true, records the parameter as modified
       *   even if the value is unchanged.
       * @return {Parameters} - This parameter object.
       */
      set(name2, index2, value2, force2) {
        const o = this, v = o[name2], mod = o[CACHE$1];
        if (index2 != null && index2 >= 0) {
          if (v[index2] !== value2 || force2) {
            v[index2] = value2;
            mod[index2 + ":" + name2] = -1;
            mod[name2] = -1;
          }
        } else if (v !== value2 || force2) {
          o[name2] = value2;
          mod[name2] = isArray(value2) ? 1 + value2.length : -1;
        }
        return o;
      },
      /**
       * Tests if one or more parameters has been modified. If invoked with no
       * arguments, returns true if any parameter value has changed. If the first
       * argument is array, returns trues if any parameter name in the array has
       * changed. Otherwise, tests if the given name and optional array index has
       * changed.
       * @param {string} name - The parameter name to test.
       * @param {number} [index=undefined] - The parameter array index to test.
       * @return {boolean} - Returns true if a queried parameter was modified.
       */
      modified(name2, index2) {
        const mod = this[CACHE$1];
        if (!arguments.length) {
          for (const k in mod) {
            if (mod[k])
              return true;
          }
          return false;
        } else if (isArray(name2)) {
          for (let k = 0; k < name2.length; ++k) {
            if (mod[name2[k]])
              return true;
          }
          return false;
        }
        return index2 != null && index2 >= 0 ? index2 + 1 < mod[name2] || !!mod[index2 + ":" + name2] : !!mod[name2];
      },
      /**
       * Clears the modification records. After calling this method,
       * all parameters are considered unmodified.
       */
      clear() {
        this[CACHE$1] = {};
        return this;
      }
    };
    let OP_ID = 0;
    const PULSE = "pulse", NO_PARAMS = new Parameters();
    const SKIP$1$1 = 1, MODIFIED = 2;
    function Operator(init2, update2, params2, react) {
      this.id = ++OP_ID;
      this.value = init2;
      this.stamp = -1;
      this.rank = -1;
      this.qrank = -1;
      this.flags = 0;
      if (update2) {
        this._update = update2;
      }
      if (params2)
        this.parameters(params2, react);
    }
    function flag(bit) {
      return function(state) {
        const f = this.flags;
        if (arguments.length === 0)
          return !!(f & bit);
        this.flags = state ? f | bit : f & ~bit;
        return this;
      };
    }
    Operator.prototype = {
      /**
       * Returns a list of target operators dependent on this operator.
       * If this list does not exist, it is created and then returned.
       * @return {UniqueList}
       */
      targets() {
        return this._targets || (this._targets = UniqueList(id));
      },
      /**
       * Sets the value of this operator.
       * @param {*} value - the value to set.
       * @return {Number} Returns 1 if the operator value has changed
       *   according to strict equality, returns 0 otherwise.
       */
      set(value2) {
        if (this.value !== value2) {
          this.value = value2;
          return 1;
        } else {
          return 0;
        }
      },
      /**
       * Indicates that operator evaluation should be skipped on the next pulse.
       * This operator will still propagate incoming pulses, but its update function
       * will not be invoked. The skip flag is reset after every pulse, so calling
       * this method will affect processing of the next pulse only.
       */
      skip: flag(SKIP$1$1),
      /**
       * Indicates that this operator's value has been modified on its most recent
       * pulse. Normally modification is checked via strict equality; however, in
       * some cases it is more efficient to update the internal state of an object.
       * In those cases, the modified flag can be used to trigger propagation. Once
       * set, the modification flag persists across pulses until unset. The flag can
       * be used with the last timestamp to test if a modification is recent.
       */
      modified: flag(MODIFIED),
      /**
       * Sets the parameters for this operator. The parameter values are analyzed for
       * operator instances. If found, this operator will be added as a dependency
       * of the parameterizing operator. Operator values are dynamically marshalled
       * from each operator parameter prior to evaluation. If a parameter value is
       * an array, the array will also be searched for Operator instances. However,
       * the search does not recurse into sub-arrays or object properties.
       * @param {object} params - A hash of operator parameters.
       * @param {boolean} [react=true] - A flag indicating if this operator should
       *   automatically update (react) when parameter values change. In other words,
       *   this flag determines if the operator registers itself as a listener on
       *   any upstream operators included in the parameters.
       * @param {boolean} [initonly=false] - A flag indicating if this operator
       *   should calculate an update only upon its initial evaluation, then
       *   deregister dependencies and suppress all future update invocations.
       * @return {Operator[]} - An array of upstream dependencies.
       */
      parameters(params2, react, initonly) {
        react = react !== false;
        const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
        let name2, value2, n, i;
        const add2 = (name3, index2, value3) => {
          if (value3 instanceof Operator) {
            if (value3 !== this) {
              if (react)
                value3.targets().add(this);
              deps.push(value3);
            }
            argops.push({
              op: value3,
              name: name3,
              index: index2
            });
          } else {
            argval.set(name3, index2, value3);
          }
        };
        for (name2 in params2) {
          value2 = params2[name2];
          if (name2 === PULSE) {
            array$2(value2).forEach((op) => {
              if (!(op instanceof Operator)) {
                error("Pulse parameters must be operator instances.");
              } else if (op !== this) {
                op.targets().add(this);
                deps.push(op);
              }
            });
            this.source = value2;
          } else if (isArray(value2)) {
            argval.set(name2, -1, Array(n = value2.length));
            for (i = 0; i < n; ++i)
              add2(name2, i, value2[i]);
          } else {
            add2(name2, -1, value2);
          }
        }
        this.marshall().clear();
        if (initonly)
          argops.initonly = true;
        return deps;
      },
      /**
       * Internal method for marshalling parameter values.
       * Visits each operator dependency to pull the latest value.
       * @return {Parameters} A Parameters object to pass to the update function.
       */
      marshall(stamp) {
        const argval = this._argval || NO_PARAMS, argops = this._argops;
        let item, i, op, mod;
        if (argops) {
          const n = argops.length;
          for (i = 0; i < n; ++i) {
            item = argops[i];
            op = item.op;
            mod = op.modified() && op.stamp === stamp;
            argval.set(item.name, item.index, op.value, mod);
          }
          if (argops.initonly) {
            for (i = 0; i < n; ++i) {
              item = argops[i];
              item.op.targets().remove(this);
            }
            this._argops = null;
            this._update = null;
          }
        }
        return argval;
      },
      /**
       * Detach this operator from the dataflow.
       * Unregisters listeners on upstream dependencies.
       */
      detach() {
        const argops = this._argops;
        let i, n, item, op;
        if (argops) {
          for (i = 0, n = argops.length; i < n; ++i) {
            item = argops[i];
            op = item.op;
            if (op._targets) {
              op._targets.remove(this);
            }
          }
        }
        this.pulse = null;
        this.source = null;
      },
      /**
       * Delegate method to perform operator processing.
       * Subclasses can override this method to perform custom processing.
       * By default, it marshalls parameters and calls the update function
       * if that function is defined. If the update function does not
       * change the operator value then StopPropagation is returned.
       * If no update function is defined, this method does nothing.
       * @param {Pulse} pulse - the current dataflow pulse.
       * @return The output pulse or StopPropagation. A falsy return value
       *   (including undefined) will let the input pulse pass through.
       */
      evaluate(pulse2) {
        const update2 = this._update;
        if (update2) {
          const params2 = this.marshall(pulse2.stamp), v = update2.call(this, params2, pulse2);
          params2.clear();
          if (v !== this.value) {
            this.value = v;
          } else if (!this.modified()) {
            return pulse2.StopPropagation;
          }
        }
      },
      /**
       * Run this operator for the current pulse. If this operator has already
       * been run at (or after) the pulse timestamp, returns StopPropagation.
       * Internally, this method calls {@link evaluate} to perform processing.
       * If {@link evaluate} returns a falsy value, the input pulse is returned.
       * This method should NOT be overridden, instead overrride {@link evaluate}.
       * @param {Pulse} pulse - the current dataflow pulse.
       * @return the output pulse for this operator (or StopPropagation)
       */
      run(pulse2) {
        if (pulse2.stamp < this.stamp)
          return pulse2.StopPropagation;
        let rv;
        if (this.skip()) {
          this.skip(false);
          rv = 0;
        } else {
          rv = this.evaluate(pulse2);
        }
        return this.pulse = rv || pulse2;
      }
    };
    function add$3(init2, update2, params2, react) {
      let shift2 = 1, op;
      if (init2 instanceof Operator) {
        op = init2;
      } else if (init2 && init2.prototype instanceof Operator) {
        op = new init2();
      } else if (isFunction(init2)) {
        op = new Operator(null, init2);
      } else {
        shift2 = 0;
        op = new Operator(init2, update2);
      }
      this.rank(op);
      if (shift2) {
        react = params2;
        params2 = update2;
      }
      if (params2)
        this.connect(op, op.parameters(params2, react));
      this.touch(op);
      return op;
    }
    function connect(target2, sources) {
      const targetRank = target2.rank, n = sources.length;
      for (let i = 0; i < n; ++i) {
        if (targetRank < sources[i].rank) {
          this.rerank(target2);
          return;
        }
      }
    }
    let STREAM_ID = 0;
    function EventStream(filter2, apply2, receive) {
      this.id = ++STREAM_ID;
      this.value = null;
      if (receive)
        this.receive = receive;
      if (filter2)
        this._filter = filter2;
      if (apply2)
        this._apply = apply2;
    }
    function stream(filter2, apply2, receive) {
      return new EventStream(filter2, apply2, receive);
    }
    EventStream.prototype = {
      _filter: truthy,
      _apply: identity$1,
      targets() {
        return this._targets || (this._targets = UniqueList(id));
      },
      consume(_) {
        if (!arguments.length)
          return !!this._consume;
        this._consume = !!_;
        return this;
      },
      receive(evt) {
        if (this._filter(evt)) {
          const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
          for (let i = 0; i < n; ++i)
            trg[i].receive(val);
          if (this._consume) {
            evt.preventDefault();
            evt.stopPropagation();
          }
        }
      },
      filter(filter2) {
        const s = stream(filter2);
        this.targets().add(s);
        return s;
      },
      apply(apply2) {
        const s = stream(null, apply2);
        this.targets().add(s);
        return s;
      },
      merge() {
        const s = stream();
        this.targets().add(s);
        for (let i = 0, n = arguments.length; i < n; ++i) {
          arguments[i].targets().add(s);
        }
        return s;
      },
      throttle(pause2) {
        let t4 = -1;
        return this.filter(() => {
          const now2 = Date.now();
          if (now2 - t4 > pause2) {
            t4 = now2;
            return 1;
          } else {
            return 0;
          }
        });
      },
      debounce(delay2) {
        const s = stream();
        this.targets().add(stream(null, null, debounce(delay2, (e3) => {
          const df = e3.dataflow;
          s.receive(e3);
          if (df && df.run)
            df.run();
        })));
        return s;
      },
      between(a2, b2) {
        let active = false;
        a2.targets().add(stream(null, null, () => active = true));
        b2.targets().add(stream(null, null, () => active = false));
        return this.filter(() => active);
      },
      detach() {
        this._filter = truthy;
        this._targets = null;
      }
    };
    function events$1(source2, type2, filter2, apply2) {
      const df = this, s = stream(filter2, apply2), send2 = function(e3) {
        e3.dataflow = df;
        try {
          s.receive(e3);
        } catch (error2) {
          df.error(error2);
        } finally {
          df.run();
        }
      };
      let sources;
      if (typeof source2 === "string" && typeof document !== "undefined") {
        sources = document.querySelectorAll(source2);
      } else {
        sources = array$2(source2);
      }
      const n = sources.length;
      for (let i = 0; i < n; ++i) {
        sources[i].addEventListener(type2, send2);
      }
      return s;
    }
    function parse$5(data2, format2) {
      const locale2 = this.locale();
      return read(data2, format2, locale2.timeParse, locale2.utcParse);
    }
    function ingest(target2, data2, format2) {
      data2 = this.parse(data2, format2);
      return this.pulse(target2, this.changeset().insert(data2));
    }
    async function request(url, format2) {
      const df = this;
      let status = 0, data2;
      try {
        data2 = await df.loader().load(url, {
          context: "dataflow",
          response: responseType(format2 && format2.type)
        });
        try {
          data2 = df.parse(data2, format2);
        } catch (err) {
          status = -2;
          df.warn("Data ingestion failed", url, err);
        }
      } catch (err) {
        status = -1;
        df.warn("Loading failed", url, err);
      }
      return {
        data: data2,
        status
      };
    }
    async function preload(target2, url, format2) {
      const df = this, pending = df._pending || loadPending(df);
      pending.requests += 1;
      const res = await df.request(url, format2);
      df.pulse(target2, df.changeset().remove(truthy).insert(res.data || []));
      pending.done();
      return res;
    }
    function loadPending(df) {
      let accept;
      const pending = new Promise((a2) => accept = a2);
      pending.requests = 0;
      pending.done = () => {
        if (--pending.requests === 0) {
          df._pending = null;
          accept(df);
        }
      };
      return df._pending = pending;
    }
    const SKIP$2 = {
      skip: true
    };
    function on(source2, target2, update2, params2, options) {
      const fn = source2 instanceof Operator ? onOperator : onStream;
      fn(this, source2, target2, update2, params2, options);
      return this;
    }
    function onStream(df, stream2, target2, update2, params2, options) {
      const opt = extend({}, options, SKIP$2);
      let func2, op;
      if (!isFunction(target2))
        target2 = constant$1(target2);
      if (update2 === void 0) {
        func2 = (e3) => df.touch(target2(e3));
      } else if (isFunction(update2)) {
        op = new Operator(null, update2, params2, false);
        func2 = (e3) => {
          op.evaluate(e3);
          const t4 = target2(e3), v = op.value;
          isChangeSet(v) ? df.pulse(t4, v, options) : df.update(t4, v, opt);
        };
      } else {
        func2 = (e3) => df.update(target2(e3), update2, opt);
      }
      stream2.apply(func2);
    }
    function onOperator(df, source2, target2, update2, params2, options) {
      if (update2 === void 0) {
        source2.targets().add(target2);
      } else {
        const opt = options || {}, op = new Operator(null, updater(target2, update2), params2, false);
        op.modified(opt.force);
        op.rank = source2.rank;
        source2.targets().add(op);
        if (target2) {
          op.skip(true);
          op.value = target2.value;
          op.targets().add(target2);
          df.connect(target2, [op]);
        }
      }
    }
    function updater(target2, update2) {
      update2 = isFunction(update2) ? update2 : constant$1(update2);
      return target2 ? function(_, pulse2) {
        const value2 = update2(_, pulse2);
        if (!target2.skip()) {
          target2.skip(value2 !== this.value).value = value2;
        }
        return value2;
      } : update2;
    }
    function rank(op) {
      op.rank = ++this._rank;
    }
    function rerank(op) {
      const queue = [op];
      let cur, list2, i;
      while (queue.length) {
        this.rank(cur = queue.pop());
        if (list2 = cur._targets) {
          for (i = list2.length; --i >= 0; ) {
            queue.push(cur = list2[i]);
            if (cur === op)
              error("Cycle detected in dataflow graph.");
          }
        }
      }
    }
    const StopPropagation = {};
    const ADD = 1 << 0, REM = 1 << 1, MOD$1 = 1 << 2, ADD_REM = ADD | REM, ADD_MOD = ADD | MOD$1, ALL = ADD | REM | MOD$1, REFLOW = 1 << 3, SOURCE = 1 << 4, NO_SOURCE = 1 << 5, NO_FIELDS = 1 << 6;
    function Pulse(dataflow, stamp, encode2) {
      this.dataflow = dataflow;
      this.stamp = stamp == null ? -1 : stamp;
      this.add = [];
      this.rem = [];
      this.mod = [];
      this.fields = null;
      this.encode = encode2 || null;
    }
    function materialize(data2, filter2) {
      const out = [];
      visitArray(data2, filter2, (_) => out.push(_));
      return out;
    }
    function filter$1(pulse2, flags) {
      const map2 = {};
      pulse2.visit(flags, (t4) => {
        map2[tupleid(t4)] = 1;
      });
      return (t4) => map2[tupleid(t4)] ? null : t4;
    }
    function addFilter(a2, b2) {
      return a2 ? (t4, i) => a2(t4, i) && b2(t4, i) : b2;
    }
    Pulse.prototype = {
      /**
       * Sentinel value indicating pulse propagation should stop.
       */
      StopPropagation,
      /**
       * Boolean flag indicating ADD (added) tuples.
       */
      ADD,
      /**
       * Boolean flag indicating REM (removed) tuples.
       */
      REM,
      /**
       * Boolean flag indicating MOD (modified) tuples.
       */
      MOD: MOD$1,
      /**
       * Boolean flag indicating ADD (added) and REM (removed) tuples.
       */
      ADD_REM,
      /**
       * Boolean flag indicating ADD (added) and MOD (modified) tuples.
       */
      ADD_MOD,
      /**
       * Boolean flag indicating ADD, REM and MOD tuples.
       */
      ALL,
      /**
       * Boolean flag indicating all tuples in a data source
       * except for the ADD, REM and MOD tuples.
       */
      REFLOW,
      /**
       * Boolean flag indicating a 'pass-through' to a
       * backing data source, ignoring ADD, REM and MOD tuples.
       */
      SOURCE,
      /**
       * Boolean flag indicating that source data should be
       * suppressed when creating a forked pulse.
       */
      NO_SOURCE,
      /**
       * Boolean flag indicating that field modifications should be
       * suppressed when creating a forked pulse.
       */
      NO_FIELDS,
      /**
       * Creates a new pulse based on the values of this pulse.
       * The dataflow, time stamp and field modification values are copied over.
       * By default, new empty ADD, REM and MOD arrays are created.
       * @param {number} flags - Integer of boolean flags indicating which (if any)
       *   tuple arrays should be copied to the new pulse. The supported flag values
       *   are ADD, REM and MOD. Array references are copied directly: new array
       *   instances are not created.
       * @return {Pulse} - The forked pulse instance.
       * @see init
       */
      fork(flags) {
        return new Pulse(this.dataflow).init(this, flags);
      },
      /**
       * Creates a copy of this pulse with new materialized array
       * instances for the ADD, REM, MOD, and SOURCE arrays.
       * The dataflow, time stamp and field modification values are copied over.
       * @return {Pulse} - The cloned pulse instance.
       * @see init
       */
      clone() {
        const p = this.fork(ALL);
        p.add = p.add.slice();
        p.rem = p.rem.slice();
        p.mod = p.mod.slice();
        if (p.source)
          p.source = p.source.slice();
        return p.materialize(ALL | SOURCE);
      },
      /**
       * Returns a pulse that adds all tuples from a backing source. This is
       * useful for cases where operators are added to a dataflow after an
       * upstream data pipeline has already been processed, ensuring that
       * new operators can observe all tuples within a stream.
       * @return {Pulse} - A pulse instance with all source tuples included
       *   in the add array. If the current pulse already has all source
       *   tuples in its add array, it is returned directly. If the current
       *   pulse does not have a backing source, it is returned directly.
       */
      addAll() {
        let p = this;
        const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
        if (reuse) {
          return p;
        } else {
          p = new Pulse(this.dataflow).init(this);
          p.add = p.source;
          p.rem = [];
          return p;
        }
      },
      /**
       * Initialize this pulse based on the values of another pulse. This method
       * is used internally by {@link fork} to initialize a new forked tuple.
       * The dataflow, time stamp and field modification values are copied over.
       * By default, new empty ADD, REM and MOD arrays are created.
       * @param {Pulse} src - The source pulse to copy from.
       * @param {number} flags - Integer of boolean flags indicating which (if any)
       *   tuple arrays should be copied to the new pulse. The supported flag values
       *   are ADD, REM and MOD. Array references are copied directly: new array
       *   instances are not created. By default, source data arrays are copied
       *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
       * @return {Pulse} - Returns this Pulse instance.
       */
      init(src, flags) {
        const p = this;
        p.stamp = src.stamp;
        p.encode = src.encode;
        if (src.fields && !(flags & NO_FIELDS)) {
          p.fields = src.fields;
        }
        if (flags & ADD) {
          p.addF = src.addF;
          p.add = src.add;
        } else {
          p.addF = null;
          p.add = [];
        }
        if (flags & REM) {
          p.remF = src.remF;
          p.rem = src.rem;
        } else {
          p.remF = null;
          p.rem = [];
        }
        if (flags & MOD$1) {
          p.modF = src.modF;
          p.mod = src.mod;
        } else {
          p.modF = null;
          p.mod = [];
        }
        if (flags & NO_SOURCE) {
          p.srcF = null;
          p.source = null;
        } else {
          p.srcF = src.srcF;
          p.source = src.source;
          if (src.cleans)
            p.cleans = src.cleans;
        }
        return p;
      },
      /**
       * Schedules a function to run after pulse propagation completes.
       * @param {function} func - The function to run.
       */
      runAfter(func2) {
        this.dataflow.runAfter(func2);
      },
      /**
       * Indicates if tuples have been added, removed or modified.
       * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
       *   Defaults to ALL, returning true if any tuple type has changed.
       * @return {boolean} - Returns true if one or more queried tuple types have
       *   changed, false otherwise.
       */
      changed(flags) {
        const f = flags || ALL;
        return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD$1 && this.mod.length;
      },
      /**
       * Forces a "reflow" of tuple values, such that all tuples in the backing
       * source are added to the MOD set, unless already present in the ADD set.
       * @param {boolean} [fork=false] - If true, returns a forked copy of this
       *   pulse, and invokes reflow on that derived pulse.
       * @return {Pulse} - The reflowed pulse instance.
       */
      reflow(fork) {
        if (fork)
          return this.fork(ALL).reflow();
        const len = this.add.length, src = this.source && this.source.length;
        if (src && src !== len) {
          this.mod = this.source;
          if (len)
            this.filter(MOD$1, filter$1(this, ADD));
        }
        return this;
      },
      /**
       * Get/set metadata to pulse requesting garbage collection
       * to reclaim currently unused resources.
       */
      clean(value2) {
        if (arguments.length) {
          this.cleans = !!value2;
          return this;
        } else {
          return this.cleans;
        }
      },
      /**
       * Marks one or more data field names as modified to assist dependency
       * tracking and incremental processing by transform operators.
       * @param {string|Array<string>} _ - The field(s) to mark as modified.
       * @return {Pulse} - This pulse instance.
       */
      modifies(_) {
        const hash2 = this.fields || (this.fields = {});
        if (isArray(_)) {
          _.forEach((f) => hash2[f] = true);
        } else {
          hash2[_] = true;
        }
        return this;
      },
      /**
       * Checks if one or more data fields have been modified during this pulse
       * propagation timestamp.
       * @param {string|Array<string>} _ - The field(s) to check for modified.
       * @param {boolean} nomod - If true, will check the modified flag even if
       *   no mod tuples exist. If false (default), mod tuples must be present.
       * @return {boolean} - Returns true if any of the provided fields has been
       *   marked as modified, false otherwise.
       */
      modified(_, nomod) {
        const fields = this.fields;
        return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some((f) => fields[f]) : fields[_];
      },
      /**
       * Adds a filter function to one more tuple sets. Filters are applied to
       * backing tuple arrays, to determine the actual set of tuples considered
       * added, removed or modified. They can be used to delay materialization of
       * a tuple set in order to avoid expensive array copies. In addition, the
       * filter functions can serve as value transformers: unlike standard predicate
       * function (which return boolean values), Pulse filters should return the
       * actual tuple value to process. If a tuple set is already filtered, the
       * new filter function will be appended into a conjuntive ('and') query.
       * @param {number} flags - Flags indicating the tuple set(s) to filter.
       * @param {function(*):object} filter - Filter function that will be applied
       *   to the tuple set array, and should return a data tuple if the value
       *   should be included in the tuple set, and falsy (or null) otherwise.
       * @return {Pulse} - Returns this pulse instance.
       */
      filter(flags, filter2) {
        const p = this;
        if (flags & ADD)
          p.addF = addFilter(p.addF, filter2);
        if (flags & REM)
          p.remF = addFilter(p.remF, filter2);
        if (flags & MOD$1)
          p.modF = addFilter(p.modF, filter2);
        if (flags & SOURCE)
          p.srcF = addFilter(p.srcF, filter2);
        return p;
      },
      /**
       * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
       * a registered filter function, it will be applied and the tuple set(s) will
       * be replaced with materialized tuple arrays.
       * @param {number} flags - Flags indicating the tuple set(s) to materialize.
       * @return {Pulse} - Returns this pulse instance.
       */
      materialize(flags) {
        flags = flags || ALL;
        const p = this;
        if (flags & ADD && p.addF) {
          p.add = materialize(p.add, p.addF);
          p.addF = null;
        }
        if (flags & REM && p.remF) {
          p.rem = materialize(p.rem, p.remF);
          p.remF = null;
        }
        if (flags & MOD$1 && p.modF) {
          p.mod = materialize(p.mod, p.modF);
          p.modF = null;
        }
        if (flags & SOURCE && p.srcF) {
          p.source = p.source.filter(p.srcF);
          p.srcF = null;
        }
        return p;
      },
      /**
       * Visit one or more tuple sets in this pulse.
       * @param {number} flags - Flags indicating the tuple set(s) to visit.
       *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
       *   has been set).
       * @param {function(object):*} - Visitor function invoked per-tuple.
       * @return {Pulse} - Returns this pulse instance.
       */
      visit(flags, visitor) {
        const p = this, v = visitor;
        if (flags & SOURCE) {
          visitArray(p.source, p.srcF, v);
          return p;
        }
        if (flags & ADD)
          visitArray(p.add, p.addF, v);
        if (flags & REM)
          visitArray(p.rem, p.remF, v);
        if (flags & MOD$1)
          visitArray(p.mod, p.modF, v);
        const src = p.source;
        if (flags & REFLOW && src) {
          const sum2 = p.add.length + p.mod.length;
          if (sum2 === src.length)
            ;
          else if (sum2) {
            visitArray(src, filter$1(p, ADD_MOD), v);
          } else {
            visitArray(src, p.srcF, v);
          }
        }
        return p;
      }
    };
    function MultiPulse(dataflow, stamp, pulses, encode2) {
      const p = this;
      let c2 = 0;
      this.dataflow = dataflow;
      this.stamp = stamp;
      this.fields = null;
      this.encode = encode2 || null;
      this.pulses = pulses;
      for (const pulse2 of pulses) {
        if (pulse2.stamp !== stamp)
          continue;
        if (pulse2.fields) {
          const hash2 = p.fields || (p.fields = {});
          for (const f in pulse2.fields) {
            hash2[f] = 1;
          }
        }
        if (pulse2.changed(p.ADD))
          c2 |= p.ADD;
        if (pulse2.changed(p.REM))
          c2 |= p.REM;
        if (pulse2.changed(p.MOD))
          c2 |= p.MOD;
      }
      this.changes = c2;
    }
    inherits(MultiPulse, Pulse, {
      /**
       * Creates a new pulse based on the values of this pulse.
       * The dataflow, time stamp and field modification values are copied over.
       * @return {Pulse}
       */
      fork(flags) {
        const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
        if (flags !== void 0) {
          if (flags & p.ADD)
            this.visit(p.ADD, (t4) => p.add.push(t4));
          if (flags & p.REM)
            this.visit(p.REM, (t4) => p.rem.push(t4));
          if (flags & p.MOD)
            this.visit(p.MOD, (t4) => p.mod.push(t4));
        }
        return p;
      },
      changed(flags) {
        return this.changes & flags;
      },
      modified(_) {
        const p = this, fields = p.fields;
        return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some((f) => fields[f]) : fields[_];
      },
      filter() {
        error("MultiPulse does not support filtering.");
      },
      materialize() {
        error("MultiPulse does not support materialization.");
      },
      visit(flags, visitor) {
        const p = this, pulses = p.pulses, n = pulses.length;
        let i = 0;
        if (flags & p.SOURCE) {
          for (; i < n; ++i) {
            pulses[i].visit(flags, visitor);
          }
        } else {
          for (; i < n; ++i) {
            if (pulses[i].stamp === p.stamp) {
              pulses[i].visit(flags, visitor);
            }
          }
        }
        return p;
      }
    });
    async function evaluate(encode2, prerun, postrun) {
      const df = this, async = [];
      if (df._pulse)
        return reentrant(df);
      if (df._pending)
        await df._pending;
      if (prerun)
        await asyncCallback(df, prerun);
      if (!df._touched.length) {
        df.debug("Dataflow invoked, but nothing to do.");
        return df;
      }
      const stamp = ++df._clock;
      df._pulse = new Pulse(df, stamp, encode2);
      df._touched.forEach((op2) => df._enqueue(op2, true));
      df._touched = UniqueList(id);
      let count2 = 0, op, next2, error2;
      try {
        while (df._heap.size() > 0) {
          op = df._heap.pop();
          if (op.rank !== op.qrank) {
            df._enqueue(op, true);
            continue;
          }
          next2 = op.run(df._getPulse(op, encode2));
          if (next2.then) {
            next2 = await next2;
          } else if (next2.async) {
            async.push(next2.async);
            next2 = StopPropagation;
          }
          if (next2 !== StopPropagation) {
            if (op._targets)
              op._targets.forEach((op2) => df._enqueue(op2));
          }
          ++count2;
        }
      } catch (err) {
        df._heap.clear();
        error2 = err;
      }
      df._input = {};
      df._pulse = null;
      df.debug(`Pulse ${stamp}: ${count2} operators`);
      if (error2) {
        df._postrun = [];
        df.error(error2);
      }
      if (df._postrun.length) {
        const pr = df._postrun.sort((a2, b2) => b2.priority - a2.priority);
        df._postrun = [];
        for (let i = 0; i < pr.length; ++i) {
          await asyncCallback(df, pr[i].callback);
        }
      }
      if (postrun)
        await asyncCallback(df, postrun);
      if (async.length) {
        Promise.all(async).then((cb) => df.runAsync(null, () => {
          cb.forEach((f) => {
            try {
              f(df);
            } catch (err) {
              df.error(err);
            }
          });
        }));
      }
      return df;
    }
    async function runAsync(encode2, prerun, postrun) {
      while (this._running)
        await this._running;
      const clear2 = () => this._running = null;
      (this._running = this.evaluate(encode2, prerun, postrun)).then(clear2, clear2);
      return this._running;
    }
    function run(encode2, prerun, postrun) {
      return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
    }
    function runAfter(callback, enqueue2, priority) {
      if (this._pulse || enqueue2) {
        this._postrun.push({
          priority: priority || 0,
          callback
        });
      } else {
        try {
          callback(this);
        } catch (err) {
          this.error(err);
        }
      }
    }
    function reentrant(df) {
      df.error("Dataflow already running. Use runAsync() to chain invocations.");
      return df;
    }
    function enqueue(op, force2) {
      const q = op.stamp < this._clock;
      if (q)
        op.stamp = this._clock;
      if (q || force2) {
        op.qrank = op.rank;
        this._heap.push(op);
      }
    }
    function getPulse(op, encode2) {
      const s = op.source, stamp = this._clock;
      return s && isArray(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
    }
    function singlePulse(p, s) {
      if (s && s.stamp === p.stamp) {
        return s;
      }
      p = p.fork();
      if (s && s !== StopPropagation) {
        p.source = s.source;
      }
      return p;
    }
    const NO_OPT = {
      skip: false,
      force: false
    };
    function touch(op, options) {
      const opt = options || NO_OPT;
      if (this._pulse) {
        this._enqueue(op);
      } else {
        this._touched.add(op);
      }
      if (opt.skip)
        op.skip(true);
      return this;
    }
    function update$6(op, value2, options) {
      const opt = options || NO_OPT;
      if (op.set(value2) || opt.force) {
        this.touch(op, opt);
      }
      return this;
    }
    function pulse(op, changeset2, options) {
      this.touch(op, options || NO_OPT);
      const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t4 = op.pulse && op.pulse.source || [];
      p.target = op;
      this._input[op.id] = changeset2.pulse(p, t4);
      return this;
    }
    function Heap(cmp2) {
      let nodes = [];
      return {
        clear: () => nodes = [],
        size: () => nodes.length,
        peek: () => nodes[0],
        push: (x2) => {
          nodes.push(x2);
          return siftdown(nodes, 0, nodes.length - 1, cmp2);
        },
        pop: () => {
          const last2 = nodes.pop();
          let item;
          if (nodes.length) {
            item = nodes[0];
            nodes[0] = last2;
            siftup(nodes, 0, cmp2);
          } else {
            item = last2;
          }
          return item;
        }
      };
    }
    function siftdown(array2, start2, idx, cmp2) {
      let parent, pidx;
      const item = array2[idx];
      while (idx > start2) {
        pidx = idx - 1 >> 1;
        parent = array2[pidx];
        if (cmp2(item, parent) < 0) {
          array2[idx] = parent;
          idx = pidx;
          continue;
        }
        break;
      }
      return array2[idx] = item;
    }
    function siftup(array2, idx, cmp2) {
      const start2 = idx, end = array2.length, item = array2[idx];
      let cidx = (idx << 1) + 1, ridx;
      while (cidx < end) {
        ridx = cidx + 1;
        if (ridx < end && cmp2(array2[cidx], array2[ridx]) >= 0) {
          cidx = ridx;
        }
        array2[idx] = array2[cidx];
        idx = cidx;
        cidx = (idx << 1) + 1;
      }
      array2[idx] = item;
      return siftdown(array2, start2, idx, cmp2);
    }
    function Dataflow() {
      this.logger(logger());
      this.logLevel(Error$1);
      this._clock = 0;
      this._rank = 0;
      this._locale = defaultLocale();
      try {
        this._loader = loader();
      } catch (e3) {
      }
      this._touched = UniqueList(id);
      this._input = {};
      this._pulse = null;
      this._heap = Heap((a2, b2) => a2.qrank - b2.qrank);
      this._postrun = [];
    }
    function logMethod(method2) {
      return function() {
        return this._log[method2].apply(this, arguments);
      };
    }
    Dataflow.prototype = {
      /**
       * The current timestamp of this dataflow. This value reflects the
       * timestamp of the previous dataflow run. The dataflow is initialized
       * with a stamp value of 0. The initial run of the dataflow will have
       * a timestap of 1, and so on. This value will match the
       * {@link Pulse.stamp} property.
       * @return {number} - The current timestamp value.
       */
      stamp() {
        return this._clock;
      },
      /**
       * Gets or sets the loader instance to use for data file loading. A
       * loader object must provide a "load" method for loading files and a
       * "sanitize" method for checking URL/filename validity. Both methods
       * should accept a URI and options hash as arguments, and return a Promise
       * that resolves to the loaded file contents (load) or a hash containing
       * sanitized URI data with the sanitized url assigned to the "href" property
       * (sanitize).
       * @param {object} _ - The loader instance to use.
       * @return {object|Dataflow} - If no arguments are provided, returns
       *   the current loader instance. Otherwise returns this Dataflow instance.
       */
      loader(_) {
        if (arguments.length) {
          this._loader = _;
          return this;
        } else {
          return this._loader;
        }
      },
      /**
       * Gets or sets the locale instance to use for formatting and parsing
       * string values. The locale object should be provided by the
       * vega-format library, and include methods such as format, timeFormat,
       * utcFormat, timeParse, and utcParse.
       * @param {object} _ - The locale instance to use.
       * @return {object|Dataflow} - If no arguments are provided, returns
       *   the current locale instance. Otherwise returns this Dataflow instance.
       */
      locale(_) {
        if (arguments.length) {
          this._locale = _;
          return this;
        } else {
          return this._locale;
        }
      },
      /**
       * Get or set the logger instance used to log messages. If no arguments are
       * provided, returns the current logger instance. Otherwise, sets the logger
       * and return this Dataflow instance. Provided loggers must support the full
       * API of logger objects generated by the vega-util logger method. Note that
       * by default the log level of the new logger will be used; use the logLevel
       * method to adjust the log level as needed.
       */
      logger(logger2) {
        if (arguments.length) {
          this._log = logger2;
          return this;
        } else {
          return this._log;
        }
      },
      /**
       * Logs an error message. By default, logged messages are written to console
       * output. The message will only be logged if the current log level is high
       * enough to permit error messages.
       */
      error: logMethod("error"),
      /**
       * Logs a warning message. By default, logged messages are written to console
       * output. The message will only be logged if the current log level is high
       * enough to permit warning messages.
       */
      warn: logMethod("warn"),
      /**
       * Logs a information message. By default, logged messages are written to
       * console output. The message will only be logged if the current log level is
       * high enough to permit information messages.
       */
      info: logMethod("info"),
      /**
       * Logs a debug message. By default, logged messages are written to console
       * output. The message will only be logged if the current log level is high
       * enough to permit debug messages.
       */
      debug: logMethod("debug"),
      /**
       * Get or set the current log level. If an argument is provided, it
       * will be used as the new log level.
       * @param {number} [level] - Should be one of None, Warn, Info
       * @return {number} - The current log level.
       */
      logLevel: logMethod("level"),
      /**
       * Empty entry threshold for garbage cleaning. Map data structures will
       * perform cleaning once the number of empty entries exceeds this value.
       */
      cleanThreshold: 1e4,
      // OPERATOR REGISTRATION
      add: add$3,
      connect,
      rank,
      rerank,
      // OPERATOR UPDATES
      pulse,
      touch,
      update: update$6,
      changeset,
      // DATA LOADING
      ingest,
      parse: parse$5,
      preload,
      request,
      // EVENT HANDLING
      events: events$1,
      on,
      // PULSE PROPAGATION
      evaluate,
      run,
      runAsync,
      runAfter,
      _enqueue: enqueue,
      _getPulse: getPulse
    };
    function Transform(init2, params2) {
      Operator.call(this, init2, null, params2);
    }
    inherits(Transform, Operator, {
      /**
       * Overrides {@link Operator.evaluate} for transform operators.
       * Internally, this method calls {@link evaluate} to perform processing.
       * If {@link evaluate} returns a falsy value, the input pulse is returned.
       * This method should NOT be overridden, instead overrride {@link evaluate}.
       * @param {Pulse} pulse - the current dataflow pulse.
       * @return the output pulse for this operator (or StopPropagation)
       */
      run(pulse2) {
        if (pulse2.stamp < this.stamp)
          return pulse2.StopPropagation;
        let rv;
        if (this.skip()) {
          this.skip(false);
        } else {
          rv = this.evaluate(pulse2);
        }
        rv = rv || pulse2;
        if (rv.then) {
          rv = rv.then((_) => this.pulse = _);
        } else if (rv !== pulse2.StopPropagation) {
          this.pulse = rv;
        }
        return rv;
      },
      /**
       * Overrides {@link Operator.evaluate} for transform operators.
       * Marshalls parameter values and then invokes {@link transform}.
       * @param {Pulse} pulse - the current dataflow pulse.
       * @return {Pulse} The output pulse (or StopPropagation). A falsy return
           value (including undefined) will let the input pulse pass through.
      */
      evaluate(pulse2) {
        const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
        params2.clear();
        return out;
      },
      /**
       * Process incoming pulses.
       * Subclasses should override this method to implement transforms.
       * @param {Parameters} _ - The operator parameter values.
       * @param {Pulse} pulse - The current dataflow pulse.
       * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       *   value (including undefined) will let the input pulse pass through.
       */
      transform() {
      }
    });
    const transforms = {};
    function definition$1(type2) {
      const t4 = transform$2(type2);
      return t4 && t4.Definition || null;
    }
    function transform$2(type2) {
      type2 = type2 && type2.toLowerCase();
      return has$1(transforms, type2) ? transforms[type2] : null;
    }
    function* numbers$1(values2, valueof) {
      if (valueof == null) {
        for (let value2 of values2) {
          if (value2 != null && value2 !== "" && (value2 = +value2) >= value2) {
            yield value2;
          }
        }
      } else {
        let index2 = -1;
        for (let value2 of values2) {
          value2 = valueof(value2, ++index2, values2);
          if (value2 != null && value2 !== "" && (value2 = +value2) >= value2) {
            yield value2;
          }
        }
      }
    }
    function quantiles(array2, p, f) {
      const values2 = Float64Array.from(numbers$1(array2, f));
      values2.sort(ascending$3);
      return p.map((_) => quantileSorted(values2, _));
    }
    function quartiles(array2, f) {
      return quantiles(array2, [0.25, 0.5, 0.75], f);
    }
    function estimateBandwidth(array2, f) {
      const n = array2.length, d = deviation(array2, f), q = quartiles(array2, f), h2 = (q[2] - q[0]) / 1.34, v = Math.min(d, h2) || d || Math.abs(q[0]) || 1;
      return 1.06 * v * Math.pow(n, -0.2);
    }
    function bin$1(_) {
      const maxb = _.maxbins || 20, base2 = _.base || 10, logb = Math.log(base2), div = _.divide || [5, 2];
      let min2 = _.extent[0], max2 = _.extent[1], step, level, minstep, v, i, n;
      const span2 = _.span || max2 - min2 || Math.abs(min2) || 1;
      if (_.step) {
        step = _.step;
      } else if (_.steps) {
        v = span2 / maxb;
        for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i)
          ;
        step = _.steps[Math.max(0, i - 1)];
      } else {
        level = Math.ceil(Math.log(maxb) / logb);
        minstep = _.minstep || 0;
        step = Math.max(minstep, Math.pow(base2, Math.round(Math.log(span2) / logb) - level));
        while (Math.ceil(span2 / step) > maxb) {
          step *= base2;
        }
        for (i = 0, n = div.length; i < n; ++i) {
          v = step / div[i];
          if (v >= minstep && span2 / v <= maxb)
            step = v;
        }
      }
      v = Math.log(step);
      const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base2, -precision - 1);
      if (_.nice || _.nice === void 0) {
        v = Math.floor(min2 / step + eps) * step;
        min2 = min2 < v ? v - step : v;
        max2 = Math.ceil(max2 / step) * step;
      }
      return {
        start: min2,
        stop: max2 === min2 ? min2 + step : max2,
        step
      };
    }
    var random = Math.random;
    function setRandom(r) {
      random = r;
    }
    function bootstrapCI(array2, samples, alpha, f) {
      if (!array2.length)
        return [void 0, void 0];
      const values2 = Float64Array.from(numbers$1(array2, f)), n = values2.length, m2 = samples;
      let a2, i, j, mu;
      for (j = 0, mu = Array(m2); j < m2; ++j) {
        for (a2 = 0, i = 0; i < n; ++i) {
          a2 += values2[~~(random() * n)];
        }
        mu[j] = a2 / n;
      }
      mu.sort(ascending$3);
      return [quantile$1(mu, alpha / 2), quantile$1(mu, 1 - alpha / 2)];
    }
    function dotbin(array2, step, smooth, f) {
      f = f || ((_) => _);
      const n = array2.length, v = new Float64Array(n);
      let i = 0, j = 1, a2 = f(array2[0]), b2 = a2, w2 = a2 + step, x2;
      for (; j < n; ++j) {
        x2 = f(array2[j]);
        if (x2 >= w2) {
          b2 = (a2 + b2) / 2;
          for (; i < j; ++i)
            v[i] = b2;
          w2 = x2 + step;
          a2 = x2;
        }
        b2 = x2;
      }
      b2 = (a2 + b2) / 2;
      for (; i < j; ++i)
        v[i] = b2;
      return smooth ? smoothing(v, step + step / 4) : v;
    }
    function smoothing(v, thresh) {
      const n = v.length;
      let a2 = 0, b2 = 1, c2, d;
      while (v[a2] === v[b2])
        ++b2;
      while (b2 < n) {
        c2 = b2 + 1;
        while (v[b2] === v[c2])
          ++c2;
        if (v[b2] - v[b2 - 1] < thresh) {
          d = b2 + (a2 + c2 - b2 - b2 >> 1);
          while (d < b2)
            v[d++] = v[b2];
          while (d > b2)
            v[d--] = v[a2];
        }
        a2 = b2;
        b2 = c2;
      }
      return v;
    }
    function lcg(seed) {
      return function() {
        seed = (1103515245 * seed + 12345) % 2147483647;
        return seed / 2147483647;
      };
    }
    function integer(min2, max2) {
      if (max2 == null) {
        max2 = min2;
        min2 = 0;
      }
      let a2, b2, d;
      const dist2 = {
        min(_) {
          if (arguments.length) {
            a2 = _ || 0;
            d = b2 - a2;
            return dist2;
          } else {
            return a2;
          }
        },
        max(_) {
          if (arguments.length) {
            b2 = _ || 0;
            d = b2 - a2;
            return dist2;
          } else {
            return b2;
          }
        },
        sample() {
          return a2 + Math.floor(d * random());
        },
        pdf(x2) {
          return x2 === Math.floor(x2) && x2 >= a2 && x2 < b2 ? 1 / d : 0;
        },
        cdf(x2) {
          const v = Math.floor(x2);
          return v < a2 ? 0 : v >= b2 ? 1 : (v - a2 + 1) / d;
        },
        icdf(p) {
          return p >= 0 && p <= 1 ? a2 - 1 + Math.floor(p * d) : NaN;
        }
      };
      return dist2.min(min2).max(max2);
    }
    const SQRT2PI = Math.sqrt(2 * Math.PI);
    const SQRT2 = Math.SQRT2;
    let nextSample = NaN;
    function sampleNormal(mean2, stdev) {
      mean2 = mean2 || 0;
      stdev = stdev == null ? 1 : stdev;
      let x2 = 0, y2 = 0, rds, c2;
      if (nextSample === nextSample) {
        x2 = nextSample;
        nextSample = NaN;
      } else {
        do {
          x2 = random() * 2 - 1;
          y2 = random() * 2 - 1;
          rds = x2 * x2 + y2 * y2;
        } while (rds === 0 || rds > 1);
        c2 = Math.sqrt(-2 * Math.log(rds) / rds);
        x2 *= c2;
        nextSample = y2 * c2;
      }
      return mean2 + x2 * stdev;
    }
    function densityNormal(value2, mean2, stdev) {
      stdev = stdev == null ? 1 : stdev;
      const z = (value2 - (mean2 || 0)) / stdev;
      return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
    }
    function cumulativeNormal(value2, mean2, stdev) {
      mean2 = mean2 || 0;
      stdev = stdev == null ? 1 : stdev;
      const z = (value2 - mean2) / stdev, Z = Math.abs(z);
      let cd;
      if (Z > 37) {
        cd = 0;
      } else {
        const exp2 = Math.exp(-Z * Z / 2);
        let sum2;
        if (Z < 7.07106781186547) {
          sum2 = 0.0352624965998911 * Z + 0.700383064443688;
          sum2 = sum2 * Z + 6.37396220353165;
          sum2 = sum2 * Z + 33.912866078383;
          sum2 = sum2 * Z + 112.079291497871;
          sum2 = sum2 * Z + 221.213596169931;
          sum2 = sum2 * Z + 220.206867912376;
          cd = exp2 * sum2;
          sum2 = 0.0883883476483184 * Z + 1.75566716318264;
          sum2 = sum2 * Z + 16.064177579207;
          sum2 = sum2 * Z + 86.7807322029461;
          sum2 = sum2 * Z + 296.564248779674;
          sum2 = sum2 * Z + 637.333633378831;
          sum2 = sum2 * Z + 793.826512519948;
          sum2 = sum2 * Z + 440.413735824752;
          cd = cd / sum2;
        } else {
          sum2 = Z + 0.65;
          sum2 = Z + 4 / sum2;
          sum2 = Z + 3 / sum2;
          sum2 = Z + 2 / sum2;
          sum2 = Z + 1 / sum2;
          cd = exp2 / sum2 / 2.506628274631;
        }
      }
      return z > 0 ? 1 - cd : cd;
    }
    function quantileNormal(p, mean2, stdev) {
      if (p < 0 || p > 1)
        return NaN;
      return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
    }
    function erfinv(x2) {
      let w2 = -Math.log((1 - x2) * (1 + x2)), p;
      if (w2 < 6.25) {
        w2 -= 3.125;
        p = -364441206401782e-35;
        p = -16850591381820166e-35 + p * w2;
        p = 128584807152564e-32 + p * w2;
        p = 11157877678025181e-33 + p * w2;
        p = -1333171662854621e-31 + p * w2;
        p = 20972767875968562e-33 + p * w2;
        p = 6637638134358324e-30 + p * w2;
        p = -4054566272975207e-29 + p * w2;
        p = -8151934197605472e-29 + p * w2;
        p = 26335093153082323e-28 + p * w2;
        p = -12975133253453532e-27 + p * w2;
        p = -5415412054294628e-26 + p * w2;
        p = 10512122733215323e-25 + p * w2;
        p = -4112633980346984e-24 + p * w2;
        p = -29070369957882005e-24 + p * w2;
        p = 42347877827932404e-23 + p * w2;
        p = -13654692000834679e-22 + p * w2;
        p = -13882523362786469e-21 + p * w2;
        p = 18673420803405714e-20 + p * w2;
        p = -740702534166267e-18 + p * w2;
        p = -0.006033670871430149 + p * w2;
        p = 0.24015818242558962 + p * w2;
        p = 1.6536545626831027 + p * w2;
      } else if (w2 < 16) {
        w2 = Math.sqrt(w2) - 3.25;
        p = 22137376921775787e-25;
        p = 9075656193888539e-23 + p * w2;
        p = -27517406297064545e-23 + p * w2;
        p = 18239629214389228e-24 + p * w2;
        p = 15027403968909828e-22 + p * w2;
        p = -4013867526981546e-21 + p * w2;
        p = 29234449089955446e-22 + p * w2;
        p = 12475304481671779e-21 + p * w2;
        p = -47318229009055734e-21 + p * w2;
        p = 6828485145957318e-20 + p * w2;
        p = 24031110387097894e-21 + p * w2;
        p = -3550375203628475e-19 + p * w2;
        p = 9532893797373805e-19 + p * w2;
        p = -0.0016882755560235047 + p * w2;
        p = 0.002491442096107851 + p * w2;
        p = -0.003751208507569241 + p * w2;
        p = 0.005370914553590064 + p * w2;
        p = 1.0052589676941592 + p * w2;
        p = 3.0838856104922208 + p * w2;
      } else if (Number.isFinite(w2)) {
        w2 = Math.sqrt(w2) - 5;
        p = -27109920616438573e-27;
        p = -2555641816996525e-25 + p * w2;
        p = 15076572693500548e-25 + p * w2;
        p = -3789465440126737e-24 + p * w2;
        p = 761570120807834e-23 + p * w2;
        p = -1496002662714924e-23 + p * w2;
        p = 2914795345090108e-23 + p * w2;
        p = -6771199775845234e-23 + p * w2;
        p = 22900482228026655e-23 + p * w2;
        p = -99298272942317e-20 + p * w2;
        p = 4526062597223154e-21 + p * w2;
        p = -1968177810553167e-20 + p * w2;
        p = 7599527703001776e-20 + p * w2;
        p = -21503011930044477e-20 + p * w2;
        p = -13871931833623122e-20 + p * w2;
        p = 1.0103004648645344 + p * w2;
        p = 4.849906401408584 + p * w2;
      } else {
        p = Infinity;
      }
      return p * x2;
    }
    function gaussian(mean2, stdev) {
      let mu, sigma;
      const dist2 = {
        mean(_) {
          if (arguments.length) {
            mu = _ || 0;
            return dist2;
          } else {
            return mu;
          }
        },
        stdev(_) {
          if (arguments.length) {
            sigma = _ == null ? 1 : _;
            return dist2;
          } else {
            return sigma;
          }
        },
        sample: () => sampleNormal(mu, sigma),
        pdf: (value2) => densityNormal(value2, mu, sigma),
        cdf: (value2) => cumulativeNormal(value2, mu, sigma),
        icdf: (p) => quantileNormal(p, mu, sigma)
      };
      return dist2.mean(mean2).stdev(stdev);
    }
    function kde(support2, bandwidth2) {
      const kernel = gaussian();
      let n = 0;
      const dist2 = {
        data(_) {
          if (arguments.length) {
            support2 = _;
            n = _ ? _.length : 0;
            return dist2.bandwidth(bandwidth2);
          } else {
            return support2;
          }
        },
        bandwidth(_) {
          if (!arguments.length)
            return bandwidth2;
          bandwidth2 = _;
          if (!bandwidth2 && support2)
            bandwidth2 = estimateBandwidth(support2);
          return dist2;
        },
        sample() {
          return support2[~~(random() * n)] + bandwidth2 * kernel.sample();
        },
        pdf(x2) {
          let y2 = 0, i = 0;
          for (; i < n; ++i) {
            y2 += kernel.pdf((x2 - support2[i]) / bandwidth2);
          }
          return y2 / bandwidth2 / n;
        },
        cdf(x2) {
          let y2 = 0, i = 0;
          for (; i < n; ++i) {
            y2 += kernel.cdf((x2 - support2[i]) / bandwidth2);
          }
          return y2 / n;
        },
        icdf() {
          throw Error("KDE icdf not supported.");
        }
      };
      return dist2.data(support2);
    }
    function sampleLogNormal(mean2, stdev) {
      mean2 = mean2 || 0;
      stdev = stdev == null ? 1 : stdev;
      return Math.exp(mean2 + sampleNormal() * stdev);
    }
    function densityLogNormal(value2, mean2, stdev) {
      if (value2 <= 0)
        return 0;
      mean2 = mean2 || 0;
      stdev = stdev == null ? 1 : stdev;
      const z = (Math.log(value2) - mean2) / stdev;
      return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value2);
    }
    function cumulativeLogNormal(value2, mean2, stdev) {
      return cumulativeNormal(Math.log(value2), mean2, stdev);
    }
    function quantileLogNormal(p, mean2, stdev) {
      return Math.exp(quantileNormal(p, mean2, stdev));
    }
    function lognormal(mean2, stdev) {
      let mu, sigma;
      const dist2 = {
        mean(_) {
          if (arguments.length) {
            mu = _ || 0;
            return dist2;
          } else {
            return mu;
          }
        },
        stdev(_) {
          if (arguments.length) {
            sigma = _ == null ? 1 : _;
            return dist2;
          } else {
            return sigma;
          }
        },
        sample: () => sampleLogNormal(mu, sigma),
        pdf: (value2) => densityLogNormal(value2, mu, sigma),
        cdf: (value2) => cumulativeLogNormal(value2, mu, sigma),
        icdf: (p) => quantileLogNormal(p, mu, sigma)
      };
      return dist2.mean(mean2).stdev(stdev);
    }
    function mixture$1(dists, weights) {
      let m2 = 0, w2;
      function normalize2(x2) {
        const w3 = [];
        let sum2 = 0, i;
        for (i = 0; i < m2; ++i) {
          sum2 += w3[i] = x2[i] == null ? 1 : +x2[i];
        }
        for (i = 0; i < m2; ++i) {
          w3[i] /= sum2;
        }
        return w3;
      }
      const dist2 = {
        weights(_) {
          if (arguments.length) {
            w2 = normalize2(weights = _ || []);
            return dist2;
          }
          return weights;
        },
        distributions(_) {
          if (arguments.length) {
            if (_) {
              m2 = _.length;
              dists = _;
            } else {
              m2 = 0;
              dists = [];
            }
            return dist2.weights(weights);
          }
          return dists;
        },
        sample() {
          const r = random();
          let d = dists[m2 - 1], v = w2[0], i = 0;
          for (; i < m2 - 1; v += w2[++i]) {
            if (r < v) {
              d = dists[i];
              break;
            }
          }
          return d.sample();
        },
        pdf(x2) {
          let p = 0, i = 0;
          for (; i < m2; ++i) {
            p += w2[i] * dists[i].pdf(x2);
          }
          return p;
        },
        cdf(x2) {
          let p = 0, i = 0;
          for (; i < m2; ++i) {
            p += w2[i] * dists[i].cdf(x2);
          }
          return p;
        },
        icdf() {
          throw Error("Mixture icdf not supported.");
        }
      };
      return dist2.distributions(dists).weights(weights);
    }
    function sampleUniform(min2, max2) {
      if (max2 == null) {
        max2 = min2 == null ? 1 : min2;
        min2 = 0;
      }
      return min2 + (max2 - min2) * random();
    }
    function densityUniform(value2, min2, max2) {
      if (max2 == null) {
        max2 = min2 == null ? 1 : min2;
        min2 = 0;
      }
      return value2 >= min2 && value2 <= max2 ? 1 / (max2 - min2) : 0;
    }
    function cumulativeUniform(value2, min2, max2) {
      if (max2 == null) {
        max2 = min2 == null ? 1 : min2;
        min2 = 0;
      }
      return value2 < min2 ? 0 : value2 > max2 ? 1 : (value2 - min2) / (max2 - min2);
    }
    function quantileUniform(p, min2, max2) {
      if (max2 == null) {
        max2 = min2 == null ? 1 : min2;
        min2 = 0;
      }
      return p >= 0 && p <= 1 ? min2 + p * (max2 - min2) : NaN;
    }
    function uniform(min2, max2) {
      let a2, b2;
      const dist2 = {
        min(_) {
          if (arguments.length) {
            a2 = _ || 0;
            return dist2;
          } else {
            return a2;
          }
        },
        max(_) {
          if (arguments.length) {
            b2 = _ == null ? 1 : _;
            return dist2;
          } else {
            return b2;
          }
        },
        sample: () => sampleUniform(a2, b2),
        pdf: (value2) => densityUniform(value2, a2, b2),
        cdf: (value2) => cumulativeUniform(value2, a2, b2),
        icdf: (p) => quantileUniform(p, a2, b2)
      };
      if (max2 == null) {
        max2 = min2 == null ? 1 : min2;
        min2 = 0;
      }
      return dist2.min(min2).max(max2);
    }
    function constant(data2, x2, y2) {
      let mean2 = 0, n = 0;
      for (const d of data2) {
        const val = y2(d);
        if (x2(d) == null || val == null || isNaN(val))
          continue;
        mean2 += (val - mean2) / ++n;
      }
      return {
        coef: [mean2],
        predict: () => mean2,
        rSquared: 0
      };
    }
    function ols(uX, uY, uXY, uX2) {
      const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
      return [intercept, slope];
    }
    function points(data2, x2, y2, sort2) {
      data2 = data2.filter((d2) => {
        let u2 = x2(d2), v = y2(d2);
        return u2 != null && (u2 = +u2) >= u2 && v != null && (v = +v) >= v;
      });
      if (sort2) {
        data2.sort((a2, b2) => x2(a2) - x2(b2));
      }
      const n = data2.length, X3 = new Float64Array(n), Y3 = new Float64Array(n);
      let i = 0, ux = 0, uy = 0, xv, yv, d;
      for (d of data2) {
        X3[i] = xv = +x2(d);
        Y3[i] = yv = +y2(d);
        ++i;
        ux += (xv - ux) / i;
        uy += (yv - uy) / i;
      }
      for (i = 0; i < n; ++i) {
        X3[i] -= ux;
        Y3[i] -= uy;
      }
      return [X3, Y3, ux, uy];
    }
    function visitPoints(data2, x2, y2, callback) {
      let i = -1, u2, v;
      for (const d of data2) {
        u2 = x2(d);
        v = y2(d);
        if (u2 != null && (u2 = +u2) >= u2 && v != null && (v = +v) >= v) {
          callback(u2, v, ++i);
        }
      }
    }
    function rSquared(data2, x2, y2, uY, predict) {
      let SSE = 0, SST = 0;
      visitPoints(data2, x2, y2, (dx, dy) => {
        const sse = dy - predict(dx), sst = dy - uY;
        SSE += sse * sse;
        SST += sst * sst;
      });
      return 1 - SSE / SST;
    }
    function linear(data2, x2, y2) {
      let X3 = 0, Y3 = 0, XY = 0, X22 = 0, n = 0;
      visitPoints(data2, x2, y2, (dx, dy) => {
        ++n;
        X3 += (dx - X3) / n;
        Y3 += (dy - Y3) / n;
        XY += (dx * dy - XY) / n;
        X22 += (dx * dx - X22) / n;
      });
      const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] + coef[1] * x3;
      return {
        coef,
        predict,
        rSquared: rSquared(data2, x2, y2, Y3, predict)
      };
    }
    function log$1(data2, x2, y2) {
      let X3 = 0, Y3 = 0, XY = 0, X22 = 0, n = 0;
      visitPoints(data2, x2, y2, (dx, dy) => {
        ++n;
        dx = Math.log(dx);
        X3 += (dx - X3) / n;
        Y3 += (dy - Y3) / n;
        XY += (dx * dy - XY) / n;
        X22 += (dx * dx - X22) / n;
      });
      const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] + coef[1] * Math.log(x3);
      return {
        coef,
        predict,
        rSquared: rSquared(data2, x2, y2, Y3, predict)
      };
    }
    function exp(data2, x2, y2) {
      const [xv, yv, ux, uy] = points(data2, x2, y2);
      let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
      visitPoints(data2, x2, y2, (_, dy) => {
        dx = xv[n++];
        ly2 = Math.log(dy);
        xy = dx * dy;
        YL += (dy * ly2 - YL) / n;
        XY += (xy - XY) / n;
        XYL += (xy * ly2 - XYL) / n;
        X2Y += (dx * xy - X2Y) / n;
      });
      const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x3) => Math.exp(c0 + c1 * (x3 - ux));
      return {
        coef: [Math.exp(c0 - c1 * ux), c1],
        predict,
        rSquared: rSquared(data2, x2, y2, uy, predict)
      };
    }
    function pow(data2, x2, y2) {
      let X3 = 0, Y3 = 0, XY = 0, X22 = 0, YS = 0, n = 0;
      visitPoints(data2, x2, y2, (dx, dy) => {
        const lx2 = Math.log(dx), ly2 = Math.log(dy);
        ++n;
        X3 += (lx2 - X3) / n;
        Y3 += (ly2 - Y3) / n;
        XY += (lx2 * ly2 - XY) / n;
        X22 += (lx2 * lx2 - X22) / n;
        YS += (dy - YS) / n;
      });
      const coef = ols(X3, Y3, XY, X22), predict = (x3) => coef[0] * Math.pow(x3, coef[1]);
      coef[0] = Math.exp(coef[0]);
      return {
        coef,
        predict,
        rSquared: rSquared(data2, x2, y2, YS, predict)
      };
    }
    function quad(data2, x2, y2) {
      const [xv, yv, ux, uy] = points(data2, x2, y2), n = xv.length;
      let X22 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
      for (i = 0; i < n; ) {
        dx = xv[i];
        dy = yv[i++];
        x22 = dx * dx;
        X22 += (x22 - X22) / i;
        X3 += (x22 * dx - X3) / i;
        X4 += (x22 * x22 - X4) / i;
        XY += (dx * dy - XY) / i;
        X2Y += (x22 * dy - X2Y) / i;
      }
      const X2X2 = X4 - X22 * X22, d = X22 * X2X2 - X3 * X3, a2 = (X2Y * X22 - XY * X3) / d, b2 = (XY * X2X2 - X2Y * X3) / d, c2 = -a2 * X22, predict = (x3) => {
        x3 = x3 - ux;
        return a2 * x3 * x3 + b2 * x3 + c2 + uy;
      };
      return {
        coef: [c2 - b2 * ux + a2 * ux * ux + uy, b2 - 2 * a2 * ux, a2],
        predict,
        rSquared: rSquared(data2, x2, y2, uy, predict)
      };
    }
    function poly(data2, x2, y2, order) {
      if (order === 0)
        return constant(data2, x2, y2);
      if (order === 1)
        return linear(data2, x2, y2);
      if (order === 2)
        return quad(data2, x2, y2);
      const [xv, yv, ux, uy] = points(data2, x2, y2), n = xv.length, lhs = [], rhs = [], k = order + 1;
      let i, j, l, v, c2;
      for (i = 0; i < k; ++i) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i) * yv[l];
        }
        lhs.push(v);
        c2 = new Float64Array(k);
        for (j = 0; j < k; ++j) {
          for (l = 0, v = 0; l < n; ++l) {
            v += Math.pow(xv[l], i + j);
          }
          c2[j] = v;
        }
        rhs.push(c2);
      }
      rhs.push(lhs);
      const coef = gaussianElimination(rhs), predict = (x3) => {
        x3 -= ux;
        let y3 = uy + coef[0] + coef[1] * x3 + coef[2] * x3 * x3;
        for (i = 3; i < k; ++i)
          y3 += coef[i] * Math.pow(x3, i);
        return y3;
      };
      return {
        coef: uncenter(k, coef, -ux, uy),
        predict,
        rSquared: rSquared(data2, x2, y2, uy, predict)
      };
    }
    function uncenter(k, a2, x2, y2) {
      const z = Array(k);
      let i, j, v, c2;
      for (i = 0; i < k; ++i)
        z[i] = 0;
      for (i = k - 1; i >= 0; --i) {
        v = a2[i];
        c2 = 1;
        z[i] += v;
        for (j = 1; j <= i; ++j) {
          c2 *= (i + 1 - j) / j;
          z[i - j] += v * Math.pow(x2, j) * c2;
        }
      }
      z[0] += y2;
      return z;
    }
    function gaussianElimination(matrix) {
      const n = matrix.length - 1, coef = [];
      let i, j, k, r, t4;
      for (i = 0; i < n; ++i) {
        r = i;
        for (j = i + 1; j < n; ++j) {
          if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
            r = j;
          }
        }
        for (k = i; k < n + 1; ++k) {
          t4 = matrix[k][i];
          matrix[k][i] = matrix[k][r];
          matrix[k][r] = t4;
        }
        for (j = i + 1; j < n; ++j) {
          for (k = n; k >= i; k--) {
            matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
          }
        }
      }
      for (j = n - 1; j >= 0; --j) {
        t4 = 0;
        for (k = j + 1; k < n; ++k) {
          t4 += matrix[k][j] * coef[k];
        }
        coef[j] = (matrix[n][j] - t4) / matrix[j][j];
      }
      return coef;
    }
    const maxiters = 2, epsilon$1 = 1e-12;
    function loess(data2, x2, y2, bandwidth2) {
      const [xv, yv, ux, uy] = points(data2, x2, y2, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
      for (let iter = -1; ++iter <= maxiters; ) {
        const interval2 = [0, bw - 1];
        for (let i = 0; i < n; ++i) {
          const dx = xv[i], i0 = interval2[0], i1 = interval2[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
          let W = 0, X3 = 0, Y3 = 0, XY = 0, X22 = 0;
          const denom = 1 / Math.abs(xv[edge] - dx || 1);
          for (let k = i0; k <= i1; ++k) {
            const xk = xv[k], yk = yv[k], w2 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w2;
            W += w2;
            X3 += xkw;
            Y3 += yk * w2;
            XY += yk * xkw;
            X22 += xk * xkw;
          }
          const [a2, b2] = ols(X3 / W, Y3 / W, XY / W, X22 / W);
          yhat[i] = a2 + b2 * dx;
          residuals[i] = Math.abs(yv[i] - yhat[i]);
          updateInterval(xv, i + 1, interval2);
        }
        if (iter === maxiters) {
          break;
        }
        const medianResidual = median(residuals);
        if (Math.abs(medianResidual) < epsilon$1)
          break;
        for (let i = 0, arg, w2; i < n; ++i) {
          arg = residuals[i] / (6 * medianResidual);
          robustWeights[i] = arg >= 1 ? epsilon$1 : (w2 = 1 - arg * arg) * w2;
        }
      }
      return output$1(xv, yhat, ux, uy);
    }
    function tricube(x2) {
      return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
    }
    function updateInterval(xv, i, interval2) {
      const val = xv[i];
      let left2 = interval2[0], right2 = interval2[1] + 1;
      if (right2 >= xv.length)
        return;
      while (i > left2 && xv[right2] - val <= val - xv[left2]) {
        interval2[0] = ++left2;
        interval2[1] = right2;
        ++right2;
      }
    }
    function output$1(xv, yhat, ux, uy) {
      const n = xv.length, out = [];
      let i = 0, cnt = 0, prev2 = [], v;
      for (; i < n; ++i) {
        v = xv[i] + ux;
        if (prev2[0] === v) {
          prev2[1] += (yhat[i] - prev2[1]) / ++cnt;
        } else {
          cnt = 0;
          prev2[1] += uy;
          prev2 = [v, yhat[i]];
          out.push(prev2);
        }
      }
      prev2[1] += uy;
      return out;
    }
    const MIN_RADIANS = 0.5 * Math.PI / 180;
    function sampleCurve(f, extent2, minSteps, maxSteps) {
      minSteps = minSteps || 25;
      maxSteps = Math.max(minSteps, maxSteps || 200);
      const point2 = (x2) => [x2, f(x2)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop2 = span2 / maxSteps, prev2 = [point2(minX)], next2 = [];
      if (minSteps === maxSteps) {
        for (let i = 1; i < maxSteps; ++i) {
          prev2.push(point2(minX + i / minSteps * span2));
        }
        prev2.push(point2(maxX));
        return prev2;
      } else {
        next2.push(point2(maxX));
        for (let i = minSteps; --i > 0; ) {
          next2.push(point2(minX + i / minSteps * span2));
        }
      }
      let p02 = prev2[0];
      let p1 = next2[next2.length - 1];
      const sx = 1 / span2;
      const sy = scaleY(p02[1], next2);
      while (p1) {
        const pm = point2((p02[0] + p1[0]) / 2);
        const dx = pm[0] - p02[0] >= stop2;
        if (dx && angleDelta(p02, pm, p1, sx, sy) > MIN_RADIANS) {
          next2.push(pm);
        } else {
          p02 = p1;
          prev2.push(p1);
          next2.pop();
        }
        p1 = next2[next2.length - 1];
      }
      return prev2;
    }
    function scaleY(init2, points2) {
      let ymin = init2;
      let ymax = init2;
      const n = points2.length;
      for (let i = 0; i < n; ++i) {
        const y2 = points2[i][1];
        if (y2 < ymin)
          ymin = y2;
        if (y2 > ymax)
          ymax = y2;
      }
      return 1 / (ymax - ymin);
    }
    function angleDelta(p, q, r, sx, sy) {
      const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
      return Math.abs(a0 - a1);
    }
    function multikey(f) {
      return (x2) => {
        const n = f.length;
        let i = 1, k = String(f[0](x2));
        for (; i < n; ++i) {
          k += "|" + f[i](x2);
        }
        return k;
      };
    }
    function groupkey(fields) {
      return !fields || !fields.length ? function() {
        return "";
      } : fields.length === 1 ? fields[0] : multikey(fields);
    }
    function measureName(op, field2, as) {
      return as || op + (!field2 ? "" : "_" + field2);
    }
    const noop$1 = () => {
    };
    const base_op = {
      init: noop$1,
      add: noop$1,
      rem: noop$1,
      idx: 0
    };
    const AggregateOps = {
      values: {
        init: (m2) => m2.cell.store = true,
        value: (m2) => m2.cell.data.values(),
        idx: -1
      },
      count: {
        value: (m2) => m2.cell.num
      },
      __count__: {
        value: (m2) => m2.missing + m2.valid
      },
      missing: {
        value: (m2) => m2.missing
      },
      valid: {
        value: (m2) => m2.valid
      },
      sum: {
        init: (m2) => m2.sum = 0,
        value: (m2) => m2.valid ? m2.sum : void 0,
        add: (m2, v) => m2.sum += +v,
        rem: (m2, v) => m2.sum -= v
      },
      product: {
        init: (m2) => m2.product = 1,
        value: (m2) => m2.valid ? m2.product : void 0,
        add: (m2, v) => m2.product *= v,
        rem: (m2, v) => m2.product /= v
      },
      mean: {
        init: (m2) => m2.mean = 0,
        value: (m2) => m2.valid ? m2.mean : void 0,
        add: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean += m2.mean_d / m2.valid),
        rem: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean -= m2.valid ? m2.mean_d / m2.valid : m2.mean)
      },
      average: {
        value: (m2) => m2.valid ? m2.mean : void 0,
        req: ["mean"],
        idx: 1
      },
      variance: {
        init: (m2) => m2.dev = 0,
        value: (m2) => m2.valid > 1 ? m2.dev / (m2.valid - 1) : void 0,
        add: (m2, v) => m2.dev += m2.mean_d * (v - m2.mean),
        rem: (m2, v) => m2.dev -= m2.mean_d * (v - m2.mean),
        req: ["mean"],
        idx: 1
      },
      variancep: {
        value: (m2) => m2.valid > 1 ? m2.dev / m2.valid : void 0,
        req: ["variance"],
        idx: 2
      },
      stdev: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid - 1)) : void 0,
        req: ["variance"],
        idx: 2
      },
      stdevp: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / m2.valid) : void 0,
        req: ["variance"],
        idx: 2
      },
      stderr: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid * (m2.valid - 1))) : void 0,
        req: ["variance"],
        idx: 2
      },
      distinct: {
        value: (m2) => m2.cell.data.distinct(m2.get),
        req: ["values"],
        idx: 3
      },
      ci0: {
        value: (m2) => m2.cell.data.ci0(m2.get),
        req: ["values"],
        idx: 3
      },
      ci1: {
        value: (m2) => m2.cell.data.ci1(m2.get),
        req: ["values"],
        idx: 3
      },
      median: {
        value: (m2) => m2.cell.data.q2(m2.get),
        req: ["values"],
        idx: 3
      },
      q1: {
        value: (m2) => m2.cell.data.q1(m2.get),
        req: ["values"],
        idx: 3
      },
      q3: {
        value: (m2) => m2.cell.data.q3(m2.get),
        req: ["values"],
        idx: 3
      },
      min: {
        init: (m2) => m2.min = void 0,
        value: (m2) => m2.min = Number.isNaN(m2.min) ? m2.cell.data.min(m2.get) : m2.min,
        add: (m2, v) => {
          if (v < m2.min || m2.min === void 0)
            m2.min = v;
        },
        rem: (m2, v) => {
          if (v <= m2.min)
            m2.min = NaN;
        },
        req: ["values"],
        idx: 4
      },
      max: {
        init: (m2) => m2.max = void 0,
        value: (m2) => m2.max = Number.isNaN(m2.max) ? m2.cell.data.max(m2.get) : m2.max,
        add: (m2, v) => {
          if (v > m2.max || m2.max === void 0)
            m2.max = v;
        },
        rem: (m2, v) => {
          if (v >= m2.max)
            m2.max = NaN;
        },
        req: ["values"],
        idx: 4
      },
      argmin: {
        init: (m2) => m2.argmin = void 0,
        value: (m2) => m2.argmin || m2.cell.data.argmin(m2.get),
        add: (m2, v, t4) => {
          if (v < m2.min)
            m2.argmin = t4;
        },
        rem: (m2, v) => {
          if (v <= m2.min)
            m2.argmin = void 0;
        },
        req: ["min", "values"],
        idx: 3
      },
      argmax: {
        init: (m2) => m2.argmax = void 0,
        value: (m2) => m2.argmax || m2.cell.data.argmax(m2.get),
        add: (m2, v, t4) => {
          if (v > m2.max)
            m2.argmax = t4;
        },
        rem: (m2, v) => {
          if (v >= m2.max)
            m2.argmax = void 0;
        },
        req: ["max", "values"],
        idx: 3
      },
      exponential: {
        init: (m2, r) => {
          m2.exp = 0;
          m2.exp_r = r;
        },
        value: (m2) => m2.valid ? m2.exp * (1 - m2.exp_r) / (1 - m2.exp_r ** m2.valid) : void 0,
        add: (m2, v) => m2.exp = m2.exp_r * m2.exp + v,
        rem: (m2, v) => m2.exp = (m2.exp - v / m2.exp_r ** (m2.valid - 1)) / m2.exp_r
      },
      exponentialb: {
        value: (m2) => m2.valid ? m2.exp * (1 - m2.exp_r) : void 0,
        req: ["exponential"],
        idx: 1
      }
    };
    const ValidAggregateOps = Object.keys(AggregateOps).filter((d) => d !== "__count__");
    function measure(key2, value2) {
      return (out, aggregate_param) => extend({
        name: key2,
        aggregate_param,
        out: out || key2
      }, base_op, value2);
    }
    [...ValidAggregateOps, "__count__"].forEach((key2) => {
      AggregateOps[key2] = measure(key2, AggregateOps[key2]);
    });
    function createMeasure(op, param2, name2) {
      return AggregateOps[op](name2, param2);
    }
    function compareIndex(a2, b2) {
      return a2.idx - b2.idx;
    }
    function resolve(agg) {
      const map2 = {};
      agg.forEach((a2) => map2[a2.name] = a2);
      const getreqs = (a2) => {
        if (!a2.req)
          return;
        a2.req.forEach((key2) => {
          if (!map2[key2])
            getreqs(map2[key2] = AggregateOps[key2]());
        });
      };
      agg.forEach(getreqs);
      return Object.values(map2).sort(compareIndex);
    }
    function init() {
      this.valid = 0;
      this.missing = 0;
      this._ops.forEach((op) => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
    }
    function add$2(v, t4) {
      if (v == null || v === "") {
        ++this.missing;
        return;
      }
      if (v !== v)
        return;
      ++this.valid;
      this._ops.forEach((op) => op.add(this, v, t4));
    }
    function rem(v, t4) {
      if (v == null || v === "") {
        --this.missing;
        return;
      }
      if (v !== v)
        return;
      --this.valid;
      this._ops.forEach((op) => op.rem(this, v, t4));
    }
    function set$3(t4) {
      this._out.forEach((op) => t4[op.out] = op.value(this));
      return t4;
    }
    function compileMeasures(agg, field2) {
      const get2 = field2 || identity$1, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
      function ctr(cell2) {
        this._ops = ops2;
        this._out = out;
        this.cell = cell2;
        this.init();
      }
      ctr.prototype.init = init;
      ctr.prototype.add = add$2;
      ctr.prototype.rem = rem;
      ctr.prototype.set = set$3;
      ctr.prototype.get = get2;
      ctr.fields = agg.map((op) => op.out);
      return ctr;
    }
    function TupleStore(key2) {
      this._key = key2 ? field$1(key2) : tupleid;
      this.reset();
    }
    const prototype$1 = TupleStore.prototype;
    prototype$1.reset = function() {
      this._add = [];
      this._rem = [];
      this._ext = null;
      this._get = null;
      this._q = null;
    };
    prototype$1.add = function(v) {
      this._add.push(v);
    };
    prototype$1.rem = function(v) {
      this._rem.push(v);
    };
    prototype$1.values = function() {
      this._get = null;
      if (this._rem.length === 0)
        return this._add;
      const a2 = this._add, r = this._rem, k = this._key, n = a2.length, m2 = r.length, x2 = Array(n - m2), map2 = {};
      let i, j, v;
      for (i = 0; i < m2; ++i) {
        map2[k(r[i])] = 1;
      }
      for (i = 0, j = 0; i < n; ++i) {
        if (map2[k(v = a2[i])]) {
          map2[k(v)] = 0;
        } else {
          x2[j++] = v;
        }
      }
      this._rem = [];
      return this._add = x2;
    };
    prototype$1.distinct = function(get2) {
      const v = this.values(), map2 = {};
      let n = v.length, count2 = 0, s;
      while (--n >= 0) {
        s = get2(v[n]) + "";
        if (!has$1(map2, s)) {
          map2[s] = 1;
          ++count2;
        }
      }
      return count2;
    };
    prototype$1.extent = function(get2) {
      if (this._get !== get2 || !this._ext) {
        const v = this.values(), i = extentIndex(v, get2);
        this._ext = [v[i[0]], v[i[1]]];
        this._get = get2;
      }
      return this._ext;
    };
    prototype$1.argmin = function(get2) {
      return this.extent(get2)[0] || {};
    };
    prototype$1.argmax = function(get2) {
      return this.extent(get2)[1] || {};
    };
    prototype$1.min = function(get2) {
      const m2 = this.extent(get2)[0];
      return m2 != null ? get2(m2) : void 0;
    };
    prototype$1.max = function(get2) {
      const m2 = this.extent(get2)[1];
      return m2 != null ? get2(m2) : void 0;
    };
    prototype$1.quartile = function(get2) {
      if (this._get !== get2 || !this._q) {
        this._q = quartiles(this.values(), get2);
        this._get = get2;
      }
      return this._q;
    };
    prototype$1.q1 = function(get2) {
      return this.quartile(get2)[0];
    };
    prototype$1.q2 = function(get2) {
      return this.quartile(get2)[1];
    };
    prototype$1.q3 = function(get2) {
      return this.quartile(get2)[2];
    };
    prototype$1.ci = function(get2) {
      if (this._get !== get2 || !this._ci) {
        this._ci = bootstrapCI(this.values(), 1e3, 0.05, get2);
        this._get = get2;
      }
      return this._ci;
    };
    prototype$1.ci0 = function(get2) {
      return this.ci(get2)[0];
    };
    prototype$1.ci1 = function(get2) {
      return this.ci(get2)[1];
    };
    function Aggregate$1(params2) {
      Transform.call(this, null, params2);
      this._adds = [];
      this._mods = [];
      this._alen = 0;
      this._mlen = 0;
      this._drop = true;
      this._cross = false;
      this._dims = [];
      this._dnames = [];
      this._measures = [];
      this._countOnly = false;
      this._counts = null;
      this._prev = null;
      this._inputs = null;
      this._outputs = null;
    }
    Aggregate$1.Definition = {
      "type": "Aggregate",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidAggregateOps
      }, {
        "name": "aggregate_params",
        "type": "number",
        "null": true,
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "drop",
        "type": "boolean",
        "default": true
      }, {
        "name": "cross",
        "type": "boolean",
        "default": false
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(Aggregate$1, Transform, {
      transform(_, pulse2) {
        const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
        aggr.stamp = out.stamp;
        if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
          aggr._prev = aggr.value;
          aggr.value = mod ? aggr.init(_) : /* @__PURE__ */ Object.create(null);
          pulse2.visit(pulse2.SOURCE, (t4) => aggr.add(t4));
        } else {
          aggr.value = aggr.value || aggr.init(_);
          pulse2.visit(pulse2.REM, (t4) => aggr.rem(t4));
          pulse2.visit(pulse2.ADD, (t4) => aggr.add(t4));
        }
        out.modifies(aggr._outputs);
        aggr._drop = _.drop !== false;
        if (_.cross && aggr._dims.length > 1) {
          aggr._drop = false;
          aggr.cross();
        }
        if (pulse2.clean() && aggr._drop) {
          out.clean(true).runAfter(() => this.clean());
        }
        return aggr.changes(out);
      },
      cross() {
        const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
        function collect2(cells) {
          let key2, i, t4, v;
          for (key2 in cells) {
            t4 = cells[key2].tuple;
            for (i = 0; i < n; ++i) {
              vals2[i][v = t4[dims[i]]] = v;
            }
          }
        }
        collect2(aggr._prev);
        collect2(curr);
        function generate2(base2, tuple, index2) {
          const name2 = dims[index2], v = vals2[index2++];
          for (const k in v) {
            const key2 = base2 ? base2 + "|" + k : k;
            tuple[name2] = v[k];
            if (index2 < n)
              generate2(key2, tuple, index2);
            else if (!curr[key2])
              aggr.cell(key2, tuple);
          }
        }
        generate2("", {}, 0);
      },
      init(_) {
        const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
        function inputVisit(get2) {
          const fields2 = array$2(accessorFields(get2)), n2 = fields2.length;
          let i2 = 0, f;
          for (; i2 < n2; ++i2) {
            if (!inputMap[f = fields2[i2]]) {
              inputMap[f] = 1;
              inputs.push(f);
            }
          }
        }
        this._dims = array$2(_.groupby);
        this._dnames = this._dims.map((d) => {
          const dname = accessorName(d);
          inputVisit(d);
          outputs.push(dname);
          return dname;
        });
        this.cellkey = _.key ? _.key : groupkey(this._dims);
        this._countOnly = true;
        this._counts = [];
        this._measures = [];
        const fields = _.fields || [null], ops2 = _.ops || ["count"], aggregate_params = _.aggregate_params || [null], as = _.as || [], n = fields.length, map2 = {};
        let field2, op, aggregate_param, m2, mname, outname, i;
        if (n !== ops2.length) {
          error("Unmatched number of fields and aggregate ops.");
        }
        for (i = 0; i < n; ++i) {
          field2 = fields[i];
          op = ops2[i];
          aggregate_param = aggregate_params[i] || null;
          if (field2 == null && op !== "count") {
            error("Null aggregate field specified.");
          }
          mname = accessorName(field2);
          outname = measureName(op, mname, as[i]);
          outputs.push(outname);
          if (op === "count") {
            this._counts.push(outname);
            continue;
          }
          m2 = map2[mname];
          if (!m2) {
            inputVisit(field2);
            m2 = map2[mname] = [];
            m2.field = field2;
            this._measures.push(m2);
          }
          if (op !== "count")
            this._countOnly = false;
          m2.push(createMeasure(op, aggregate_param, outname));
        }
        this._measures = this._measures.map((m3) => compileMeasures(m3, m3.field));
        return /* @__PURE__ */ Object.create(null);
      },
      // -- Cell Management -----
      cellkey: groupkey(),
      cell(key2, t4) {
        let cell2 = this.value[key2];
        if (!cell2) {
          cell2 = this.value[key2] = this.newcell(key2, t4);
          this._adds[this._alen++] = cell2;
        } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
          cell2.stamp = this.stamp;
          this._adds[this._alen++] = cell2;
        } else if (cell2.stamp < this.stamp) {
          cell2.stamp = this.stamp;
          this._mods[this._mlen++] = cell2;
        }
        return cell2;
      },
      newcell(key2, t4) {
        const cell2 = {
          key: key2,
          num: 0,
          agg: null,
          tuple: this.newtuple(t4, this._prev && this._prev[key2]),
          stamp: this.stamp,
          store: false
        };
        if (!this._countOnly) {
          const measures = this._measures, n = measures.length;
          cell2.agg = Array(n);
          for (let i = 0; i < n; ++i) {
            cell2.agg[i] = new measures[i](cell2);
          }
        }
        if (cell2.store) {
          cell2.data = new TupleStore();
        }
        return cell2;
      },
      newtuple(t4, p) {
        const names = this._dnames, dims = this._dims, n = dims.length, x2 = {};
        for (let i = 0; i < n; ++i) {
          x2[names[i]] = dims[i](t4);
        }
        return p ? replace$1(p.tuple, x2) : ingest$1(x2);
      },
      clean() {
        const cells = this.value;
        for (const key2 in cells) {
          if (cells[key2].num === 0) {
            delete cells[key2];
          }
        }
      },
      // -- Process Tuples -----
      add(t4) {
        const key2 = this.cellkey(t4), cell2 = this.cell(key2, t4);
        cell2.num += 1;
        if (this._countOnly)
          return;
        if (cell2.store)
          cell2.data.add(t4);
        const agg = cell2.agg;
        for (let i = 0, n = agg.length; i < n; ++i) {
          agg[i].add(agg[i].get(t4), t4);
        }
      },
      rem(t4) {
        const key2 = this.cellkey(t4), cell2 = this.cell(key2, t4);
        cell2.num -= 1;
        if (this._countOnly)
          return;
        if (cell2.store)
          cell2.data.rem(t4);
        const agg = cell2.agg;
        for (let i = 0, n = agg.length; i < n; ++i) {
          agg[i].rem(agg[i].get(t4), t4);
        }
      },
      celltuple(cell2) {
        const tuple = cell2.tuple, counts = this._counts;
        if (cell2.store) {
          cell2.data.values();
        }
        for (let i = 0, n = counts.length; i < n; ++i) {
          tuple[counts[i]] = cell2.num;
        }
        if (!this._countOnly) {
          const agg = cell2.agg;
          for (let i = 0, n = agg.length; i < n; ++i) {
            agg[i].set(tuple);
          }
        }
        return tuple;
      },
      changes(out) {
        const adds = this._adds, mods = this._mods, prev2 = this._prev, drop = this._drop, add2 = out.add, rem2 = out.rem, mod = out.mod;
        let cell2, key2, i, n;
        if (prev2)
          for (key2 in prev2) {
            cell2 = prev2[key2];
            if (!drop || cell2.num)
              rem2.push(cell2.tuple);
          }
        for (i = 0, n = this._alen; i < n; ++i) {
          add2.push(this.celltuple(adds[i]));
          adds[i] = null;
        }
        for (i = 0, n = this._mlen; i < n; ++i) {
          cell2 = mods[i];
          (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
          mods[i] = null;
        }
        this._alen = this._mlen = 0;
        this._prev = null;
        return out;
      }
    });
    const EPSILON$1 = 1e-14;
    function Bin(params2) {
      Transform.call(this, null, params2);
    }
    Bin.Definition = {
      "type": "Bin",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "interval",
        "type": "boolean",
        "default": true
      }, {
        "name": "anchor",
        "type": "number"
      }, {
        "name": "maxbins",
        "type": "number",
        "default": 20
      }, {
        "name": "base",
        "type": "number",
        "default": 10
      }, {
        "name": "divide",
        "type": "number",
        "array": true,
        "default": [5, 2]
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "span",
        "type": "number"
      }, {
        "name": "step",
        "type": "number"
      }, {
        "name": "steps",
        "type": "number",
        "array": true
      }, {
        "name": "minstep",
        "type": "number",
        "default": 0
      }, {
        "name": "nice",
        "type": "boolean",
        "default": true
      }, {
        "name": "name",
        "type": "string"
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["bin0", "bin1"]
      }]
    };
    inherits(Bin, Transform, {
      transform(_, pulse2) {
        const band2 = _.interval !== false, bins2 = this._bins(_), start2 = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
        let flag2;
        if (_.modified()) {
          pulse2 = pulse2.reflow(true);
          flag2 = pulse2.SOURCE;
        } else {
          flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
        }
        pulse2.visit(flag2, band2 ? (t4) => {
          const v = bins2(t4);
          t4[b0] = v;
          t4[b1] = v == null ? null : start2 + step * (1 + (v - start2) / step);
        } : (t4) => t4[b0] = bins2(t4));
        return pulse2.modifies(band2 ? as : b0);
      },
      _bins(_) {
        if (this.value && !_.modified()) {
          return this.value;
        }
        const field2 = _.field, bins2 = bin$1(_), step = bins2.step;
        let start2 = bins2.start, stop2 = start2 + Math.ceil((bins2.stop - start2) / step) * step, a2, d;
        if ((a2 = _.anchor) != null) {
          d = a2 - (start2 + step * Math.floor((a2 - start2) / step));
          start2 += d;
          stop2 += d;
        }
        const f = function(t4) {
          let v = toNumber(field2(t4));
          return v == null ? null : v < start2 ? -Infinity : v > stop2 ? Infinity : (v = Math.max(start2, Math.min(v, stop2 - step)), start2 + step * Math.floor(EPSILON$1 + (v - start2) / step));
        };
        f.start = start2;
        f.stop = bins2.stop;
        f.step = step;
        return this.value = accessor(f, accessorFields(field2), _.name || "bin_" + accessorName(field2));
      }
    });
    function SortedList(idFunc, source2, input) {
      const $2 = idFunc;
      let data2 = source2 || [], add2 = input || [], rem2 = {}, cnt = 0;
      return {
        add: (t4) => add2.push(t4),
        remove: (t4) => rem2[$2(t4)] = ++cnt,
        size: () => data2.length,
        data: (compare2, resort) => {
          if (cnt) {
            data2 = data2.filter((t4) => !rem2[$2(t4)]);
            rem2 = {};
            cnt = 0;
          }
          if (resort && compare2) {
            data2.sort(compare2);
          }
          if (add2.length) {
            data2 = compare2 ? merge$2(compare2, data2, add2.sort(compare2)) : data2.concat(add2);
            add2 = [];
          }
          return data2;
        }
      };
    }
    function Collect$1(params2) {
      Transform.call(this, [], params2);
    }
    Collect$1.Definition = {
      "type": "Collect",
      "metadata": {
        "source": true
      },
      "params": [{
        "name": "sort",
        "type": "compare"
      }]
    };
    inherits(Collect$1, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.ALL), list2 = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort2 = _.sort, mod = pulse2.changed() || sort2 && (_.modified("sort") || pulse2.modified(sort2.fields));
        out.visit(out.REM, list2.remove);
        this.modified(mod);
        this.value = out.source = list2.data(stableCompare(sort2), mod);
        if (pulse2.source && pulse2.source.root) {
          this.value.root = pulse2.source.root;
        }
        return out;
      }
    });
    function Compare$1(params2) {
      Operator.call(this, null, update$5, params2);
    }
    inherits(Compare$1, Operator);
    function update$5(_) {
      return this.value && !_.modified() ? this.value : compare$8(_.fields, _.orders);
    }
    function CountPattern(params2) {
      Transform.call(this, null, params2);
    }
    CountPattern.Definition = {
      "type": "CountPattern",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "case",
        "type": "enum",
        "values": ["upper", "lower", "mixed"],
        "default": "mixed"
      }, {
        "name": "pattern",
        "type": "string",
        "default": '[\\w"]+'
      }, {
        "name": "stopwords",
        "type": "string",
        "default": ""
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["text", "count"]
      }]
    };
    function tokenize(text2, tcase, match2) {
      switch (tcase) {
        case "upper":
          text2 = text2.toUpperCase();
          break;
        case "lower":
          text2 = text2.toLowerCase();
          break;
      }
      return text2.match(match2);
    }
    inherits(CountPattern, Transform, {
      transform(_, pulse2) {
        const process2 = (update2) => (tuple) => {
          var tokens = tokenize(get2(tuple), _.case, match2) || [], t4;
          for (var i = 0, n = tokens.length; i < n; ++i) {
            if (!stop2.test(t4 = tokens[i]))
              update2(t4);
          }
        };
        const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match2 = this._match, stop2 = this._stop, get2 = _.field, as = _.as || ["text", "count"], add2 = process2((t4) => counts[t4] = 1 + (counts[t4] || 0)), rem2 = process2((t4) => counts[t4] -= 1);
        if (init2) {
          pulse2.visit(pulse2.SOURCE, add2);
        } else {
          pulse2.visit(pulse2.ADD, add2);
          pulse2.visit(pulse2.REM, rem2);
        }
        return this._finish(pulse2, as);
      },
      _parameterCheck(_, pulse2) {
        let init2 = false;
        if (_.modified("stopwords") || !this._stop) {
          this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
          init2 = true;
        }
        if (_.modified("pattern") || !this._match) {
          this._match = new RegExp(_.pattern || "[\\w']+", "g");
          init2 = true;
        }
        if (_.modified("field") || pulse2.modified(_.field.fields)) {
          init2 = true;
        }
        if (init2)
          this._counts = {};
        return init2;
      },
      _finish(pulse2, as) {
        const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text2 = as[0], count2 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        let w2, t4, c2;
        for (w2 in counts) {
          t4 = tuples[w2];
          c2 = counts[w2] || 0;
          if (!t4 && c2) {
            tuples[w2] = t4 = ingest$1({});
            t4[text2] = w2;
            t4[count2] = c2;
            out.add.push(t4);
          } else if (c2 === 0) {
            if (t4)
              out.rem.push(t4);
            counts[w2] = null;
            tuples[w2] = null;
          } else if (t4[count2] !== c2) {
            t4[count2] = c2;
            out.mod.push(t4);
          }
        }
        return out.modifies(as);
      }
    });
    function Cross(params2) {
      Transform.call(this, null, params2);
    }
    Cross.Definition = {
      "type": "Cross",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "filter",
        "type": "expr"
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["a", "b"]
      }]
    };
    inherits(Cross, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a2 = as[0], b2 = as[1], reset2 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
        let data2 = this.value;
        if (reset2) {
          if (data2)
            out.rem = data2;
          data2 = pulse2.materialize(pulse2.SOURCE).source;
          out.add = this.value = cross(data2, a2, b2, _.filter || truthy);
        } else {
          out.mod = data2;
        }
        out.source = this.value;
        return out.modifies(as);
      }
    });
    function cross(input, a2, b2, filter2) {
      var data2 = [], t4 = {}, n = input.length, i = 0, j, left2;
      for (; i < n; ++i) {
        t4[a2] = left2 = input[i];
        for (j = 0; j < n; ++j) {
          t4[b2] = input[j];
          if (filter2(t4)) {
            data2.push(ingest$1(t4));
            t4 = {};
            t4[a2] = left2;
          }
        }
      }
      return data2;
    }
    const Distributions = {
      kde,
      mixture: mixture$1,
      normal: gaussian,
      lognormal,
      uniform
    };
    const DISTRIBUTIONS = "distributions", FUNCTION = "function", FIELD = "field";
    function parse$4(def2, data2) {
      const func2 = def2[FUNCTION];
      if (!has$1(Distributions, func2)) {
        error("Unknown distribution function: " + func2);
      }
      const d = Distributions[func2]();
      for (const name2 in def2) {
        if (name2 === FIELD) {
          d.data((def2.from || data2()).map(def2[name2]));
        } else if (name2 === DISTRIBUTIONS) {
          d[name2](def2[name2].map((_) => parse$4(_, data2)));
        } else if (typeof d[name2] === FUNCTION) {
          d[name2](def2[name2]);
        }
      }
      return d;
    }
    function Density(params2) {
      Transform.call(this, null, params2);
    }
    const distributions = [{
      "key": {
        "function": "normal"
      },
      "params": [{
        "name": "mean",
        "type": "number",
        "default": 0
      }, {
        "name": "stdev",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "lognormal"
      },
      "params": [{
        "name": "mean",
        "type": "number",
        "default": 0
      }, {
        "name": "stdev",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "uniform"
      },
      "params": [{
        "name": "min",
        "type": "number",
        "default": 0
      }, {
        "name": "max",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "kde"
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "from",
        "type": "data"
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0
      }]
    }];
    const mixture = {
      "key": {
        "function": "mixture"
      },
      "params": [{
        "name": "distributions",
        "type": "param",
        "array": true,
        "params": distributions
      }, {
        "name": "weights",
        "type": "number",
        "array": true
      }]
    };
    Density.Definition = {
      "type": "Density",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "steps",
        "type": "number"
      }, {
        "name": "minsteps",
        "type": "number",
        "default": 25
      }, {
        "name": "maxsteps",
        "type": "number",
        "default": 200
      }, {
        "name": "method",
        "type": "string",
        "default": "pdf",
        "values": ["pdf", "cdf"]
      }, {
        "name": "distribution",
        "type": "param",
        "params": distributions.concat(mixture)
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["value", "density"]
      }]
    };
    inherits(Density, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const dist2 = parse$4(_.distribution, source$1(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
          let method2 = _.method || "pdf";
          if (method2 !== "pdf" && method2 !== "cdf") {
            error("Invalid density method: " + method2);
          }
          if (!_.extent && !dist2.data) {
            error("Missing density extent parameter.");
          }
          method2 = dist2[method2];
          const as = _.as || ["value", "density"], domain2 = _.extent || extent(dist2.data()), values2 = sampleCurve(method2, domain2, minsteps, maxsteps).map((v) => {
            const tuple = {};
            tuple[as[0]] = v[0];
            tuple[as[1]] = v[1];
            return ingest$1(tuple);
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values2;
        }
        return out;
      }
    });
    function source$1(pulse2) {
      return () => pulse2.materialize(pulse2.SOURCE).source;
    }
    function fieldNames(fields, as) {
      if (!fields)
        return null;
      return fields.map((f, i) => as[i] || accessorName(f));
    }
    function partition$1$1(data2, groupby, field2) {
      const groups = [], get2 = (f) => f(t4);
      let map2, i, n, t4, k, g;
      if (groupby == null) {
        groups.push(data2.map(field2));
      } else {
        for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
          t4 = data2[i];
          k = groupby.map(get2);
          g = map2[k];
          if (!g) {
            map2[k] = g = [];
            g.dims = k;
            groups.push(g);
          }
          g.push(field2(t4));
        }
      }
      return groups;
    }
    const Output$5 = "bin";
    function DotBin(params2) {
      Transform.call(this, null, params2);
    }
    DotBin.Definition = {
      "type": "DotBin",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "step",
        "type": "number"
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "default": Output$5
      }]
    };
    const autostep = (data2, field2) => span(extent(data2, field2)) / 30;
    inherits(DotBin, Transform, {
      transform(_, pulse2) {
        if (this.value && !(_.modified() || pulse2.changed())) {
          return pulse2;
        }
        const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(pulse2.source, _.groupby, identity$1), smooth = _.smooth || false, field2 = _.field, step = _.step || autostep(source2, field2), sort2 = stableCompare((a2, b2) => field2(a2) - field2(b2)), as = _.as || Output$5, n = groups.length;
        let min2 = Infinity, max2 = -Infinity, i = 0, j;
        for (; i < n; ++i) {
          const g = groups[i].sort(sort2);
          j = -1;
          for (const v of dotbin(g, step, smooth, field2)) {
            if (v < min2)
              min2 = v;
            if (v > max2)
              max2 = v;
            g[++j][as] = v;
          }
        }
        this.value = {
          start: min2,
          stop: max2,
          step
        };
        return pulse2.reflow(true).modifies(as);
      }
    });
    function Expression$1(params2) {
      Operator.call(this, null, update$4, params2);
      this.modified(true);
    }
    inherits(Expression$1, Operator);
    function update$4(_) {
      const expr2 = _.expr;
      return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
    }
    function Extent(params2) {
      Transform.call(this, [void 0, void 0], params2);
    }
    Extent.Definition = {
      "type": "Extent",
      "metadata": {},
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }]
    };
    inherits(Extent, Transform, {
      transform(_, pulse2) {
        const extent2 = this.value, field2 = _.field, mod = pulse2.changed() || pulse2.modified(field2.fields) || _.modified("field");
        let min2 = extent2[0], max2 = extent2[1];
        if (mod || min2 == null) {
          min2 = Infinity;
          max2 = -Infinity;
        }
        pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t4) => {
          const v = toNumber(field2(t4));
          if (v != null) {
            if (v < min2)
              min2 = v;
            if (v > max2)
              max2 = v;
          }
        });
        if (!Number.isFinite(min2) || !Number.isFinite(max2)) {
          let name2 = accessorName(field2);
          if (name2)
            name2 = ` for field "${name2}"`;
          pulse2.dataflow.warn(`Infinite extent${name2}: [${min2}, ${max2}]`);
          min2 = max2 = void 0;
        }
        this.value = [min2, max2];
      }
    });
    function Subflow(pulse2, parent) {
      Operator.call(this, pulse2);
      this.parent = parent;
      this.count = 0;
    }
    inherits(Subflow, Operator, {
      /**
       * Routes pulses from this subflow to a target transform.
       * @param {Transform} target - A transform that receives the subflow of tuples.
       */
      connect(target2) {
        this.detachSubflow = target2.detachSubflow;
        this.targets().add(target2);
        return target2.source = this;
      },
      /**
       * Add an 'add' tuple to the subflow pulse.
       * @param {Tuple} t - The tuple being added.
       */
      add(t4) {
        this.count += 1;
        this.value.add.push(t4);
      },
      /**
       * Add a 'rem' tuple to the subflow pulse.
       * @param {Tuple} t - The tuple being removed.
       */
      rem(t4) {
        this.count -= 1;
        this.value.rem.push(t4);
      },
      /**
       * Add a 'mod' tuple to the subflow pulse.
       * @param {Tuple} t - The tuple being modified.
       */
      mod(t4) {
        this.value.mod.push(t4);
      },
      /**
       * Re-initialize this operator's pulse value.
       * @param {Pulse} pulse - The pulse to copy from.
       * @see Pulse.init
       */
      init(pulse2) {
        this.value.init(pulse2, pulse2.NO_SOURCE);
      },
      /**
       * Evaluate this operator. This method overrides the
       * default behavior to simply return the contained pulse value.
       * @return {Pulse}
       */
      evaluate() {
        return this.value;
      }
    });
    function Facet$1(params2) {
      Transform.call(this, {}, params2);
      this._keys = fastmap();
      const a2 = this._targets = [];
      a2.active = 0;
      a2.forEach = (f) => {
        for (let i = 0, n = a2.active; i < n; ++i) {
          f(a2[i], i, a2);
        }
      };
    }
    inherits(Facet$1, Transform, {
      activate(flow) {
        this._targets[this._targets.active++] = flow;
      },
      // parent argument provided by PreFacet subclass
      subflow(key2, flow, pulse2, parent) {
        const flows = this.value;
        let sf = has$1(flows, key2) && flows[key2], df, p;
        if (!sf) {
          p = parent || (p = this._group[key2]) && p.tuple;
          df = pulse2.dataflow;
          sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
          df.add(sf).connect(flow(df, key2, p));
          flows[key2] = sf;
          this.activate(sf);
        } else if (sf.value.stamp < pulse2.stamp) {
          sf.init(pulse2);
          this.activate(sf);
        }
        return sf;
      },
      clean() {
        const flows = this.value;
        let detached = 0;
        for (const key2 in flows) {
          if (flows[key2].count === 0) {
            const detach2 = flows[key2].detachSubflow;
            if (detach2)
              detach2();
            delete flows[key2];
            ++detached;
          }
        }
        if (detached) {
          const active = this._targets.filter((sf) => sf && sf.count > 0);
          this.initTargets(active);
        }
      },
      initTargets(act) {
        const a2 = this._targets, n = a2.length, m2 = act ? act.length : 0;
        let i = 0;
        for (; i < m2; ++i) {
          a2[i] = act[i];
        }
        for (; i < n && a2[i] != null; ++i) {
          a2[i] = null;
        }
        a2.active = m2;
      },
      transform(_, pulse2) {
        const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
        this._group = _.group || {};
        this.initTargets();
        pulse2.visit(pulse2.REM, (t4) => {
          const id2 = tupleid(t4), k = cache2.get(id2);
          if (k !== void 0) {
            cache2.delete(id2);
            subflow(k).rem(t4);
          }
        });
        pulse2.visit(pulse2.ADD, (t4) => {
          const k = key2(t4);
          cache2.set(tupleid(t4), k);
          subflow(k).add(t4);
        });
        if (rekey || pulse2.modified(key2.fields)) {
          pulse2.visit(pulse2.MOD, (t4) => {
            const id2 = tupleid(t4), k0 = cache2.get(id2), k1 = key2(t4);
            if (k0 === k1) {
              subflow(k1).mod(t4);
            } else {
              cache2.set(id2, k1);
              subflow(k0).rem(t4);
              subflow(k1).add(t4);
            }
          });
        } else if (pulse2.changed(pulse2.MOD)) {
          pulse2.visit(pulse2.MOD, (t4) => {
            subflow(cache2.get(tupleid(t4))).mod(t4);
          });
        }
        if (rekey) {
          pulse2.visit(pulse2.REFLOW, (t4) => {
            const id2 = tupleid(t4), k0 = cache2.get(id2), k1 = key2(t4);
            if (k0 !== k1) {
              cache2.set(id2, k1);
              subflow(k0).rem(t4);
              subflow(k1).add(t4);
            }
          });
        }
        if (pulse2.clean()) {
          df.runAfter(() => {
            this.clean();
            cache2.clean();
          });
        } else if (cache2.empty > df.cleanThreshold) {
          df.runAfter(cache2.clean);
        }
        return pulse2;
      }
    });
    function Field$1(params2) {
      Operator.call(this, null, update$3, params2);
    }
    inherits(Field$1, Operator);
    function update$3(_) {
      return this.value && !_.modified() ? this.value : isArray(_.name) ? array$2(_.name).map((f) => field$1(f)) : field$1(_.name, _.as);
    }
    function Filter(params2) {
      Transform.call(this, fastmap(), params2);
    }
    Filter.Definition = {
      "type": "Filter",
      "metadata": {
        "changes": true
      },
      "params": [{
        "name": "expr",
        "type": "expr",
        "required": true
      }]
    };
    inherits(Filter, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow, cache2 = this.value, output2 = pulse2.fork(), add2 = output2.add, rem2 = output2.rem, mod = output2.mod, test2 = _.expr;
        let isMod = true;
        pulse2.visit(pulse2.REM, (t4) => {
          const id2 = tupleid(t4);
          if (!cache2.has(id2))
            rem2.push(t4);
          else
            cache2.delete(id2);
        });
        pulse2.visit(pulse2.ADD, (t4) => {
          if (test2(t4, _))
            add2.push(t4);
          else
            cache2.set(tupleid(t4), 1);
        });
        function revisit(t4) {
          const id2 = tupleid(t4), b2 = test2(t4, _), s = cache2.get(id2);
          if (b2 && s) {
            cache2.delete(id2);
            add2.push(t4);
          } else if (!b2 && !s) {
            cache2.set(id2, 1);
            rem2.push(t4);
          } else if (isMod && b2 && !s) {
            mod.push(t4);
          }
        }
        pulse2.visit(pulse2.MOD, revisit);
        if (_.modified()) {
          isMod = false;
          pulse2.visit(pulse2.REFLOW, revisit);
        }
        if (cache2.empty > df.cleanThreshold)
          df.runAfter(cache2.clean);
        return output2;
      }
    });
    function Flatten(params2) {
      Transform.call(this, [], params2);
    }
    Flatten.Definition = {
      "type": "Flatten",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "index",
        "type": "string"
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Flatten, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index2 = _.index || null, m2 = as.length;
        out.rem = this.value;
        pulse2.visit(pulse2.SOURCE, (t4) => {
          const arrays = fields.map((f) => f(t4)), maxlen = arrays.reduce((l, a2) => Math.max(l, a2.length), 0);
          let i = 0, j, d, v;
          for (; i < maxlen; ++i) {
            d = derive(t4);
            for (j = 0; j < m2; ++j) {
              d[as[j]] = (v = arrays[j][i]) == null ? null : v;
            }
            if (index2) {
              d[index2] = i;
            }
            out.add.push(d);
          }
        });
        this.value = out.source = out.add;
        if (index2)
          out.modifies(index2);
        return out.modifies(as);
      }
    });
    function Fold(params2) {
      Transform.call(this, [], params2);
    }
    Fold.Definition = {
      "type": "Fold",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["key", "value"]
      }]
    };
    inherits(Fold, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k = as[0], v = as[1], n = fields.length;
        out.rem = this.value;
        pulse2.visit(pulse2.SOURCE, (t4) => {
          for (let i = 0, d; i < n; ++i) {
            d = derive(t4);
            d[k] = fnames[i];
            d[v] = fields[i](t4);
            out.add.push(d);
          }
        });
        this.value = out.source = out.add;
        return out.modifies(as);
      }
    });
    function Formula(params2) {
      Transform.call(this, null, params2);
    }
    Formula.Definition = {
      "type": "Formula",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "expr",
        "type": "expr",
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "required": true
      }, {
        "name": "initonly",
        "type": "boolean"
      }]
    };
    inherits(Formula, Transform, {
      transform(_, pulse2) {
        const func2 = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func2.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
        if (mod) {
          pulse2 = pulse2.materialize().reflow(true);
        }
        if (!_.initonly) {
          pulse2.modifies(as);
        }
        return pulse2.visit(flag2, (t4) => t4[as] = func2(t4, _));
      }
    });
    function Generate(params2) {
      Transform.call(this, [], params2);
    }
    inherits(Generate, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.ALL), gen = _.generator;
        let data2 = this.value, num = _.size - data2.length, add2, rem2, t4;
        if (num > 0) {
          for (add2 = []; --num >= 0; ) {
            add2.push(t4 = ingest$1(gen(_)));
            data2.push(t4);
          }
          out.add = out.add.length ? out.materialize(out.ADD).add.concat(add2) : add2;
        } else {
          rem2 = data2.slice(0, -num);
          out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
          data2 = data2.slice(-num);
        }
        out.source = this.value = data2;
        return out;
      }
    });
    const Methods$1 = {
      value: "value",
      median,
      mean,
      min: min$2,
      max: max$2
    };
    const Empty$1 = [];
    function Impute(params2) {
      Transform.call(this, [], params2);
    }
    Impute.Definition = {
      "type": "Impute",
      "metadata": {
        "changes": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "key",
        "type": "field",
        "required": true
      }, {
        "name": "keyvals",
        "array": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "method",
        "type": "enum",
        "default": "value",
        "values": ["value", "mean", "median", "max", "min"]
      }, {
        "name": "value",
        "default": 0
      }]
    };
    function getValue(_) {
      var m2 = _.method || Methods$1.value, v;
      if (Methods$1[m2] == null) {
        error("Unrecognized imputation method: " + m2);
      } else if (m2 === Methods$1.value) {
        v = _.value !== void 0 ? _.value : 0;
        return () => v;
      } else {
        return Methods$1[m2];
      }
    }
    function getField$1(_) {
      const f = _.field;
      return (t4) => t4 ? f(t4) : NaN;
    }
    inherits(Impute, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field2 = getField$1(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition$3(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev2 = this.value, m2 = groups.domain.length, group2, value2, gVals, kVal, g, i, j, l, n, t4;
        for (g = 0, l = groups.length; g < l; ++g) {
          group2 = groups[g];
          gVals = group2.values;
          value2 = NaN;
          for (j = 0; j < m2; ++j) {
            if (group2[j] != null)
              continue;
            kVal = groups.domain[j];
            t4 = {
              _impute: true
            };
            for (i = 0, n = gVals.length; i < n; ++i)
              t4[gNames[i]] = gVals[i];
            t4[kName] = kVal;
            t4[fName] = Number.isNaN(value2) ? value2 = impute(group2, field2) : value2;
            curr.push(ingest$1(t4));
          }
        }
        if (curr.length)
          out.add = out.materialize(out.ADD).add.concat(curr);
        if (prev2.length)
          out.rem = out.materialize(out.REM).rem.concat(prev2);
        this.value = curr;
        return out;
      }
    });
    function partition$3(data2, groupby, key2, keyvals) {
      var get2 = (f) => f(t4), groups = [], domain2 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k, n, t4;
      domain2.forEach((k2, i2) => kMap[k2] = i2 + 1);
      for (i = 0, n = data2.length; i < n; ++i) {
        t4 = data2[i];
        k = key2(t4);
        j = kMap[k] || (kMap[k] = domain2.push(k));
        gKey = (gVals = groupby ? groupby.map(get2) : Empty$1) + "";
        if (!(group2 = gMap[gKey])) {
          group2 = gMap[gKey] = [];
          groups.push(group2);
          group2.values = gVals;
        }
        group2[j - 1] = t4;
      }
      groups.domain = domain2;
      return groups;
    }
    function JoinAggregate(params2) {
      Aggregate$1.call(this, params2);
    }
    JoinAggregate.Definition = {
      "type": "JoinAggregate",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidAggregateOps
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(JoinAggregate, Aggregate$1, {
      transform(_, pulse2) {
        const aggr = this, mod = _.modified();
        let cells;
        if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
          cells = aggr.value = mod ? aggr.init(_) : {};
          pulse2.visit(pulse2.SOURCE, (t4) => aggr.add(t4));
        } else {
          cells = aggr.value = aggr.value || this.init(_);
          pulse2.visit(pulse2.REM, (t4) => aggr.rem(t4));
          pulse2.visit(pulse2.ADD, (t4) => aggr.add(t4));
        }
        aggr.changes();
        pulse2.visit(pulse2.SOURCE, (t4) => {
          extend(t4, cells[aggr.cellkey(t4)].tuple);
        });
        return pulse2.reflow(mod).modifies(this._outputs);
      },
      changes() {
        const adds = this._adds, mods = this._mods;
        let i, n;
        for (i = 0, n = this._alen; i < n; ++i) {
          this.celltuple(adds[i]);
          adds[i] = null;
        }
        for (i = 0, n = this._mlen; i < n; ++i) {
          this.celltuple(mods[i]);
          mods[i] = null;
        }
        this._alen = this._mlen = 0;
      }
    });
    function KDE(params2) {
      Transform.call(this, null, params2);
    }
    KDE.Definition = {
      "type": "KDE",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "cumulative",
        "type": "boolean",
        "default": false
      }, {
        "name": "counts",
        "type": "boolean",
        "default": false
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "steps",
        "type": "number"
      }, {
        "name": "minsteps",
        "type": "number",
        "default": 25
      }, {
        "name": "maxsteps",
        "type": "number",
        "default": 200
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["value", "density"]
      }]
    };
    inherits(KDE, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(source2, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values2 = [];
          let domain2 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
          if (method2 !== "pdf" && method2 !== "cdf") {
            error("Invalid density method: " + method2);
          }
          if (_.resolve === "shared") {
            if (!domain2)
              domain2 = extent(source2, _.field);
            minsteps = maxsteps = _.steps || maxsteps;
          }
          groups.forEach((g) => {
            const density = kde(g, bandwidth2)[method2], scale2 = _.counts ? g.length : 1, local = domain2 || extent(g);
            sampleCurve(density, local, minsteps, maxsteps).forEach((v) => {
              const t4 = {};
              for (let i = 0; i < names.length; ++i) {
                t4[names[i]] = g.dims[i];
              }
              t4[as[0]] = v[0];
              t4[as[1]] = v[1] * scale2;
              values2.push(ingest$1(t4));
            });
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values2;
        }
        return out;
      }
    });
    function Key$1(params2) {
      Operator.call(this, null, update$2, params2);
    }
    inherits(Key$1, Operator);
    function update$2(_) {
      return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
    }
    function Load$1(params2) {
      Transform.call(this, [], params2);
      this._pending = null;
    }
    inherits(Load$1, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow;
        if (this._pending) {
          return output(this, pulse2, this._pending);
        }
        if (stop(_))
          return pulse2.StopPropagation;
        if (_.values) {
          return output(this, pulse2, df.parse(_.values, _.format));
        } else if (_.async) {
          const p = df.request(_.url, _.format).then((res) => {
            this._pending = array$2(res.data);
            return (df2) => df2.touch(this);
          });
          return {
            async: p
          };
        } else {
          return df.request(_.url, _.format).then((res) => output(this, pulse2, array$2(res.data)));
        }
      }
    });
    function stop(_) {
      return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
    }
    function output(op, pulse2, data2) {
      data2.forEach(ingest$1);
      const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
      out.rem = op.value;
      op.value = out.source = out.add = data2;
      op._pending = null;
      if (out.rem.length)
        out.clean(true);
      return out;
    }
    function Lookup(params2) {
      Transform.call(this, {}, params2);
    }
    Lookup.Definition = {
      "type": "Lookup",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "index",
        "type": "index",
        "params": [{
          "name": "from",
          "type": "data",
          "required": true
        }, {
          "name": "key",
          "type": "field",
          "required": true
        }]
      }, {
        "name": "values",
        "type": "field",
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }, {
        "name": "default",
        "default": null
      }]
    };
    inherits(Lookup, Transform, {
      transform(_, pulse2) {
        const keys2 = _.fields, index2 = _.index, values2 = _.values, defaultValue = _.default == null ? null : _.default, reset2 = _.modified(), n = keys2.length;
        let flag2 = reset2 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set2, m2, mods;
        if (values2) {
          m2 = values2.length;
          if (n > 1 && !as) {
            error('Multi-field lookup requires explicit "as" parameter.');
          }
          if (as && as.length !== n * m2) {
            error('The "as" parameter has too few output field names.');
          }
          as = as || values2.map(accessorName);
          set2 = function(t4) {
            for (var i = 0, k = 0, j, v; i < n; ++i) {
              v = index2.get(keys2[i](t4));
              if (v == null)
                for (j = 0; j < m2; ++j, ++k)
                  t4[as[k]] = defaultValue;
              else
                for (j = 0; j < m2; ++j, ++k)
                  t4[as[k]] = values2[j](v);
            }
          };
        } else {
          if (!as) {
            error("Missing output field names.");
          }
          set2 = function(t4) {
            for (var i = 0, v; i < n; ++i) {
              v = index2.get(keys2[i](t4));
              t4[as[i]] = v == null ? defaultValue : v;
            }
          };
        }
        if (reset2) {
          out = pulse2.reflow(true);
        } else {
          mods = keys2.some((k) => pulse2.modified(k.fields));
          flag2 |= mods ? pulse2.MOD : 0;
        }
        pulse2.visit(flag2, set2);
        return out.modifies(as);
      }
    });
    function MultiExtent$1(params2) {
      Operator.call(this, null, update$1, params2);
    }
    inherits(MultiExtent$1, Operator);
    function update$1(_) {
      if (this.value && !_.modified()) {
        return this.value;
      }
      const ext = _.extents, n = ext.length;
      let min2 = Infinity, max2 = -Infinity, i, e3;
      for (i = 0; i < n; ++i) {
        e3 = ext[i];
        if (e3[0] < min2)
          min2 = e3[0];
        if (e3[1] > max2)
          max2 = e3[1];
      }
      return [min2, max2];
    }
    function MultiValues$1(params2) {
      Operator.call(this, null, update, params2);
    }
    inherits(MultiValues$1, Operator);
    function update(_) {
      return this.value && !_.modified() ? this.value : _.values.reduce((data2, _2) => data2.concat(_2), []);
    }
    function Params$2(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Params$2, Transform, {
      transform(_, pulse2) {
        this.modified(_.modified());
        this.value = _;
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
    function Pivot(params2) {
      Aggregate$1.call(this, params2);
    }
    Pivot.Definition = {
      "type": "Pivot",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "value",
        "type": "field",
        "required": true
      }, {
        "name": "op",
        "type": "enum",
        "values": ValidAggregateOps,
        "default": "sum"
      }, {
        "name": "limit",
        "type": "number",
        "default": 0
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(Pivot, Aggregate$1, {
      _transform: Aggregate$1.prototype.transform,
      transform(_, pulse2) {
        return this._transform(aggregateParams(_, pulse2), pulse2);
      }
    });
    function aggregateParams(_, pulse2) {
      const key2 = _.field, value2 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value2)), keys2 = pivotKeys(key2, _.limit || 0, pulse2);
      if (pulse2.changed())
        _.set("__pivot__", null, null, true);
      return {
        key: _.key,
        groupby: _.groupby,
        ops: keys2.map(() => op),
        fields: keys2.map((k) => get$4(k, key2, value2, fields)),
        as: keys2.map((k) => k + ""),
        modified: _.modified.bind(_)
      };
    }
    function get$4(k, key2, value2, fields) {
      return accessor((d) => key2(d) === k ? value2(d) : NaN, fields, k + "");
    }
    function pivotKeys(key2, limit, pulse2) {
      const map2 = {}, list2 = [];
      pulse2.visit(pulse2.SOURCE, (t4) => {
        const k = key2(t4);
        if (!map2[k]) {
          map2[k] = 1;
          list2.push(k);
        }
      });
      list2.sort(ascending$1);
      return limit ? list2.slice(0, limit) : list2;
    }
    function PreFacet$1(params2) {
      Facet$1.call(this, params2);
    }
    inherits(PreFacet$1, Facet$1, {
      transform(_, pulse2) {
        const flow = _.subflow, field2 = _.field, subflow = (t4) => this.subflow(tupleid(t4), flow, pulse2, t4);
        if (_.modified("field") || field2 && pulse2.modified(accessorFields(field2))) {
          error("PreFacet does not support field modification.");
        }
        this.initTargets();
        if (field2) {
          pulse2.visit(pulse2.MOD, (t4) => {
            const sf = subflow(t4);
            field2(t4).forEach((_2) => sf.mod(_2));
          });
          pulse2.visit(pulse2.ADD, (t4) => {
            const sf = subflow(t4);
            field2(t4).forEach((_2) => sf.add(ingest$1(_2)));
          });
          pulse2.visit(pulse2.REM, (t4) => {
            const sf = subflow(t4);
            field2(t4).forEach((_2) => sf.rem(_2));
          });
        } else {
          pulse2.visit(pulse2.MOD, (t4) => subflow(t4).mod(t4));
          pulse2.visit(pulse2.ADD, (t4) => subflow(t4).add(t4));
          pulse2.visit(pulse2.REM, (t4) => subflow(t4).rem(t4));
        }
        if (pulse2.clean()) {
          pulse2.runAfter(() => this.clean());
        }
        return pulse2;
      }
    });
    function Project(params2) {
      Transform.call(this, null, params2);
    }
    Project.Definition = {
      "type": "Project",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }]
    };
    inherits(Project, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t4) => project$1(s, t4, fields, as) : rederive;
        let lut;
        if (this.value) {
          lut = this.value;
        } else {
          pulse2 = pulse2.addAll();
          lut = this.value = {};
        }
        pulse2.visit(pulse2.REM, (t4) => {
          const id2 = tupleid(t4);
          out.rem.push(lut[id2]);
          lut[id2] = null;
        });
        pulse2.visit(pulse2.ADD, (t4) => {
          const dt = derive2(t4, ingest$1({}));
          lut[tupleid(t4)] = dt;
          out.add.push(dt);
        });
        pulse2.visit(pulse2.MOD, (t4) => {
          out.mod.push(derive2(t4, lut[tupleid(t4)]));
        });
        return out;
      }
    });
    function project$1(s, t4, fields, as) {
      for (let i = 0, n = fields.length; i < n; ++i) {
        t4[as[i]] = fields[i](s);
      }
      return t4;
    }
    function Proxy$2(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Proxy$2, Transform, {
      transform(_, pulse2) {
        this.value = _.value;
        return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
      }
    });
    function Quantile$1(params2) {
      Transform.call(this, null, params2);
    }
    Quantile$1.Definition = {
      "type": "Quantile",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "probs",
        "type": "number",
        "array": true
      }, {
        "name": "step",
        "type": "number",
        "default": 0.01
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["prob", "value"]
      }]
    };
    const EPSILON = 1e-14;
    inherits(Quantile$1, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
        if (this.value && !_.modified() && !pulse2.changed()) {
          out.source = this.value;
          return out;
        }
        const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1$1(source2, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values2 = [], step = _.step || 0.01, p = _.probs || range$5(step / 2, 1 - EPSILON, step), n = p.length;
        groups.forEach((g) => {
          const q = quantiles(g, p);
          for (let i = 0; i < n; ++i) {
            const t4 = {};
            for (let i2 = 0; i2 < names.length; ++i2) {
              t4[names[i2]] = g.dims[i2];
            }
            t4[as[0]] = p[i];
            t4[as[1]] = q[i];
            values2.push(ingest$1(t4));
          }
        });
        if (this.value)
          out.rem = this.value;
        this.value = out.add = out.source = values2;
        return out;
      }
    });
    function Relay$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Relay$1, Transform, {
      transform(_, pulse2) {
        let out, lut;
        if (this.value) {
          lut = this.value;
        } else {
          out = pulse2 = pulse2.addAll();
          lut = this.value = {};
        }
        if (_.derive) {
          out = pulse2.fork(pulse2.NO_SOURCE);
          pulse2.visit(pulse2.REM, (t4) => {
            const id2 = tupleid(t4);
            out.rem.push(lut[id2]);
            lut[id2] = null;
          });
          pulse2.visit(pulse2.ADD, (t4) => {
            const dt = derive(t4);
            lut[tupleid(t4)] = dt;
            out.add.push(dt);
          });
          pulse2.visit(pulse2.MOD, (t4) => {
            const dt = lut[tupleid(t4)];
            for (const k in t4) {
              dt[k] = t4[k];
              out.modifies(k);
            }
            out.mod.push(dt);
          });
        }
        return out;
      }
    });
    function Sample(params2) {
      Transform.call(this, [], params2);
      this.count = 0;
    }
    Sample.Definition = {
      "type": "Sample",
      "metadata": {},
      "params": [{
        "name": "size",
        "type": "number",
        "default": 1e3
      }]
    };
    inherits(Sample, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map2 = this.value.reduce((m2, t4) => (m2[tupleid(t4)] = 1, m2), {});
        let res = this.value, cnt = this.count, cap = 0;
        function update2(t4) {
          let p, idx;
          if (res.length < num) {
            res.push(t4);
          } else {
            idx = ~~((cnt + 1) * random());
            if (idx < res.length && idx >= cap) {
              p = res[idx];
              if (map2[tupleid(p)])
                out.rem.push(p);
              res[idx] = t4;
            }
          }
          ++cnt;
        }
        if (pulse2.rem.length) {
          pulse2.visit(pulse2.REM, (t4) => {
            const id2 = tupleid(t4);
            if (map2[id2]) {
              map2[id2] = -1;
              out.rem.push(t4);
            }
            --cnt;
          });
          res = res.filter((t4) => map2[tupleid(t4)] !== -1);
        }
        if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
          cap = cnt = res.length;
          pulse2.visit(pulse2.SOURCE, (t4) => {
            if (!map2[tupleid(t4)])
              update2(t4);
          });
          cap = -1;
        }
        if (mod && res.length > num) {
          const n = res.length - num;
          for (let i = 0; i < n; ++i) {
            map2[tupleid(res[i])] = -1;
            out.rem.push(res[i]);
          }
          res = res.slice(n);
        }
        if (pulse2.mod.length) {
          pulse2.visit(pulse2.MOD, (t4) => {
            if (map2[tupleid(t4)])
              out.mod.push(t4);
          });
        }
        if (pulse2.add.length) {
          pulse2.visit(pulse2.ADD, update2);
        }
        if (pulse2.add.length || cap < 0) {
          out.add = res.filter((t4) => !map2[tupleid(t4)]);
        }
        this.count = cnt;
        this.value = out.source = res;
        return out;
      }
    });
    function Sequence(params2) {
      Transform.call(this, null, params2);
    }
    Sequence.Definition = {
      "type": "Sequence",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "start",
        "type": "number",
        "required": true
      }, {
        "name": "stop",
        "type": "number",
        "required": true
      }, {
        "name": "step",
        "type": "number",
        "default": 1
      }, {
        "name": "as",
        "type": "string",
        "default": "data"
      }]
    };
    inherits(Sequence, Transform, {
      transform(_, pulse2) {
        if (this.value && !_.modified())
          return;
        const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
        out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
        this.value = range$5(_.start, _.stop, _.step || 1).map((v) => {
          const t4 = {};
          t4[as] = v;
          return ingest$1(t4);
        });
        out.add = pulse2.add.concat(this.value);
        return out;
      }
    });
    function Sieve$1(params2) {
      Transform.call(this, null, params2);
      this.modified(true);
    }
    inherits(Sieve$1, Transform, {
      transform(_, pulse2) {
        this.value = pulse2.source;
        return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
      }
    });
    function TimeUnit(params2) {
      Transform.call(this, null, params2);
    }
    const OUTPUT = ["unit0", "unit1"];
    TimeUnit.Definition = {
      "type": "TimeUnit",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "interval",
        "type": "boolean",
        "default": true
      }, {
        "name": "units",
        "type": "enum",
        "values": TIME_UNITS,
        "array": true
      }, {
        "name": "step",
        "type": "number",
        "default": 1
      }, {
        "name": "maxbins",
        "type": "number",
        "default": 40
      }, {
        "name": "extent",
        "type": "date",
        "array": true
      }, {
        "name": "timezone",
        "type": "enum",
        "default": "local",
        "values": ["local", "utc"]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": OUTPUT
      }]
    };
    inherits(TimeUnit, Transform, {
      transform(_, pulse2) {
        const field2 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor2 = this._floor(_, pulse2), offset2 = (utc ? utcInterval : timeInterval)(floor2.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor2.step;
        let min2 = floor2.start || Infinity, max2 = floor2.stop || -Infinity, flag2 = pulse2.ADD;
        if (_.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(field2))) {
          pulse2 = pulse2.reflow(true);
          flag2 = pulse2.SOURCE;
          min2 = Infinity;
          max2 = -Infinity;
        }
        pulse2.visit(flag2, (t4) => {
          const v = field2(t4);
          let a2, b2;
          if (v == null) {
            t4[u0] = null;
            if (band2)
              t4[u1] = null;
          } else {
            t4[u0] = a2 = b2 = floor2(v);
            if (band2)
              t4[u1] = b2 = offset2(a2, step);
            if (a2 < min2)
              min2 = a2;
            if (b2 > max2)
              max2 = b2;
          }
        });
        floor2.start = min2;
        floor2.stop = max2;
        return pulse2.modifies(band2 ? as : u0);
      },
      _floor(_, pulse2) {
        const utc = _.timezone === "utc";
        const {
          units,
          step
        } = _.units ? {
          units: _.units,
          step: _.step || 1
        } : bin$2({
          extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
          maxbins: _.maxbins
        });
        const tunits = timeUnits(units), prev2 = this.value || {}, floor2 = (utc ? utcFloor : timeFloor)(tunits, step);
        floor2.unit = peek$1(tunits);
        floor2.units = tunits;
        floor2.step = step;
        floor2.start = prev2.start;
        floor2.stop = prev2.stop;
        return this.value = floor2;
      }
    });
    function TupleIndex(params2) {
      Transform.call(this, fastmap(), params2);
    }
    inherits(TupleIndex, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow, field2 = _.field, index2 = this.value, set2 = (t4) => index2.set(field2(t4), t4);
        let mod = true;
        if (_.modified("field") || pulse2.modified(field2.fields)) {
          index2.clear();
          pulse2.visit(pulse2.SOURCE, set2);
        } else if (pulse2.changed()) {
          pulse2.visit(pulse2.REM, (t4) => index2.delete(field2(t4)));
          pulse2.visit(pulse2.ADD, set2);
        } else {
          mod = false;
        }
        this.modified(mod);
        if (index2.empty > df.cleanThreshold)
          df.runAfter(index2.clean);
        return pulse2.fork();
      }
    });
    function Values$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Values$1, Transform, {
      transform(_, pulse2) {
        const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
        if (run2) {
          this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
        }
      }
    });
    function WindowOp(op, field2, param2, as) {
      const fn = WindowOps[op](field2, param2);
      return {
        init: fn.init || zero$2,
        update: function(w2, t4) {
          t4[as] = fn.next(w2);
        }
      };
    }
    const WindowOps = {
      row_number: function() {
        return {
          next: (w2) => w2.index + 1
        };
      },
      rank: function() {
        let rank2;
        return {
          init: () => rank2 = 1,
          next: (w2) => {
            const i = w2.index, data2 = w2.data;
            return i && w2.compare(data2[i - 1], data2[i]) ? rank2 = i + 1 : rank2;
          }
        };
      },
      dense_rank: function() {
        let drank;
        return {
          init: () => drank = 1,
          next: (w2) => {
            const i = w2.index, d = w2.data;
            return i && w2.compare(d[i - 1], d[i]) ? ++drank : drank;
          }
        };
      },
      percent_rank: function() {
        const rank2 = WindowOps.rank(), next2 = rank2.next;
        return {
          init: rank2.init,
          next: (w2) => (next2(w2) - 1) / (w2.data.length - 1)
        };
      },
      cume_dist: function() {
        let cume;
        return {
          init: () => cume = 0,
          next: (w2) => {
            const d = w2.data, c2 = w2.compare;
            let i = w2.index;
            if (cume < i) {
              while (i + 1 < d.length && !c2(d[i], d[i + 1]))
                ++i;
              cume = i;
            }
            return (1 + cume) / d.length;
          }
        };
      },
      ntile: function(field2, num) {
        num = +num;
        if (!(num > 0))
          error("ntile num must be greater than zero.");
        const cume = WindowOps.cume_dist(), next2 = cume.next;
        return {
          init: cume.init,
          next: (w2) => Math.ceil(num * next2(w2))
        };
      },
      lag: function(field2, offset2) {
        offset2 = +offset2 || 1;
        return {
          next: (w2) => {
            const i = w2.index - offset2;
            return i >= 0 ? field2(w2.data[i]) : null;
          }
        };
      },
      lead: function(field2, offset2) {
        offset2 = +offset2 || 1;
        return {
          next: (w2) => {
            const i = w2.index + offset2, d = w2.data;
            return i < d.length ? field2(d[i]) : null;
          }
        };
      },
      first_value: function(field2) {
        return {
          next: (w2) => field2(w2.data[w2.i0])
        };
      },
      last_value: function(field2) {
        return {
          next: (w2) => field2(w2.data[w2.i1 - 1])
        };
      },
      nth_value: function(field2, nth) {
        nth = +nth;
        if (!(nth > 0))
          error("nth_value nth must be greater than zero.");
        return {
          next: (w2) => {
            const i = w2.i0 + (nth - 1);
            return i < w2.i1 ? field2(w2.data[i]) : null;
          }
        };
      },
      prev_value: function(field2) {
        let prev2;
        return {
          init: () => prev2 = null,
          next: (w2) => {
            const v = field2(w2.data[w2.index]);
            return v != null ? prev2 = v : prev2;
          }
        };
      },
      next_value: function(field2) {
        let v, i;
        return {
          init: () => (v = null, i = -1),
          next: (w2) => {
            const d = w2.data;
            return w2.index <= i ? v : (i = find$1(field2, d, w2.index)) < 0 ? (i = d.length, v = null) : v = field2(d[i]);
          }
        };
      }
    };
    function find$1(field2, data2, index2) {
      for (let n = data2.length; index2 < n; ++index2) {
        const v = field2(data2[index2]);
        if (v != null)
          return index2;
      }
      return -1;
    }
    const ValidWindowOps = Object.keys(WindowOps);
    function WindowState(_) {
      const ops2 = array$2(_.ops), fields = array$2(_.fields), params2 = array$2(_.params), aggregate_params = array$2(_.aggregate_params), as = array$2(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map2 = {}, counts = [], measures = [];
      let countOnly = true;
      function visitInputs(f) {
        array$2(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
      }
      visitInputs(_.sort);
      ops2.forEach((op, i) => {
        const field2 = fields[i], param2 = params2[i], aggregate_param = aggregate_params[i] || null, mname = accessorName(field2), name2 = measureName(op, mname, as[i]);
        visitInputs(field2);
        outputs.push(name2);
        if (has$1(WindowOps, op)) {
          windows.push(WindowOp(op, field2, param2, name2));
        } else {
          if (field2 == null && op !== "count") {
            error("Null aggregate field specified.");
          }
          if (op === "count") {
            counts.push(name2);
            return;
          }
          countOnly = false;
          let m2 = map2[mname];
          if (!m2) {
            m2 = map2[mname] = [];
            m2.field = field2;
            measures.push(m2);
          }
          m2.push(createMeasure(op, aggregate_param, name2));
        }
      });
      if (counts.length || measures.length) {
        this.cell = cell(measures, counts, countOnly);
      }
      this.inputs = Object.keys(inputs);
    }
    const prototype = WindowState.prototype;
    prototype.init = function() {
      this.windows.forEach((_) => _.init());
      if (this.cell)
        this.cell.init();
    };
    prototype.update = function(w2, t4) {
      const cell2 = this.cell, wind = this.windows, data2 = w2.data, m2 = wind && wind.length;
      let j;
      if (cell2) {
        for (j = w2.p0; j < w2.i0; ++j)
          cell2.rem(data2[j]);
        for (j = w2.p1; j < w2.i1; ++j)
          cell2.add(data2[j]);
        cell2.set(t4);
      }
      for (j = 0; j < m2; ++j)
        wind[j].update(w2, t4);
    };
    function cell(measures, counts, countOnly) {
      measures = measures.map((m2) => compileMeasures(m2, m2.field));
      const cell2 = {
        num: 0,
        agg: null,
        store: false,
        count: counts
      };
      if (!countOnly) {
        var n = measures.length, a2 = cell2.agg = Array(n), i = 0;
        for (; i < n; ++i)
          a2[i] = new measures[i](cell2);
      }
      if (cell2.store) {
        var store2 = cell2.data = new TupleStore();
      }
      cell2.add = function(t4) {
        cell2.num += 1;
        if (countOnly)
          return;
        if (store2)
          store2.add(t4);
        for (let i2 = 0; i2 < n; ++i2) {
          a2[i2].add(a2[i2].get(t4), t4);
        }
      };
      cell2.rem = function(t4) {
        cell2.num -= 1;
        if (countOnly)
          return;
        if (store2)
          store2.rem(t4);
        for (let i2 = 0; i2 < n; ++i2) {
          a2[i2].rem(a2[i2].get(t4), t4);
        }
      };
      cell2.set = function(t4) {
        let i2, n2;
        if (store2)
          store2.values();
        for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
          t4[counts[i2]] = cell2.num;
        if (!countOnly)
          for (i2 = 0, n2 = a2.length; i2 < n2; ++i2)
            a2[i2].set(t4);
      };
      cell2.init = function() {
        cell2.num = 0;
        if (store2)
          store2.reset();
        for (let i2 = 0; i2 < n; ++i2)
          a2[i2].init();
      };
      return cell2;
    }
    function Window(params2) {
      Transform.call(this, {}, params2);
      this._mlen = 0;
      this._mods = [];
    }
    Window.Definition = {
      "type": "Window",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "sort",
        "type": "compare"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidWindowOps.concat(ValidAggregateOps)
      }, {
        "name": "params",
        "type": "number",
        "null": true,
        "array": true
      }, {
        "name": "aggregate_params",
        "type": "number",
        "null": true,
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "frame",
        "type": "number",
        "null": true,
        "array": true,
        "length": 2,
        "default": [null, 0]
      }, {
        "name": "ignorePeers",
        "type": "boolean",
        "default": false
      }]
    };
    inherits(Window, Transform, {
      transform(_, pulse2) {
        this.stamp = pulse2.stamp;
        const mod = _.modified(), cmp2 = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t4) => this.group(key2(t4));
        let state = this.state;
        if (!state || mod) {
          state = this.state = new WindowState(_);
        }
        if (mod || pulse2.modified(state.inputs)) {
          this.value = {};
          pulse2.visit(pulse2.SOURCE, (t4) => group2(t4).add(t4));
        } else {
          pulse2.visit(pulse2.REM, (t4) => group2(t4).remove(t4));
          pulse2.visit(pulse2.ADD, (t4) => group2(t4).add(t4));
        }
        for (let i = 0, n = this._mlen; i < n; ++i) {
          processPartition(this._mods[i], state, cmp2, _);
        }
        this._mlen = 0;
        this._mods = [];
        return pulse2.reflow(mod).modifies(state.outputs);
      },
      group(key2) {
        let group2 = this.value[key2];
        if (!group2) {
          group2 = this.value[key2] = SortedList(tupleid);
          group2.stamp = -1;
        }
        if (group2.stamp < this.stamp) {
          group2.stamp = this.stamp;
          this._mods[this._mlen++] = group2;
        }
        return group2;
      }
    });
    function processPartition(list2, state, cmp2, _) {
      const sort2 = _.sort, range2 = sort2 && !_.ignorePeers, frame2 = _.frame || [null, 0], data2 = list2.data(cmp2), n = data2.length, b2 = range2 ? bisector(sort2) : null, w2 = {
        i0: 0,
        i1: 0,
        p0: 0,
        p1: 0,
        index: 0,
        data: data2,
        compare: sort2 || constant$1(-1)
      };
      state.init();
      for (let i = 0; i < n; ++i) {
        setWindow(w2, frame2, i, n);
        if (range2)
          adjustRange(w2, b2);
        state.update(w2, data2[i]);
      }
    }
    function setWindow(w2, f, i, n) {
      w2.p0 = w2.i0;
      w2.p1 = w2.i1;
      w2.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
      w2.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
      w2.index = i;
    }
    function adjustRange(w2, bisect2) {
      const r0 = w2.i0, r1 = w2.i1 - 1, c2 = w2.compare, d = w2.data, n = d.length - 1;
      if (r0 > 0 && !c2(d[r0], d[r0 - 1]))
        w2.i0 = bisect2.left(d, d[r0]);
      if (r1 < n && !c2(d[r1], d[r1 + 1]))
        w2.i1 = bisect2.right(d, d[r1]);
    }
    const tx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      aggregate: Aggregate$1,
      bin: Bin,
      collect: Collect$1,
      compare: Compare$1,
      countpattern: CountPattern,
      cross: Cross,
      density: Density,
      dotbin: DotBin,
      expression: Expression$1,
      extent: Extent,
      facet: Facet$1,
      field: Field$1,
      filter: Filter,
      flatten: Flatten,
      fold: Fold,
      formula: Formula,
      generate: Generate,
      impute: Impute,
      joinaggregate: JoinAggregate,
      kde: KDE,
      key: Key$1,
      load: Load$1,
      lookup: Lookup,
      multiextent: MultiExtent$1,
      multivalues: MultiValues$1,
      params: Params$2,
      pivot: Pivot,
      prefacet: PreFacet$1,
      project: Project,
      proxy: Proxy$2,
      quantile: Quantile$1,
      relay: Relay$1,
      sample: Sample,
      sequence: Sequence,
      sieve: Sieve$1,
      subflow: Subflow,
      timeunit: TimeUnit,
      tupleindex: TupleIndex,
      values: Values$1,
      window: Window
    }, Symbol.toStringTag, { value: "Module" }));
    function domCanvas(w2, h2) {
      if (typeof document !== "undefined" && document.createElement) {
        const c2 = document.createElement("canvas");
        if (c2 && c2.getContext) {
          c2.width = w2;
          c2.height = h2;
          return c2;
        }
      }
      return null;
    }
    const domImage = () => typeof Image !== "undefined" ? Image : null;
    function bandSpace(count2, paddingInner2, paddingOuter2) {
      const space2 = count2 - paddingInner2 + paddingOuter2 * 2;
      return count2 ? space2 > 0 ? space2 : 1 : 0;
    }
    const Identity = "identity";
    const Linear = "linear";
    const Log = "log";
    const Pow = "pow";
    const Sqrt = "sqrt";
    const Symlog = "symlog";
    const Time = "time";
    const UTC = "utc";
    const Sequential = "sequential";
    const Diverging = "diverging";
    const Quantile = "quantile";
    const Quantize = "quantize";
    const Threshold = "threshold";
    const Ordinal = "ordinal";
    const Point = "point";
    const Band = "band";
    const BinOrdinal = "bin-ordinal";
    const Continuous = "continuous";
    const Discrete$1 = "discrete";
    const Discretizing = "discretizing";
    const Interpolating = "interpolating";
    const Temporal = "temporal";
    function invertRange(scale2) {
      return function(_) {
        let lo = _[0], hi = _[1], t4;
        if (hi < lo) {
          t4 = lo;
          lo = hi;
          hi = t4;
        }
        return [scale2.invert(lo), scale2.invert(hi)];
      };
    }
    function invertRangeExtent(scale2) {
      return function(_) {
        const range2 = scale2.range();
        let lo = _[0], hi = _[1], min2 = -1, max2, t4, i, n;
        if (hi < lo) {
          t4 = lo;
          lo = hi;
          hi = t4;
        }
        for (i = 0, n = range2.length; i < n; ++i) {
          if (range2[i] >= lo && range2[i] <= hi) {
            if (min2 < 0)
              min2 = i;
            max2 = i;
          }
        }
        if (min2 < 0)
          return void 0;
        lo = scale2.invertExtent(range2[min2]);
        hi = scale2.invertExtent(range2[max2]);
        return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
      };
    }
    function band() {
      const scale2 = ordinal().unknown(void 0), domain2 = scale2.domain, ordinalRange = scale2.range;
      let range$12 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
      delete scale2.unknown;
      function rescale() {
        const n = domain2().length, reverse2 = range$12[1] < range$12[0], stop2 = range$12[1 - reverse2], space2 = bandSpace(n, paddingInner2, paddingOuter2);
        let start2 = range$12[reverse2 - 0];
        step = (stop2 - start2) / (space2 || 1);
        if (round2) {
          step = Math.floor(step);
        }
        start2 += (stop2 - start2 - step * (n - paddingInner2)) * align2;
        bandwidth2 = step * (1 - paddingInner2);
        if (round2) {
          start2 = Math.round(start2);
          bandwidth2 = Math.round(bandwidth2);
        }
        const values2 = range$5(n).map((i) => start2 + step * i);
        return ordinalRange(reverse2 ? values2.reverse() : values2);
      }
      scale2.domain = function(_) {
        if (arguments.length) {
          domain2(_);
          return rescale();
        } else {
          return domain2();
        }
      };
      scale2.range = function(_) {
        if (arguments.length) {
          range$12 = [+_[0], +_[1]];
          return rescale();
        } else {
          return range$12.slice();
        }
      };
      scale2.rangeRound = function(_) {
        range$12 = [+_[0], +_[1]];
        round2 = true;
        return rescale();
      };
      scale2.bandwidth = function() {
        return bandwidth2;
      };
      scale2.step = function() {
        return step;
      };
      scale2.round = function(_) {
        if (arguments.length) {
          round2 = !!_;
          return rescale();
        } else {
          return round2;
        }
      };
      scale2.padding = function(_) {
        if (arguments.length) {
          paddingOuter2 = Math.max(0, Math.min(1, _));
          paddingInner2 = paddingOuter2;
          return rescale();
        } else {
          return paddingInner2;
        }
      };
      scale2.paddingInner = function(_) {
        if (arguments.length) {
          paddingInner2 = Math.max(0, Math.min(1, _));
          return rescale();
        } else {
          return paddingInner2;
        }
      };
      scale2.paddingOuter = function(_) {
        if (arguments.length) {
          paddingOuter2 = Math.max(0, Math.min(1, _));
          return rescale();
        } else {
          return paddingOuter2;
        }
      };
      scale2.align = function(_) {
        if (arguments.length) {
          align2 = Math.max(0, Math.min(1, _));
          return rescale();
        } else {
          return align2;
        }
      };
      scale2.invertRange = function(_) {
        if (_[0] == null || _[1] == null)
          return;
        const reverse2 = range$12[1] < range$12[0], values2 = reverse2 ? ordinalRange().reverse() : ordinalRange(), n = values2.length - 1;
        let lo = +_[0], hi = +_[1], a2, b2, t4;
        if (lo !== lo || hi !== hi)
          return;
        if (hi < lo) {
          t4 = lo;
          lo = hi;
          hi = t4;
        }
        if (hi < values2[0] || lo > range$12[1 - reverse2])
          return;
        a2 = Math.max(0, bisectRight$1(values2, lo) - 1);
        b2 = lo === hi ? a2 : bisectRight$1(values2, hi) - 1;
        if (lo - values2[a2] > bandwidth2 + 1e-10)
          ++a2;
        if (reverse2) {
          t4 = a2;
          a2 = n - b2;
          b2 = n - t4;
        }
        return a2 > b2 ? void 0 : domain2().slice(a2, b2 + 1);
      };
      scale2.invert = function(_) {
        const value2 = scale2.invertRange([_, _]);
        return value2 ? value2[0] : value2;
      };
      scale2.copy = function() {
        return band().domain(domain2()).range(range$12).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
      };
      return rescale();
    }
    function pointish(scale2) {
      const copy2 = scale2.copy;
      scale2.padding = scale2.paddingOuter;
      delete scale2.paddingInner;
      scale2.copy = function() {
        return pointish(copy2());
      };
      return scale2;
    }
    function point$3() {
      return pointish(band().paddingInner(1));
    }
    var map = Array.prototype.map;
    function numbers(_) {
      return map.call(_, toNumber);
    }
    const slice$2 = Array.prototype.slice;
    function scaleBinOrdinal() {
      let domain2 = [], range2 = [];
      function scale2(x2) {
        return x2 == null || x2 !== x2 ? void 0 : range2[(bisect$1(domain2, x2) - 1) % range2.length];
      }
      scale2.domain = function(_) {
        if (arguments.length) {
          domain2 = numbers(_);
          return scale2;
        } else {
          return domain2.slice();
        }
      };
      scale2.range = function(_) {
        if (arguments.length) {
          range2 = slice$2.call(_);
          return scale2;
        } else {
          return range2.slice();
        }
      };
      scale2.tickFormat = function(count2, specifier) {
        return tickFormat$1(domain2[0], peek$1(domain2), count2 == null ? 10 : count2, specifier);
      };
      scale2.copy = function() {
        return scaleBinOrdinal().domain(scale2.domain()).range(scale2.range());
      };
      return scale2;
    }
    const scales = /* @__PURE__ */ new Map();
    const VEGA_SCALE = Symbol("vega_scale");
    function registerScale(scale2) {
      scale2[VEGA_SCALE] = true;
      return scale2;
    }
    function isRegisteredScale(scale2) {
      return scale2 && scale2[VEGA_SCALE] === true;
    }
    function create$2(type2, constructor, metadata2) {
      const ctr = function scale2() {
        const s = constructor();
        if (!s.invertRange) {
          s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
        }
        s.type = type2;
        return registerScale(s);
      };
      ctr.metadata = toSet(array$2(metadata2));
      return ctr;
    }
    function scale$4(type2, scale2, metadata2) {
      if (arguments.length > 1) {
        scales.set(type2, create$2(type2, scale2, metadata2));
        return this;
      } else {
        return isValidScaleType(type2) ? scales.get(type2) : void 0;
      }
    }
    scale$4(Identity, identity$2);
    scale$4(Linear, linear$1, Continuous);
    scale$4(Log, log$3, [Continuous, Log]);
    scale$4(Pow, pow$2, Continuous);
    scale$4(Sqrt, sqrt$2, Continuous);
    scale$4(Symlog, symlog$1, Continuous);
    scale$4(Time, time$1, [Continuous, Temporal]);
    scale$4(UTC, utcTime, [Continuous, Temporal]);
    scale$4(Sequential, sequential, [Continuous, Interpolating]);
    scale$4(`${Sequential}-${Linear}`, sequential, [Continuous, Interpolating]);
    scale$4(`${Sequential}-${Log}`, sequentialLog, [Continuous, Interpolating, Log]);
    scale$4(`${Sequential}-${Pow}`, sequentialPow, [Continuous, Interpolating]);
    scale$4(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]);
    scale$4(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]);
    scale$4(`${Diverging}-${Linear}`, diverging, [Continuous, Interpolating]);
    scale$4(`${Diverging}-${Log}`, divergingLog, [Continuous, Interpolating, Log]);
    scale$4(`${Diverging}-${Pow}`, divergingPow, [Continuous, Interpolating]);
    scale$4(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]);
    scale$4(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]);
    scale$4(Quantile, quantile, [Discretizing, Quantile]);
    scale$4(Quantize, quantize$1, Discretizing);
    scale$4(Threshold, threshold, Discretizing);
    scale$4(BinOrdinal, scaleBinOrdinal, [Discrete$1, Discretizing]);
    scale$4(Ordinal, ordinal, Discrete$1);
    scale$4(Band, band, Discrete$1);
    scale$4(Point, point$3, Discrete$1);
    function isValidScaleType(type2) {
      return scales.has(type2);
    }
    function hasType(key2, type2) {
      const s = scales.get(key2);
      return s && s.metadata[type2];
    }
    function isContinuous$1(key2) {
      return hasType(key2, Continuous);
    }
    function isDiscrete$2(key2) {
      return hasType(key2, Discrete$1);
    }
    function isDiscretizing$1(key2) {
      return hasType(key2, Discretizing);
    }
    function isLogarithmic(key2) {
      return hasType(key2, Log);
    }
    function isTemporal(key2) {
      return hasType(key2, Temporal);
    }
    function isInterpolating(key2) {
      return hasType(key2, Interpolating);
    }
    function isQuantile$1(key2) {
      return hasType(key2, Quantile);
    }
    const scaleProps = ["clamp", "base", "constant", "exponent"];
    function interpolateRange$1(interpolator, range2) {
      const start2 = range2[0], span2 = peek$1(range2) - start2;
      return function(i) {
        return interpolator(start2 + i * span2);
      };
    }
    function interpolateColors(colors2, type2, gamma2) {
      return piecewise(interpolate$1(type2 || "rgb", gamma2), colors2);
    }
    function quantizeInterpolator(interpolator, count2) {
      const samples = new Array(count2), n = count2 + 1;
      for (let i = 0; i < count2; )
        samples[i] = interpolator(++i / n);
      return samples;
    }
    function scaleFraction(scale$12, min2, max2) {
      const delta = max2 - min2;
      let i, t4, s;
      if (!delta || !Number.isFinite(delta)) {
        return constant$1(0.5);
      } else {
        i = (t4 = scale$12.type).indexOf("-");
        t4 = i < 0 ? t4 : t4.slice(i + 1);
        s = scale$4(t4)().domain([min2, max2]).range([0, 1]);
        scaleProps.forEach((m2) => scale$12[m2] ? s[m2](scale$12[m2]()) : 0);
        return s;
      }
    }
    function interpolate$1(type2, gamma2) {
      const interp = $$1[method(type2)];
      return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
    }
    function method(type2) {
      return "interpolate" + type2.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
    }
    const continuous = {
      blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
      greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
      greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
      oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
      purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
      reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
      blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
      bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
      greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
      orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
      purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
      purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
      purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
      redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
      yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
      yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
      yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
      blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
      brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
      purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
      purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
      redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
      redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
      yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
      redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
      redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
      pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
      spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
      viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
      magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
      inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
      plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
      cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
      rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
      sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
      turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
      browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
      tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
      teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
      warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
      goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
      goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
      goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
      lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
      lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
      lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
      lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
      lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
      darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
      darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
      darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
      darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
      darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
    };
    const discrete = {
      category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
      category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
      category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
      category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
      tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
      tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
      accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
      dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
      paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
      pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
      pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
      set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
      set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
      set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
    };
    function colors(palette) {
      const n = palette.length / 6 | 0, c2 = new Array(n);
      for (let i = 0; i < n; ) {
        c2[i] = "#" + palette.slice(i * 6, ++i * 6);
      }
      return c2;
    }
    function apply$1(_, f) {
      for (const k in _)
        scheme$1(k, f(_[k]));
    }
    const schemes = {};
    apply$1(discrete, colors);
    apply$1(continuous, (_) => interpolateColors(colors(_)));
    function scheme$1(name2, scheme2) {
      name2 = name2 && name2.toLowerCase();
      if (arguments.length > 1) {
        schemes[name2] = scheme2;
        return this;
      } else {
        return schemes[name2];
      }
    }
    const SymbolLegend = "symbol";
    const DiscreteLegend = "discrete";
    const GradientLegend = "gradient";
    const defaultFormatter = (value2) => isArray(value2) ? value2.map((v) => String(v)) : String(value2);
    const ascending = (a2, b2) => a2[1] - b2[1];
    const descending = (a2, b2) => b2[1] - a2[1];
    function tickCount(scale2, count2, minStep) {
      let step;
      if (isNumber$1(count2)) {
        if (scale2.bins) {
          count2 = Math.max(count2, scale2.bins.length);
        }
        if (minStep != null) {
          count2 = Math.min(count2, Math.floor(span(scale2.domain()) / minStep || 1) + 1);
        }
      }
      if (isObject(count2)) {
        step = count2.step;
        count2 = count2.interval;
      }
      if (isString(count2)) {
        count2 = scale2.type === Time ? timeInterval(count2) : scale2.type == UTC ? utcInterval(count2) : error("Only time and utc scales accept interval strings.");
        if (step)
          count2 = count2.every(step);
      }
      return count2;
    }
    function validTicks(scale2, ticks2, count2) {
      let range2 = scale2.range(), lo = range2[0], hi = peek$1(range2), cmp2 = ascending;
      if (lo > hi) {
        range2 = hi;
        hi = lo;
        lo = range2;
        cmp2 = descending;
      }
      lo = Math.floor(lo);
      hi = Math.ceil(hi);
      ticks2 = ticks2.map((v) => [v, scale2(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp2).map((_) => _[0]);
      if (count2 > 0 && ticks2.length > 1) {
        const endpoints = [ticks2[0], peek$1(ticks2)];
        while (ticks2.length > count2 && ticks2.length >= 3) {
          ticks2 = ticks2.filter((_, i) => !(i % 2));
        }
        if (ticks2.length < 3) {
          ticks2 = endpoints;
        }
      }
      return ticks2;
    }
    function tickValues(scale2, count2) {
      return scale2.bins ? validTicks(scale2, scale2.bins) : scale2.ticks ? scale2.ticks(count2) : scale2.domain();
    }
    function tickFormat(locale2, scale2, count2, specifier, formatType, noSkip) {
      const type2 = scale2.type;
      let format2 = defaultFormatter;
      if (type2 === Time || formatType === Time) {
        format2 = locale2.timeFormat(specifier);
      } else if (type2 === UTC || formatType === UTC) {
        format2 = locale2.utcFormat(specifier);
      } else if (isLogarithmic(type2)) {
        const varfmt = locale2.formatFloat(specifier);
        if (noSkip || scale2.bins) {
          format2 = varfmt;
        } else {
          const test2 = tickLog(scale2, count2, false);
          format2 = (_) => test2(_) ? varfmt(_) : "";
        }
      } else if (scale2.tickFormat) {
        const d = scale2.domain();
        format2 = locale2.formatSpan(d[0], d[d.length - 1], count2, specifier);
      } else if (specifier) {
        format2 = locale2.format(specifier);
      }
      return format2;
    }
    function tickLog(scale2, count2, values2) {
      const ticks2 = tickValues(scale2, count2), base2 = scale2.base(), logb = Math.log(base2), k = Math.max(1, base2 * count2 / ticks2.length);
      const test2 = (d) => {
        let i = d / Math.pow(base2, Math.round(Math.log(d) / logb));
        if (i * base2 < base2 - 0.5)
          i *= base2;
        return i <= k;
      };
      return values2 ? ticks2.filter(test2) : test2;
    }
    const symbols$2 = {
      [Quantile]: "quantiles",
      [Quantize]: "thresholds",
      [Threshold]: "domain"
    };
    const formats = {
      [Quantile]: "quantiles",
      [Quantize]: "domain"
    };
    function labelValues(scale2, count2) {
      return scale2.bins ? binValues(scale2.bins) : scale2.type === Log ? tickLog(scale2, count2, true) : symbols$2[scale2.type] ? thresholdValues(scale2[symbols$2[scale2.type]]()) : tickValues(scale2, count2);
    }
    function thresholdFormat(locale2, scale2, specifier) {
      const _ = scale2[formats[scale2.type]](), n = _.length;
      let d = n > 1 ? _[1] - _[0] : _[0], i;
      for (i = 1; i < n; ++i) {
        d = Math.min(d, _[i] - _[i - 1]);
      }
      return locale2.formatSpan(0, d, 3 * 10, specifier);
    }
    function thresholdValues(thresholds) {
      const values2 = [-Infinity].concat(thresholds);
      values2.max = Infinity;
      return values2;
    }
    function binValues(bins2) {
      const values2 = bins2.slice(0, -1);
      values2.max = peek$1(bins2);
      return values2;
    }
    const isDiscreteRange = (scale2) => symbols$2[scale2.type] || scale2.bins;
    function labelFormat(locale2, scale2, count2, type2, specifier, formatType, noSkip) {
      const format2 = formats[scale2.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale2, scale2, specifier) : tickFormat(locale2, scale2, count2, specifier, formatType, noSkip);
      return type2 === SymbolLegend && isDiscreteRange(scale2) ? formatRange(format2) : type2 === DiscreteLegend ? formatDiscrete(format2) : formatPoint(format2);
    }
    const formatRange = (format2) => (value2, index2, array2) => {
      const limit = get$3(array2[index2 + 1], get$3(array2.max, Infinity)), lo = formatValue$2(value2, format2), hi = formatValue$2(limit, format2);
      return lo && hi ? lo + "  " + hi : hi ? "< " + hi : " " + lo;
    };
    const get$3 = (value2, dflt) => value2 != null ? value2 : dflt;
    const formatDiscrete = (format2) => (value2, index2) => index2 ? format2(value2) : null;
    const formatPoint = (format2) => (value2) => format2(value2);
    const formatValue$2 = (value2, format2) => Number.isFinite(value2) ? format2(value2) : null;
    function labelFraction(scale2) {
      const domain2 = scale2.domain(), count2 = domain2.length - 1;
      let lo = +domain2[0], hi = +peek$1(domain2), span2 = hi - lo;
      if (scale2.type === Threshold) {
        const adjust = count2 ? span2 / count2 : 0.1;
        lo -= adjust;
        hi += adjust;
        span2 = hi - lo;
      }
      return (value2) => (value2 - lo) / span2;
    }
    function format$1(locale2, scale2, specifier, formatType) {
      const type2 = formatType || scale2.type;
      if (isString(specifier) && isTemporal(type2)) {
        specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
      }
      return !specifier && type2 === Time ? locale2.timeFormat("%A, %d %B %Y, %X") : !specifier && type2 === UTC ? locale2.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale2, scale2, 5, null, specifier, formatType, true);
    }
    function domainCaption(locale2, scale2, opt) {
      opt = opt || {};
      const max2 = Math.max(3, opt.maxlen || 7), fmt = format$1(locale2, scale2, opt.format, opt.formatType);
      if (isDiscretizing$1(scale2.type)) {
        const v = labelValues(scale2).slice(1).map(fmt), n = v.length;
        return `${n} boundar${n === 1 ? "y" : "ies"}: ${v.join(", ")}`;
      } else if (isDiscrete$2(scale2.type)) {
        const d = scale2.domain(), n = d.length, v = n > max2 ? d.slice(0, max2 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
        return `${n} value${n === 1 ? "" : "s"}: ${v}`;
      } else {
        const d = scale2.domain();
        return `values from ${fmt(d[0])} to ${fmt(peek$1(d))}`;
      }
    }
    let gradient_id = 0;
    function resetSVGGradientId() {
      gradient_id = 0;
    }
    const patternPrefix = "p_";
    function isGradient(value2) {
      return value2 && value2.gradient;
    }
    function gradientRef(g, defs, base2) {
      const type2 = g.gradient;
      let id2 = g.id, prefix = type2 === "radial" ? patternPrefix : "";
      if (!id2) {
        id2 = g.id = "gradient_" + gradient_id++;
        if (type2 === "radial") {
          g.x1 = get$2(g.x1, 0.5);
          g.y1 = get$2(g.y1, 0.5);
          g.r1 = get$2(g.r1, 0);
          g.x2 = get$2(g.x2, 0.5);
          g.y2 = get$2(g.y2, 0.5);
          g.r2 = get$2(g.r2, 0.5);
          prefix = patternPrefix;
        } else {
          g.x1 = get$2(g.x1, 0);
          g.y1 = get$2(g.y1, 0);
          g.x2 = get$2(g.x2, 1);
          g.y2 = get$2(g.y2, 0);
        }
      }
      defs[id2] = g;
      return "url(" + (base2 || "") + "#" + prefix + id2 + ")";
    }
    function get$2(val, def2) {
      return val != null ? val : def2;
    }
    function Gradient$1(p02, p1) {
      var stops = [], gradient2;
      return gradient2 = {
        gradient: "linear",
        x1: p02 ? p02[0] : 0,
        y1: p02 ? p02[1] : 0,
        x2: p1 ? p1[0] : 1,
        y2: p1 ? p1[1] : 0,
        stops,
        stop: function(offset2, color2) {
          stops.push({
            offset: offset2,
            color: color2
          });
          return gradient2;
        }
      };
    }
    const lookup$4 = {
      "basis": {
        curve: curveBasis
      },
      "basis-closed": {
        curve: curveBasisClosed
      },
      "basis-open": {
        curve: curveBasisOpen
      },
      "bundle": {
        curve: curveBundle,
        tension: "beta",
        value: 0.85
      },
      "cardinal": {
        curve: curveCardinal,
        tension: "tension",
        value: 0
      },
      "cardinal-open": {
        curve: curveCardinalOpen,
        tension: "tension",
        value: 0
      },
      "cardinal-closed": {
        curve: curveCardinalClosed,
        tension: "tension",
        value: 0
      },
      "catmull-rom": {
        curve: curveCatmullRom,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-closed": {
        curve: curveCatmullRomClosed,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-open": {
        curve: curveCatmullRomOpen,
        tension: "alpha",
        value: 0.5
      },
      "linear": {
        curve: curveLinear
      },
      "linear-closed": {
        curve: curveLinearClosed
      },
      "monotone": {
        horizontal: monotoneY,
        vertical: monotoneX
      },
      "natural": {
        curve: curveNatural
      },
      "step": {
        curve: curveStep
      },
      "step-after": {
        curve: stepAfter
      },
      "step-before": {
        curve: stepBefore
      }
    };
    function curves(type2, orientation, tension) {
      var entry2 = has$1(lookup$4, type2) && lookup$4[type2], curve2 = null;
      if (entry2) {
        curve2 = entry2.curve || entry2[orientation || "vertical"];
        if (entry2.tension && tension != null) {
          curve2 = curve2[entry2.tension](tension);
        }
      }
      return curve2;
    }
    const paramCounts = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      z: 0,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7
    };
    const commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
    const numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
    const spacePattern = /^((\s+,?\s*)|(,\s*))/;
    const flagPattern = /^[01]/;
    function parse$3(path2) {
      const commands = [];
      const matches2 = path2.match(commandPattern) || [];
      matches2.forEach((str) => {
        let cmd = str[0];
        const type2 = cmd.toLowerCase();
        const paramCount = paramCounts[type2];
        const params2 = parseParams(type2, paramCount, str.slice(1).trim());
        const count2 = params2.length;
        if (count2 < paramCount || count2 && count2 % paramCount !== 0) {
          throw Error("Invalid SVG path, incorrect parameter count");
        }
        commands.push([cmd, ...params2.slice(0, paramCount)]);
        if (count2 === paramCount) {
          return;
        }
        if (type2 === "m") {
          cmd = cmd === "M" ? "L" : "l";
        }
        for (let i = paramCount; i < count2; i += paramCount) {
          commands.push([cmd, ...params2.slice(i, i + paramCount)]);
        }
      });
      return commands;
    }
    function parseParams(type2, paramCount, segment) {
      const params2 = [];
      for (let index2 = 0; paramCount && index2 < segment.length; ) {
        for (let i = 0; i < paramCount; ++i) {
          const pattern = type2 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
          const match2 = segment.slice(index2).match(pattern);
          if (match2 === null) {
            throw Error("Invalid SVG path, incorrect parameter type");
          }
          index2 += match2[0].length;
          params2.push(+match2[0]);
          const ws = segment.slice(index2).match(spacePattern);
          if (ws !== null) {
            index2 += ws[0].length;
          }
        }
      }
      return params2;
    }
    const DegToRad = Math.PI / 180;
    const Epsilon = 1e-14;
    const HalfPi = Math.PI / 2;
    const Tau = Math.PI * 2;
    const HalfSqrt3 = Math.sqrt(3) / 2;
    var segmentCache = {};
    var bezierCache = {};
    var join$1 = [].join;
    function segments(x2, y2, rx, ry, large, sweep, rotateX, ox, oy) {
      const key2 = join$1.call(arguments);
      if (segmentCache[key2]) {
        return segmentCache[key2];
      }
      const th = rotateX * DegToRad;
      const sin_th = Math.sin(th);
      const cos_th = Math.cos(th);
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const px2 = cos_th * (ox - x2) * 0.5 + sin_th * (oy - y2) * 0.5;
      const py2 = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x2) * 0.5;
      let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
      if (pl > 1) {
        pl = Math.sqrt(pl);
        rx *= pl;
        ry *= pl;
      }
      const a00 = cos_th / rx;
      const a01 = sin_th / rx;
      const a10 = -sin_th / ry;
      const a11 = cos_th / ry;
      const x02 = a00 * ox + a01 * oy;
      const y02 = a10 * ox + a11 * oy;
      const x12 = a00 * x2 + a01 * y2;
      const y12 = a10 * x2 + a11 * y2;
      const d = (x12 - x02) * (x12 - x02) + (y12 - y02) * (y12 - y02);
      let sfactor_sq = 1 / d - 0.25;
      if (sfactor_sq < 0)
        sfactor_sq = 0;
      let sfactor = Math.sqrt(sfactor_sq);
      if (sweep == large)
        sfactor = -sfactor;
      const xc = 0.5 * (x02 + x12) - sfactor * (y12 - y02);
      const yc = 0.5 * (y02 + y12) + sfactor * (x12 - x02);
      const th0 = Math.atan2(y02 - yc, x02 - xc);
      const th1 = Math.atan2(y12 - yc, x12 - xc);
      let th_arc = th1 - th0;
      if (th_arc < 0 && sweep === 1) {
        th_arc += Tau;
      } else if (th_arc > 0 && sweep === 0) {
        th_arc -= Tau;
      }
      const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
      const result = [];
      for (let i = 0; i < segs; ++i) {
        const th2 = th0 + i * th_arc / segs;
        const th3 = th0 + (i + 1) * th_arc / segs;
        result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
      }
      return segmentCache[key2] = result;
    }
    function bezier(params2) {
      const key2 = join$1.call(params2);
      if (bezierCache[key2]) {
        return bezierCache[key2];
      }
      var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
      const a00 = cos_th * rx;
      const a01 = -sin_th * ry;
      const a10 = sin_th * rx;
      const a11 = cos_th * ry;
      const cos_th0 = Math.cos(th0);
      const sin_th0 = Math.sin(th0);
      const cos_th1 = Math.cos(th1);
      const sin_th1 = Math.sin(th1);
      const th_half = 0.5 * (th1 - th0);
      const sin_th_h2 = Math.sin(th_half * 0.5);
      const t4 = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
      const x12 = cx + cos_th0 - t4 * sin_th0;
      const y12 = cy + sin_th0 + t4 * cos_th0;
      const x3 = cx + cos_th1;
      const y3 = cy + sin_th1;
      const x2 = x3 + t4 * sin_th1;
      const y2 = y3 - t4 * cos_th1;
      return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
    }
    const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
    function scale$1$1(current2, sX, sY) {
      const c2 = temp[0] = current2[0];
      if (c2 === "a" || c2 === "A") {
        temp[1] = sX * current2[1];
        temp[2] = sY * current2[2];
        temp[3] = current2[3];
        temp[4] = current2[4];
        temp[5] = current2[5];
        temp[6] = sX * current2[6];
        temp[7] = sY * current2[7];
      } else if (c2 === "h" || c2 === "H") {
        temp[1] = sX * current2[1];
      } else if (c2 === "v" || c2 === "V") {
        temp[1] = sY * current2[1];
      } else {
        for (var i = 1, n = current2.length; i < n; ++i) {
          temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
        }
      }
      return temp;
    }
    function pathRender(context2, path2, l, t4, sX, sY) {
      var current2, previous = null, x2 = 0, y2 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
      if (l == null)
        l = 0;
      if (t4 == null)
        t4 = 0;
      if (sX == null)
        sX = 1;
      if (sY == null)
        sY = sX;
      if (context2.beginPath)
        context2.beginPath();
      for (var i = 0, len = path2.length; i < len; ++i) {
        current2 = path2[i];
        if (sX !== 1 || sY !== 1) {
          current2 = scale$1$1(current2, sX, sY);
        }
        switch (current2[0]) {
          case "l":
            x2 += current2[1];
            y2 += current2[2];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "L":
            x2 = current2[1];
            y2 = current2[2];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "h":
            x2 += current2[1];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "H":
            x2 = current2[1];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "v":
            y2 += current2[1];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "V":
            y2 = current2[1];
            context2.lineTo(x2 + l, y2 + t4);
            break;
          case "m":
            x2 += current2[1];
            y2 += current2[2];
            anchorX = x2;
            anchorY = y2;
            context2.moveTo(x2 + l, y2 + t4);
            break;
          case "M":
            x2 = current2[1];
            y2 = current2[2];
            anchorX = x2;
            anchorY = y2;
            context2.moveTo(x2 + l, y2 + t4);
            break;
          case "c":
            tempX = x2 + current2[5];
            tempY = y2 + current2[6];
            controlX = x2 + current2[3];
            controlY = y2 + current2[4];
            context2.bezierCurveTo(
              x2 + current2[1] + l,
              // x1
              y2 + current2[2] + t4,
              // y1
              controlX + l,
              // x2
              controlY + t4,
              // y2
              tempX + l,
              tempY + t4
            );
            x2 = tempX;
            y2 = tempY;
            break;
          case "C":
            x2 = current2[5];
            y2 = current2[6];
            controlX = current2[3];
            controlY = current2[4];
            context2.bezierCurveTo(current2[1] + l, current2[2] + t4, controlX + l, controlY + t4, x2 + l, y2 + t4);
            break;
          case "s":
            tempX = x2 + current2[3];
            tempY = y2 + current2[4];
            controlX = 2 * x2 - controlX;
            controlY = 2 * y2 - controlY;
            context2.bezierCurveTo(controlX + l, controlY + t4, x2 + current2[1] + l, y2 + current2[2] + t4, tempX + l, tempY + t4);
            controlX = x2 + current2[1];
            controlY = y2 + current2[2];
            x2 = tempX;
            y2 = tempY;
            break;
          case "S":
            tempX = current2[3];
            tempY = current2[4];
            controlX = 2 * x2 - controlX;
            controlY = 2 * y2 - controlY;
            context2.bezierCurveTo(controlX + l, controlY + t4, current2[1] + l, current2[2] + t4, tempX + l, tempY + t4);
            x2 = tempX;
            y2 = tempY;
            controlX = current2[1];
            controlY = current2[2];
            break;
          case "q":
            tempX = x2 + current2[3];
            tempY = y2 + current2[4];
            controlX = x2 + current2[1];
            controlY = y2 + current2[2];
            context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
            x2 = tempX;
            y2 = tempY;
            break;
          case "Q":
            tempX = current2[3];
            tempY = current2[4];
            context2.quadraticCurveTo(current2[1] + l, current2[2] + t4, tempX + l, tempY + t4);
            x2 = tempX;
            y2 = tempY;
            controlX = current2[1];
            controlY = current2[2];
            break;
          case "t":
            tempX = x2 + current2[1];
            tempY = y2 + current2[2];
            if (previous[0].match(/[QqTt]/) === null) {
              controlX = x2;
              controlY = y2;
            } else if (previous[0] === "t") {
              controlX = 2 * x2 - tempControlX;
              controlY = 2 * y2 - tempControlY;
            } else if (previous[0] === "q") {
              controlX = 2 * x2 - controlX;
              controlY = 2 * y2 - controlY;
            }
            tempControlX = controlX;
            tempControlY = controlY;
            context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
            x2 = tempX;
            y2 = tempY;
            controlX = x2 + current2[1];
            controlY = y2 + current2[2];
            break;
          case "T":
            tempX = current2[1];
            tempY = current2[2];
            controlX = 2 * x2 - controlX;
            controlY = 2 * y2 - controlY;
            context2.quadraticCurveTo(controlX + l, controlY + t4, tempX + l, tempY + t4);
            x2 = tempX;
            y2 = tempY;
            break;
          case "a":
            drawArc(context2, x2 + l, y2 + t4, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x2 + l, current2[7] + y2 + t4]);
            x2 += current2[6];
            y2 += current2[7];
            break;
          case "A":
            drawArc(context2, x2 + l, y2 + t4, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t4]);
            x2 = current2[6];
            y2 = current2[7];
            break;
          case "z":
          case "Z":
            x2 = anchorX;
            y2 = anchorY;
            context2.closePath();
            break;
        }
        previous = current2;
      }
    }
    function drawArc(context2, x2, y2, coords) {
      const seg = segments(
        coords[5],
        // end x
        coords[6],
        // end y
        coords[0],
        // radius x
        coords[1],
        // radius y
        coords[3],
        // large flag
        coords[4],
        // sweep flag
        coords[2],
        // rotation
        x2,
        y2
      );
      for (let i = 0; i < seg.length; ++i) {
        const bez = bezier(seg[i]);
        context2.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
      }
    }
    const Tan30 = 0.5773502691896257;
    const builtins = {
      "circle": {
        draw: function(context2, size2) {
          const r = Math.sqrt(size2) / 2;
          context2.moveTo(r, 0);
          context2.arc(0, 0, r, 0, Tau);
        }
      },
      "cross": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, s = r / 2.5;
          context2.moveTo(-r, -s);
          context2.lineTo(-r, s);
          context2.lineTo(-s, s);
          context2.lineTo(-s, r);
          context2.lineTo(s, r);
          context2.lineTo(s, s);
          context2.lineTo(r, s);
          context2.lineTo(r, -s);
          context2.lineTo(s, -s);
          context2.lineTo(s, -r);
          context2.lineTo(-s, -r);
          context2.lineTo(-s, -s);
          context2.closePath();
        }
      },
      "diamond": {
        draw: function(context2, size2) {
          const r = Math.sqrt(size2) / 2;
          context2.moveTo(-r, 0);
          context2.lineTo(0, -r);
          context2.lineTo(r, 0);
          context2.lineTo(0, r);
          context2.closePath();
        }
      },
      "square": {
        draw: function(context2, size2) {
          var w2 = Math.sqrt(size2), x2 = -w2 / 2;
          context2.rect(x2, x2, w2, w2);
        }
      },
      "arrow": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, s = r / 7, t4 = r / 2.5, v = r / 8;
          context2.moveTo(-s, r);
          context2.lineTo(s, r);
          context2.lineTo(s, -v);
          context2.lineTo(t4, -v);
          context2.lineTo(0, -r);
          context2.lineTo(-t4, -v);
          context2.lineTo(-s, -v);
          context2.closePath();
        }
      },
      "wedge": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30, b2 = r / 4;
          context2.moveTo(0, -h2 - o);
          context2.lineTo(-b2, h2 - o);
          context2.lineTo(b2, h2 - o);
          context2.closePath();
        }
      },
      "triangle": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30;
          context2.moveTo(0, -h2 - o);
          context2.lineTo(-r, h2 - o);
          context2.lineTo(r, h2 - o);
          context2.closePath();
        }
      },
      "triangle-up": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r;
          context2.moveTo(0, -h2);
          context2.lineTo(-r, h2);
          context2.lineTo(r, h2);
          context2.closePath();
        }
      },
      "triangle-down": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r;
          context2.moveTo(0, h2);
          context2.lineTo(-r, -h2);
          context2.lineTo(r, -h2);
          context2.closePath();
        }
      },
      "triangle-right": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r;
          context2.moveTo(h2, 0);
          context2.lineTo(-h2, -r);
          context2.lineTo(-h2, r);
          context2.closePath();
        }
      },
      "triangle-left": {
        draw: function(context2, size2) {
          var r = Math.sqrt(size2) / 2, h2 = HalfSqrt3 * r;
          context2.moveTo(-h2, 0);
          context2.lineTo(h2, -r);
          context2.lineTo(h2, r);
          context2.closePath();
        }
      },
      "stroke": {
        draw: function(context2, size2) {
          const r = Math.sqrt(size2) / 2;
          context2.moveTo(-r, 0);
          context2.lineTo(r, 0);
        }
      }
    };
    function symbols$1(_) {
      return has$1(builtins, _) ? builtins[_] : customSymbol(_);
    }
    var custom = {};
    function customSymbol(path2) {
      if (!has$1(custom, path2)) {
        const parsed = parse$3(path2);
        custom[path2] = {
          draw: function(context2, size2) {
            pathRender(context2, parsed, 0, 0, Math.sqrt(size2) / 2);
          }
        };
      }
      return custom[path2];
    }
    const C = 0.448084975506;
    function rectangleX(d) {
      return d.x;
    }
    function rectangleY(d) {
      return d.y;
    }
    function rectangleWidth(d) {
      return d.width;
    }
    function rectangleHeight(d) {
      return d.height;
    }
    function number$3(_) {
      return typeof _ === "function" ? _ : () => +_;
    }
    function clamp(value2, min2, max2) {
      return Math.max(min2, Math.min(value2, max2));
    }
    function vg_rect() {
      var x2 = rectangleX, y2 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number$3(0), crTR = crTL, crBL = crTL, crBR = crTL, context2 = null;
      function rectangle2(_, x02, y02) {
        var buffer, x12 = x02 != null ? x02 : +x2.call(this, _), y12 = y02 != null ? y02 : +y2.call(this, _), w2 = +width2.call(this, _), h2 = +height2.call(this, _), s = Math.min(w2, h2) / 2, tl2 = clamp(+crTL.call(this, _), 0, s), tr2 = clamp(+crTR.call(this, _), 0, s), bl2 = clamp(+crBL.call(this, _), 0, s), br2 = clamp(+crBR.call(this, _), 0, s);
        if (!context2)
          context2 = buffer = path$3();
        if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
          context2.rect(x12, y12, w2, h2);
        } else {
          var x22 = x12 + w2, y22 = y12 + h2;
          context2.moveTo(x12 + tl2, y12);
          context2.lineTo(x22 - tr2, y12);
          context2.bezierCurveTo(x22 - C * tr2, y12, x22, y12 + C * tr2, x22, y12 + tr2);
          context2.lineTo(x22, y22 - br2);
          context2.bezierCurveTo(x22, y22 - C * br2, x22 - C * br2, y22, x22 - br2, y22);
          context2.lineTo(x12 + bl2, y22);
          context2.bezierCurveTo(x12 + C * bl2, y22, x12, y22 - C * bl2, x12, y22 - bl2);
          context2.lineTo(x12, y12 + tl2);
          context2.bezierCurveTo(x12, y12 + C * tl2, x12 + C * tl2, y12, x12 + tl2, y12);
          context2.closePath();
        }
        if (buffer) {
          context2 = null;
          return buffer + "" || null;
        }
      }
      rectangle2.x = function(_) {
        if (arguments.length) {
          x2 = number$3(_);
          return rectangle2;
        } else {
          return x2;
        }
      };
      rectangle2.y = function(_) {
        if (arguments.length) {
          y2 = number$3(_);
          return rectangle2;
        } else {
          return y2;
        }
      };
      rectangle2.width = function(_) {
        if (arguments.length) {
          width2 = number$3(_);
          return rectangle2;
        } else {
          return width2;
        }
      };
      rectangle2.height = function(_) {
        if (arguments.length) {
          height2 = number$3(_);
          return rectangle2;
        } else {
          return height2;
        }
      };
      rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
        if (arguments.length) {
          crTL = number$3(tl2);
          crTR = tr2 != null ? number$3(tr2) : crTL;
          crBR = br2 != null ? number$3(br2) : crTL;
          crBL = bl2 != null ? number$3(bl2) : crTR;
          return rectangle2;
        } else {
          return crTL;
        }
      };
      rectangle2.context = function(_) {
        if (arguments.length) {
          context2 = _ == null ? null : _;
          return rectangle2;
        } else {
          return context2;
        }
      };
      return rectangle2;
    }
    function vg_trail() {
      var x2, y2, size2, defined2, context2 = null, ready, x12, y12, r1;
      function point2(x22, y22, w2) {
        const r2 = w2 / 2;
        if (ready) {
          var ux = y12 - y22, uy = x22 - x12;
          if (ux || uy) {
            var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t4 = Math.atan2(uy, ux);
            context2.moveTo(x12 - rx, y12 - ry);
            context2.lineTo(x22 - ux * r2, y22 - uy * r2);
            context2.arc(x22, y22, r2, t4 - Math.PI, t4);
            context2.lineTo(x12 + rx, y12 + ry);
            context2.arc(x12, y12, r1, t4, t4 + Math.PI);
          } else {
            context2.arc(x22, y22, r2, 0, Tau);
          }
          context2.closePath();
        } else {
          ready = 1;
        }
        x12 = x22;
        y12 = y22;
        r1 = r2;
      }
      function trail2(data2) {
        var i, n = data2.length, d, defined0 = false, buffer;
        if (context2 == null)
          context2 = buffer = path$3();
        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined2(d = data2[i], i, data2)) === defined0) {
            if (defined0 = !defined0)
              ready = 0;
          }
          if (defined0)
            point2(+x2(d, i, data2), +y2(d, i, data2), +size2(d, i, data2));
        }
        if (buffer) {
          context2 = null;
          return buffer + "" || null;
        }
      }
      trail2.x = function(_) {
        if (arguments.length) {
          x2 = _;
          return trail2;
        } else {
          return x2;
        }
      };
      trail2.y = function(_) {
        if (arguments.length) {
          y2 = _;
          return trail2;
        } else {
          return y2;
        }
      };
      trail2.size = function(_) {
        if (arguments.length) {
          size2 = _;
          return trail2;
        } else {
          return size2;
        }
      };
      trail2.defined = function(_) {
        if (arguments.length) {
          defined2 = _;
          return trail2;
        } else {
          return defined2;
        }
      };
      trail2.context = function(_) {
        if (arguments.length) {
          if (_ == null) {
            context2 = null;
          } else {
            context2 = _;
          }
          return trail2;
        } else {
          return context2;
        }
      };
      return trail2;
    }
    function value$1(a2, b2) {
      return a2 != null ? a2 : b2;
    }
    const x = (item) => item.x || 0, y = (item) => item.y || 0, w$1 = (item) => item.width || 0, h = (item) => item.height || 0, xw = (item) => (item.x || 0) + (item.width || 0), yh = (item) => (item.y || 0) + (item.height || 0), sa = (item) => item.startAngle || 0, ea = (item) => item.endAngle || 0, pa = (item) => item.padAngle || 0, ir = (item) => item.innerRadius || 0, or = (item) => item.outerRadius || 0, cr = (item) => item.cornerRadius || 0, tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0, tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0, br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0, bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0, sz = (item) => value$1(item.size, 64), ts = (item) => item.size || 1, def = (item) => !(item.defined === false), type$1 = (item) => symbols$1(item.shape || "circle");
    const arcShape = arc$2$1().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr), areavShape = area$2$1().x(x).y1(y).y0(yh).defined(def), areahShape = area$2$1().y(y).x1(x).x0(xw).defined(def), lineShape = line$2$1().x(x).y(y).defined(def), rectShape = vg_rect().x(x).y(y).width(w$1).height(h).cornerRadius(tl, tr, br, bl), symbolShape = Symbol$1().type(type$1).size(sz), trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
    function hasCornerRadius(item) {
      return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
    }
    function arc$1$1(context2, item) {
      return arcShape.context(context2)(item);
    }
    function area$1$1(context2, items) {
      const item = items[0], interp = item.interpolate || "linear";
      return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context2)(items);
    }
    function line$1$1(context2, items) {
      const item = items[0], interp = item.interpolate || "linear";
      return lineShape.curve(curves(interp, item.orient, item.tension)).context(context2)(items);
    }
    function rectangle(context2, item, x2, y2) {
      return rectShape.context(context2)(item, x2, y2);
    }
    function shape$1(context2, item) {
      return (item.mark.shape || item.shape).context(context2)(item);
    }
    function symbol$1(context2, item) {
      return symbolShape.context(context2)(item);
    }
    function trail$1(context2, items) {
      return trailShape.context(context2)(items);
    }
    var clip_id = 1;
    function resetSVGClipId() {
      clip_id = 1;
    }
    function clip$1(renderer, item, size2) {
      var clip2 = item.clip, defs = renderer._defs, id2 = item.clip_id || (item.clip_id = "clip" + clip_id++), c2 = defs.clipping[id2] || (defs.clipping[id2] = {
        id: id2
      });
      if (isFunction(clip2)) {
        c2.path = clip2(null);
      } else if (hasCornerRadius(size2)) {
        c2.path = rectangle(null, size2, 0, 0);
      } else {
        c2.width = size2.width || 0;
        c2.height = size2.height || 0;
      }
      return "url(#" + id2 + ")";
    }
    function Bounds(b2) {
      this.clear();
      if (b2)
        this.union(b2);
    }
    Bounds.prototype = {
      clone() {
        return new Bounds(this);
      },
      clear() {
        this.x1 = +Number.MAX_VALUE;
        this.y1 = +Number.MAX_VALUE;
        this.x2 = -Number.MAX_VALUE;
        this.y2 = -Number.MAX_VALUE;
        return this;
      },
      empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      },
      equals(b2) {
        return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
      },
      set(x12, y12, x2, y2) {
        if (x2 < x12) {
          this.x2 = x12;
          this.x1 = x2;
        } else {
          this.x1 = x12;
          this.x2 = x2;
        }
        if (y2 < y12) {
          this.y2 = y12;
          this.y1 = y2;
        } else {
          this.y1 = y12;
          this.y2 = y2;
        }
        return this;
      },
      add(x2, y2) {
        if (x2 < this.x1)
          this.x1 = x2;
        if (y2 < this.y1)
          this.y1 = y2;
        if (x2 > this.x2)
          this.x2 = x2;
        if (y2 > this.y2)
          this.y2 = y2;
        return this;
      },
      expand(d) {
        this.x1 -= d;
        this.y1 -= d;
        this.x2 += d;
        this.y2 += d;
        return this;
      },
      round() {
        this.x1 = Math.floor(this.x1);
        this.y1 = Math.floor(this.y1);
        this.x2 = Math.ceil(this.x2);
        this.y2 = Math.ceil(this.y2);
        return this;
      },
      scale(s) {
        this.x1 *= s;
        this.y1 *= s;
        this.x2 *= s;
        this.y2 *= s;
        return this;
      },
      translate(dx, dy) {
        this.x1 += dx;
        this.x2 += dx;
        this.y1 += dy;
        this.y2 += dy;
        return this;
      },
      rotate(angle2, x2, y2) {
        const p = this.rotatedPoints(angle2, x2, y2);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      },
      rotatedPoints(angle2, x2, y2) {
        var {
          x1: x12,
          y1: y12,
          x2: x22,
          y2: y22
        } = this, cos2 = Math.cos(angle2), sin2 = Math.sin(angle2), cx = x2 - x2 * cos2 + y2 * sin2, cy = y2 - x2 * sin2 - y2 * cos2;
        return [cos2 * x12 - sin2 * y12 + cx, sin2 * x12 + cos2 * y12 + cy, cos2 * x12 - sin2 * y22 + cx, sin2 * x12 + cos2 * y22 + cy, cos2 * x22 - sin2 * y12 + cx, sin2 * x22 + cos2 * y12 + cy, cos2 * x22 - sin2 * y22 + cx, sin2 * x22 + cos2 * y22 + cy];
      },
      union(b2) {
        if (b2.x1 < this.x1)
          this.x1 = b2.x1;
        if (b2.y1 < this.y1)
          this.y1 = b2.y1;
        if (b2.x2 > this.x2)
          this.x2 = b2.x2;
        if (b2.y2 > this.y2)
          this.y2 = b2.y2;
        return this;
      },
      intersect(b2) {
        if (b2.x1 > this.x1)
          this.x1 = b2.x1;
        if (b2.y1 > this.y1)
          this.y1 = b2.y1;
        if (b2.x2 < this.x2)
          this.x2 = b2.x2;
        if (b2.y2 < this.y2)
          this.y2 = b2.y2;
        return this;
      },
      encloses(b2) {
        return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
      },
      alignsWith(b2) {
        return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
      },
      intersects(b2) {
        return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
      },
      contains(x2, y2) {
        return !(x2 < this.x1 || x2 > this.x2 || y2 < this.y1 || y2 > this.y2);
      },
      width() {
        return this.x2 - this.x1;
      },
      height() {
        return this.y2 - this.y1;
      }
    };
    function Item(mark) {
      this.mark = mark;
      this.bounds = this.bounds || new Bounds();
    }
    function GroupItem(mark) {
      Item.call(this, mark);
      this.items = this.items || [];
    }
    inherits(GroupItem, Item);
    function ResourceLoader(customLoader) {
      this._pending = 0;
      this._loader = customLoader || loader();
    }
    function increment(loader2) {
      loader2._pending += 1;
    }
    function decrement(loader2) {
      loader2._pending -= 1;
    }
    ResourceLoader.prototype = {
      pending() {
        return this._pending;
      },
      sanitizeURL(uri) {
        const loader2 = this;
        increment(loader2);
        return loader2._loader.sanitize(uri, {
          context: "href"
        }).then((opt) => {
          decrement(loader2);
          return opt;
        }).catch(() => {
          decrement(loader2);
          return null;
        });
      },
      loadImage(uri) {
        const loader2 = this, Image2 = domImage();
        increment(loader2);
        return loader2._loader.sanitize(uri, {
          context: "image"
        }).then((opt) => {
          const url = opt.href;
          if (!url || !Image2)
            throw {
              url
            };
          const img = new Image2();
          const cors = has$1(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
          if (cors != null)
            img.crossOrigin = cors;
          img.onload = () => decrement(loader2);
          img.onerror = () => decrement(loader2);
          img.src = url;
          return img;
        }).catch((e3) => {
          decrement(loader2);
          return {
            complete: false,
            width: 0,
            height: 0,
            src: e3 && e3.url || ""
          };
        });
      },
      ready() {
        const loader2 = this;
        return new Promise((accept) => {
          function poll(value2) {
            if (!loader2.pending())
              accept(value2);
            else
              setTimeout(() => {
                poll(true);
              }, 10);
          }
          poll(false);
        });
      }
    };
    function boundStroke(bounds2, item, miter) {
      if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
        const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
        bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
      }
      return bounds2;
    }
    function miterAdjustment(item, strokeWidth) {
      return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
    }
    const circleThreshold = Tau - 1e-8;
    let bounds, lx, ly, rot, ma, mb, mc, md;
    const add$1 = (x2, y2) => bounds.add(x2, y2);
    const addL = (x2, y2) => add$1(lx = x2, ly = y2);
    const addX = (x2) => add$1(x2, bounds.y1);
    const addY = (y2) => add$1(bounds.x1, y2);
    const px = (x2, y2) => ma * x2 + mc * y2;
    const py = (x2, y2) => mb * x2 + md * y2;
    const addp = (x2, y2) => add$1(px(x2, y2), py(x2, y2));
    const addpL = (x2, y2) => addL(px(x2, y2), py(x2, y2));
    function boundContext(_, deg) {
      bounds = _;
      if (deg) {
        rot = deg * DegToRad;
        ma = md = Math.cos(rot);
        mb = Math.sin(rot);
        mc = -mb;
      } else {
        ma = md = 1;
        rot = mb = mc = 0;
      }
      return context$1;
    }
    const context$1 = {
      beginPath() {
      },
      closePath() {
      },
      moveTo: addpL,
      lineTo: addpL,
      rect(x2, y2, w2, h2) {
        if (rot) {
          addp(x2 + w2, y2);
          addp(x2 + w2, y2 + h2);
          addp(x2, y2 + h2);
          addpL(x2, y2);
        } else {
          add$1(x2 + w2, y2 + h2);
          addL(x2, y2);
        }
      },
      quadraticCurveTo(x12, y12, x2, y2) {
        const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2);
        quadExtrema(lx, px1, px2, addX);
        quadExtrema(ly, py1, py2, addY);
        addL(px2, py2);
      },
      bezierCurveTo(x12, y12, x2, y2, x3, y3) {
        const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2), px3 = px(x3, y3), py3 = py(x3, y3);
        cubicExtrema(lx, px1, px2, px3, addX);
        cubicExtrema(ly, py1, py2, py3, addY);
        addL(px3, py3);
      },
      arc(cx, cy, r, sa2, ea2, ccw) {
        sa2 += rot;
        ea2 += rot;
        lx = r * Math.cos(ea2) + cx;
        ly = r * Math.sin(ea2) + cy;
        if (Math.abs(ea2 - sa2) > circleThreshold) {
          add$1(cx - r, cy - r);
          add$1(cx + r, cy + r);
        } else {
          const update2 = (a2) => add$1(r * Math.cos(a2) + cx, r * Math.sin(a2) + cy);
          let s, i;
          update2(sa2);
          update2(ea2);
          if (ea2 !== sa2) {
            sa2 = sa2 % Tau;
            if (sa2 < 0)
              sa2 += Tau;
            ea2 = ea2 % Tau;
            if (ea2 < 0)
              ea2 += Tau;
            if (ea2 < sa2) {
              ccw = !ccw;
              s = sa2;
              sa2 = ea2;
              ea2 = s;
            }
            if (ccw) {
              ea2 -= Tau;
              s = sa2 - sa2 % HalfPi;
              for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi)
                update2(s);
            } else {
              s = sa2 - sa2 % HalfPi + HalfPi;
              for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi)
                update2(s);
            }
          }
        }
      }
    };
    function quadExtrema(x02, x12, x2, cb) {
      const t4 = (x02 - x12) / (x02 + x2 - 2 * x12);
      if (0 < t4 && t4 < 1)
        cb(x02 + (x12 - x02) * t4);
    }
    function cubicExtrema(x02, x12, x2, x3, cb) {
      const a2 = x3 - x02 + 3 * x12 - 3 * x2, b2 = x02 + x2 - 2 * x12, c2 = x02 - x12;
      let t02 = 0, t12 = 0, r;
      if (Math.abs(a2) > Epsilon) {
        r = b2 * b2 + c2 * a2;
        if (r >= 0) {
          r = Math.sqrt(r);
          t02 = (-b2 + r) / a2;
          t12 = (-b2 - r) / a2;
        }
      } else {
        t02 = 0.5 * c2 / b2;
      }
      if (0 < t02 && t02 < 1)
        cb(cubic(t02, x02, x12, x2, x3));
      if (0 < t12 && t12 < 1)
        cb(cubic(t12, x02, x12, x2, x3));
    }
    function cubic(t4, x02, x12, x2, x3) {
      const s = 1 - t4, s2 = s * s, t22 = t4 * t4;
      return s2 * s * x02 + 3 * s2 * t4 * x12 + 3 * s * t22 * x2 + t22 * t4 * x3;
    }
    var context$2 = (context$2 = domCanvas(1, 1)) ? context$2.getContext("2d") : null;
    const b = new Bounds();
    function intersectPath(draw2) {
      return function(item, brush2) {
        if (!context$2)
          return true;
        draw2(context$2, item);
        b.clear().union(item.bounds).intersect(brush2).round();
        const {
          x1: x12,
          y1: y12,
          x2,
          y2
        } = b;
        for (let y3 = y12; y3 <= y2; ++y3) {
          for (let x3 = x12; x3 <= x2; ++x3) {
            if (context$2.isPointInPath(x3, y3)) {
              return true;
            }
          }
        }
        return false;
      };
    }
    function intersectPoint(item, box) {
      return box.contains(item.x || 0, item.y || 0);
    }
    function intersectRect(item, box) {
      const x2 = item.x || 0, y2 = item.y || 0, w2 = item.width || 0, h2 = item.height || 0;
      return box.intersects(b.set(x2, y2, x2 + w2, y2 + h2));
    }
    function intersectRule(item, box) {
      const x2 = item.x || 0, y2 = item.y || 0, x22 = item.x2 != null ? item.x2 : x2, y22 = item.y2 != null ? item.y2 : y2;
      return intersectBoxLine(box, x2, y2, x22, y22);
    }
    function intersectBoxLine(box, x2, y2, u2, v) {
      const {
        x1: x12,
        y1: y12,
        x2: x22,
        y2: y22
      } = box, dx = u2 - x2, dy = v - y2;
      let t02 = 0, t12 = 1, p, q, r, e3;
      for (e3 = 0; e3 < 4; ++e3) {
        if (e3 === 0) {
          p = -dx;
          q = -(x12 - x2);
        }
        if (e3 === 1) {
          p = dx;
          q = x22 - x2;
        }
        if (e3 === 2) {
          p = -dy;
          q = -(y12 - y2);
        }
        if (e3 === 3) {
          p = dy;
          q = y22 - y2;
        }
        if (Math.abs(p) < 1e-10 && q < 0)
          return false;
        r = q / p;
        if (p < 0) {
          if (r > t12)
            return false;
          else if (r > t02)
            t02 = r;
        } else if (p > 0) {
          if (r < t02)
            return false;
          else if (r < t12)
            t12 = r;
        }
      }
      return true;
    }
    function blend(context2, item) {
      context2.globalCompositeOperation = item.blend || "source-over";
    }
    function value$2(value2, dflt) {
      return value2 == null ? dflt : value2;
    }
    function addStops(gradient2, stops) {
      const n = stops.length;
      for (let i = 0; i < n; ++i) {
        gradient2.addColorStop(stops[i].offset, stops[i].color);
      }
      return gradient2;
    }
    function gradient$2(context2, spec, bounds2) {
      const w2 = bounds2.width(), h2 = bounds2.height();
      let gradient2;
      if (spec.gradient === "radial") {
        gradient2 = context2.createRadialGradient(bounds2.x1 + value$2(spec.x1, 0.5) * w2, bounds2.y1 + value$2(spec.y1, 0.5) * h2, Math.max(w2, h2) * value$2(spec.r1, 0), bounds2.x1 + value$2(spec.x2, 0.5) * w2, bounds2.y1 + value$2(spec.y2, 0.5) * h2, Math.max(w2, h2) * value$2(spec.r2, 0.5));
      } else {
        const x12 = value$2(spec.x1, 0), y12 = value$2(spec.y1, 0), x2 = value$2(spec.x2, 1), y2 = value$2(spec.y2, 0);
        if (x12 === x2 || y12 === y2 || w2 === h2) {
          gradient2 = context2.createLinearGradient(bounds2.x1 + x12 * w2, bounds2.y1 + y12 * h2, bounds2.x1 + x2 * w2, bounds2.y1 + y2 * h2);
        } else {
          const image2 = domCanvas(Math.ceil(w2), Math.ceil(h2)), ictx = image2.getContext("2d");
          ictx.scale(w2, h2);
          ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x2, y2), spec.stops);
          ictx.fillRect(0, 0, w2, h2);
          return context2.createPattern(image2, "no-repeat");
        }
      }
      return addStops(gradient2, spec.stops);
    }
    function color$2(context2, item, value2) {
      return isGradient(value2) ? gradient$2(context2, value2, item.bounds) : value2;
    }
    function fill(context2, item, opacity2) {
      opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
      if (opacity2 > 0) {
        context2.globalAlpha = opacity2;
        context2.fillStyle = color$2(context2, item, item.fill);
        return true;
      } else {
        return false;
      }
    }
    var Empty = [];
    function stroke(context2, item, opacity2) {
      var lw = (lw = item.strokeWidth) != null ? lw : 1;
      if (lw <= 0)
        return false;
      opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
      if (opacity2 > 0) {
        context2.globalAlpha = opacity2;
        context2.strokeStyle = color$2(context2, item, item.stroke);
        context2.lineWidth = lw;
        context2.lineCap = item.strokeCap || "butt";
        context2.lineJoin = item.strokeJoin || "miter";
        context2.miterLimit = item.strokeMiterLimit || 10;
        if (context2.setLineDash) {
          context2.setLineDash(item.strokeDash || Empty);
          context2.lineDashOffset = item.strokeDashOffset || 0;
        }
        return true;
      } else {
        return false;
      }
    }
    function compare$7(a2, b2) {
      return a2.zindex - b2.zindex || a2.index - b2.index;
    }
    function zorder(scene) {
      if (!scene.zdirty)
        return scene.zitems;
      var items = scene.items, output2 = [], item, i, n;
      for (i = 0, n = items.length; i < n; ++i) {
        item = items[i];
        item.index = i;
        if (item.zindex)
          output2.push(item);
      }
      scene.zdirty = false;
      return scene.zitems = output2.sort(compare$7);
    }
    function visit(scene, visitor) {
      var items = scene.items, i, n;
      if (!items || !items.length)
        return;
      const zitems = zorder(scene);
      if (zitems && zitems.length) {
        for (i = 0, n = items.length; i < n; ++i) {
          if (!items[i].zindex)
            visitor(items[i]);
        }
        items = zitems;
      }
      for (i = 0, n = items.length; i < n; ++i) {
        visitor(items[i]);
      }
    }
    function pickVisit(scene, visitor) {
      var items = scene.items, hit2, i;
      if (!items || !items.length)
        return null;
      const zitems = zorder(scene);
      if (zitems && zitems.length)
        items = zitems;
      for (i = items.length; --i >= 0; ) {
        if (hit2 = visitor(items[i]))
          return hit2;
      }
      if (items === zitems) {
        for (items = scene.items, i = items.length; --i >= 0; ) {
          if (!items[i].zindex) {
            if (hit2 = visitor(items[i]))
              return hit2;
          }
        }
      }
      return null;
    }
    function drawAll(path2) {
      return function(context2, scene, bounds2) {
        visit(scene, (item) => {
          if (!bounds2 || bounds2.intersects(item.bounds)) {
            drawPath(path2, context2, item, item);
          }
        });
      };
    }
    function drawOne(path2) {
      return function(context2, scene, bounds2) {
        if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
          drawPath(path2, context2, scene.items[0], scene.items);
        }
      };
    }
    function drawPath(path2, context2, item, items) {
      var opacity2 = item.opacity == null ? 1 : item.opacity;
      if (opacity2 === 0)
        return;
      if (path2(context2, items))
        return;
      blend(context2, item);
      if (item.fill && fill(context2, item, opacity2)) {
        context2.fill();
      }
      if (item.stroke && stroke(context2, item, opacity2)) {
        context2.stroke();
      }
    }
    function pick$1(test2) {
      test2 = test2 || truthy;
      return function(context2, scene, x2, y2, gx, gy) {
        x2 *= context2.pixelRatio;
        y2 *= context2.pixelRatio;
        return pickVisit(scene, (item) => {
          const b2 = item.bounds;
          if (b2 && !b2.contains(gx, gy) || !b2)
            return;
          if (test2(context2, item, x2, y2, gx, gy))
            return item;
        });
      };
    }
    function hitPath(path2, filled) {
      return function(context2, o, x2, y2) {
        var item = Array.isArray(o) ? o[0] : o, fill2 = filled == null ? item.fill : filled, stroke2 = item.stroke && context2.isPointInStroke, lw, lc;
        if (stroke2) {
          lw = item.strokeWidth;
          lc = item.strokeCap;
          context2.lineWidth = lw != null ? lw : 1;
          context2.lineCap = lc != null ? lc : "butt";
        }
        return path2(context2, o) ? false : fill2 && context2.isPointInPath(x2, y2) || stroke2 && context2.isPointInStroke(x2, y2);
      };
    }
    function pickPath(path2) {
      return pick$1(hitPath(path2));
    }
    function translate$2(x2, y2) {
      return "translate(" + x2 + "," + y2 + ")";
    }
    function rotate(a2) {
      return "rotate(" + a2 + ")";
    }
    function scale$3(scaleX, scaleY2) {
      return "scale(" + scaleX + "," + scaleY2 + ")";
    }
    function translateItem(item) {
      return translate$2(item.x || 0, item.y || 0);
    }
    function rotateItem(item) {
      return translate$2(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
    }
    function transformItem(item) {
      return translate$2(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale$3(item.scaleX || 1, item.scaleY || 1) : "");
    }
    function markItemPath(type2, shape2, isect) {
      function attr2(emit2, item) {
        emit2("transform", rotateItem(item));
        emit2("d", shape2(null, item));
      }
      function bound2(bounds2, item) {
        shape2(boundContext(bounds2, item.angle), item);
        return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
      }
      function draw2(context2, item) {
        var x2 = item.x || 0, y2 = item.y || 0, a2 = item.angle || 0;
        context2.translate(x2, y2);
        if (a2)
          context2.rotate(a2 *= DegToRad);
        context2.beginPath();
        shape2(context2, item);
        if (a2)
          context2.rotate(-a2);
        context2.translate(-x2, -y2);
      }
      return {
        type: type2,
        tag: "path",
        nested: false,
        attr: attr2,
        bound: bound2,
        draw: drawAll(draw2),
        pick: pickPath(draw2),
        isect: isect || intersectPath(draw2)
      };
    }
    var arc$2 = markItemPath("arc", arc$1$1);
    function pickArea(a2, p) {
      var v = a2[0].orient === "horizontal" ? p[1] : p[0], z = a2[0].orient === "horizontal" ? "y" : "x", i = a2.length, min2 = Infinity, hit2, d;
      while (--i >= 0) {
        if (a2[i].defined === false)
          continue;
        d = Math.abs(a2[i][z] - v);
        if (d < min2) {
          min2 = d;
          hit2 = a2[i];
        }
      }
      return hit2;
    }
    function pickLine(a2, p) {
      var t4 = Math.pow(a2[0].strokeWidth || 1, 2), i = a2.length, dx, dy, dd;
      while (--i >= 0) {
        if (a2[i].defined === false)
          continue;
        dx = a2[i].x - p[0];
        dy = a2[i].y - p[1];
        dd = dx * dx + dy * dy;
        if (dd < t4)
          return a2[i];
      }
      return null;
    }
    function pickTrail(a2, p) {
      var i = a2.length, dx, dy, dd;
      while (--i >= 0) {
        if (a2[i].defined === false)
          continue;
        dx = a2[i].x - p[0];
        dy = a2[i].y - p[1];
        dd = dx * dx + dy * dy;
        dx = a2[i].size || 1;
        if (dd < dx * dx)
          return a2[i];
      }
      return null;
    }
    function markMultiItemPath(type2, shape2, tip) {
      function attr2(emit2, item) {
        var items = item.mark.items;
        if (items.length)
          emit2("d", shape2(null, items));
      }
      function bound2(bounds2, mark) {
        var items = mark.items;
        if (items.length === 0) {
          return bounds2;
        } else {
          shape2(boundContext(bounds2), items);
          return boundStroke(bounds2, items[0]);
        }
      }
      function draw2(context2, items) {
        context2.beginPath();
        shape2(context2, items);
      }
      const hit2 = hitPath(draw2);
      function pick2(context2, scene, x2, y2, gx, gy) {
        var items = scene.items, b2 = scene.bounds;
        if (!items || !items.length || b2 && !b2.contains(gx, gy)) {
          return null;
        }
        x2 *= context2.pixelRatio;
        y2 *= context2.pixelRatio;
        return hit2(context2, items, x2, y2) ? items[0] : null;
      }
      return {
        type: type2,
        tag: "path",
        nested: true,
        attr: attr2,
        bound: bound2,
        draw: drawOne(draw2),
        pick: pick2,
        isect: intersectPoint,
        tip
      };
    }
    var area$2 = markMultiItemPath("area", area$1$1, pickArea);
    function clip$2(context2, scene) {
      var clip2 = scene.clip;
      context2.save();
      if (isFunction(clip2)) {
        context2.beginPath();
        clip2(context2);
        context2.clip();
      } else {
        clipGroup(context2, scene.group);
      }
    }
    function clipGroup(context2, group2) {
      context2.beginPath();
      hasCornerRadius(group2) ? rectangle(context2, group2, 0, 0) : context2.rect(0, 0, group2.width || 0, group2.height || 0);
      context2.clip();
    }
    function offset$1(item) {
      const sw = value$2(item.strokeWidth, 1);
      return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
    }
    function attr$5(emit2, item) {
      emit2("transform", translateItem(item));
    }
    function emitRectangle(emit2, item) {
      const off = offset$1(item);
      emit2("d", rectangle(null, item, off, off));
    }
    function background$1(emit2, item) {
      emit2("class", "background");
      emit2("aria-hidden", true);
      emitRectangle(emit2, item);
    }
    function foreground(emit2, item) {
      emit2("class", "foreground");
      emit2("aria-hidden", true);
      if (item.strokeForeground) {
        emitRectangle(emit2, item);
      } else {
        emit2("d", "");
      }
    }
    function content(emit2, item, renderer) {
      const url = item.clip ? clip$1(renderer, item, item) : null;
      emit2("clip-path", url);
    }
    function bound$5(bounds2, group2) {
      if (!group2.clip && group2.items) {
        const items = group2.items, m2 = items.length;
        for (let j = 0; j < m2; ++j) {
          bounds2.union(items[j].bounds);
        }
      }
      if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
        bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
      }
      boundStroke(bounds2, group2);
      return bounds2.translate(group2.x || 0, group2.y || 0);
    }
    function rectanglePath(context2, group2, x2, y2) {
      const off = offset$1(group2);
      context2.beginPath();
      rectangle(context2, group2, (x2 || 0) + off, (y2 || 0) + off);
    }
    const hitBackground = hitPath(rectanglePath);
    const hitForeground = hitPath(rectanglePath, false);
    const hitCorner = hitPath(rectanglePath, true);
    function draw$4(context2, scene, bounds2, markTypes) {
      visit(scene, (group2) => {
        const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity2 = group2.opacity == null ? 1 : group2.opacity;
        if ((group2.stroke || group2.fill) && opacity2) {
          rectanglePath(context2, group2, gx, gy);
          blend(context2, group2);
          if (group2.fill && fill(context2, group2, opacity2)) {
            context2.fill();
          }
          if (group2.stroke && !fore && stroke(context2, group2, opacity2)) {
            context2.stroke();
          }
        }
        context2.save();
        context2.translate(gx, gy);
        if (group2.clip)
          clipGroup(context2, group2);
        if (bounds2)
          bounds2.translate(-gx, -gy);
        visit(group2, (item) => {
          if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
            this.draw(context2, item, bounds2, markTypes);
          }
        });
        if (bounds2)
          bounds2.translate(gx, gy);
        context2.restore();
        if (fore && group2.stroke && opacity2) {
          rectanglePath(context2, group2, gx, gy);
          blend(context2, group2);
          if (stroke(context2, group2, opacity2)) {
            context2.stroke();
          }
        }
      });
    }
    function pick$2(context2, scene, x2, y2, gx, gy) {
      if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
        return null;
      }
      const cx = x2 * context2.pixelRatio, cy = y2 * context2.pixelRatio;
      return pickVisit(scene, (group2) => {
        let hit2, dx, dy;
        const b2 = group2.bounds;
        if (b2 && !b2.contains(gx, gy))
          return;
        dx = group2.x || 0;
        dy = group2.y || 0;
        const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c2 = group2.clip;
        if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh))
          return;
        context2.save();
        context2.translate(dx, dy);
        dx = gx - dx;
        dy = gy - dy;
        if (c2 && hasCornerRadius(group2) && !hitCorner(context2, group2, cx, cy)) {
          context2.restore();
          return null;
        }
        const fore = group2.strokeForeground, ix = scene.interactive !== false;
        if (ix && fore && group2.stroke && hitForeground(context2, group2, cx, cy)) {
          context2.restore();
          return group2;
        }
        hit2 = pickVisit(group2, (mark) => pickMark(mark, dx, dy) ? this.pick(mark, x2, y2, dx, dy) : null);
        if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context2, group2, cx, cy)) {
          hit2 = group2;
        }
        context2.restore();
        return hit2 || null;
      });
    }
    function pickMark(mark, x2, y2) {
      return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x2, y2);
    }
    var group = {
      type: "group",
      tag: "g",
      nested: false,
      attr: attr$5,
      bound: bound$5,
      draw: draw$4,
      pick: pick$2,
      isect: intersectRect,
      content,
      background: background$1,
      foreground
    };
    var metadata = {
      "xmlns": "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "version": "1.1"
    };
    function getImage(item, renderer) {
      var image2 = item.image;
      if (!image2 || item.url && item.url !== image2.url) {
        image2 = {
          complete: false,
          width: 0,
          height: 0
        };
        renderer.loadImage(item.url).then((image3) => {
          item.image = image3;
          item.image.url = item.url;
        });
      }
      return image2;
    }
    function imageWidth(item, image2) {
      return item.width != null ? item.width : !image2 || !image2.width ? 0 : item.aspect !== false && item.height ? item.height * image2.width / image2.height : image2.width;
    }
    function imageHeight(item, image2) {
      return item.height != null ? item.height : !image2 || !image2.height ? 0 : item.aspect !== false && item.width ? item.width * image2.height / image2.width : image2.height;
    }
    function imageXOffset(align2, w2) {
      return align2 === "center" ? w2 / 2 : align2 === "right" ? w2 : 0;
    }
    function imageYOffset(baseline2, h2) {
      return baseline2 === "middle" ? h2 / 2 : baseline2 === "bottom" ? h2 : 0;
    }
    function attr$4(emit2, item, renderer) {
      const img = getImage(item, renderer), w2 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
      emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
      emit2("transform", translate$2(x2, y2));
      emit2("width", w2);
      emit2("height", h2);
      emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
    }
    function bound$4(bounds2, item) {
      const img = item.image, w2 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2);
      return bounds2.set(x2, y2, x2 + w2, y2 + h2);
    }
    function draw$3(context2, scene, bounds2) {
      visit(scene, (item) => {
        if (bounds2 && !bounds2.intersects(item.bounds))
          return;
        const img = getImage(item, this);
        let w2 = imageWidth(item, img);
        let h2 = imageHeight(item, img);
        if (w2 === 0 || h2 === 0)
          return;
        let x2 = (item.x || 0) - imageXOffset(item.align, w2), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), opacity2, ar0, ar1, t4;
        if (item.aspect !== false) {
          ar0 = img.width / img.height;
          ar1 = item.width / item.height;
          if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
            if (ar1 < ar0) {
              t4 = w2 / ar0;
              y2 += (h2 - t4) / 2;
              h2 = t4;
            } else {
              t4 = h2 * ar0;
              x2 += (w2 - t4) / 2;
              w2 = t4;
            }
          }
        }
        if (img.complete || img.toDataURL) {
          blend(context2, item);
          context2.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
          context2.imageSmoothingEnabled = item.smooth !== false;
          context2.drawImage(img, x2, y2, w2, h2);
        }
      });
    }
    var image$1 = {
      type: "image",
      tag: "image",
      nested: false,
      attr: attr$4,
      bound: bound$4,
      draw: draw$3,
      pick: pick$1(),
      isect: truthy,
      // bounds check is sufficient
      get: getImage,
      xOffset: imageXOffset,
      yOffset: imageYOffset
    };
    var line$2 = markMultiItemPath("line", line$1$1, pickLine);
    function attr$3(emit2, item) {
      var sx = item.scaleX || 1, sy = item.scaleY || 1;
      if (sx !== 1 || sy !== 1) {
        emit2("vector-effect", "non-scaling-stroke");
      }
      emit2("transform", transformItem(item));
      emit2("d", item.path);
    }
    function path$1(context2, item) {
      var path2 = item.path;
      if (path2 == null)
        return true;
      var x2 = item.x || 0, y2 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a2 = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
      if (!cache2 || cache2.path !== path2) {
        (item.pathCache = cache2 = parse$3(path2)).path = path2;
      }
      if (a2 && context2.rotate && context2.translate) {
        context2.translate(x2, y2);
        context2.rotate(a2);
        pathRender(context2, cache2, 0, 0, sx, sy);
        context2.rotate(-a2);
        context2.translate(-x2, -y2);
      } else {
        pathRender(context2, cache2, x2, y2, sx, sy);
      }
    }
    function bound$3(bounds2, item) {
      return path$1(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
    }
    var path$2 = {
      type: "path",
      tag: "path",
      nested: false,
      attr: attr$3,
      bound: bound$3,
      draw: drawAll(path$1),
      pick: pickPath(path$1),
      isect: intersectPath(path$1)
    };
    function attr$2(emit2, item) {
      emit2("d", rectangle(null, item));
    }
    function bound$2(bounds2, item) {
      var x2, y2;
      return boundStroke(bounds2.set(x2 = item.x || 0, y2 = item.y || 0, x2 + item.width || 0, y2 + item.height || 0), item);
    }
    function draw$2(context2, item) {
      context2.beginPath();
      rectangle(context2, item);
    }
    var rect$1 = {
      type: "rect",
      tag: "path",
      nested: false,
      attr: attr$2,
      bound: bound$2,
      draw: drawAll(draw$2),
      pick: pickPath(draw$2),
      isect: intersectRect
    };
    function attr$1(emit2, item) {
      emit2("transform", translateItem(item));
      emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
      emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
    }
    function bound$1(bounds2, item) {
      var x12, y12;
      return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
    }
    function path(context2, item, opacity2) {
      var x12, y12, x2, y2;
      if (item.stroke && stroke(context2, item, opacity2)) {
        x12 = item.x || 0;
        y12 = item.y || 0;
        x2 = item.x2 != null ? item.x2 : x12;
        y2 = item.y2 != null ? item.y2 : y12;
        context2.beginPath();
        context2.moveTo(x12, y12);
        context2.lineTo(x2, y2);
        return true;
      }
      return false;
    }
    function draw$1(context2, scene, bounds2) {
      visit(scene, (item) => {
        if (bounds2 && !bounds2.intersects(item.bounds))
          return;
        var opacity2 = item.opacity == null ? 1 : item.opacity;
        if (opacity2 && path(context2, item, opacity2)) {
          blend(context2, item);
          context2.stroke();
        }
      });
    }
    function hit$1(context2, item, x2, y2) {
      if (!context2.isPointInStroke)
        return false;
      return path(context2, item, 1) && context2.isPointInStroke(x2, y2);
    }
    var rule$2 = {
      type: "rule",
      tag: "line",
      nested: false,
      attr: attr$1,
      bound: bound$1,
      draw: draw$1,
      pick: pick$1(hit$1),
      isect: intersectRule
    };
    var shape = markItemPath("shape", shape$1);
    var symbol = markItemPath("symbol", symbol$1, intersectPoint);
    const widthCache = lruCache$1();
    var textMetrics = {
      height: fontSize,
      measureWidth,
      estimateWidth,
      width: estimateWidth,
      canvas: useCanvas
    };
    useCanvas(true);
    function useCanvas(use) {
      textMetrics.width = use && context$2 ? measureWidth : estimateWidth;
    }
    function estimateWidth(item, text2) {
      return _estimateWidth(textValue(item, text2), fontSize(item));
    }
    function _estimateWidth(text2, currentFontHeight) {
      return ~~(0.8 * text2.length * currentFontHeight);
    }
    function measureWidth(item, text2) {
      return fontSize(item) <= 0 || !(text2 = textValue(item, text2)) ? 0 : _measureWidth(text2, font$1(item));
    }
    function _measureWidth(text2, currentFont) {
      const key2 = `(${currentFont}) ${text2}`;
      let width2 = widthCache.get(key2);
      if (width2 === void 0) {
        context$2.font = currentFont;
        width2 = context$2.measureText(text2).width;
        widthCache.set(key2, width2);
      }
      return width2;
    }
    function fontSize(item) {
      return item.fontSize != null ? +item.fontSize || 0 : 11;
    }
    function lineHeight(item) {
      return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
    }
    function lineArray(_) {
      return isArray(_) ? _.length > 1 ? _ : _[0] : _;
    }
    function textLines(item) {
      return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
    }
    function multiLineOffset(item) {
      const tl2 = textLines(item);
      return (isArray(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
    }
    function textValue(item, line2) {
      const text2 = line2 == null ? "" : (line2 + "").trim();
      return item.limit > 0 && text2.length ? truncate(item, text2) : text2;
    }
    function widthGetter(item) {
      if (textMetrics.width === measureWidth) {
        const currentFont = font$1(item);
        return (text2) => _measureWidth(text2, currentFont);
      } else if (textMetrics.width === estimateWidth) {
        const currentFontHeight = fontSize(item);
        return (text2) => _estimateWidth(text2, currentFontHeight);
      } else {
        return (text2) => textMetrics.width(item, text2);
      }
    }
    function truncate(item, text2) {
      var limit = +item.limit, width2 = widthGetter(item);
      if (width2(text2) < limit)
        return text2;
      var ellipsis = item.ellipsis || "", rtl = item.dir === "rtl", lo = 0, hi = text2.length, mid;
      limit -= width2(ellipsis);
      if (rtl) {
        while (lo < hi) {
          mid = lo + hi >>> 1;
          if (width2(text2.slice(mid)) > limit)
            lo = mid + 1;
          else
            hi = mid;
        }
        return ellipsis + text2.slice(lo);
      } else {
        while (lo < hi) {
          mid = 1 + (lo + hi >>> 1);
          if (width2(text2.slice(0, mid)) < limit)
            lo = mid;
          else
            hi = mid - 1;
        }
        return text2.slice(0, lo) + ellipsis;
      }
    }
    function fontFamily(item, quote) {
      var font2 = item.font;
      return (quote && font2 ? String(font2).replace(/"/g, "'") : font2) || "sans-serif";
    }
    function font$1(item, quote) {
      return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
    }
    function offset$2(item) {
      var baseline2 = item.baseline, h2 = fontSize(item);
      return Math.round(baseline2 === "top" ? 0.79 * h2 : baseline2 === "middle" ? 0.3 * h2 : baseline2 === "bottom" ? -0.21 * h2 : baseline2 === "line-top" ? 0.29 * h2 + 0.5 * lineHeight(item) : baseline2 === "line-bottom" ? 0.29 * h2 - 0.5 * lineHeight(item) : 0);
    }
    const textAlign = {
      "left": "start",
      "center": "middle",
      "right": "end"
    };
    const tempBounds$1 = new Bounds();
    function anchorPoint(item) {
      var x2 = item.x || 0, y2 = item.y || 0, r = item.radius || 0, t4;
      if (r) {
        t4 = (item.theta || 0) - HalfPi;
        x2 += r * Math.cos(t4);
        y2 += r * Math.sin(t4);
      }
      tempBounds$1.x1 = x2;
      tempBounds$1.y1 = y2;
      return tempBounds$1;
    }
    function attr(emit2, item) {
      var dx = item.dx || 0, dy = (item.dy || 0) + offset$2(item), p = anchorPoint(item), x2 = p.x1, y2 = p.y1, a2 = item.angle || 0, t4;
      emit2("text-anchor", textAlign[item.align] || "start");
      if (a2) {
        t4 = translate$2(x2, y2) + " " + rotate(a2);
        if (dx || dy)
          t4 += " " + translate$2(dx, dy);
      } else {
        t4 = translate$2(x2 + dx, y2 + dy);
      }
      emit2("transform", t4);
    }
    function bound(bounds2, item, mode) {
      var h2 = textMetrics.height(item), a2 = item.align, p = anchorPoint(item), x2 = p.x1, y2 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset$2(item) - Math.round(0.8 * h2), tl2 = textLines(item), w2;
      if (isArray(tl2)) {
        h2 += lineHeight(item) * (tl2.length - 1);
        w2 = tl2.reduce((w3, t4) => Math.max(w3, textMetrics.width(item, t4)), 0);
      } else {
        w2 = textMetrics.width(item, tl2);
      }
      if (a2 === "center") {
        dx -= w2 / 2;
      } else if (a2 === "right") {
        dx -= w2;
      } else
        ;
      bounds2.set(dx += x2, dy += y2, dx + w2, dy + h2);
      if (item.angle && !mode) {
        bounds2.rotate(item.angle * DegToRad, x2, y2);
      } else if (mode === 2) {
        return bounds2.rotatedPoints(item.angle * DegToRad, x2, y2);
      }
      return bounds2;
    }
    function draw$5(context2, scene, bounds2) {
      visit(scene, (item) => {
        var opacity2 = item.opacity == null ? 1 : item.opacity, p, x2, y2, i, lh, tl2, str;
        if (bounds2 && !bounds2.intersects(item.bounds) || // bounds check
        opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
          return;
        context2.font = font$1(item);
        context2.textAlign = item.align || "left";
        p = anchorPoint(item);
        x2 = p.x1, y2 = p.y1;
        if (item.angle) {
          context2.save();
          context2.translate(x2, y2);
          context2.rotate(item.angle * DegToRad);
          x2 = y2 = 0;
        }
        x2 += item.dx || 0;
        y2 += (item.dy || 0) + offset$2(item);
        tl2 = textLines(item);
        blend(context2, item);
        if (isArray(tl2)) {
          lh = lineHeight(item);
          for (i = 0; i < tl2.length; ++i) {
            str = textValue(item, tl2[i]);
            if (item.fill && fill(context2, item, opacity2)) {
              context2.fillText(str, x2, y2);
            }
            if (item.stroke && stroke(context2, item, opacity2)) {
              context2.strokeText(str, x2, y2);
            }
            y2 += lh;
          }
        } else {
          str = textValue(item, tl2);
          if (item.fill && fill(context2, item, opacity2)) {
            context2.fillText(str, x2, y2);
          }
          if (item.stroke && stroke(context2, item, opacity2)) {
            context2.strokeText(str, x2, y2);
          }
        }
        if (item.angle)
          context2.restore();
      });
    }
    function hit(context2, item, x2, y2, gx, gy) {
      if (item.fontSize <= 0)
        return false;
      if (!item.angle)
        return true;
      var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound(tempBounds$1, item, 1), a2 = -item.angle * DegToRad, cos2 = Math.cos(a2), sin2 = Math.sin(a2), px2 = cos2 * gx - sin2 * gy + (ax - cos2 * ax + sin2 * ay), py2 = sin2 * gx + cos2 * gy + (ay - sin2 * ax - cos2 * ay);
      return b2.contains(px2, py2);
    }
    function intersectText(item, box) {
      const p = bound(tempBounds$1, item, 2);
      return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
    }
    var text$2 = {
      type: "text",
      tag: "text",
      nested: false,
      attr,
      bound,
      draw: draw$5,
      pick: pick$1(hit),
      isect: intersectText
    };
    var trail$2 = markMultiItemPath("trail", trail$1, pickTrail);
    var Marks = {
      arc: arc$2,
      area: area$2,
      group,
      image: image$1,
      line: line$2,
      path: path$2,
      rect: rect$1,
      rule: rule$2,
      shape,
      symbol,
      text: text$2,
      trail: trail$2
    };
    function boundItem$1(item, func2, opt) {
      var type2 = Marks[item.mark.marktype], bound2 = func2 || type2.bound;
      if (type2.nested)
        item = item.mark;
      return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
    }
    var DUMMY = {
      mark: null
    };
    function boundMark(mark, bounds2, opt) {
      var type2 = Marks[mark.marktype], bound2 = type2.bound, items = mark.items, hasItems = items && items.length, i, n, item, b2;
      if (type2.nested) {
        if (hasItems) {
          item = items[0];
        } else {
          DUMMY.mark = mark;
          item = DUMMY;
        }
        b2 = boundItem$1(item, bound2, opt);
        bounds2 = bounds2 && bounds2.union(b2) || b2;
        return bounds2;
      }
      bounds2 = bounds2 || mark.bounds && mark.bounds.clear() || new Bounds();
      if (hasItems) {
        for (i = 0, n = items.length; i < n; ++i) {
          bounds2.union(boundItem$1(items[i], bound2, opt));
        }
      }
      return mark.bounds = bounds2;
    }
    const keys$2 = [
      "marktype",
      "name",
      "role",
      "interactive",
      "clip",
      "items",
      "zindex",
      "x",
      "y",
      "width",
      "height",
      "align",
      "baseline",
      // layout
      "fill",
      "fillOpacity",
      "opacity",
      "blend",
      // fill
      "stroke",
      "strokeOpacity",
      "strokeWidth",
      "strokeCap",
      // stroke
      "strokeDash",
      "strokeDashOffset",
      // stroke dash
      "strokeForeground",
      "strokeOffset",
      // group
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      // arc
      "cornerRadius",
      "padAngle",
      // arc, rect
      "cornerRadiusTopLeft",
      "cornerRadiusTopRight",
      // rect, group
      "cornerRadiusBottomLeft",
      "cornerRadiusBottomRight",
      "interpolate",
      "tension",
      "orient",
      "defined",
      // area, line
      "url",
      "aspect",
      "smooth",
      // image
      "path",
      "scaleX",
      "scaleY",
      // path
      "x2",
      "y2",
      // rule
      "size",
      "shape",
      // symbol
      "text",
      "angle",
      "theta",
      "radius",
      "dir",
      "dx",
      "dy",
      // text
      "ellipsis",
      "limit",
      "lineBreak",
      "lineHeight",
      "font",
      "fontSize",
      "fontWeight",
      "fontStyle",
      "fontVariant",
      // font
      "description",
      "aria",
      "ariaRole",
      "ariaRoleDescription"
      // aria
    ];
    function sceneToJSON(scene, indent) {
      return JSON.stringify(scene, keys$2, indent);
    }
    function sceneFromJSON(json2) {
      const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
      return initialize$1(scene);
    }
    function initialize$1(scene) {
      var type2 = scene.marktype, items = scene.items, parent, i, n;
      if (items) {
        for (i = 0, n = items.length; i < n; ++i) {
          parent = type2 ? "mark" : "group";
          items[i][parent] = scene;
          if (items[i].zindex)
            items[i][parent].zdirty = true;
          if ("group" === (type2 || parent))
            initialize$1(items[i]);
        }
      }
      if (type2)
        boundMark(scene);
      return scene;
    }
    function Scenegraph(scene) {
      if (arguments.length) {
        this.root = sceneFromJSON(scene);
      } else {
        this.root = createMark({
          marktype: "group",
          name: "root",
          role: "frame"
        });
        this.root.items = [new GroupItem(this.root)];
      }
    }
    Scenegraph.prototype = {
      toJSON(indent) {
        return sceneToJSON(this.root, indent || 0);
      },
      mark(markdef, group2, index2) {
        group2 = group2 || this.root.items[0];
        const mark = createMark(markdef, group2);
        group2.items[index2] = mark;
        if (mark.zindex)
          mark.group.zdirty = true;
        return mark;
      }
    };
    function createMark(def2, group2) {
      const mark = {
        bounds: new Bounds(),
        clip: !!def2.clip,
        group: group2,
        interactive: def2.interactive === false ? false : true,
        items: [],
        marktype: def2.marktype,
        name: def2.name || void 0,
        role: def2.role || void 0,
        zindex: def2.zindex || 0
      };
      if (def2.aria != null) {
        mark.aria = def2.aria;
      }
      if (def2.description) {
        mark.description = def2.description;
      }
      return mark;
    }
    function domCreate(doc, tag2, ns) {
      if (!doc && typeof document !== "undefined" && document.createElement) {
        doc = document;
      }
      return doc ? ns ? doc.createElementNS(ns, tag2) : doc.createElement(tag2) : null;
    }
    function domFind(el, tag2) {
      tag2 = tag2.toLowerCase();
      var nodes = el.childNodes, i = 0, n = nodes.length;
      for (; i < n; ++i)
        if (nodes[i].tagName.toLowerCase() === tag2) {
          return nodes[i];
        }
    }
    function domChild(el, index2, tag2, ns) {
      var a2 = el.childNodes[index2], b2;
      if (!a2 || a2.tagName.toLowerCase() !== tag2.toLowerCase()) {
        b2 = a2 || null;
        a2 = domCreate(el.ownerDocument, tag2, ns);
        el.insertBefore(a2, b2);
      }
      return a2;
    }
    function domClear(el, index2) {
      var nodes = el.childNodes, curr = nodes.length;
      while (curr > index2)
        el.removeChild(nodes[--curr]);
      return el;
    }
    function cssClass(mark) {
      return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
    }
    function point$2(event2, el) {
      const rect2 = el.getBoundingClientRect();
      return [event2.clientX - rect2.left - (el.clientLeft || 0), event2.clientY - rect2.top - (el.clientTop || 0)];
    }
    function resolveItem(item, event2, el, origin) {
      var mark = item && item.mark, mdef, p;
      if (mark && (mdef = Marks[mark.marktype]).tip) {
        p = point$2(event2, el);
        p[0] -= origin[0];
        p[1] -= origin[1];
        while (item = item.mark.group) {
          p[0] -= item.x || 0;
          p[1] -= item.y || 0;
        }
        item = mdef.tip(mark.items, p);
      }
      return item;
    }
    function Handler$1(customLoader, customTooltip) {
      this._active = null;
      this._handlers = {};
      this._loader = customLoader || loader();
      this._tooltip = customTooltip || defaultTooltip$1;
    }
    function defaultTooltip$1(handler, event2, item, value2) {
      handler.element().setAttribute("title", value2 || "");
    }
    Handler$1.prototype = {
      /**
       * Initialize a new Handler instance.
       * @param {DOMElement} el - The containing DOM element for the display.
       * @param {Array<number>} origin - The origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {object} [obj] - Optional context object that should serve as
       *   the "this" context for event callbacks.
       * @return {Handler} - This handler instance.
       */
      initialize(el, origin, obj) {
        this._el = el;
        this._obj = obj || null;
        return this.origin(origin);
      },
      /**
       * Returns the parent container element for a visualization.
       * @return {DOMElement} - The containing DOM element.
       */
      element() {
        return this._el;
      },
      /**
       * Returns the scene element (e.g., canvas or SVG) of the visualization
       * Subclasses must override if the first child is not the scene element.
       * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
       */
      canvas() {
        return this._el && this._el.firstChild;
      },
      /**
       * Get / set the origin coordinates of the visualization.
       */
      origin(origin) {
        if (arguments.length) {
          this._origin = origin || [0, 0];
          return this;
        } else {
          return this._origin.slice();
        }
      },
      /**
       * Get / set the scenegraph root.
       */
      scene(scene) {
        if (!arguments.length)
          return this._scene;
        this._scene = scene;
        return this;
      },
      /**
       * Add an event handler. Subclasses should override this method.
       */
      on() {
      },
      /**
       * Remove an event handler. Subclasses should override this method.
       */
      off() {
      },
      /**
       * Utility method for finding the array index of an event handler.
       * @param {Array} h - An array of registered event handlers.
       * @param {string} type - The event type.
       * @param {function} handler - The event handler instance to find.
       * @return {number} - The handler's array index or -1 if not registered.
       */
      _handlerIndex(h2, type2, handler) {
        for (let i = h2 ? h2.length : 0; --i >= 0; ) {
          if (h2[i].type === type2 && (!handler || h2[i].handler === handler)) {
            return i;
          }
        }
        return -1;
      },
      /**
       * Returns an array with registered event handlers.
       * @param {string} [type] - The event type to query. Any annotations
       *   are ignored; for example, for the argument "click.foo", ".foo" will
       *   be ignored and the method returns all "click" handlers. If type is
       *   null or unspecified, this method returns handlers for all types.
       * @return {Array} - A new array containing all registered event handlers.
       */
      handlers(type2) {
        const h2 = this._handlers, a2 = [];
        if (type2) {
          a2.push(...h2[this.eventName(type2)]);
        } else {
          for (const k in h2) {
            a2.push(...h2[k]);
          }
        }
        return a2;
      },
      /**
       * Parses an event name string to return the specific event type.
       * For example, given "click.foo" returns "click"
       * @param {string} name - The input event type string.
       * @return {string} - A string with the event type only.
       */
      eventName(name2) {
        const i = name2.indexOf(".");
        return i < 0 ? name2 : name2.slice(0, i);
      },
      /**
       * Handle hyperlink navigation in response to an item.href value.
       * @param {Event} event - The event triggering hyperlink navigation.
       * @param {Item} item - The scenegraph item.
       * @param {string} href - The URL to navigate to.
       */
      handleHref(event2, item, href2) {
        this._loader.sanitize(href2, {
          context: "href"
        }).then((opt) => {
          const e3 = new MouseEvent(event2.type, event2), a2 = domCreate(null, "a");
          for (const name2 in opt)
            a2.setAttribute(name2, opt[name2]);
          a2.dispatchEvent(e3);
        }).catch(() => {
        });
      },
      /**
       * Handle tooltip display in response to an item.tooltip value.
       * @param {Event} event - The event triggering tooltip display.
       * @param {Item} item - The scenegraph item.
       * @param {boolean} show - A boolean flag indicating whether
       *   to show or hide a tooltip for the given item.
       */
      handleTooltip(event2, item, show) {
        if (item && item.tooltip != null) {
          item = resolveItem(item, event2, this.canvas(), this._origin);
          const value2 = show && item && item.tooltip || null;
          this._tooltip.call(this._obj, this, event2, item, value2);
        }
      },
      /**
       * Returns the size of a scenegraph item and its position relative
       * to the viewport.
       * @param {Item} item - The scenegraph item.
       * @return {object} - A bounding box object (compatible with the
       *   DOMRect type) consisting of x, y, width, heigh, top, left,
       *   right, and bottom properties.
       */
      getItemBoundingClientRect(item) {
        const el = this.canvas();
        if (!el)
          return;
        const rect2 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
        let x2 = bounds2.x1 + origin[0] + rect2.left, y2 = bounds2.y1 + origin[1] + rect2.top;
        while (item.mark && (item = item.mark.group)) {
          x2 += item.x || 0;
          y2 += item.y || 0;
        }
        return {
          x: x2,
          y: y2,
          width: width2,
          height: height2,
          left: x2,
          top: y2,
          right: x2 + width2,
          bottom: y2 + height2
        };
      }
    };
    function Renderer(loader2) {
      this._el = null;
      this._bgcolor = null;
      this._loader = new ResourceLoader(loader2);
    }
    Renderer.prototype = {
      /**
       * Initialize a new Renderer instance.
       * @param {DOMElement} el - The containing DOM element for the display.
       * @param {number} width - The coordinate width of the display, in pixels.
       * @param {number} height - The coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {Renderer} - This renderer instance.
       */
      initialize(el, width2, height2, origin, scaleFactor) {
        this._el = el;
        return this.resize(width2, height2, origin, scaleFactor);
      },
      /**
       * Returns the parent container element for a visualization.
       * @return {DOMElement} - The containing DOM element.
       */
      element() {
        return this._el;
      },
      /**
       * Returns the scene element (e.g., canvas or SVG) of the visualization
       * Subclasses must override if the first child is not the scene element.
       * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
       */
      canvas() {
        return this._el && this._el.firstChild;
      },
      /**
       * Get / set the background color.
       */
      background(bgcolor) {
        if (arguments.length === 0)
          return this._bgcolor;
        this._bgcolor = bgcolor;
        return this;
      },
      /**
       * Resize the display.
       * @param {number} width - The new coordinate width of the display, in pixels.
       * @param {number} height - The new coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The new origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {Renderer} - This renderer instance;
       */
      resize(width2, height2, origin, scaleFactor) {
        this._width = width2;
        this._height = height2;
        this._origin = origin || [0, 0];
        this._scale = scaleFactor || 1;
        return this;
      },
      /**
       * Report a dirty item whose bounds should be redrawn.
       * This base class method does nothing. Subclasses that perform
       * incremental should implement this method.
       * @param {Item} item - The dirty item whose bounds should be redrawn.
       */
      dirty() {
      },
      /**
       * Render an input scenegraph, potentially with a set of dirty items.
       * This method will perform an immediate rendering with available resources.
       * The renderer may also need to perform image loading to perform a complete
       * render. This process can lead to asynchronous re-rendering of the scene
       * after this method returns. To receive notification when rendering is
       * complete, use the renderAsync method instead.
       * @param {object} scene - The root mark of a scenegraph to render.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       * @return {Renderer} - This renderer instance.
       */
      render(scene, markTypes) {
        const r = this;
        r._call = function() {
          r._render(scene, markTypes);
        };
        r._call();
        r._call = null;
        return r;
      },
      /**
       * Internal rendering method. Renderer subclasses should override this
       * method to actually perform rendering.
       * @param {object} scene - The root mark of a scenegraph to render.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       */
      _render() {
      },
      /**
       * Asynchronous rendering method. Similar to render, but returns a Promise
       * that resolves when all rendering is completed. Sometimes a renderer must
       * perform image loading to get a complete rendering. The returned
       * Promise will not resolve until this process completes.
       * @param {object} scene - The root mark of a scenegraph to render.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       * @return {Promise} - A Promise that resolves when rendering is complete.
       */
      renderAsync(scene, markTypes) {
        const r = this.render(scene, markTypes);
        return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
      },
      /**
       * Internal method for asynchronous resource loading.
       * Proxies method calls to the ImageLoader, and tracks loading
       * progress to invoke a re-render once complete.
       * @param {string} method - The method name to invoke on the ImageLoader.
       * @param {string} uri - The URI for the requested resource.
       * @return {Promise} - A Promise that resolves to the requested resource.
       */
      _load(method2, uri) {
        var r = this, p = r._loader[method2](uri);
        if (!r._ready) {
          const call2 = r._call;
          r._ready = r._loader.ready().then((redraw) => {
            if (redraw)
              call2();
            r._ready = null;
          });
        }
        return p;
      },
      /**
       * Sanitize a URL to include as a hyperlink in the rendered scene.
       * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
       * image loading progress and invokes a re-render once complete.
       * @param {string} uri - The URI string to sanitize.
       * @return {Promise} - A Promise that resolves to the sanitized URL.
       */
      sanitizeURL(uri) {
        return this._load("sanitizeURL", uri);
      },
      /**
       * Requests an image to include in the rendered scene.
       * This method proxies a call to ImageLoader.loadImage, but also tracks
       * image loading progress and invokes a re-render once complete.
       * @param {string} uri - The URI string of the image.
       * @return {Promise} - A Promise that resolves to the loaded Image.
       */
      loadImage(uri) {
        return this._load("loadImage", uri);
      }
    };
    const KeyDownEvent = "keydown";
    const KeyPressEvent = "keypress";
    const KeyUpEvent = "keyup";
    const DragEnterEvent = "dragenter";
    const DragLeaveEvent = "dragleave";
    const DragOverEvent = "dragover";
    const PointerDownEvent = "pointerdown";
    const PointerUpEvent = "pointerup";
    const PointerMoveEvent = "pointermove";
    const PointerOutEvent = "pointerout";
    const PointerOverEvent = "pointerover";
    const MouseDownEvent = "mousedown";
    const MouseUpEvent = "mouseup";
    const MouseMoveEvent = "mousemove";
    const MouseOutEvent = "mouseout";
    const MouseOverEvent = "mouseover";
    const ClickEvent = "click";
    const DoubleClickEvent = "dblclick";
    const WheelEvent = "wheel";
    const MouseWheelEvent = "mousewheel";
    const TouchStartEvent = "touchstart";
    const TouchMoveEvent = "touchmove";
    const TouchEndEvent = "touchend";
    const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
    const TooltipShowEvent = PointerMoveEvent;
    const TooltipHideEvent = PointerOutEvent;
    const HrefEvent = ClickEvent;
    function CanvasHandler(loader2, tooltip2) {
      Handler$1.call(this, loader2, tooltip2);
      this._down = null;
      this._touch = null;
      this._first = true;
      this._events = {};
    }
    const eventBundle = (type2) => type2 === TouchStartEvent || type2 === TouchMoveEvent || type2 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type2];
    function eventListenerCheck(handler, type2) {
      eventBundle(type2).forEach((_) => addEventListener(handler, _));
    }
    function addEventListener(handler, type2) {
      const canvas = handler.canvas();
      if (canvas && !handler._events[type2]) {
        handler._events[type2] = 1;
        canvas.addEventListener(type2, handler[type2] ? (evt) => handler[type2](evt) : (evt) => handler.fire(type2, evt));
      }
    }
    function fireAll(handler, types2, event2) {
      types2.forEach((type2) => handler.fire(type2, event2));
    }
    function move(moveEvents, overEvents, outEvents) {
      return function(evt) {
        const a2 = this._active, p = this.pickEvent(evt);
        if (p === a2) {
          fireAll(this, moveEvents, evt);
        } else {
          if (!a2 || !a2.exit) {
            fireAll(this, outEvents, evt);
          }
          this._active = p;
          fireAll(this, overEvents, evt);
          fireAll(this, moveEvents, evt);
        }
      };
    }
    function inactive(types2) {
      return function(evt) {
        fireAll(this, types2, evt);
        this._active = null;
      };
    }
    inherits(CanvasHandler, Handler$1, {
      initialize(el, origin, obj) {
        this._canvas = el && domFind(el, "canvas");
        [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach((type2) => eventListenerCheck(this, type2));
        return Handler$1.prototype.initialize.call(this, el, origin, obj);
      },
      // return the backing canvas instance
      canvas() {
        return this._canvas;
      },
      // retrieve the current canvas context
      context() {
        return this._canvas.getContext("2d");
      },
      // supported events
      events: Events,
      // to keep old versions of firefox happy
      DOMMouseScroll(evt) {
        this.fire(MouseWheelEvent, evt);
      },
      pointermove: move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]),
      dragover: move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]),
      pointerout: inactive([PointerOutEvent, MouseOutEvent]),
      dragleave: inactive([DragLeaveEvent]),
      pointerdown(evt) {
        this._down = this._active;
        this.fire(PointerDownEvent, evt);
      },
      mousedown(evt) {
        this._down = this._active;
        this.fire(MouseDownEvent, evt);
      },
      click(evt) {
        if (this._down === this._active) {
          this.fire(ClickEvent, evt);
          this._down = null;
        }
      },
      touchstart(evt) {
        this._touch = this.pickEvent(evt.changedTouches[0]);
        if (this._first) {
          this._active = this._touch;
          this._first = false;
        }
        this.fire(TouchStartEvent, evt, true);
      },
      touchmove(evt) {
        this.fire(TouchMoveEvent, evt, true);
      },
      touchend(evt) {
        this.fire(TouchEndEvent, evt, true);
        this._touch = null;
      },
      // fire an event
      fire(type2, evt, touch2) {
        const a2 = touch2 ? this._touch : this._active, h2 = this._handlers[type2];
        evt.vegaType = type2;
        if (type2 === HrefEvent && a2 && a2.href) {
          this.handleHref(evt, a2, a2.href);
        } else if (type2 === TooltipShowEvent || type2 === TooltipHideEvent) {
          this.handleTooltip(evt, a2, type2 !== TooltipHideEvent);
        }
        if (h2) {
          for (let i = 0, len = h2.length; i < len; ++i) {
            h2[i].handler.call(this._obj, evt, a2);
          }
        }
      },
      // add an event handler
      on(type2, handler) {
        const name2 = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name2], type2, handler);
        if (i < 0) {
          eventListenerCheck(this, type2);
          (h2[name2] || (h2[name2] = [])).push({
            type: type2,
            handler
          });
        }
        return this;
      },
      // remove an event handler
      off(type2, handler) {
        const name2 = this.eventName(type2), h2 = this._handlers[name2], i = this._handlerIndex(h2, type2, handler);
        if (i >= 0) {
          h2.splice(i, 1);
        }
        return this;
      },
      pickEvent(evt) {
        const p = point$2(evt, this._canvas), o = this._origin;
        return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
      },
      // find the scenegraph item at the current pointer position
      // x, y -- the absolute x, y pointer coordinates on the canvas element
      // gx, gy -- the relative coordinates within the current group
      pick(scene, x2, y2, gx, gy) {
        const g = this.context(), mark = Marks[scene.marktype];
        return mark.pick.call(this, g, scene, x2, y2, gx, gy);
      }
    });
    function devicePixelRatio() {
      return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
    }
    function resize(canvas, width2, height2, origin, scaleFactor, opt) {
      const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context2 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio() : scaleFactor;
      canvas.width = width2 * ratio;
      canvas.height = height2 * ratio;
      for (const key2 in opt) {
        context2[key2] = opt[key2];
      }
      if (inDOM && ratio !== 1) {
        canvas.style.width = width2 + "px";
        canvas.style.height = height2 + "px";
      }
      context2.pixelRatio = ratio;
      context2.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
      return canvas;
    }
    function CanvasRenderer(loader2) {
      Renderer.call(this, loader2);
      this._options = {};
      this._redraw = false;
      this._dirty = new Bounds();
      this._tempb = new Bounds();
    }
    const base$2 = Renderer.prototype;
    const viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
    function clipToBounds(g, b2, origin) {
      b2.expand(1).round();
      if (g.pixelRatio % 1) {
        b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
      }
      b2.translate(-(origin[0] % 1), -(origin[1] % 1));
      g.beginPath();
      g.rect(b2.x1, b2.y1, b2.width(), b2.height());
      g.clip();
      return b2;
    }
    inherits(CanvasRenderer, Renderer, {
      initialize(el, width2, height2, origin, scaleFactor, options) {
        this._options = options || {};
        this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
        if (el && this._canvas) {
          domClear(el, 0).appendChild(this._canvas);
          this._canvas.setAttribute("class", "marks");
        }
        return base$2.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      resize(width2, height2, origin, scaleFactor) {
        base$2.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._canvas) {
          resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
        } else {
          const ctx = this._options.externalContext;
          if (!ctx)
            error("CanvasRenderer is missing a valid canvas or context");
          ctx.scale(this._scale, this._scale);
          ctx.translate(this._origin[0], this._origin[1]);
        }
        this._redraw = true;
        return this;
      },
      canvas() {
        return this._canvas;
      },
      context() {
        return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
      },
      dirty(item) {
        const b2 = this._tempb.clear().union(item.bounds);
        let g = item.mark.group;
        while (g) {
          b2.translate(g.x || 0, g.y || 0);
          g = g.mark.group;
        }
        this._dirty.union(b2);
      },
      _render(scene, markTypes) {
        const g = this.context(), o = this._origin, w2 = this._width, h2 = this._height, db = this._dirty, vb = viewBounds(o, w2, h2);
        g.save();
        const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
        this.clear(-o[0], -o[1], w2, h2);
        this.draw(g, scene, b2, markTypes);
        g.restore();
        db.clear();
        return this;
      },
      draw(ctx, scene, bounds2, markTypes) {
        if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
          return;
        }
        const mark = Marks[scene.marktype];
        if (scene.clip)
          clip$2(ctx, scene);
        mark.draw.call(this, ctx, scene, bounds2, markTypes);
        if (scene.clip)
          ctx.restore();
      },
      clear(x2, y2, w2, h2) {
        const opt = this._options, g = this.context();
        if (opt.type !== "pdf" && !opt.externalContext) {
          g.clearRect(x2, y2, w2, h2);
        }
        if (this._bgcolor != null) {
          g.fillStyle = this._bgcolor;
          g.fillRect(x2, y2, w2, h2);
        }
      }
    });
    function SVGHandler(loader2, tooltip2) {
      Handler$1.call(this, loader2, tooltip2);
      const h2 = this;
      h2._hrefHandler = listener(h2, (evt, item) => {
        if (item && item.href)
          h2.handleHref(evt, item, item.href);
      });
      h2._tooltipHandler = listener(h2, (evt, item) => {
        h2.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
      });
    }
    const listener = (context2, handler) => (evt) => {
      let item = evt.target.__data__;
      item = Array.isArray(item) ? item[0] : item;
      evt.vegaType = evt.type;
      handler.call(context2._obj, evt, item);
    };
    inherits(SVGHandler, Handler$1, {
      initialize(el, origin, obj) {
        let svg = this._svg;
        if (svg) {
          svg.removeEventListener(HrefEvent, this._hrefHandler);
          svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
          svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
        }
        this._svg = svg = el && domFind(el, "svg");
        if (svg) {
          svg.addEventListener(HrefEvent, this._hrefHandler);
          svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
          svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
        }
        return Handler$1.prototype.initialize.call(this, el, origin, obj);
      },
      canvas() {
        return this._svg;
      },
      // add an event handler
      on(type2, handler) {
        const name2 = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name2], type2, handler);
        if (i < 0) {
          const x2 = {
            type: type2,
            handler,
            listener: listener(this, handler)
          };
          (h2[name2] || (h2[name2] = [])).push(x2);
          if (this._svg) {
            this._svg.addEventListener(name2, x2.listener);
          }
        }
        return this;
      },
      // remove an event handler
      off(type2, handler) {
        const name2 = this.eventName(type2), h2 = this._handlers[name2], i = this._handlerIndex(h2, type2, handler);
        if (i >= 0) {
          if (this._svg) {
            this._svg.removeEventListener(name2, h2[i].listener);
          }
          h2.splice(i, 1);
        }
        return this;
      }
    });
    const ARIA_HIDDEN = "aria-hidden";
    const ARIA_LABEL = "aria-label";
    const ARIA_ROLE = "role";
    const ARIA_ROLEDESCRIPTION = "aria-roledescription";
    const GRAPHICS_OBJECT = "graphics-object";
    const GRAPHICS_SYMBOL = "graphics-symbol";
    const bundle = (role, roledesc, label2) => ({
      [ARIA_ROLE]: role,
      [ARIA_ROLEDESCRIPTION]: roledesc,
      [ARIA_LABEL]: label2 || void 0
    });
    const AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
    const AriaGuides = {
      "axis": {
        desc: "axis",
        caption: axisCaption
      },
      "legend": {
        desc: "legend",
        caption: legendCaption
      },
      "title-text": {
        desc: "title",
        caption: (item) => `Title text '${titleCaption(item)}'`
      },
      "title-subtitle": {
        desc: "subtitle",
        caption: (item) => `Subtitle text '${titleCaption(item)}'`
      }
    };
    const AriaEncode = {
      ariaRole: ARIA_ROLE,
      ariaRoleDescription: ARIA_ROLEDESCRIPTION,
      description: ARIA_LABEL
    };
    function ariaItemAttributes(emit2, item) {
      const hide = item.aria === false;
      emit2(ARIA_HIDDEN, hide || void 0);
      if (hide || item.description == null) {
        for (const prop in AriaEncode) {
          emit2(AriaEncode[prop], void 0);
        }
      } else {
        const type2 = item.mark.marktype;
        emit2(ARIA_LABEL, item.description);
        emit2(ARIA_ROLE, item.ariaRole || (type2 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
        emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type2} mark`);
      }
    }
    function ariaMarkAttributes(mark) {
      return mark.aria === false ? {
        [ARIA_HIDDEN]: true
      } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
    }
    function ariaMark(mark) {
      const type2 = mark.marktype;
      const recurse2 = type2 === "group" || type2 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
      return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type2} mark container`, mark.description);
    }
    function ariaGuide(mark, opt) {
      try {
        const item = mark.items[0], caption = opt.caption || (() => "");
        return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
      } catch (err) {
        return null;
      }
    }
    function titleCaption(item) {
      return array$2(item.text).join(" ");
    }
    function axisCaption(item) {
      const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle(item) : null, ctx = item.context, scale2 = ctx.scales[datum2.scale].value, locale2 = ctx.dataflow.locale(), type2 = scale2.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
      return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete$2(type2) ? "discrete" : type2} scale with ${domainCaption(locale2, scale2, item)}`;
    }
    function legendCaption(item) {
      const datum2 = item.datum, title2 = datum2.title ? extractTitle(item) : null, type2 = `${datum2.type || ""} legend`.trim(), scales2 = datum2.scales, props = Object.keys(scales2), ctx = item.context, scale2 = ctx.scales[scales2[props[0]]].value, locale2 = ctx.dataflow.locale();
      return capitalize(type2) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale2, scale2, item)}`;
    }
    function extractTitle(item) {
      try {
        return array$2(peek$1(item.items).items[0].text).join(" ");
      } catch (err) {
        return null;
      }
    }
    function channelCaption(props) {
      props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
      return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek$1(props);
    }
    function capitalize(s) {
      return s.length ? s[0].toUpperCase() + s.slice(1) : s;
    }
    const innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
    function markup() {
      let buf = "", outer = "", inner = "";
      const stack2 = [], clear2 = () => outer = inner = "", push2 = (tag2) => {
        if (outer) {
          buf += `${outer}>${inner}`;
          clear2();
        }
        stack2.push(tag2);
      }, attr2 = (name2, value2) => {
        if (value2 != null)
          outer += ` ${name2}="${attrText(value2)}"`;
        return m2;
      }, m2 = {
        open(tag2) {
          push2(tag2);
          outer = "<" + tag2;
          for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            attrs[_key - 1] = arguments[_key];
          }
          for (const set2 of attrs) {
            for (const key2 in set2)
              attr2(key2, set2[key2]);
          }
          return m2;
        },
        close() {
          const tag2 = stack2.pop();
          if (outer) {
            buf += outer + (inner ? `>${inner}</${tag2}>` : "/>");
          } else {
            buf += `</${tag2}>`;
          }
          clear2();
          return m2;
        },
        attr: attr2,
        text: (t4) => (inner += innerText(t4), m2),
        toString: () => buf
      };
      return m2;
    }
    const serializeXML = (node) => _serialize(markup(), node) + "";
    function _serialize(m2, node) {
      m2.open(node.tagName);
      if (node.hasAttributes()) {
        const attrs = node.attributes, n = attrs.length;
        for (let i = 0; i < n; ++i) {
          m2.attr(attrs[i].name, attrs[i].value);
        }
      }
      if (node.hasChildNodes()) {
        const children2 = node.childNodes;
        for (const child of children2) {
          child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize(m2, child);
        }
      }
      return m2.close();
    }
    const stylesAttr = {
      fill: "fill",
      fillOpacity: "fill-opacity",
      stroke: "stroke",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      strokeCap: "stroke-linecap",
      strokeJoin: "stroke-linejoin",
      strokeDash: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeMiterLimit: "stroke-miterlimit",
      opacity: "opacity"
    };
    const stylesCss = {
      blend: "mix-blend-mode"
    };
    const rootAttributes = {
      "fill": "none",
      "stroke-miterlimit": 10
    };
    const RootIndex = 0, xmlns = "http://www.w3.org/2000/xmlns/", svgns = metadata.xmlns;
    function SVGRenderer(loader2) {
      Renderer.call(this, loader2);
      this._dirtyID = 0;
      this._dirty = [];
      this._svg = null;
      this._root = null;
      this._defs = null;
    }
    const base$1 = Renderer.prototype;
    inherits(SVGRenderer, Renderer, {
      /**
       * Initialize a new SVGRenderer instance.
       * @param {DOMElement} el - The containing DOM element for the display.
       * @param {number} width - The coordinate width of the display, in pixels.
       * @param {number} height - The coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {SVGRenderer} - This renderer instance.
       */
      initialize(el, width2, height2, origin, scaleFactor) {
        this._defs = {};
        this._clearDefs();
        if (el) {
          this._svg = domChild(el, 0, "svg", svgns);
          this._svg.setAttributeNS(xmlns, "xmlns", svgns);
          this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
          this._svg.setAttribute("version", metadata["version"]);
          this._svg.setAttribute("class", "marks");
          domClear(el, 1);
          this._root = domChild(this._svg, RootIndex, "g", svgns);
          setAttributes(this._root, rootAttributes);
          domClear(this._svg, RootIndex + 1);
        }
        this.background(this._bgcolor);
        return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      /**
       * Get / set the background color.
       */
      background(bgcolor) {
        if (arguments.length && this._svg) {
          this._svg.style.setProperty("background-color", bgcolor);
        }
        return base$1.background.apply(this, arguments);
      },
      /**
       * Resize the display.
       * @param {number} width - The new coordinate width of the display, in pixels.
       * @param {number} height - The new coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The new origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {SVGRenderer} - This renderer instance;
       */
      resize(width2, height2, origin, scaleFactor) {
        base$1.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._svg) {
          setAttributes(this._svg, {
            width: this._width * this._scale,
            height: this._height * this._scale,
            viewBox: `0 0 ${this._width} ${this._height}`
          });
          this._root.setAttribute("transform", `translate(${this._origin})`);
        }
        this._dirty = [];
        return this;
      },
      /**
       * Returns the SVG element of the visualization.
       * @return {DOMElement} - The SVG element.
       */
      canvas() {
        return this._svg;
      },
      /**
       * Returns an SVG text string for the rendered content,
       * or null if this renderer is currently headless.
       */
      svg() {
        const svg = this._svg, bg = this._bgcolor;
        if (!svg)
          return null;
        let node;
        if (bg) {
          svg.removeAttribute("style");
          node = domChild(svg, RootIndex, "rect", svgns);
          setAttributes(node, {
            width: this._width,
            height: this._height,
            fill: bg
          });
        }
        const text2 = serializeXML(svg);
        if (bg) {
          svg.removeChild(node);
          this._svg.style.setProperty("background-color", bg);
        }
        return text2;
      },
      /**
       * Internal rendering method.
       * @param {object} scene - The root mark of a scenegraph to render.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       */
      _render(scene, markTypes) {
        if (this._dirtyCheck()) {
          if (this._dirtyAll)
            this._clearDefs();
          this.mark(this._root, scene, void 0, markTypes);
          domClear(this._root, 1);
        }
        this.defs();
        this._dirty = [];
        ++this._dirtyID;
        return this;
      },
      // -- Manage rendering of items marked as dirty --
      /**
       * Flag a mark item as dirty.
       * @param {Item} item - The mark item.
       */
      dirty(item) {
        if (item.dirty !== this._dirtyID) {
          item.dirty = this._dirtyID;
          this._dirty.push(item);
        }
      },
      /**
       * Check if a mark item is considered dirty.
       * @param {Item} item - The mark item.
       */
      isDirty(item) {
        return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
      },
      /**
       * Internal method to check dirty status and, if possible,
       * make targetted updates without a full rendering pass.
       */
      _dirtyCheck() {
        this._dirtyAll = true;
        const items = this._dirty;
        if (!items.length || !this._dirtyID)
          return true;
        const id2 = ++this._dirtyID;
        let item, mark, type2, mdef, i, n, o;
        for (i = 0, n = items.length; i < n; ++i) {
          item = items[i];
          mark = item.mark;
          if (mark.marktype !== type2) {
            type2 = mark.marktype;
            mdef = Marks[type2];
          }
          if (mark.zdirty && mark.dirty !== id2) {
            this._dirtyAll = false;
            dirtyParents(item, id2);
            mark.items.forEach((i2) => {
              i2.dirty = id2;
            });
          }
          if (mark.zdirty)
            continue;
          if (item.exit) {
            if (mdef.nested && mark.items.length) {
              o = mark.items[0];
              if (o._svg)
                this._update(mdef, o._svg, o);
            } else if (item._svg) {
              o = item._svg.parentNode;
              if (o)
                o.removeChild(item._svg);
            }
            item._svg = null;
            continue;
          }
          item = mdef.nested ? mark.items[0] : item;
          if (item._update === id2)
            continue;
          if (!item._svg || !item._svg.ownerSVGElement) {
            this._dirtyAll = false;
            dirtyParents(item, id2);
          } else {
            this._update(mdef, item._svg, item);
          }
          item._update = id2;
        }
        return !this._dirtyAll;
      },
      // -- Construct & maintain scenegraph to SVG mapping ---
      /**
       * Render a set of mark items.
       * @param {SVGElement} el - The parent element in the SVG tree.
       * @param {object} scene - The mark parent to render.
       * @param {SVGElement} prev - The previous sibling in the SVG tree.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       */
      mark(el, scene, prev2, markTypes) {
        if (!this.isDirty(scene)) {
          return scene._svg;
        }
        const svg = this._svg, markType2 = scene.marktype, mdef = Marks[markType2], events2 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
        const parent = bind$1(scene, el, prev2, "g", svg);
        if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
          domClear(parent, 0);
          return scene._svg;
        }
        parent.setAttribute("class", cssClass(scene));
        const aria2 = ariaMarkAttributes(scene);
        for (const key2 in aria2)
          setAttribute(parent, key2, aria2[key2]);
        if (!isGroup) {
          setAttribute(parent, "pointer-events", events2);
        }
        setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
        let sibling = null, i = 0;
        const process2 = (item) => {
          const dirty = this.isDirty(item), node = bind$1(item, parent, sibling, mdef.tag, svg);
          if (dirty) {
            this._update(mdef, node, item);
            if (isGroup)
              recurse(this, node, item, markTypes);
          }
          sibling = node;
          ++i;
        };
        if (mdef.nested) {
          if (scene.items.length)
            process2(scene.items[0]);
        } else {
          visit(scene, process2);
        }
        domClear(parent, i);
        return parent;
      },
      /**
       * Update the attributes of an SVG element for a mark item.
       * @param {object} mdef - The mark definition object
       * @param {SVGElement} el - The SVG element.
       * @param {Item} item - The mark item.
       */
      _update(mdef, el, item) {
        element$1 = el;
        values$2 = el.__values__;
        ariaItemAttributes(emit, item);
        mdef.attr(emit, item, this);
        const extra = mark_extras[mdef.type];
        if (extra)
          extra.call(this, mdef, el, item);
        if (element$1)
          this.style(element$1, item);
      },
      /**
       * Update the presentation attributes of an SVG element for a mark item.
       * @param {SVGElement} el - The SVG element.
       * @param {Item} item - The mark item.
       */
      style(el, item) {
        if (item == null)
          return;
        for (const prop in stylesAttr) {
          let value2 = prop === "font" ? fontFamily(item) : item[prop];
          if (value2 === values$2[prop])
            continue;
          const name2 = stylesAttr[prop];
          if (value2 == null) {
            el.removeAttribute(name2);
          } else {
            if (isGradient(value2)) {
              value2 = gradientRef(value2, this._defs.gradient, href());
            }
            el.setAttribute(name2, value2 + "");
          }
          values$2[prop] = value2;
        }
        for (const prop in stylesCss) {
          setStyle(el, stylesCss[prop], item[prop]);
        }
      },
      /**
       * Render SVG defs, as needed.
       * Must be called *after* marks have been processed to ensure the
       * collected state is current and accurate.
       */
      defs() {
        const svg = this._svg, defs = this._defs;
        let el = defs.el, index2 = 0;
        for (const id2 in defs.gradient) {
          if (!el)
            defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
          index2 = updateGradient(el, defs.gradient[id2], index2);
        }
        for (const id2 in defs.clipping) {
          if (!el)
            defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
          index2 = updateClipping(el, defs.clipping[id2], index2);
        }
        if (el) {
          index2 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index2);
        }
      },
      /**
       * Clear defs caches.
       */
      _clearDefs() {
        const def2 = this._defs;
        def2.gradient = {};
        def2.clipping = {};
      }
    });
    function dirtyParents(item, id2) {
      for (; item && item.dirty !== id2; item = item.mark.group) {
        item.dirty = id2;
        if (item.mark && item.mark.dirty !== id2) {
          item.mark.dirty = id2;
        } else
          return;
      }
    }
    function updateGradient(el, grad, index2) {
      let i, n, stop2;
      if (grad.gradient === "radial") {
        let pt2 = domChild(el, index2++, "pattern", svgns);
        setAttributes(pt2, {
          id: patternPrefix + grad.id,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        pt2 = domChild(pt2, 0, "rect", svgns);
        setAttributes(pt2, {
          width: 1,
          height: 1,
          fill: `url(${href()}#${grad.id})`
        });
        el = domChild(el, index2++, "radialGradient", svgns);
        setAttributes(el, {
          id: grad.id,
          fx: grad.x1,
          fy: grad.y1,
          fr: grad.r1,
          cx: grad.x2,
          cy: grad.y2,
          r: grad.r2
        });
      } else {
        el = domChild(el, index2++, "linearGradient", svgns);
        setAttributes(el, {
          id: grad.id,
          x1: grad.x1,
          x2: grad.x2,
          y1: grad.y1,
          y2: grad.y2
        });
      }
      for (i = 0, n = grad.stops.length; i < n; ++i) {
        stop2 = domChild(el, i, "stop", svgns);
        stop2.setAttribute("offset", grad.stops[i].offset);
        stop2.setAttribute("stop-color", grad.stops[i].color);
      }
      domClear(el, i);
      return index2;
    }
    function updateClipping(el, clip2, index2) {
      let mask;
      el = domChild(el, index2, "clipPath", svgns);
      el.setAttribute("id", clip2.id);
      if (clip2.path) {
        mask = domChild(el, 0, "path", svgns);
        mask.setAttribute("d", clip2.path);
      } else {
        mask = domChild(el, 0, "rect", svgns);
        setAttributes(mask, {
          x: 0,
          y: 0,
          width: clip2.width,
          height: clip2.height
        });
      }
      domClear(el, 1);
      return index2 + 1;
    }
    function recurse(renderer, el, group2, markTypes) {
      el = el.lastChild.previousSibling;
      let prev2, idx = 0;
      visit(group2, (item) => {
        prev2 = renderer.mark(el, item, prev2, markTypes);
        ++idx;
      });
      domClear(el, 1 + idx);
    }
    function bind$1(item, el, sibling, tag2, svg) {
      let node = item._svg, doc;
      if (!node) {
        doc = el.ownerDocument;
        node = domCreate(doc, tag2, svgns);
        item._svg = node;
        if (item.mark) {
          node.__data__ = item;
          node.__values__ = {
            fill: "default"
          };
          if (tag2 === "g") {
            const bg = domCreate(doc, "path", svgns);
            node.appendChild(bg);
            bg.__data__ = item;
            const cg = domCreate(doc, "g", svgns);
            node.appendChild(cg);
            cg.__data__ = item;
            const fg = domCreate(doc, "path", svgns);
            node.appendChild(fg);
            fg.__data__ = item;
            fg.__values__ = {
              fill: "default"
            };
          }
        }
      }
      if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
        el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
      }
      return node;
    }
    function siblingCheck(node, sibling) {
      return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
    }
    let element$1 = null, values$2 = null;
    const mark_extras = {
      group(mdef, el, item) {
        const fg = element$1 = el.childNodes[2];
        values$2 = fg.__values__;
        mdef.foreground(emit, item, this);
        values$2 = el.__values__;
        element$1 = el.childNodes[1];
        mdef.content(emit, item, this);
        const bg = element$1 = el.childNodes[0];
        mdef.background(emit, item, this);
        const value2 = item.mark.interactive === false ? "none" : null;
        if (value2 !== values$2.events) {
          setAttribute(fg, "pointer-events", value2);
          setAttribute(bg, "pointer-events", value2);
          values$2.events = value2;
        }
        if (item.strokeForeground && item.stroke) {
          const fill2 = item.fill;
          setAttribute(fg, "display", null);
          this.style(bg, item);
          setAttribute(bg, "stroke", null);
          if (fill2)
            item.fill = null;
          values$2 = fg.__values__;
          this.style(fg, item);
          if (fill2)
            item.fill = fill2;
          element$1 = null;
        } else {
          setAttribute(fg, "display", "none");
        }
      },
      image(mdef, el, item) {
        if (item.smooth === false) {
          setStyle(el, "image-rendering", "optimizeSpeed");
          setStyle(el, "image-rendering", "pixelated");
        } else {
          setStyle(el, "image-rendering", null);
        }
      },
      text(mdef, el, item) {
        const tl2 = textLines(item);
        let key2, value2, doc, lh;
        if (isArray(tl2)) {
          value2 = tl2.map((_) => textValue(item, _));
          key2 = value2.join("\n");
          if (key2 !== values$2.text) {
            domClear(el, 0);
            doc = el.ownerDocument;
            lh = lineHeight(item);
            value2.forEach((t4, i) => {
              const ts2 = domCreate(doc, "tspan", svgns);
              ts2.__data__ = item;
              ts2.textContent = t4;
              if (i) {
                ts2.setAttribute("x", 0);
                ts2.setAttribute("dy", lh);
              }
              el.appendChild(ts2);
            });
            values$2.text = key2;
          }
        } else {
          value2 = textValue(item, tl2);
          if (value2 !== values$2.text) {
            el.textContent = value2;
            values$2.text = value2;
          }
        }
        setAttribute(el, "font-family", fontFamily(item));
        setAttribute(el, "font-size", fontSize(item) + "px");
        setAttribute(el, "font-style", item.fontStyle);
        setAttribute(el, "font-variant", item.fontVariant);
        setAttribute(el, "font-weight", item.fontWeight);
      }
    };
    function emit(name2, value2, ns) {
      if (value2 === values$2[name2])
        return;
      if (ns) {
        setAttributeNS(element$1, name2, value2, ns);
      } else {
        setAttribute(element$1, name2, value2);
      }
      values$2[name2] = value2;
    }
    function setStyle(el, name2, value2) {
      if (value2 !== values$2[name2]) {
        if (value2 == null) {
          el.style.removeProperty(name2);
        } else {
          el.style.setProperty(name2, value2 + "");
        }
        values$2[name2] = value2;
      }
    }
    function setAttributes(el, attrs) {
      for (const key2 in attrs) {
        setAttribute(el, key2, attrs[key2]);
      }
    }
    function setAttribute(el, name2, value2) {
      if (value2 != null) {
        el.setAttribute(name2, value2);
      } else {
        el.removeAttribute(name2);
      }
    }
    function setAttributeNS(el, name2, value2, ns) {
      if (value2 != null) {
        el.setAttributeNS(ns, name2, value2);
      } else {
        el.removeAttributeNS(ns, name2);
      }
    }
    function href() {
      let loc;
      return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
    }
    function SVGStringRenderer(loader2) {
      Renderer.call(this, loader2);
      this._text = null;
      this._defs = {
        gradient: {},
        clipping: {}
      };
    }
    inherits(SVGStringRenderer, Renderer, {
      /**
       * Returns the rendered SVG text string,
       * or null if rendering has not yet occurred.
       */
      svg() {
        return this._text;
      },
      /**
       * Internal rendering method.
       * @param {object} scene - The root mark of a scenegraph to render.
       */
      _render(scene) {
        const m2 = markup();
        m2.open("svg", extend({}, metadata, {
          class: "marks",
          width: this._width * this._scale,
          height: this._height * this._scale,
          viewBox: `0 0 ${this._width} ${this._height}`
        }));
        const bg = this._bgcolor;
        if (bg && bg !== "transparent" && bg !== "none") {
          m2.open("rect", {
            width: this._width,
            height: this._height,
            fill: bg
          }).close();
        }
        m2.open("g", rootAttributes, {
          transform: "translate(" + this._origin + ")"
        });
        this.mark(m2, scene);
        m2.close();
        this.defs(m2);
        this._text = m2.close() + "";
        return this;
      },
      /**
       * Render a set of mark items.
       * @param {object} m - The markup context.
       * @param {object} scene - The mark parent to render.
       */
      mark(m2, scene) {
        const mdef = Marks[scene.marktype], tag2 = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
        m2.open("g", {
          "class": cssClass(scene),
          "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
        }, ariaMarkAttributes(scene), {
          "pointer-events": tag2 !== "g" && scene.interactive === false ? "none" : null
        });
        const process2 = (item) => {
          const href2 = this.href(item);
          if (href2)
            m2.open("a", href2);
          m2.open(tag2, this.attr(scene, item, attrList, tag2 !== "g" ? tag2 : null));
          if (tag2 === "text") {
            const tl2 = textLines(item);
            if (isArray(tl2)) {
              const attrs = {
                x: 0,
                dy: lineHeight(item)
              };
              for (let i = 0; i < tl2.length; ++i) {
                m2.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
              }
            } else {
              m2.text(textValue(item, tl2));
            }
          } else if (tag2 === "g") {
            const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
            if (fore && stroke2) {
              item.stroke = null;
            }
            m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
            m2.open("g", this.attr(scene, item, mdef.content));
            visit(item, (scene2) => this.mark(m2, scene2));
            m2.close();
            if (fore && stroke2) {
              if (fill2)
                item.fill = null;
              item.stroke = stroke2;
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
              if (fill2)
                item.fill = fill2;
            } else {
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
            }
          }
          m2.close();
          if (href2)
            m2.close();
        };
        if (mdef.nested) {
          if (scene.items && scene.items.length)
            process2(scene.items[0]);
        } else {
          visit(scene, process2);
        }
        return m2.close();
      },
      /**
       * Get href attributes for a hyperlinked mark item.
       * @param {Item} item - The mark item.
       */
      href(item) {
        const href2 = item.href;
        let attr2;
        if (href2) {
          if (attr2 = this._hrefs && this._hrefs[href2]) {
            return attr2;
          } else {
            this.sanitizeURL(href2).then((attr3) => {
              attr3["xlink:href"] = attr3.href;
              attr3.href = null;
              (this._hrefs || (this._hrefs = {}))[href2] = attr3;
            });
          }
        }
        return null;
      },
      /**
       * Get an object of SVG attributes for a mark item.
       * @param {object} scene - The mark parent.
       * @param {Item} item - The mark item.
       * @param {array|function} attrs - One or more attribute emitters.
       * @param {string} tag - The tag being rendered.
       */
      attr(scene, item, attrs, tag2) {
        const object2 = {}, emit2 = (name2, value2, ns, prefixed) => {
          object2[prefixed || name2] = value2;
        };
        if (Array.isArray(attrs)) {
          attrs.forEach((fn) => fn(emit2, item, this));
        } else {
          attrs(emit2, item, this);
        }
        if (tag2) {
          style(object2, item, scene, tag2, this._defs);
        }
        return object2;
      },
      /**
       * Render SVG defs, as needed.
       * Must be called *after* marks have been processed to ensure the
       * collected state is current and accurate.
       * @param {object} m - The markup context.
       */
      defs(m2) {
        const gradient2 = this._defs.gradient, clipping = this._defs.clipping, count2 = Object.keys(gradient2).length + Object.keys(clipping).length;
        if (count2 === 0)
          return;
        m2.open("defs");
        for (const id2 in gradient2) {
          const def2 = gradient2[id2], stops = def2.stops;
          if (def2.gradient === "radial") {
            m2.open("pattern", {
              id: patternPrefix + id2,
              viewBox: "0,0,1,1",
              width: "100%",
              height: "100%",
              preserveAspectRatio: "xMidYMid slice"
            });
            m2.open("rect", {
              width: "1",
              height: "1",
              fill: "url(#" + id2 + ")"
            }).close();
            m2.close();
            m2.open("radialGradient", {
              id: id2,
              fx: def2.x1,
              fy: def2.y1,
              fr: def2.r1,
              cx: def2.x2,
              cy: def2.y2,
              r: def2.r2
            });
          } else {
            m2.open("linearGradient", {
              id: id2,
              x1: def2.x1,
              x2: def2.x2,
              y1: def2.y1,
              y2: def2.y2
            });
          }
          for (let i = 0; i < stops.length; ++i) {
            m2.open("stop", {
              offset: stops[i].offset,
              "stop-color": stops[i].color
            }).close();
          }
          m2.close();
        }
        for (const id2 in clipping) {
          const def2 = clipping[id2];
          m2.open("clipPath", {
            id: id2
          });
          if (def2.path) {
            m2.open("path", {
              d: def2.path
            }).close();
          } else {
            m2.open("rect", {
              x: 0,
              y: 0,
              width: def2.width,
              height: def2.height
            }).close();
          }
          m2.close();
        }
        m2.close();
      }
    });
    function style(s, item, scene, tag2, defs) {
      let styleList;
      if (item == null)
        return s;
      if (tag2 === "bgrect" && scene.interactive === false) {
        s["pointer-events"] = "none";
      }
      if (tag2 === "bgfore") {
        if (scene.interactive === false) {
          s["pointer-events"] = "none";
        }
        s.display = "none";
        if (item.fill !== null)
          return s;
      }
      if (tag2 === "image" && item.smooth === false) {
        styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
      }
      if (tag2 === "text") {
        s["font-family"] = fontFamily(item);
        s["font-size"] = fontSize(item) + "px";
        s["font-style"] = item.fontStyle;
        s["font-variant"] = item.fontVariant;
        s["font-weight"] = item.fontWeight;
      }
      for (const prop in stylesAttr) {
        let value2 = item[prop];
        const name2 = stylesAttr[prop];
        if (value2 === "transparent" && (name2 === "fill" || name2 === "stroke"))
          ;
        else if (value2 != null) {
          if (isGradient(value2)) {
            value2 = gradientRef(value2, defs.gradient, "");
          }
          s[name2] = value2;
        }
      }
      for (const prop in stylesCss) {
        const value2 = item[prop];
        if (value2 != null) {
          styleList = styleList || [];
          styleList.push(`${stylesCss[prop]}: ${value2};`);
        }
      }
      if (styleList) {
        s.style = styleList.join(" ");
      }
      return s;
    }
    const OPTS = {
      svgMarkTypes: ["text"],
      svgOnTop: true,
      debug: false
    };
    function setHybridRendererOptions(options) {
      OPTS["svgMarkTypes"] = options.svgMarkTypes ?? ["text"];
      OPTS["svgOnTop"] = options.svgOnTop ?? true;
      OPTS["debug"] = options.debug ?? false;
    }
    function HybridRenderer(loader2) {
      Renderer.call(this, loader2);
      this._svgRenderer = new SVGRenderer(loader2);
      this._canvasRenderer = new CanvasRenderer(loader2);
    }
    const base = Renderer.prototype;
    inherits(HybridRenderer, Renderer, {
      /**
       * Initialize a new HybridRenderer instance.
       * @param {DOMElement} el - The containing DOM element for the display.
       * @param {number} width - The coordinate width of the display, in pixels.
       * @param {number} height - The coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {HybridRenderer} - This renderer instance.
       */
      initialize(el, width2, height2, origin, scaleFactor) {
        this._root_el = domChild(el, 0, "div");
        const bottomEl = domChild(this._root_el, 0, "div");
        const topEl = domChild(this._root_el, 1, "div");
        this._root_el.style.position = "relative";
        if (!OPTS.debug) {
          bottomEl.style.height = "100%";
          topEl.style.position = "absolute";
          topEl.style.top = "0";
          topEl.style.left = "0";
          topEl.style.height = "100%";
          topEl.style.width = "100%";
        }
        this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;
        this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;
        this._svgEl.style.pointerEvents = "none";
        this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
        this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
        return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      /**
       * Flag a mark item as dirty.
       * @param {Item} item - The mark item.
       */
      dirty(item) {
        if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {
          this._svgRenderer.dirty(item);
        } else {
          this._canvasRenderer.dirty(item);
        }
        return this;
      },
      /**
       * Internal rendering method.
       * @param {object} scene - The root mark of a scenegraph to render.
       * @param {Array} markTypes - Array of the mark types to render.
       *                            If undefined, render all mark types
       */
      _render(scene, markTypes) {
        const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
        const canvasMarkTypes = allMarkTypes.filter((m2) => !OPTS.svgMarkTypes.includes(m2));
        this._svgRenderer.render(scene, OPTS.svgMarkTypes);
        this._canvasRenderer.render(scene, canvasMarkTypes);
      },
      /**
       * Resize the display.
       * @param {number} width - The new coordinate width of the display, in pixels.
       * @param {number} height - The new coordinate height of the display, in pixels.
       * @param {Array<number>} origin - The new origin of the display, in pixels.
       *   The coordinate system will be translated to this point.
       * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
       *   the width and height to determine the final pixel size.
       * @return {SVGRenderer} - This renderer instance;
       */
      resize(width2, height2, origin, scaleFactor) {
        base.resize.call(this, width2, height2, origin, scaleFactor);
        this._svgRenderer.resize(width2, height2, origin, scaleFactor);
        this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
        return this;
      },
      background(bgcolor) {
        if (OPTS.svgOnTop) {
          this._canvasRenderer.background(bgcolor);
        } else {
          this._svgRenderer.background(bgcolor);
        }
        return this;
      }
    });
    function HybridHandler(loader2, tooltip2) {
      CanvasHandler.call(this, loader2, tooltip2);
    }
    inherits(HybridHandler, CanvasHandler, {
      initialize(el, origin, obj) {
        const canvas = domChild(domChild(el, 0, "div"), OPTS.svgOnTop ? 0 : 1, "div");
        return CanvasHandler.prototype.initialize.call(this, canvas, origin, obj);
      }
    });
    const Canvas = "canvas";
    const Hybrid = "hybrid";
    const PNG = "png";
    const SVG = "svg";
    const None$1 = "none";
    const RenderType = {
      Canvas,
      PNG,
      SVG,
      Hybrid,
      None: None$1
    };
    const modules = {};
    modules[Canvas] = modules[PNG] = {
      renderer: CanvasRenderer,
      headless: CanvasRenderer,
      handler: CanvasHandler
    };
    modules[SVG] = {
      renderer: SVGRenderer,
      headless: SVGStringRenderer,
      handler: SVGHandler
    };
    modules[Hybrid] = {
      renderer: HybridRenderer,
      headless: HybridRenderer,
      handler: HybridHandler
    };
    modules[None$1] = {};
    function renderModule(name2, _) {
      name2 = String(name2 || "").toLowerCase();
      if (arguments.length > 1) {
        modules[name2] = _;
        return this;
      } else {
        return modules[name2];
      }
    }
    function intersect$2(scene, bounds2, filter2) {
      const hits = [], box = new Bounds().union(bounds2), type2 = scene.marktype;
      return type2 ? intersectMark(scene, box, filter2, hits) : type2 === "group" ? intersectGroup(scene, box, filter2, hits) : error("Intersect scene must be mark node or group item.");
    }
    function intersectMark(mark, box, filter2, hits) {
      if (visitMark(mark, box, filter2)) {
        const items = mark.items, type2 = mark.marktype, n = items.length;
        let i = 0;
        if (type2 === "group") {
          for (; i < n; ++i) {
            intersectGroup(items[i], box, filter2, hits);
          }
        } else {
          for (const test2 = Marks[type2].isect; i < n; ++i) {
            const item = items[i];
            if (intersectItem(item, box, test2))
              hits.push(item);
          }
        }
      }
      return hits;
    }
    function visitMark(mark, box, filter2) {
      return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter2 || filter2(mark)));
    }
    function intersectGroup(group2, box, filter2, hits) {
      if (filter2 && filter2(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
        hits.push(group2);
      }
      const marks = group2.items, n = marks && marks.length;
      if (n) {
        const x2 = group2.x || 0, y2 = group2.y || 0;
        box.translate(-x2, -y2);
        for (let i = 0; i < n; ++i) {
          intersectMark(marks[i], box, filter2, hits);
        }
        box.translate(x2, y2);
      }
      return hits;
    }
    function intersectItem(item, box, test2) {
      const bounds2 = item.bounds;
      return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
    }
    const clipBounds = new Bounds();
    function boundClip(mark) {
      const clip2 = mark.clip;
      if (isFunction(clip2)) {
        clip2(boundContext(clipBounds.clear()));
      } else if (clip2) {
        clipBounds.set(0, 0, mark.group.width, mark.group.height);
      } else
        return;
      mark.bounds.intersect(clipBounds);
    }
    const TOLERANCE = 1e-9;
    function sceneEqual(a2, b2, key2) {
      return a2 === b2 ? true : key2 === "path" ? pathEqual(a2, b2) : a2 instanceof Date && b2 instanceof Date ? +a2 === +b2 : isNumber$1(a2) && isNumber$1(b2) ? Math.abs(a2 - b2) <= TOLERANCE : !a2 || !b2 || !isObject(a2) && !isObject(b2) ? a2 == b2 : objectEqual(a2, b2);
    }
    function pathEqual(a2, b2) {
      return sceneEqual(parse$3(a2), parse$3(b2));
    }
    function objectEqual(a2, b2) {
      var ka = Object.keys(a2), kb = Object.keys(b2), key2, i;
      if (ka.length !== kb.length)
        return false;
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key2 = ka[i];
        if (!sceneEqual(a2[key2], b2[key2], key2))
          return false;
      }
      return typeof a2 === typeof b2;
    }
    function resetSVGDefIds() {
      resetSVGClipId();
      resetSVGGradientId();
    }
    const Top$1 = "top";
    const Left$1 = "left";
    const Right$1 = "right";
    const Bottom$1 = "bottom";
    const TopLeft = "top-left";
    const TopRight = "top-right";
    const BottomLeft = "bottom-left";
    const BottomRight = "bottom-right";
    const Start$1 = "start";
    const Middle$1 = "middle";
    const End$1 = "end";
    const X$1 = "x";
    const Y$1 = "y";
    const Group = "group";
    const AxisRole$1 = "axis";
    const TitleRole$1 = "title";
    const FrameRole$1 = "frame";
    const ScopeRole$1 = "scope";
    const LegendRole$1 = "legend";
    const RowHeader = "row-header";
    const RowFooter = "row-footer";
    const RowTitle = "row-title";
    const ColHeader = "column-header";
    const ColFooter = "column-footer";
    const ColTitle = "column-title";
    const Padding$1 = "padding";
    const Symbols$1 = "symbol";
    const Fit = "fit";
    const FitX = "fit-x";
    const FitY = "fit-y";
    const Pad = "pad";
    const None = "none";
    const All = "all";
    const Each = "each";
    const Flush = "flush";
    const Column = "column";
    const Row = "row";
    function Bound$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Bound$1, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow, mark = _.mark, type2 = mark.marktype, entry2 = Marks[type2], bound2 = entry2.bound;
        let markBounds = mark.bounds, rebound;
        if (entry2.nested) {
          if (mark.items.length)
            view.dirty(mark.items[0]);
          markBounds = boundItem(mark, bound2);
          mark.items.forEach((item) => {
            item.bounds.clear().union(markBounds);
          });
        } else if (type2 === Group || _.modified()) {
          pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
          markBounds.clear();
          mark.items.forEach((item) => markBounds.union(boundItem(item, bound2)));
          switch (mark.role) {
            case AxisRole$1:
            case LegendRole$1:
            case TitleRole$1:
              pulse2.reflow();
          }
        } else {
          rebound = pulse2.changed(pulse2.REM);
          pulse2.visit(pulse2.ADD, (item) => {
            markBounds.union(boundItem(item, bound2));
          });
          pulse2.visit(pulse2.MOD, (item) => {
            rebound = rebound || markBounds.alignsWith(item.bounds);
            view.dirty(item);
            markBounds.union(boundItem(item, bound2));
          });
          if (rebound) {
            markBounds.clear();
            mark.items.forEach((item) => markBounds.union(item.bounds));
          }
        }
        boundClip(mark);
        return pulse2.modifies("bounds");
      }
    });
    function boundItem(item, bound2, opt) {
      return bound2(item.bounds.clear(), item, opt);
    }
    const COUNTER_NAME = ":vega_identifier:";
    function Identifier$1(params2) {
      Transform.call(this, 0, params2);
    }
    Identifier$1.Definition = {
      "type": "Identifier",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "as",
        "type": "string",
        "required": true
      }]
    };
    inherits(Identifier$1, Transform, {
      transform(_, pulse2) {
        const counter = getCounter(pulse2.dataflow), as = _.as;
        let id2 = counter.value;
        pulse2.visit(pulse2.ADD, (t4) => t4[as] = t4[as] || ++id2);
        counter.set(this.value = id2);
        return pulse2;
      }
    });
    function getCounter(view) {
      return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
    }
    function Mark$2(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Mark$2, Transform, {
      transform(_, pulse2) {
        let mark = this.value;
        if (!mark) {
          mark = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$1$1(_), _.index);
          mark.group.context = _.context;
          if (!_.context.group)
            _.context.group = mark.group;
          mark.source = this.source;
          mark.clip = _.clip;
          mark.interactive = _.interactive;
          this.value = mark;
        }
        const Init = mark.marktype === Group ? GroupItem : Item;
        pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark));
        if (_.modified("clip") || _.modified("interactive")) {
          mark.clip = _.clip;
          mark.interactive = !!_.interactive;
          mark.zdirty = true;
          pulse2.reflow();
        }
        mark.items = pulse2.source;
        return pulse2;
      }
    });
    function lookup$1$1(_) {
      const g = _.groups, p = _.parent;
      return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
    }
    function Overlap$1(params2) {
      Transform.call(this, null, params2);
    }
    const methods = {
      parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
      greedy: (items, sep) => {
        let a2;
        return items.filter((b2, i) => !i || !intersect$1(a2.bounds, b2.bounds, sep) ? (a2 = b2, 1) : b2.opacity = 0);
      }
    };
    const intersect$1 = (a2, b2, sep) => sep > Math.max(b2.x1 - a2.x2, a2.x1 - b2.x2, b2.y1 - a2.y2, a2.y1 - b2.y2);
    const hasOverlap = (items, pad2) => {
      for (var i = 1, n = items.length, a2 = items[0].bounds, b2; i < n; a2 = b2, ++i) {
        if (intersect$1(a2, b2 = items[i].bounds, pad2))
          return true;
      }
    };
    const hasBounds = (item) => {
      const b2 = item.bounds;
      return b2.width() > 1 && b2.height() > 1;
    };
    const boundTest = (scale2, orient2, tolerance) => {
      var range2 = scale2.range(), b2 = new Bounds();
      if (orient2 === Top$1 || orient2 === Bottom$1) {
        b2.set(range2[0], -Infinity, range2[1], Infinity);
      } else {
        b2.set(-Infinity, range2[0], Infinity, range2[1]);
      }
      b2.expand(tolerance || 1);
      return (item) => b2.encloses(item.bounds);
    };
    const reset$1 = (source2) => {
      source2.forEach((item) => item.opacity = 1);
      return source2;
    };
    const reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
    inherits(Overlap$1, Transform, {
      transform(_, pulse2) {
        const reduce2 = methods[_.method] || methods.parity, sep = _.separation || 0;
        let source2 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
        if (!source2 || !source2.length)
          return;
        if (!_.method) {
          if (_.modified("method")) {
            reset$1(source2);
            pulse2 = reflow(pulse2, _);
          }
          return pulse2;
        }
        source2 = source2.filter(hasBounds);
        if (!source2.length)
          return;
        if (_.sort) {
          source2 = source2.slice().sort(_.sort);
        }
        items = reset$1(source2);
        pulse2 = reflow(pulse2, _);
        if (items.length >= 3 && hasOverlap(items, sep)) {
          do {
            items = reduce2(items, sep);
          } while (items.length >= 3 && hasOverlap(items, sep));
          if (items.length < 3 && !peek$1(source2).opacity) {
            if (items.length > 1)
              peek$1(items).opacity = 0;
            peek$1(source2).opacity = 1;
          }
        }
        if (_.boundScale && _.boundTolerance >= 0) {
          test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
          source2.forEach((item) => {
            if (!test2(item))
              item.opacity = 0;
          });
        }
        const bounds2 = items[0].mark.bounds.clear();
        source2.forEach((item) => {
          if (item.opacity)
            bounds2.union(item.bounds);
        });
        return pulse2;
      }
    });
    function Render$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Render$1, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow;
        pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
        if (pulse2.fields && pulse2.fields["zindex"]) {
          const item = pulse2.source && pulse2.source[0];
          if (item)
            item.mark.zdirty = true;
        }
      }
    });
    const tempBounds = new Bounds();
    function set$2(item, property2, value2) {
      return item[property2] === value2 ? 0 : (item[property2] = value2, 1);
    }
    function isYAxis(mark) {
      var orient2 = mark.items[0].orient;
      return orient2 === Left$1 || orient2 === Right$1;
    }
    function axisIndices(datum2) {
      let index2 = +datum2.grid;
      return [
        datum2.ticks ? index2++ : -1,
        // ticks index
        datum2.labels ? index2++ : -1,
        // labels index
        index2 + +datum2.domain
        // title index
      ];
    }
    function axisLayout(view, axis2, width2, height2) {
      var item = axis2.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient2 = item.orient, indices = axisIndices(datum2), range2 = item.range, offset2 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title2 && multiLineOffset(title2), x2 = 0, y2 = 0, i, s;
      tempBounds.clear().union(bounds2);
      bounds2.clear();
      if ((i = indices[0]) > -1)
        bounds2.union(item.items[i].bounds);
      if ((i = indices[1]) > -1)
        bounds2.union(item.items[i].bounds);
      switch (orient2) {
        case Top$1:
          x2 = position2 || 0;
          y2 = -offset2;
          s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
          bounds2.add(0, -s).add(range2, 0);
          if (title2)
            axisTitleLayout(view, title2, s, titlePadding, dl, 0, -1, bounds2);
          break;
        case Left$1:
          x2 = -offset2;
          y2 = position2 || 0;
          s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
          bounds2.add(-s, 0).add(0, range2);
          if (title2)
            axisTitleLayout(view, title2, s, titlePadding, dl, 1, -1, bounds2);
          break;
        case Right$1:
          x2 = width2 + offset2;
          y2 = position2 || 0;
          s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
          bounds2.add(0, 0).add(s, range2);
          if (title2)
            axisTitleLayout(view, title2, s, titlePadding, dl, 1, 1, bounds2);
          break;
        case Bottom$1:
          x2 = position2 || 0;
          y2 = height2 + offset2;
          s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
          bounds2.add(0, 0).add(range2, s);
          if (title2)
            axisTitleLayout(view, title2, s, titlePadding, 0, 0, 1, bounds2);
          break;
        default:
          x2 = item.x;
          y2 = item.y;
      }
      boundStroke(bounds2.translate(x2, y2), item);
      if (set$2(item, "x", x2 + delta) | set$2(item, "y", y2 + delta)) {
        item.bounds = tempBounds;
        view.dirty(item);
        item.bounds = bounds2;
        view.dirty(item);
      }
      return item.mark.bounds.clear().union(bounds2);
    }
    function axisTitleLayout(view, title2, offset2, pad2, dl, isYAxis2, sign2, bounds2) {
      const b2 = title2.bounds;
      if (title2.auto) {
        const v = sign2 * (offset2 + dl + pad2);
        let dx = 0, dy = 0;
        view.dirty(title2);
        isYAxis2 ? dx = (title2.x || 0) - (title2.x = v) : dy = (title2.y || 0) - (title2.y = v);
        title2.mark.bounds.clear().union(b2.translate(-dx, -dy));
        view.dirty(title2);
      }
      bounds2.union(b2);
    }
    const min = (a2, b2) => Math.floor(Math.min(a2, b2));
    const max = (a2, b2) => Math.ceil(Math.max(a2, b2));
    function gridLayoutGroups(group2) {
      var groups = group2.items, n = groups.length, i = 0, mark, items;
      const views = {
        marks: [],
        rowheaders: [],
        rowfooters: [],
        colheaders: [],
        colfooters: [],
        rowtitle: null,
        coltitle: null
      };
      for (; i < n; ++i) {
        mark = groups[i];
        items = mark.items;
        if (mark.marktype === Group) {
          switch (mark.role) {
            case AxisRole$1:
            case LegendRole$1:
            case TitleRole$1:
              break;
            case RowHeader:
              views.rowheaders.push(...items);
              break;
            case RowFooter:
              views.rowfooters.push(...items);
              break;
            case ColHeader:
              views.colheaders.push(...items);
              break;
            case ColFooter:
              views.colfooters.push(...items);
              break;
            case RowTitle:
              views.rowtitle = items[0];
              break;
            case ColTitle:
              views.coltitle = items[0];
              break;
            default:
              views.marks.push(...items);
          }
        }
      }
      return views;
    }
    function bboxFlush(item) {
      return new Bounds().set(0, 0, item.width || 0, item.height || 0);
    }
    function bboxFull(item) {
      const b2 = item.bounds.clone();
      return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
    }
    function get$1(opt, key2, d) {
      const v = isObject(opt) ? opt[key2] : opt;
      return v != null ? v : d !== void 0 ? d : 0;
    }
    function offsetValue$1(v) {
      return v < 0 ? Math.ceil(-v) : 0;
    }
    function gridLayout(view, groups, opt) {
      var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds.set(0, 0, 0, 0), alignCol = get$1(opt.align, Column), alignRow = get$1(opt.align, Row), padCol = get$1(opt.padding, Column), padRow = get$1(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m2, i, c2, r, b2, g, px2, py2, x2, y2, offset2;
      for (i = 0; i < ncols; ++i)
        xExtent[i] = 0;
      for (i = 0; i < nrows; ++i)
        yExtent[i] = 0;
      for (i = 0; i < n; ++i) {
        g = groups[i];
        b2 = boxes[i] = bbox(g);
        g.x = g.x || 0;
        dx[i] = 0;
        g.y = g.y || 0;
        dy[i] = 0;
        c2 = i % ncols;
        r = ~~(i / ncols);
        xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
        yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
        xExtent[c2] = Math.max(xExtent[c2], px2);
        yExtent[r] = Math.max(yExtent[r], py2);
        xOffset[i] = padCol + offsetValue$1(b2.x1);
        yOffset[i] = padRow + offsetValue$1(b2.y1);
        if (dirty)
          view.dirty(groups[i]);
      }
      for (i = 0; i < n; ++i) {
        if (i % ncols === 0)
          xOffset[i] = 0;
        if (i < ncols)
          yOffset[i] = 0;
      }
      if (alignCol === Each) {
        for (c2 = 1; c2 < ncols; ++c2) {
          for (offset2 = 0, i = c2; i < n; i += ncols) {
            if (offset2 < xOffset[i])
              offset2 = xOffset[i];
          }
          for (i = c2; i < n; i += ncols) {
            xOffset[i] = offset2 + xExtent[c2 - 1];
          }
        }
      } else if (alignCol === All) {
        for (offset2 = 0, i = 0; i < n; ++i) {
          if (i % ncols && offset2 < xOffset[i])
            offset2 = xOffset[i];
        }
        for (i = 0; i < n; ++i) {
          if (i % ncols)
            xOffset[i] = offset2 + xMax;
        }
      } else {
        for (alignCol = false, c2 = 1; c2 < ncols; ++c2) {
          for (i = c2; i < n; i += ncols) {
            xOffset[i] += xExtent[c2 - 1];
          }
        }
      }
      if (alignRow === Each) {
        for (r = 1; r < nrows; ++r) {
          for (offset2 = 0, i = r * ncols, m2 = i + ncols; i < m2; ++i) {
            if (offset2 < yOffset[i])
              offset2 = yOffset[i];
          }
          for (i = r * ncols; i < m2; ++i) {
            yOffset[i] = offset2 + yExtent[r - 1];
          }
        }
      } else if (alignRow === All) {
        for (offset2 = 0, i = ncols; i < n; ++i) {
          if (offset2 < yOffset[i])
            offset2 = yOffset[i];
        }
        for (i = ncols; i < n; ++i) {
          yOffset[i] = offset2 + yMax;
        }
      } else {
        for (alignRow = false, r = 1; r < nrows; ++r) {
          for (i = r * ncols, m2 = i + ncols; i < m2; ++i) {
            yOffset[i] += yExtent[r - 1];
          }
        }
      }
      for (x2 = 0, i = 0; i < n; ++i) {
        x2 = xOffset[i] + (i % ncols ? x2 : 0);
        dx[i] += x2 - groups[i].x;
      }
      for (c2 = 0; c2 < ncols; ++c2) {
        for (y2 = 0, i = c2; i < n; i += ncols) {
          y2 += yOffset[i];
          dy[i] += y2 - groups[i].y;
        }
      }
      if (alignCol && get$1(opt.center, Column) && nrows > 1) {
        for (i = 0; i < n; ++i) {
          b2 = alignCol === All ? xMax : xExtent[i % ncols];
          x2 = b2 - boxes[i].x2 - groups[i].x - dx[i];
          if (x2 > 0)
            dx[i] += x2 / 2;
        }
      }
      if (alignRow && get$1(opt.center, Row) && ncols !== 1) {
        for (i = 0; i < n; ++i) {
          b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
          y2 = b2 - boxes[i].y2 - groups[i].y - dy[i];
          if (y2 > 0)
            dy[i] += y2 / 2;
        }
      }
      for (i = 0; i < n; ++i) {
        bounds2.union(boxes[i].translate(dx[i], dy[i]));
      }
      x2 = get$1(opt.anchor, X$1);
      y2 = get$1(opt.anchor, Y$1);
      switch (get$1(opt.anchor, Column)) {
        case End$1:
          x2 -= bounds2.width();
          break;
        case Middle$1:
          x2 -= bounds2.width() / 2;
      }
      switch (get$1(opt.anchor, Row)) {
        case End$1:
          y2 -= bounds2.height();
          break;
        case Middle$1:
          y2 -= bounds2.height() / 2;
      }
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      bounds2.clear();
      for (i = 0; i < n; ++i) {
        groups[i].mark.bounds.clear();
      }
      for (i = 0; i < n; ++i) {
        g = groups[i];
        g.x += dx[i] += x2;
        g.y += dy[i] += y2;
        bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
        if (dirty)
          view.dirty(g);
      }
      return bounds2;
    }
    function trellisLayout(view, group2, opt) {
      var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x2, y2, x22, y22, anchor2, band2, offset2;
      const bounds2 = gridLayout(view, groups, opt);
      if (bounds2.empty())
        bounds2.set(0, 0, 0, 0);
      if (views.rowheaders) {
        band2 = get$1(opt.headerBand, Row, null);
        x2 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get$1(off, "rowHeader"), min, 0, bbox, "x1", 0, ncols, 1, band2);
      }
      if (views.colheaders) {
        band2 = get$1(opt.headerBand, Column, null);
        y2 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get$1(off, "columnHeader"), min, 1, bbox, "y1", 0, 1, ncols, band2);
      }
      if (views.rowfooters) {
        band2 = get$1(opt.footerBand, Row, null);
        x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get$1(off, "rowFooter"), max, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
      }
      if (views.colfooters) {
        band2 = get$1(opt.footerBand, Column, null);
        y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get$1(off, "columnFooter"), max, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
      }
      if (views.rowtitle) {
        anchor2 = get$1(opt.titleAnchor, Row);
        offset2 = get$1(off, "rowTitle");
        offset2 = anchor2 === End$1 ? x22 + offset2 : x2 - offset2;
        band2 = get$1(opt.titleBand, Row, 0.5);
        layoutTitle(view, views.rowtitle, offset2, 0, bounds2, band2);
      }
      if (views.coltitle) {
        anchor2 = get$1(opt.titleAnchor, Column);
        offset2 = get$1(off, "columnTitle");
        offset2 = anchor2 === End$1 ? y22 + offset2 : y2 - offset2;
        band2 = get$1(opt.titleBand, Column, 0.5);
        layoutTitle(view, views.coltitle, offset2, 1, bounds2, band2);
      }
    }
    function boundFlush(item, field2) {
      return field2 === "x1" ? item.x || 0 : field2 === "y1" ? item.y || 0 : field2 === "x2" ? (item.x || 0) + (item.width || 0) : field2 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
    }
    function boundFull(item, field2) {
      return item.bounds[field2];
    }
    function layoutHeaders(view, headers, groups, ncols, limit, offset2, agg, isX2, bound2, bf, start2, stride, back2, band2) {
      var n = groups.length, init2 = 0, edge = 0, i, j, k, m2, b2, h2, g, x2, y2;
      if (!n)
        return init2;
      for (i = start2; i < n; i += stride) {
        if (groups[i])
          init2 = agg(init2, bound2(groups[i], bf));
      }
      if (!headers.length)
        return init2;
      if (headers.length > limit) {
        view.warn("Grid headers exceed limit: " + limit);
        headers = headers.slice(0, limit);
      }
      init2 += offset2;
      for (j = 0, m2 = headers.length; j < m2; ++j) {
        view.dirty(headers[j]);
        headers[j].mark.bounds.clear();
      }
      for (i = start2, j = 0, m2 = headers.length; j < m2; ++j, i += stride) {
        h2 = headers[j];
        b2 = h2.mark.bounds;
        for (k = i; k >= 0 && (g = groups[k]) == null; k -= back2)
          ;
        if (isX2) {
          x2 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
          y2 = init2;
        } else {
          x2 = init2;
          y2 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
        }
        b2.union(h2.bounds.translate(x2 - (h2.x || 0), y2 - (h2.y || 0)));
        h2.x = x2;
        h2.y = y2;
        view.dirty(h2);
        edge = agg(edge, b2[bf]);
      }
      return edge;
    }
    function layoutTitle(view, g, offset2, isX2, bounds2, band2) {
      if (!g)
        return;
      view.dirty(g);
      var x2 = offset2, y2 = offset2;
      isX2 ? x2 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y2 = Math.round(bounds2.y1 + band2 * bounds2.height());
      g.bounds.translate(x2 - (g.x || 0), y2 - (g.y || 0));
      g.mark.bounds.clear().union(g.bounds);
      g.x = x2;
      g.y = y2;
      view.dirty(g);
    }
    function lookup$3(config, orient2) {
      const opt = config[orient2] || {};
      return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
    }
    function offsets(legends, value2) {
      let max2 = -Infinity;
      legends.forEach((item) => {
        if (item.offset != null)
          max2 = Math.max(max2, item.offset);
      });
      return max2 > -Infinity ? max2 : value2;
    }
    function legendParams(g, orient2, config, xb, yb, w2, h2) {
      const _ = lookup$3(config, orient2), offset2 = offsets(g, _("offset", 0)), anchor2 = _("anchor", Start$1), mult2 = anchor2 === End$1 ? 1 : anchor2 === Middle$1 ? 0.5 : 0;
      const p = {
        align: Each,
        bounds: _("bounds", Flush),
        columns: _("direction") === "vertical" ? 1 : g.length,
        padding: _("margin", 8),
        center: _("center"),
        nodirty: true
      };
      switch (orient2) {
        case Left$1:
          p.anchor = {
            x: Math.floor(xb.x1) - offset2,
            column: End$1,
            y: mult2 * (h2 || xb.height() + 2 * xb.y1),
            row: anchor2
          };
          break;
        case Right$1:
          p.anchor = {
            x: Math.ceil(xb.x2) + offset2,
            y: mult2 * (h2 || xb.height() + 2 * xb.y1),
            row: anchor2
          };
          break;
        case Top$1:
          p.anchor = {
            y: Math.floor(yb.y1) - offset2,
            row: End$1,
            x: mult2 * (w2 || yb.width() + 2 * yb.x1),
            column: anchor2
          };
          break;
        case Bottom$1:
          p.anchor = {
            y: Math.ceil(yb.y2) + offset2,
            x: mult2 * (w2 || yb.width() + 2 * yb.x1),
            column: anchor2
          };
          break;
        case TopLeft:
          p.anchor = {
            x: offset2,
            y: offset2
          };
          break;
        case TopRight:
          p.anchor = {
            x: w2 - offset2,
            y: offset2,
            column: End$1
          };
          break;
        case BottomLeft:
          p.anchor = {
            x: offset2,
            y: h2 - offset2,
            row: End$1
          };
          break;
        case BottomRight:
          p.anchor = {
            x: w2 - offset2,
            y: h2 - offset2,
            column: End$1,
            row: End$1
          };
          break;
      }
      return p;
    }
    function legendLayout(view, legend) {
      var item = legend.items[0], datum2 = item.datum, orient2 = item.orient, bounds2 = item.bounds, x2 = item.x, y2 = item.y, w2, h2;
      item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
      bounds2.clear();
      legendGroupLayout(view, item, item.items[0].items[0]);
      bounds2 = legendBounds(item, bounds2);
      w2 = 2 * item.padding;
      h2 = 2 * item.padding;
      if (!bounds2.empty()) {
        w2 = Math.ceil(bounds2.width() + w2);
        h2 = Math.ceil(bounds2.height() + h2);
      }
      if (datum2.type === Symbols$1) {
        legendEntryLayout(item.items[0].items[0].items[0].items);
      }
      if (orient2 !== None) {
        item.x = x2 = 0;
        item.y = y2 = 0;
      }
      item.width = w2;
      item.height = h2;
      boundStroke(bounds2.set(x2, y2, x2 + w2, y2 + h2), item);
      item.mark.bounds.clear().union(bounds2);
      return item;
    }
    function legendBounds(item, b2) {
      item.items.forEach((_) => b2.union(_.bounds));
      b2.x1 = item.padding;
      b2.y1 = item.padding;
      return b2;
    }
    function legendGroupLayout(view, item, entry2) {
      var pad2 = item.padding, ex = pad2 - entry2.x, ey = pad2 - entry2.y;
      if (!item.datum.title) {
        if (ex || ey)
          translate$1(view, entry2, ex, ey);
      } else {
        var title2 = item.items[1].items[0], anchor2 = title2.anchor, tpad = item.titlePadding || 0, tx2 = pad2 - title2.x, ty = pad2 - title2.y;
        switch (title2.orient) {
          case Left$1:
            ex += Math.ceil(title2.bounds.width()) + tpad;
            break;
          case Right$1:
          case Bottom$1:
            break;
          default:
            ey += title2.bounds.height() + tpad;
        }
        if (ex || ey)
          translate$1(view, entry2, ex, ey);
        switch (title2.orient) {
          case Left$1:
            ty += legendTitleOffset(item, entry2, title2, anchor2, 1, 1);
            break;
          case Right$1:
            tx2 += legendTitleOffset(item, entry2, title2, End$1, 0, 0) + tpad;
            ty += legendTitleOffset(item, entry2, title2, anchor2, 1, 1);
            break;
          case Bottom$1:
            tx2 += legendTitleOffset(item, entry2, title2, anchor2, 0, 0);
            ty += legendTitleOffset(item, entry2, title2, End$1, -1, 0, 1) + tpad;
            break;
          default:
            tx2 += legendTitleOffset(item, entry2, title2, anchor2, 0, 0);
        }
        if (tx2 || ty)
          translate$1(view, title2, tx2, ty);
        if ((tx2 = Math.round(title2.bounds.x1 - pad2)) < 0) {
          translate$1(view, entry2, -tx2, 0);
          translate$1(view, title2, -tx2, 0);
        }
      }
    }
    function legendTitleOffset(item, entry2, title2, anchor2, y2, lr, noBar) {
      const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e3 = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e3.bounds[y2 ? "y2" : "x2"] - item.padding, u2 = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y2 <= 0 ? 0 : multiLineOffset(title2);
      return Math.round(anchor2 === Start$1 ? u2 : anchor2 === End$1 ? v - o : 0.5 * (s - o));
    }
    function translate$1(view, item, dx, dy) {
      item.x += dx;
      item.y += dy;
      item.bounds.translate(dx, dy);
      item.mark.bounds.translate(dx, dy);
      view.dirty(item);
    }
    function legendEntryLayout(entries2) {
      const widths = entries2.reduce((w2, g) => {
        w2[g.column] = Math.max(g.bounds.x2 - g.x, w2[g.column] || 0);
        return w2;
      }, {});
      entries2.forEach((g) => {
        g.width = widths[g.column];
        g.height = g.bounds.y2 - g.y;
      });
    }
    function titleLayout(view, mark, width2, height2, viewBounds2) {
      var group2 = mark.items[0], frame2 = group2.frame, orient2 = group2.orient, anchor2 = group2.anchor, offset2 = group2.offset, padding2 = group2.padding, title2 = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient2 === Left$1 || orient2 === Right$1 ? height2 : width2, start2 = 0, x2 = 0, y2 = 0, sx = 0, sy = 0, pos;
      if (frame2 !== Group) {
        orient2 === Left$1 ? (start2 = viewBounds2.y2, end = viewBounds2.y1) : orient2 === Right$1 ? (start2 = viewBounds2.y1, end = viewBounds2.y2) : (start2 = viewBounds2.x1, end = viewBounds2.x2);
      } else if (orient2 === Left$1) {
        start2 = height2, end = 0;
      }
      pos = anchor2 === Start$1 ? start2 : anchor2 === End$1 ? end : (start2 + end) / 2;
      if (subtitle && subtitle.text) {
        switch (orient2) {
          case Top$1:
          case Bottom$1:
            sy = title2.bounds.height() + padding2;
            break;
          case Left$1:
            sx = title2.bounds.width() + padding2;
            break;
          case Right$1:
            sx = -title2.bounds.width() - padding2;
            break;
        }
        tempBounds.clear().union(subtitle.bounds);
        tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
        if (set$2(subtitle, "x", sx) | set$2(subtitle, "y", sy)) {
          view.dirty(subtitle);
          subtitle.bounds.clear().union(tempBounds);
          subtitle.mark.bounds.clear().union(tempBounds);
          view.dirty(subtitle);
        }
        tempBounds.clear().union(subtitle.bounds);
      } else {
        tempBounds.clear();
      }
      tempBounds.union(title2.bounds);
      switch (orient2) {
        case Top$1:
          x2 = pos;
          y2 = viewBounds2.y1 - tempBounds.height() - offset2;
          break;
        case Left$1:
          x2 = viewBounds2.x1 - tempBounds.width() - offset2;
          y2 = pos;
          break;
        case Right$1:
          x2 = viewBounds2.x2 + tempBounds.width() + offset2;
          y2 = pos;
          break;
        case Bottom$1:
          x2 = pos;
          y2 = viewBounds2.y2 + offset2;
          break;
        default:
          x2 = group2.x;
          y2 = group2.y;
      }
      if (set$2(group2, "x", x2) | set$2(group2, "y", y2)) {
        tempBounds.translate(x2, y2);
        view.dirty(group2);
        group2.bounds.clear().union(tempBounds);
        mark.bounds.clear().union(tempBounds);
        view.dirty(group2);
      }
      return group2.bounds;
    }
    function ViewLayout$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(ViewLayout$1, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow;
        _.mark.items.forEach((group2) => {
          if (_.layout)
            trellisLayout(view, group2, _.layout);
          layoutGroup(view, group2, _);
        });
        return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
      }
    });
    function shouldReflow(group2) {
      return group2 && group2.mark.role !== "legend-entry";
    }
    function layoutGroup(view, group2, _) {
      var items = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title2, mark, orient2, b2, i, n;
      for (i = 0, n = items.length; i < n; ++i) {
        mark = items[i];
        switch (mark.role) {
          case AxisRole$1:
            b2 = isYAxis(mark) ? xBounds : yBounds;
            b2.union(axisLayout(view, mark, width2, height2));
            break;
          case TitleRole$1:
            title2 = mark;
            break;
          case LegendRole$1:
            legends.push(legendLayout(view, mark));
            break;
          case FrameRole$1:
          case ScopeRole$1:
          case RowHeader:
          case RowFooter:
          case RowTitle:
          case ColHeader:
          case ColFooter:
          case ColTitle:
            xBounds.union(mark.bounds);
            yBounds.union(mark.bounds);
            break;
          default:
            viewBounds2.union(mark.bounds);
        }
      }
      if (legends.length) {
        const l = {};
        legends.forEach((item) => {
          orient2 = item.orient || Right$1;
          if (orient2 !== None)
            (l[orient2] || (l[orient2] = [])).push(item);
        });
        for (const orient3 in l) {
          const g = l[orient3];
          gridLayout(view, g, legendParams(g, orient3, _.legends, xBounds, yBounds, width2, height2));
        }
        legends.forEach((item) => {
          const b3 = item.bounds;
          if (!b3.equals(item._bounds)) {
            item.bounds = item._bounds;
            view.dirty(item);
            item.bounds = b3;
            view.dirty(item);
          }
          if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
            switch (item.orient) {
              case Left$1:
              case Right$1:
                viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
                break;
              case Top$1:
              case Bottom$1:
                viewBounds2.add(0, b3.y1).add(0, b3.y2);
            }
          } else {
            viewBounds2.union(b3);
          }
        });
      }
      viewBounds2.union(xBounds).union(yBounds);
      if (title2) {
        viewBounds2.union(titleLayout(view, title2, width2, height2, viewBounds2));
      }
      if (group2.clip) {
        viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
      }
      viewSizeLayout(view, group2, viewBounds2, _);
    }
    function viewSizeLayout(view, group2, viewBounds2, _) {
      const auto = _.autosize || {}, type2 = auto.type;
      if (view._autosize < 1 || !type2)
        return;
      let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left2 = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top2 = Math.max(0, Math.ceil(-viewBounds2.y1));
      const right2 = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom2 = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
      if (auto.contains === Padding$1) {
        const padding2 = view.padding();
        viewWidth2 -= padding2.left + padding2.right;
        viewHeight2 -= padding2.top + padding2.bottom;
      }
      if (type2 === None) {
        left2 = 0;
        top2 = 0;
        width2 = viewWidth2;
        height2 = viewHeight2;
      } else if (type2 === Fit) {
        width2 = Math.max(0, viewWidth2 - left2 - right2);
        height2 = Math.max(0, viewHeight2 - top2 - bottom2);
      } else if (type2 === FitX) {
        width2 = Math.max(0, viewWidth2 - left2 - right2);
        viewHeight2 = height2 + top2 + bottom2;
      } else if (type2 === FitY) {
        viewWidth2 = width2 + left2 + right2;
        height2 = Math.max(0, viewHeight2 - top2 - bottom2);
      } else if (type2 === Pad) {
        viewWidth2 = width2 + left2 + right2;
        viewHeight2 = height2 + top2 + bottom2;
      }
      view._resizeView(viewWidth2, viewHeight2, width2, height2, [left2, top2], auto.resize);
    }
    const vtx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      bound: Bound$1,
      identifier: Identifier$1,
      mark: Mark$2,
      overlap: Overlap$1,
      render: Render$1,
      viewlayout: ViewLayout$1
    }, Symbol.toStringTag, { value: "Module" }));
    function AxisTicks$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(AxisTicks$1, Transform, {
      transform(_, pulse2) {
        if (this.value && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks2 = this.value, scale2 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count2 = tickCount(scale2, tally, _.minstep), format2 = _.format || tickFormat(locale2, scale2, count2, _.formatSpecifier, _.formatType, !!_.values), values2 = _.values ? validTicks(scale2, _.values, count2) : tickValues(scale2, count2);
        if (ticks2)
          out.rem = ticks2;
        ticks2 = values2.map((value2, i) => ingest$1({
          index: i / (values2.length - 1 || 1),
          value: value2,
          label: format2(value2)
        }));
        if (_.extra && ticks2.length) {
          ticks2.push(ingest$1({
            index: -1,
            extra: {
              value: ticks2[0].value
            },
            label: ""
          }));
        }
        out.source = ticks2;
        out.add = ticks2;
        this.value = ticks2;
        return out;
      }
    });
    function DataJoin$1(params2) {
      Transform.call(this, null, params2);
    }
    function defaultItemCreate() {
      return ingest$1({});
    }
    function newMap(key2) {
      const map2 = fastmap().test((t4) => t4.exit);
      map2.lookup = (t4) => map2.get(key2(t4));
      return map2;
    }
    inherits(DataJoin$1, Transform, {
      transform(_, pulse2) {
        var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map2 = this.value;
        if (isArray(out.encode)) {
          out.encode = null;
        }
        if (map2 && (_.modified("key") || pulse2.modified(key2))) {
          error("DataJoin does not support modified key function or fields.");
        }
        if (!map2) {
          pulse2 = pulse2.addAll();
          this.value = map2 = newMap(key2);
        }
        pulse2.visit(pulse2.ADD, (t4) => {
          const k = key2(t4);
          let x2 = map2.get(k);
          if (x2) {
            if (x2.exit) {
              map2.empty--;
              out.add.push(x2);
            } else {
              out.mod.push(x2);
            }
          } else {
            x2 = item(t4);
            map2.set(k, x2);
            out.add.push(x2);
          }
          x2.datum = t4;
          x2.exit = false;
        });
        pulse2.visit(pulse2.MOD, (t4) => {
          const k = key2(t4), x2 = map2.get(k);
          if (x2) {
            x2.datum = t4;
            out.mod.push(x2);
          }
        });
        pulse2.visit(pulse2.REM, (t4) => {
          const k = key2(t4), x2 = map2.get(k);
          if (t4 === x2.datum && !x2.exit) {
            out.rem.push(x2);
            x2.exit = true;
            ++map2.empty;
          }
        });
        if (pulse2.changed(pulse2.ADD_MOD))
          out.modifies("datum");
        if (pulse2.clean() || _.clean && map2.empty > df.cleanThreshold) {
          df.runAfter(map2.clean);
        }
        return out;
      }
    });
    function Encode$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(Encode$1, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
        if (isArray(encode2)) {
          if (out.changed() || encode2.every((e3) => encoders[e3])) {
            encode2 = encode2[0];
            out.encode = null;
          } else {
            return pulse2.StopPropagation;
          }
        }
        var reenter = encode2 === "enter", update2 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set2 = (encode2 && !reenter ? encoders[encode2] : update2) || falsy;
        if (pulse2.changed(pulse2.ADD)) {
          pulse2.visit(pulse2.ADD, (t4) => {
            enter(t4, _);
            update2(t4, _);
          });
          out.modifies(enter.output);
          out.modifies(update2.output);
          if (set2 !== falsy && set2 !== update2) {
            pulse2.visit(pulse2.ADD, (t4) => {
              set2(t4, _);
            });
            out.modifies(set2.output);
          }
        }
        if (pulse2.changed(pulse2.REM) && exit !== falsy) {
          pulse2.visit(pulse2.REM, (t4) => {
            exit(t4, _);
          });
          out.modifies(exit.output);
        }
        if (reenter || set2 !== falsy) {
          const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
          if (reenter) {
            pulse2.visit(flag2, (t4) => {
              const mod = enter(t4, _) || fmod;
              if (set2(t4, _) || mod)
                out.mod.push(t4);
            });
            if (out.mod.length)
              out.modifies(enter.output);
          } else {
            pulse2.visit(flag2, (t4) => {
              if (set2(t4, _) || fmod)
                out.mod.push(t4);
            });
          }
          if (out.mod.length)
            out.modifies(set2.output);
        }
        return out.changed() ? out : pulse2.StopPropagation;
      }
    });
    function LegendEntries$1(params2) {
      Transform.call(this, [], params2);
    }
    inherits(LegendEntries$1, Transform, {
      transform(_, pulse2) {
        if (this.value != null && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type2 = _.type || SymbolLegend, scale2 = _.scale, limit = +_.limit, count2 = tickCount(scale2, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type2 === SymbolLegend, format2 = _.format || labelFormat(locale2, scale2, count2, type2, _.formatSpecifier, _.formatType, lskip), values2 = _.values || labelValues(scale2, count2), domain2, fraction, size2, offset2, ellipsis;
        if (items)
          out.rem = items;
        if (type2 === SymbolLegend) {
          if (limit && values2.length > limit) {
            pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
            items = values2.slice(0, limit - 1);
            ellipsis = true;
          } else {
            items = values2;
          }
          if (isFunction(size2 = _.size)) {
            if (!_.values && scale2(items[0]) === 0) {
              items = items.slice(1);
            }
            offset2 = items.reduce((max2, value2) => Math.max(max2, size2(value2, _)), 0);
          } else {
            size2 = constant$1(offset2 = size2 || 8);
          }
          items = items.map((value2, index2) => ingest$1({
            index: index2,
            label: format2(value2, index2, items),
            value: value2,
            offset: offset2,
            size: size2(value2, _)
          }));
          if (ellipsis) {
            ellipsis = values2[items.length];
            items.push(ingest$1({
              index: items.length,
              label: `${values2.length - items.length} entries`,
              value: ellipsis,
              offset: offset2,
              size: size2(ellipsis, _)
            }));
          }
        } else if (type2 === GradientLegend) {
          domain2 = scale2.domain(), fraction = scaleFraction(scale2, domain2[0], peek$1(domain2));
          if (values2.length < 3 && !_.values && domain2[0] !== peek$1(domain2)) {
            values2 = [domain2[0], peek$1(domain2)];
          }
          items = values2.map((value2, index2) => ingest$1({
            index: index2,
            label: format2(value2, index2, values2),
            value: value2,
            perc: fraction(value2)
          }));
        } else {
          size2 = values2.length - 1;
          fraction = labelFraction(scale2);
          items = values2.map((value2, index2) => ingest$1({
            index: index2,
            label: format2(value2, index2, values2),
            value: value2,
            perc: index2 ? fraction(value2) : 0,
            perc2: index2 === size2 ? 1 : fraction(values2[index2 + 1])
          }));
        }
        out.source = items;
        out.add = items;
        this.value = items;
        return out;
      }
    });
    const sourceX = (t4) => t4.source.x;
    const sourceY = (t4) => t4.source.y;
    const targetX = (t4) => t4.target.x;
    const targetY = (t4) => t4.target.y;
    function LinkPath(params2) {
      Transform.call(this, {}, params2);
    }
    LinkPath.Definition = {
      "type": "LinkPath",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "sourceX",
        "type": "field",
        "default": "source.x"
      }, {
        "name": "sourceY",
        "type": "field",
        "default": "source.y"
      }, {
        "name": "targetX",
        "type": "field",
        "default": "target.x"
      }, {
        "name": "targetY",
        "type": "field",
        "default": "target.y"
      }, {
        "name": "orient",
        "type": "enum",
        "default": "vertical",
        "values": ["horizontal", "vertical", "radial"]
      }, {
        "name": "shape",
        "type": "enum",
        "default": "line",
        "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
      }, {
        "name": "require",
        "type": "signal"
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    inherits(LinkPath, Transform, {
      transform(_, pulse2) {
        var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx2 = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient2 = _.orient || "vertical", shape2 = _.shape || "line", path2 = Paths.get(shape2 + "-" + orient2) || Paths.get(shape2);
        if (!path2) {
          error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
        }
        pulse2.visit(pulse2.SOURCE, (t4) => {
          t4[as] = path2(sx(t4), sy(t4), tx2(t4), ty(t4));
        });
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    const line$1 = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "L" + tx2 + "," + ty;
    const lineR = (sa2, sr, ta, tr2) => line$1(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
    const arc$1 = (sx, sy, tx2, ty) => {
      var dx = tx2 - sx, dy = ty - sy, rr = Math.hypot(dx, dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
      return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx2 + "," + ty;
    };
    const arcR = (sa2, sr, ta, tr2) => arc$1(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
    const curve = (sx, sy, tx2, ty) => {
      const dx = tx2 - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
      return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx2 + iy) + "," + (ty - ix) + " " + tx2 + "," + ty;
    };
    const curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
    const orthoX = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx2;
    const orthoY = (sx, sy, tx2, ty) => "M" + sx + "," + sy + "H" + tx2 + "V" + ty;
    const orthoR = (sa2, sr, ta, tr2) => {
      const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
      return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
    };
    const diagonalX = (sx, sy, tx2, ty) => {
      const m2 = (sx + tx2) / 2;
      return "M" + sx + "," + sy + "C" + m2 + "," + sy + " " + m2 + "," + ty + " " + tx2 + "," + ty;
    };
    const diagonalY = (sx, sy, tx2, ty) => {
      const m2 = (sy + ty) / 2;
      return "M" + sx + "," + sy + "C" + sx + "," + m2 + " " + tx2 + "," + m2 + " " + tx2 + "," + ty;
    };
    const diagonalR = (sa2, sr, ta, tr2) => {
      const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
      return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
    };
    const Paths = fastmap({
      "line": line$1,
      "line-radial": lineR,
      "arc": arc$1,
      "arc-radial": arcR,
      "curve": curve,
      "curve-radial": curveR,
      "orthogonal-horizontal": orthoX,
      "orthogonal-vertical": orthoY,
      "orthogonal-radial": orthoR,
      "diagonal-horizontal": diagonalX,
      "diagonal-vertical": diagonalY,
      "diagonal-radial": diagonalR
    });
    function Pie(params2) {
      Transform.call(this, null, params2);
    }
    Pie.Definition = {
      "type": "Pie",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "startAngle",
        "type": "number",
        "default": 0
      }, {
        "name": "endAngle",
        "type": "number",
        "default": 6.283185307179586
      }, {
        "name": "sort",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["startAngle", "endAngle"]
      }]
    };
    inherits(Pie, Transform, {
      transform(_, pulse2) {
        var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field2 = _.field || one$1, start2 = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data2 = pulse2.source, values2 = data2.map(field2), n = values2.length, a2 = start2, k = (stop2 - start2) / sum$1(values2), index2 = range$5(n), i, t4, v;
        if (_.sort) {
          index2.sort((a3, b2) => values2[a3] - values2[b2]);
        }
        for (i = 0; i < n; ++i) {
          v = values2[index2[i]];
          t4 = data2[index2[i]];
          t4[startAngle] = a2;
          t4[endAngle] = a2 += v * k;
        }
        this.value = values2;
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    const DEFAULT_COUNT = 5;
    function includeZero(scale2) {
      const type2 = scale2.type;
      return !scale2.bins && (type2 === Linear || type2 === Pow || type2 === Sqrt);
    }
    function includePad(type2) {
      return isContinuous$1(type2) && type2 !== Sequential;
    }
    const SKIP$1 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
    function Scale$1(params2) {
      Transform.call(this, null, params2);
      this.modified(true);
    }
    inherits(Scale$1, Transform, {
      transform(_, pulse2) {
        var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
        if (!scale$12 || key2 !== scale$12.type) {
          this.value = scale$12 = scale$4(key2)();
        }
        for (key2 in _)
          if (!SKIP$1[key2]) {
            if (key2 === "padding" && includePad(scale$12.type))
              continue;
            isFunction(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
          }
        configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
    function scaleKey(_) {
      var t4 = _.type, d = "", n;
      if (t4 === Sequential)
        return Sequential + "-" + Linear;
      if (isContinuousColor(_)) {
        n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
        d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
      }
      return (d + t4 || Linear).toLowerCase();
    }
    function isContinuousColor(_) {
      const t4 = _.type;
      return isContinuous$1(t4) && t4 !== Time && t4 !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
    }
    function configureDomain(scale2, _, df) {
      const raw = rawDomain(scale2, _.domainRaw, df);
      if (raw > -1)
        return raw;
      var domain2 = _.domain, type2 = scale2.type, zero2 = _.zero || _.zero === void 0 && includeZero(scale2), n, mid;
      if (!domain2)
        return 0;
      if (includePad(type2) && _.padding && domain2[0] !== peek$1(domain2)) {
        domain2 = padDomain(type2, domain2, _.range, _.padding, _.exponent, _.constant);
      }
      if (zero2 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
        n = (domain2 = domain2.slice()).length - 1 || 1;
        if (zero2) {
          if (domain2[0] > 0)
            domain2[0] = 0;
          if (domain2[n] < 0)
            domain2[n] = 0;
        }
        if (_.domainMin != null)
          domain2[0] = _.domainMin;
        if (_.domainMax != null)
          domain2[n] = _.domainMax;
        if (_.domainMid != null) {
          mid = _.domainMid;
          const i = mid > domain2[n] ? n + 1 : mid < domain2[0] ? 0 : n;
          if (i !== n)
            df.warn("Scale domainMid exceeds domain min or max.", mid);
          domain2.splice(i, 0, mid);
        }
      }
      scale2.domain(domainCheck(type2, domain2, df));
      if (type2 === Ordinal) {
        scale2.unknown(_.domainImplicit ? implicit : void 0);
      }
      if (_.nice && scale2.nice) {
        scale2.nice(_.nice !== true && tickCount(scale2, _.nice) || null);
      }
      return domain2.length;
    }
    function rawDomain(scale2, raw, df) {
      if (raw) {
        scale2.domain(domainCheck(scale2.type, raw, df));
        return raw.length;
      } else {
        return -1;
      }
    }
    function padDomain(type2, domain2, range2, pad2, exponent2, constant2) {
      var span2 = Math.abs(peek$1(range2) - range2[0]), frac = span2 / (span2 - 2 * pad2), d = type2 === Log ? zoomLog(domain2, null, frac) : type2 === Sqrt ? zoomPow(domain2, null, frac, 0.5) : type2 === Pow ? zoomPow(domain2, null, frac, exponent2 || 1) : type2 === Symlog ? zoomSymlog(domain2, null, frac, constant2 || 1) : zoomLinear(domain2, null, frac);
      domain2 = domain2.slice();
      domain2[0] = d[0];
      domain2[domain2.length - 1] = d[1];
      return domain2;
    }
    function domainCheck(type2, domain2, df) {
      if (isLogarithmic(type2)) {
        var s = Math.abs(domain2.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
        if (s !== domain2.length) {
          df.warn("Log scale domain includes zero: " + $(domain2));
        }
      }
      return domain2;
    }
    function configureBins(scale2, _, count2) {
      let bins2 = _.bins;
      if (bins2 && !isArray(bins2)) {
        const domain2 = scale2.domain(), lo = domain2[0], hi = peek$1(domain2), step = bins2.step;
        let start2 = bins2.start == null ? lo : bins2.start, stop2 = bins2.stop == null ? hi : bins2.stop;
        if (!step)
          error("Scale bins parameter missing step property.");
        if (start2 < lo)
          start2 = step * Math.ceil(lo / step);
        if (stop2 > hi)
          stop2 = step * Math.floor(hi / step);
        bins2 = range$5(start2, stop2 + step / 2, step);
      }
      if (bins2) {
        scale2.bins = bins2;
      } else if (scale2.bins) {
        delete scale2.bins;
      }
      if (scale2.type === BinOrdinal) {
        if (!bins2) {
          scale2.bins = scale2.domain();
        } else if (!_.domain && !_.domainRaw) {
          scale2.domain(bins2);
          count2 = bins2.length;
        }
      }
      return count2;
    }
    function configureRange(scale2, _, count2) {
      var type2 = scale2.type, round2 = _.round || false, range2 = _.range;
      if (_.rangeStep != null) {
        range2 = configureRangeStep(type2, _, count2);
      } else if (_.scheme) {
        range2 = configureScheme(type2, _, count2);
        if (isFunction(range2)) {
          if (scale2.interpolator) {
            return scale2.interpolator(range2);
          } else {
            error(`Scale type ${type2} does not support interpolating color schemes.`);
          }
        }
      }
      if (range2 && isInterpolating(type2)) {
        return scale2.interpolator(interpolateColors(flip(range2, _.reverse), _.interpolate, _.interpolateGamma));
      }
      if (range2 && _.interpolate && scale2.interpolate) {
        scale2.interpolate(interpolate$1(_.interpolate, _.interpolateGamma));
      } else if (isFunction(scale2.round)) {
        scale2.round(round2);
      } else if (isFunction(scale2.rangeRound)) {
        scale2.interpolate(round2 ? interpolateRound : interpolate$1$1);
      }
      if (range2)
        scale2.range(flip(range2, _.reverse));
    }
    function configureRangeStep(type2, _, count2) {
      if (type2 !== Band && type2 !== Point) {
        error("Only band and point scales support rangeStep.");
      }
      var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type2 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
      return [0, _.rangeStep * bandSpace(count2, inner, outer)];
    }
    function configureScheme(type2, _, count2) {
      var extent2 = _.schemeExtent, name2, scheme$1$1;
      if (isArray(_.scheme)) {
        scheme$1$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
      } else {
        name2 = _.scheme.toLowerCase();
        scheme$1$1 = scheme$1(name2);
        if (!scheme$1$1)
          error(`Unrecognized scheme name: ${_.scheme}`);
      }
      count2 = type2 === Threshold ? count2 + 1 : type2 === BinOrdinal ? count2 - 1 : type2 === Quantile || type2 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count2;
      return isInterpolating(type2) ? adjustScheme(scheme$1$1, extent2, _.reverse) : isFunction(scheme$1$1) ? quantizeInterpolator(adjustScheme(scheme$1$1, extent2), count2) : type2 === Ordinal ? scheme$1$1 : scheme$1$1.slice(0, count2);
    }
    function adjustScheme(scheme2, extent2, reverse2) {
      return isFunction(scheme2) && (extent2 || reverse2) ? interpolateRange$1(scheme2, flip(extent2 || [0, 1], reverse2)) : scheme2;
    }
    function flip(array2, reverse2) {
      return reverse2 ? array2.slice().reverse() : array2;
    }
    function SortItems$1(params2) {
      Transform.call(this, null, params2);
    }
    inherits(SortItems$1, Transform, {
      transform(_, pulse2) {
        const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
        if (mod)
          pulse2.source.sort(stableCompare(_.sort));
        this.modified(mod);
        return pulse2;
      }
    });
    const Zero = "zero", Center$1 = "center", Normalize = "normalize", DefOutput = ["y0", "y1"];
    function Stack(params2) {
      Transform.call(this, null, params2);
    }
    Stack.Definition = {
      "type": "Stack",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "offset",
        "type": "enum",
        "default": Zero,
        "values": [Zero, Center$1, Normalize]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": DefOutput
      }]
    };
    inherits(Stack, Transform, {
      transform(_, pulse2) {
        var as = _.as || DefOutput, y02 = as[0], y12 = as[1], sort2 = stableCompare(_.sort), field2 = _.field || one$1, stack2 = _.offset === Center$1 ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max2;
        groups = partition$2(pulse2.source, _.groupby, sort2, field2);
        for (i = 0, n = groups.length, max2 = groups.max; i < n; ++i) {
          stack2(groups[i], max2, field2, y02, y12);
        }
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    function stackCenter(group2, max2, field2, y02, y12) {
      var last2 = (max2 - group2.sum) / 2, m2 = group2.length, j = 0, t4;
      for (; j < m2; ++j) {
        t4 = group2[j];
        t4[y02] = last2;
        t4[y12] = last2 += Math.abs(field2(t4));
      }
    }
    function stackNormalize(group2, max2, field2, y02, y12) {
      var scale2 = 1 / group2.sum, last2 = 0, m2 = group2.length, j = 0, v = 0, t4;
      for (; j < m2; ++j) {
        t4 = group2[j];
        t4[y02] = last2;
        t4[y12] = last2 = scale2 * (v += Math.abs(field2(t4)));
      }
    }
    function stackZero(group2, max2, field2, y02, y12) {
      var lastPos = 0, lastNeg = 0, m2 = group2.length, j = 0, v, t4;
      for (; j < m2; ++j) {
        t4 = group2[j];
        v = +field2(t4);
        if (v < 0) {
          t4[y02] = lastNeg;
          t4[y12] = lastNeg += v;
        } else {
          t4[y02] = lastPos;
          t4[y12] = lastPos += v;
        }
      }
    }
    function partition$2(data2, groupby, sort2, field2) {
      var groups = [], get2 = (f) => f(t4), map2, i, n, m2, t4, k, g, s, max2;
      if (groupby == null) {
        groups.push(data2.slice());
      } else {
        for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
          t4 = data2[i];
          k = groupby.map(get2);
          g = map2[k];
          if (!g) {
            map2[k] = g = [];
            groups.push(g);
          }
          g.push(t4);
        }
      }
      for (k = 0, max2 = 0, m2 = groups.length; k < m2; ++k) {
        g = groups[k];
        for (i = 0, s = 0, n = g.length; i < n; ++i) {
          s += Math.abs(field2(g[i]));
        }
        g.sum = s;
        if (s > max2)
          max2 = s;
        if (sort2)
          g.sort(sort2);
      }
      groups.max = max2;
      return groups;
    }
    const encode$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      axisticks: AxisTicks$1,
      datajoin: DataJoin$1,
      encode: Encode$1,
      legendentries: LegendEntries$1,
      linkpath: LinkPath,
      pie: Pie,
      scale: Scale$1,
      sortitems: SortItems$1,
      stack: Stack
    }, Symbol.toStringTag, { value: "Module" }));
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var epsilon = 1e-6;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var sqrt2 = sqrt(2);
    function asin(x2) {
      return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
    }
    function sqrt(x2) {
      return x2 > 0 ? Math.sqrt(x2) : 0;
    }
    function mollweideBromleyTheta(cp, phi2) {
      var cpsinPhi = cp * sin(phi2), i = 30, delta;
      do
        phi2 -= delta = (phi2 + sin(phi2) - cpsinPhi) / (1 + cos(phi2));
      while (abs(delta) > epsilon && --i > 0);
      return phi2 / 2;
    }
    function mollweideBromleyRaw(cx, cy, cp) {
      function forward2(lambda, phi2) {
        return [cx * lambda * cos(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin(phi2)];
      }
      forward2.invert = function(x2, y2) {
        return y2 = asin(y2 / cy), [x2 / (cx * cos(y2)), asin((2 * y2 + sin(2 * y2)) / cp)];
      };
      return forward2;
    }
    var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
    function geoMollweide() {
      return projection$1(mollweideRaw).scale(169.529);
    }
    const defaultPath = geoPath();
    const projectionProperties = [
      // standard properties in d3-geo
      "clipAngle",
      "clipExtent",
      "scale",
      "translate",
      "center",
      "rotate",
      "parallels",
      "precision",
      "reflectX",
      "reflectY",
      // extended properties in d3-geo-projections
      "coefficient",
      "distance",
      "fraction",
      "lobes",
      "parallel",
      "radius",
      "ratio",
      "spacing",
      "tilt"
    ];
    function create$1(type2, constructor) {
      return function projection2() {
        const p = constructor();
        p.type = type2;
        p.path = geoPath().projection(p);
        p.copy = p.copy || function() {
          const c2 = projection2();
          projectionProperties.forEach((prop) => {
            if (p[prop])
              c2[prop](p[prop]());
          });
          c2.path.pointRadius(p.path.pointRadius());
          return c2;
        };
        return registerScale(p);
      };
    }
    function projection(type2, proj) {
      if (!type2 || typeof type2 !== "string") {
        throw new Error("Projection type must be a name string.");
      }
      type2 = type2.toLowerCase();
      if (arguments.length > 1) {
        projections[type2] = create$1(type2, proj);
        return this;
      } else {
        return projections[type2] || null;
      }
    }
    function getProjectionPath(proj) {
      return proj && proj.path || defaultPath;
    }
    const projections = {
      // base d3-geo projection types
      albers: geoAlbers,
      albersusa: geoAlbersUsa,
      azimuthalequalarea: geoAzimuthalEqualArea,
      azimuthalequidistant: geoAzimuthalEquidistant,
      conicconformal: geoConicConformal,
      conicequalarea: geoConicEqualArea,
      conicequidistant: geoConicEquidistant,
      equalEarth: geoEqualEarth,
      equirectangular: geoEquirectangular,
      gnomonic: geoGnomonic,
      identity: geoIdentity,
      mercator: geoMercator,
      mollweide: geoMollweide,
      naturalEarth1: geoNaturalEarth1,
      orthographic: geoOrthographic,
      stereographic: geoStereographic,
      transversemercator: geoTransverseMercator
    };
    for (const key2 in projections) {
      projection(key2, projections[key2]);
    }
    function noop() {
    }
    const cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
    function contours() {
      var dx = 1, dy = 1, smooth = smoothLinear;
      function contours2(values2, tz) {
        return tz.map((value2) => contour(values2, value2));
      }
      function contour(values2, value2) {
        var polygons = [], holes = [];
        isorings(values2, value2, (ring) => {
          smooth(ring, values2, value2);
          if (area$1(ring) > 0)
            polygons.push([ring]);
          else
            holes.push(ring);
        });
        holes.forEach((hole) => {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$1((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });
        return {
          type: "MultiPolygon",
          value: value2,
          coordinates: polygons
        };
      }
      function isorings(values2, value2, callback) {
        var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t12, t22, t32;
        x2 = y2 = -1;
        t12 = values2[0] >= value2;
        cases[t12 << 1].forEach(stitch2);
        while (++x2 < dx - 1) {
          t02 = t12, t12 = values2[x2 + 1] >= value2;
          cases[t02 | t12 << 1].forEach(stitch2);
        }
        cases[t12 << 0].forEach(stitch2);
        while (++y2 < dy - 1) {
          x2 = -1;
          t12 = values2[y2 * dx + dx] >= value2;
          t22 = values2[y2 * dx] >= value2;
          cases[t12 << 1 | t22 << 2].forEach(stitch2);
          while (++x2 < dx - 1) {
            t02 = t12, t12 = values2[y2 * dx + dx + x2 + 1] >= value2;
            t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value2;
            cases[t02 | t12 << 1 | t22 << 2 | t32 << 3].forEach(stitch2);
          }
          cases[t12 | t22 << 3].forEach(stitch2);
        }
        x2 = -1;
        t22 = values2[y2 * dx] >= value2;
        cases[t22 << 2].forEach(stitch2);
        while (++x2 < dx - 1) {
          t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value2;
          cases[t22 << 2 | t32 << 3].forEach(stitch2);
        }
        cases[t22 << 3].forEach(stitch2);
        function stitch2(line2) {
          var start2 = [line2[0][0] + x2, line2[0][1] + y2], end = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index2(start2), endIndex = index2(end), f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {
                  start: f.start,
                  end: g.end,
                  ring: f.ring.concat(g.ring)
                };
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {
                  start: g.start,
                  end: f.end,
                  ring: g.ring.concat(f.ring)
                };
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start2);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
              start: startIndex,
              end: endIndex,
              ring: [start2, end]
            };
          }
        }
      }
      function index2(point2) {
        return point2[0] * 2 + point2[1] * (dx + 1) * 4;
      }
      function smoothLinear(ring, values2, value2) {
        ring.forEach((point2) => {
          var x2 = point2[0], y2 = point2[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values2[yt * dx + xt];
          if (x2 > 0 && x2 < dx && xt === x2) {
            v0 = values2[yt * dx + xt - 1];
            point2[0] = x2 + (value2 - v0) / (v1 - v0) - 0.5;
          }
          if (y2 > 0 && y2 < dy && yt === y2) {
            v0 = values2[(yt - 1) * dx + xt];
            point2[1] = y2 + (value2 - v0) / (v1 - v0) - 0.5;
          }
        });
      }
      contours2.contour = contour;
      contours2.size = function(_) {
        if (!arguments.length)
          return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0))
          error("invalid size");
        return dx = _0, dy = _1, contours2;
      };
      contours2.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop, contours2) : smooth === smoothLinear;
      };
      return contours2;
    }
    function area$1(ring) {
      var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n)
        area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area2;
    }
    function contains$1(ring, hole) {
      var i = -1, n = hole.length, c2;
      while (++i < n)
        if (c2 = ringContains(ring, hole[i]))
          return c2;
      return 0;
    }
    function ringContains(ring, point2) {
      var x2 = point2[0], y2 = point2[1], contains2 = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi2, pj, point2))
          return 0;
        if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
          contains2 = -contains2;
      }
      return contains2;
    }
    function segmentContains(a2, b2, c2) {
      var i;
      return collinear(a2, b2, c2) && within(a2[i = +(a2[0] === b2[0])], c2[i], b2[i]);
    }
    function collinear(a2, b2, c2) {
      return (b2[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b2[1] - a2[1]);
    }
    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }
    function quantize(k, nice2, zero2) {
      return function(values2) {
        var ex = extent(values2), start2 = zero2 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span2 = stop2 - start2, step = nice2 ? tickStep(start2, stop2, k) : span2 / (k + 1);
        return range$5(start2 + step, stop2, step);
      };
    }
    function Isocontour(params2) {
      Transform.call(this, null, params2);
    }
    Isocontour.Definition = {
      "type": "Isocontour",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "thresholds",
        "type": "number",
        "array": true
      }, {
        "name": "levels",
        "type": "number"
      }, {
        "name": "nice",
        "type": "boolean",
        "default": false
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "zero",
        "type": "boolean",
        "default": true
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": true
      }, {
        "name": "scale",
        "type": "number",
        "expr": true
      }, {
        "name": "translate",
        "type": "number",
        "array": true,
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "default": "contour"
      }]
    };
    inherits(Isocontour, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source2 = pulse2.materialize(pulse2.SOURCE).source, field2 = _.field || identity$1, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source2, field2, _), as = _.as === null ? null : _.as || "contour", values2 = [];
        source2.forEach((t4) => {
          const grid = field2(t4);
          const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
          transformPaths(paths, grid, t4, _);
          paths.forEach((p) => {
            values2.push(rederive(t4, ingest$1(as != null ? {
              [as]: p
            } : p)));
          });
        });
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = values2;
        return out;
      }
    });
    function levels(values2, f, _) {
      const q = quantize(_.levels || 10, _.nice, _.zero !== false);
      return _.resolve !== "shared" ? q : q(values2.map((t4) => max$2(f(t4).values)));
    }
    function transformPaths(paths, grid, datum2, _) {
      let s = _.scale || grid.scale, t4 = _.translate || grid.translate;
      if (isFunction(s))
        s = s(datum2, _);
      if (isFunction(t4))
        t4 = t4(datum2, _);
      if ((s === 1 || s == null) && !t4)
        return;
      const sx = (isNumber$1(s) ? s : s[0]) || 1, sy = (isNumber$1(s) ? s : s[1]) || 1, tx2 = t4 && t4[0] || 0, ty = t4 && t4[1] || 0;
      paths.forEach(transform$1(grid, sx, sy, tx2, ty));
    }
    function transform$1(grid, sx, sy, tx2, ty) {
      const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }
      function transformRing(coordinates) {
        if (flip2)
          coordinates.reverse();
        coordinates.forEach(transformPoint);
      }
      function transformPoint(coordinates) {
        coordinates[0] = (coordinates[0] - x12) * sx + tx2;
        coordinates[1] = (coordinates[1] - y12) * sy + ty;
      }
      return function(geometry) {
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      };
    }
    function radius(bw, data2, f) {
      const v = bw >= 0 ? bw : estimateBandwidth(data2, f);
      return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
    }
    function number$2(_) {
      return isFunction(_) ? _ : constant$1(+_);
    }
    function density2D() {
      var x2 = (d) => d[0], y2 = (d) => d[1], weight = one$1, bandwidth2 = [-1, -1], dx = 960, dy = 500, k = 2;
      function density(data2, counts) {
        const rx = radius(bandwidth2[0], data2, x2) >> k, ry = radius(bandwidth2[1], data2, y2) >> k, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k), m2 = 2 * oy + (dy >> k), values0 = new Float32Array(n * m2), values1 = new Float32Array(n * m2);
        let values2 = values0;
        data2.forEach((d) => {
          const xi = ox + (+x2(d) >> k), yi = oy + (+y2(d) >> k);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
            values0[xi + yi * n] += +weight(d);
          }
        });
        if (rx > 0 && ry > 0) {
          blurX(n, m2, values0, values1, rx);
          blurY(n, m2, values1, values0, ry);
          blurX(n, m2, values0, values1, rx);
          blurY(n, m2, values1, values0, ry);
          blurX(n, m2, values0, values1, rx);
          blurY(n, m2, values1, values0, ry);
        } else if (rx > 0) {
          blurX(n, m2, values0, values1, rx);
          blurX(n, m2, values1, values0, rx);
          blurX(n, m2, values0, values1, rx);
          values2 = values1;
        } else if (ry > 0) {
          blurY(n, m2, values0, values1, ry);
          blurY(n, m2, values1, values0, ry);
          blurY(n, m2, values0, values1, ry);
          values2 = values1;
        }
        const s = counts ? Math.pow(2, -2 * k) : 1 / sum$1(values2);
        for (let i = 0, sz2 = n * m2; i < sz2; ++i)
          values2[i] *= s;
        return {
          values: values2,
          scale: 1 << k,
          width: n,
          height: m2,
          x1: ox,
          y1: oy,
          x2: ox + (dx >> k),
          y2: oy + (dy >> k)
        };
      }
      density.x = function(_) {
        return arguments.length ? (x2 = number$2(_), density) : x2;
      };
      density.y = function(_) {
        return arguments.length ? (y2 = number$2(_), density) : y2;
      };
      density.weight = function(_) {
        return arguments.length ? (weight = number$2(_), density) : weight;
      };
      density.size = function(_) {
        if (!arguments.length)
          return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0))
          error("invalid size");
        return dx = _0, dy = _1, density;
      };
      density.cellSize = function(_) {
        if (!arguments.length)
          return 1 << k;
        if (!((_ = +_) >= 1))
          error("invalid cell size");
        k = Math.floor(Math.log(_) / Math.LN2);
        return density;
      };
      density.bandwidth = function(_) {
        if (!arguments.length)
          return bandwidth2;
        _ = array$2(_);
        if (_.length === 1)
          _ = [+_[0], +_[0]];
        if (_.length !== 2)
          error("invalid bandwidth");
        return bandwidth2 = _, density;
      };
      return density;
    }
    function blurX(n, m2, source2, target2, r) {
      const w2 = (r << 1) + 1;
      for (let j = 0; j < m2; ++j) {
        for (let i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source2[i + j * n];
          }
          if (i >= r) {
            if (i >= w2) {
              sr -= source2[i - w2 + j * n];
            }
            target2[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w2 - i, w2);
          }
        }
      }
    }
    function blurY(n, m2, source2, target2, r) {
      const w2 = (r << 1) + 1;
      for (let i = 0; i < n; ++i) {
        for (let j = 0, sr = 0; j < m2 + r; ++j) {
          if (j < m2) {
            sr += source2[i + j * n];
          }
          if (j >= r) {
            if (j >= w2) {
              sr -= source2[i + (j - w2) * n];
            }
            target2[i + (j - r) * n] = sr / Math.min(j + 1, m2 - 1 + w2 - j, w2);
          }
        }
      }
    }
    function KDE2D(params2) {
      Transform.call(this, null, params2);
    }
    KDE2D.Definition = {
      "type": "KDE2D",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "weight",
        "type": "field"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "cellSize",
        "type": "number"
      }, {
        "name": "bandwidth",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "counts",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "default": "grid"
      }]
    };
    const PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
    function params(obj, _) {
      PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
      return obj;
    }
    inherits(KDE2D, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified())
          return pulse2.StopPropagation;
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source2, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values2 = [];
        function set2(t4, vals2) {
          for (let i = 0; i < names.length; ++i)
            t4[names[i]] = vals2[i];
          return t4;
        }
        values2 = groups.map((g) => ingest$1(set2({
          [as]: kde2(g, _.counts)
        }, g.dims)));
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = values2;
        return out;
      }
    });
    function partition$1(data2, groupby) {
      var groups = [], get2 = (f) => f(t4), map2, i, n, t4, k, g;
      if (groupby == null) {
        groups.push(data2);
      } else {
        for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
          t4 = data2[i];
          k = groupby.map(get2);
          g = map2[k];
          if (!g) {
            map2[k] = g = [];
            g.dims = k;
            groups.push(g);
          }
          g.push(t4);
        }
      }
      return groups;
    }
    function Contour(params2) {
      Transform.call(this, null, params2);
    }
    Contour.Definition = {
      "type": "Contour",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "values",
        "type": "number",
        "array": true
      }, {
        "name": "x",
        "type": "field"
      }, {
        "name": "y",
        "type": "field"
      }, {
        "name": "weight",
        "type": "field"
      }, {
        "name": "cellSize",
        "type": "number"
      }, {
        "name": "bandwidth",
        "type": "number"
      }, {
        "name": "count",
        "type": "number"
      }, {
        "name": "nice",
        "type": "boolean",
        "default": false
      }, {
        "name": "thresholds",
        "type": "number",
        "array": true
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": true
      }]
    };
    inherits(Contour, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values2 = _.values, thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values2), size2 = _.size, grid, post2;
        if (!values2) {
          values2 = pulse2.materialize(pulse2.SOURCE).source;
          grid = params(density2D(), _)(values2, true);
          post2 = transform$1(grid, grid.scale || 1, grid.scale || 1, 0, 0);
          size2 = [grid.width, grid.height];
          values2 = grid.values;
        }
        thresh = isArray(thresh) ? thresh : thresh(values2);
        values2 = contour.size(size2)(values2, thresh);
        if (post2)
          values2.forEach(post2);
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = (values2 || []).map(ingest$1);
        return out;
      }
    });
    const Feature = "Feature";
    const FeatureCollection = "FeatureCollection";
    const MultiPoint = "MultiPoint";
    function GeoJSON(params2) {
      Transform.call(this, null, params2);
    }
    GeoJSON.Definition = {
      "type": "GeoJSON",
      "metadata": {},
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "length": 2
      }, {
        "name": "geojson",
        "type": "field"
      }]
    };
    inherits(GeoJSON, Transform, {
      transform(_, pulse2) {
        var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity$1, flag2 = pulse2.ADD, mod;
        mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
        if (!this.value || mod) {
          flag2 = pulse2.SOURCE;
          this._features = features = [];
          this._points = points2 = [];
        }
        if (geojson) {
          pulse2.visit(flag2, (t4) => features.push(geojson(t4)));
        }
        if (lon && lat) {
          pulse2.visit(flag2, (t4) => {
            var x2 = lon(t4), y2 = lat(t4);
            if (x2 != null && y2 != null && (x2 = +x2) === x2 && (y2 = +y2) === y2) {
              points2.push([x2, y2]);
            }
          });
          features = features.concat({
            type: Feature,
            geometry: {
              type: MultiPoint,
              coordinates: points2
            }
          });
        }
        this.value = {
          type: FeatureCollection,
          features
        };
      }
    });
    function GeoPath(params2) {
      Transform.call(this, null, params2);
    }
    GeoPath.Definition = {
      "type": "GeoPath",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "projection",
        "type": "projection"
      }, {
        "name": "field",
        "type": "field"
      }, {
        "name": "pointRadius",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    inherits(GeoPath, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), path2 = this.value, field2 = _.field || identity$1, as = _.as || "path", flag2 = out.SOURCE;
        if (!path2 || _.modified()) {
          this.value = path2 = getProjectionPath(_.projection);
          out.materialize().reflow();
        } else {
          flag2 = field2 === identity$1 || pulse2.modified(field2.fields) ? out.ADD_MOD : out.ADD;
        }
        const prev2 = initPath(path2, _.pointRadius);
        out.visit(flag2, (t4) => t4[as] = path2(field2(t4)));
        path2.pointRadius(prev2);
        return out.modifies(as);
      }
    });
    function initPath(path2, pointRadius) {
      const prev2 = path2.pointRadius();
      path2.context(null);
      if (pointRadius != null) {
        path2.pointRadius(pointRadius);
      }
      return prev2;
    }
    function GeoPoint(params2) {
      Transform.call(this, null, params2);
    }
    GeoPoint.Definition = {
      "type": "GeoPoint",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "projection",
        "type": "projection",
        "required": true
      }, {
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["x", "y"]
      }]
    };
    inherits(GeoPoint, Transform, {
      transform(_, pulse2) {
        var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x2 = as[0], y2 = as[1], mod;
        function set2(t4) {
          const xy = proj([lon(t4), lat(t4)]);
          if (xy) {
            t4[x2] = xy[0];
            t4[y2] = xy[1];
          } else {
            t4[x2] = void 0;
            t4[y2] = void 0;
          }
        }
        if (_.modified()) {
          pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set2);
        } else {
          mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
          pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set2);
        }
        return pulse2.modifies(as);
      }
    });
    function GeoShape(params2) {
      Transform.call(this, null, params2);
    }
    GeoShape.Definition = {
      "type": "GeoShape",
      "metadata": {
        "modifies": true,
        "nomod": true
      },
      "params": [{
        "name": "projection",
        "type": "projection"
      }, {
        "name": "field",
        "type": "field",
        "default": "datum"
      }, {
        "name": "pointRadius",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "default": "shape"
      }]
    };
    inherits(GeoShape, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
        if (!shape2 || _.modified()) {
          this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field$1("datum"), _.pointRadius);
          out.materialize().reflow();
          flag2 = out.SOURCE;
        }
        out.visit(flag2, (t4) => t4[as] = shape2);
        return out.modifies(as);
      }
    });
    function shapeGenerator(path2, field2, pointRadius) {
      const shape2 = pointRadius == null ? (_) => path2(field2(_)) : (_) => {
        var prev2 = path2.pointRadius(), value2 = path2.pointRadius(pointRadius)(field2(_));
        path2.pointRadius(prev2);
        return value2;
      };
      shape2.context = (_) => {
        path2.context(_);
        return shape2;
      };
      return shape2;
    }
    function Graticule(params2) {
      Transform.call(this, [], params2);
      this.generator = graticule();
    }
    Graticule.Definition = {
      "type": "Graticule",
      "metadata": {
        "changes": true,
        "generates": true
      },
      "params": [{
        "name": "extent",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "extentMajor",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "extentMinor",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "step",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "stepMajor",
        "type": "number",
        "array": true,
        "length": 2,
        "default": [90, 360]
      }, {
        "name": "stepMinor",
        "type": "number",
        "array": true,
        "length": 2,
        "default": [10, 10]
      }, {
        "name": "precision",
        "type": "number",
        "default": 2.5
      }]
    };
    inherits(Graticule, Transform, {
      transform(_, pulse2) {
        var src = this.value, gen = this.generator, t4;
        if (!src.length || _.modified()) {
          for (const prop in _) {
            if (isFunction(gen[prop])) {
              gen[prop](_[prop]);
            }
          }
        }
        t4 = gen();
        if (src.length) {
          pulse2.mod.push(replace$1(src[0], t4));
        } else {
          pulse2.add.push(ingest$1(t4));
        }
        src[0] = t4;
        return pulse2;
      }
    });
    function Heatmap(params2) {
      Transform.call(this, null, params2);
    }
    Heatmap.Definition = {
      "type": "heatmap",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "color",
        "type": "string",
        "expr": true
      }, {
        "name": "opacity",
        "type": "number",
        "expr": true
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "as",
        "type": "string",
        "default": "image"
      }]
    };
    inherits(Heatmap, Transform, {
      transform(_, pulse2) {
        if (!pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var source2 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field2 = _.field || identity$1, opacity2 = opacity_(_.opacity, _), color2 = color_(_.color, _), as = _.as || "image", obj = {
          $x: 0,
          $y: 0,
          $value: 0,
          $max: shared ? max$2(source2.map((t4) => max$2(field2(t4).values))) : 0
        };
        source2.forEach((t4) => {
          const v = field2(t4);
          const o = extend({}, t4, obj);
          if (!shared)
            o.$max = max$2(v.values || []);
          t4[as] = toCanvas(v, o, color2.dep ? color2 : constant$1(color2(o)), opacity2.dep ? opacity2 : constant$1(opacity2(o)));
        });
        return pulse2.reflow(true).modifies(as);
      }
    });
    function color_(color2, _) {
      let f;
      if (isFunction(color2)) {
        f = (obj) => rgb(color2(obj, _));
        f.dep = dependency(color2);
      } else {
        f = constant$1(rgb(color2 || "#888"));
      }
      return f;
    }
    function opacity_(opacity2, _) {
      let f;
      if (isFunction(opacity2)) {
        f = (obj) => opacity2(obj, _);
        f.dep = dependency(opacity2);
      } else if (opacity2) {
        f = constant$1(opacity2);
      } else {
        f = (obj) => obj.$value / obj.$max || 0;
        f.dep = true;
      }
      return f;
    }
    function dependency(f) {
      if (!isFunction(f))
        return false;
      const set2 = toSet(accessorFields(f));
      return set2.$x || set2.$y || set2.$value || set2.$max;
    }
    function toCanvas(grid, obj, color2, opacity2) {
      const n = grid.width, m2 = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x2 = grid.x2 || n, y2 = grid.y2 || m2, val = grid.values, value2 = val ? (i) => val[i] : zero$2, can = domCanvas(x2 - x12, y2 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x2 - x12, y2 - y12), pix = img.data;
      for (let j = y12, k = 0; j < y2; ++j) {
        obj.$y = j - y12;
        for (let i = x12, r = j * n; i < x2; ++i, k += 4) {
          obj.$x = i - x12;
          obj.$value = value2(i + r);
          const v = color2(obj);
          pix[k + 0] = v.r;
          pix[k + 1] = v.g;
          pix[k + 2] = v.b;
          pix[k + 3] = ~~(255 * opacity2(obj));
        }
      }
      ctx.putImageData(img, 0, 0);
      return can;
    }
    function Projection$1(params2) {
      Transform.call(this, null, params2);
      this.modified(true);
    }
    inherits(Projection$1, Transform, {
      transform(_, pulse2) {
        let proj = this.value;
        if (!proj || _.modified("type")) {
          this.value = proj = create(_.type);
          projectionProperties.forEach((prop) => {
            if (_[prop] != null)
              set$1(proj, prop, _[prop]);
          });
        } else {
          projectionProperties.forEach((prop) => {
            if (_.modified(prop))
              set$1(proj, prop, _[prop]);
          });
        }
        if (_.pointRadius != null)
          proj.path.pointRadius(_.pointRadius);
        if (_.fit)
          fit(proj, _);
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
    function fit(proj, _) {
      const data2 = collectGeoJSON(_.fit);
      _.extent ? proj.fitExtent(_.extent, data2) : _.size ? proj.fitSize(_.size, data2) : 0;
    }
    function create(type2) {
      const constructor = projection((type2 || "mercator").toLowerCase());
      if (!constructor)
        error("Unrecognized projection type: " + type2);
      return constructor();
    }
    function set$1(proj, key2, value2) {
      if (isFunction(proj[key2]))
        proj[key2](value2);
    }
    function collectGeoJSON(data2) {
      data2 = array$2(data2);
      return data2.length === 1 ? data2[0] : {
        type: FeatureCollection,
        features: data2.reduce((a2, f) => a2.concat(featurize(f)), [])
      };
    }
    function featurize(f) {
      return f.type === FeatureCollection ? f.features : array$2(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
        type: Feature,
        geometry: d
      });
    }
    const geo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      contour: Contour,
      geojson: GeoJSON,
      geopath: GeoPath,
      geopoint: GeoPoint,
      geoshape: GeoShape,
      graticule: Graticule,
      heatmap: Heatmap,
      isocontour: Isocontour,
      kde2d: KDE2D,
      projection: Projection$1
    }, Symbol.toStringTag, { value: "Module" }));
    const ForceMap = {
      center: forceCenter,
      collide: forceCollide,
      nbody: forceManyBody,
      link: forceLink,
      x: forceX,
      y: forceY
    };
    const Forces = "forces", ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], ForceConfig = ["static", "iterations"], ForceOutput = ["x", "y", "vx", "vy"];
    function Force(params2) {
      Transform.call(this, null, params2);
    }
    Force.Definition = {
      "type": "Force",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "static",
        "type": "boolean",
        "default": false
      }, {
        "name": "restart",
        "type": "boolean",
        "default": false
      }, {
        "name": "iterations",
        "type": "number",
        "default": 300
      }, {
        "name": "alpha",
        "type": "number",
        "default": 1
      }, {
        "name": "alphaMin",
        "type": "number",
        "default": 1e-3
      }, {
        "name": "alphaTarget",
        "type": "number",
        "default": 0
      }, {
        "name": "velocityDecay",
        "type": "number",
        "default": 0.4
      }, {
        "name": "forces",
        "type": "param",
        "array": true,
        "params": [{
          "key": {
            "force": "center"
          },
          "params": [{
            "name": "x",
            "type": "number",
            "default": 0
          }, {
            "name": "y",
            "type": "number",
            "default": 0
          }]
        }, {
          "key": {
            "force": "collide"
          },
          "params": [{
            "name": "radius",
            "type": "number",
            "expr": true
          }, {
            "name": "strength",
            "type": "number",
            "default": 0.7
          }, {
            "name": "iterations",
            "type": "number",
            "default": 1
          }]
        }, {
          "key": {
            "force": "nbody"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": -30,
            "expr": true
          }, {
            "name": "theta",
            "type": "number",
            "default": 0.9
          }, {
            "name": "distanceMin",
            "type": "number",
            "default": 1
          }, {
            "name": "distanceMax",
            "type": "number"
          }]
        }, {
          "key": {
            "force": "link"
          },
          "params": [{
            "name": "links",
            "type": "data"
          }, {
            "name": "id",
            "type": "field"
          }, {
            "name": "distance",
            "type": "number",
            "default": 30,
            "expr": true
          }, {
            "name": "strength",
            "type": "number",
            "expr": true
          }, {
            "name": "iterations",
            "type": "number",
            "default": 1
          }]
        }, {
          "key": {
            "force": "x"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": 0.1
          }, {
            "name": "x",
            "type": "field"
          }]
        }, {
          "key": {
            "force": "y"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": 0.1
          }, {
            "name": "y",
            "type": "field"
          }]
        }]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "modify": false,
        "default": ForceOutput
      }]
    };
    inherits(Force, Transform, {
      transform(_, pulse2) {
        var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
        if (!sim) {
          this.value = sim = simulation(pulse2.source, _);
          sim.on("tick", rerun(pulse2.dataflow, this));
          if (!_.static) {
            change2 = true;
            sim.tick();
          }
          pulse2.modifies("index");
        } else {
          if (change2) {
            pulse2.modifies("index");
            sim.nodes(pulse2.source);
          }
          if (params2 || pulse2.changed(pulse2.MOD)) {
            setup(sim, _, 0, pulse2);
          }
        }
        if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
          sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
          if (_.static) {
            for (sim.stop(); --iters >= 0; )
              sim.tick();
          } else {
            if (sim.stopped())
              sim.restart();
            if (!change2)
              return pulse2.StopPropagation;
          }
        }
        return this.finish(_, pulse2);
      },
      finish(_, pulse2) {
        const dataflow = pulse2.dataflow;
        for (let args = this._argops, j = 0, m2 = args.length, arg; j < m2; ++j) {
          arg = args[j];
          if (arg.name !== Forces || arg.op._argval.force !== "link") {
            continue;
          }
          for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
            if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
              dataflow.pulse(op, dataflow.changeset().reflow());
              break;
            }
          }
        }
        return pulse2.reflow(_.modified()).modifies(ForceOutput);
      }
    });
    function rerun(df, op) {
      return () => df.touch(op).run();
    }
    function simulation(nodes, _) {
      const sim = forceSimulation(nodes), stop2 = sim.stop, restart = sim.restart;
      let stopped = false;
      sim.stopped = () => stopped;
      sim.restart = () => (stopped = false, restart());
      sim.stop = () => (stopped = true, stop2());
      return setup(sim, _, true).on("end", () => stopped = true);
    }
    function setup(sim, _, init2, pulse2) {
      var f = array$2(_.forces), i, n, p, name2;
      for (i = 0, n = ForceParams.length; i < n; ++i) {
        p = ForceParams[i];
        if (p !== Forces && _.modified(p))
          sim[p](_[p]);
      }
      for (i = 0, n = f.length; i < n; ++i) {
        name2 = Forces + i;
        p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name2) : null;
        if (p)
          sim.force(name2, p);
      }
      for (n = sim.numForces || 0; i < n; ++i) {
        sim.force(Forces + i, null);
      }
      sim.numForces = f.length;
      return sim;
    }
    function modified(f, pulse2) {
      var k, v;
      for (k in f) {
        if (isFunction(v = f[k]) && pulse2.modified(accessorFields(v)))
          return 1;
      }
      return 0;
    }
    function getForce(_) {
      var f, p;
      if (!has$1(ForceMap, _.force)) {
        error("Unrecognized force: " + _.force);
      }
      f = ForceMap[_.force]();
      for (p in _) {
        if (isFunction(f[p]))
          setForceParam(f[p], _[p], _);
      }
      return f;
    }
    function setForceParam(f, v, _) {
      f(isFunction(v) ? (d) => v(d, _) : v);
    }
    const force = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      force: Force
    }, Symbol.toStringTag, { value: "Module" }));
    function lookup$2(tree2, key2, filter2) {
      const map2 = {};
      tree2.each((node) => {
        const t4 = node.data;
        if (filter2(t4))
          map2[key2(t4)] = node;
      });
      tree2.lookup = map2;
      return tree2;
    }
    function Nest(params2) {
      Transform.call(this, null, params2);
    }
    Nest.Definition = {
      "type": "Nest",
      "metadata": {
        "treesource": true,
        "changes": true
      },
      "params": [{
        "name": "keys",
        "type": "field",
        "array": true
      }, {
        "name": "generate",
        "type": "boolean"
      }]
    };
    const children$1 = (n) => n.values;
    inherits(Nest, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source) {
          error("Nest transform requires an upstream data source.");
        }
        var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree2 = this.value;
        if (!tree2 || mod || pulse2.changed()) {
          if (tree2) {
            tree2.each((node) => {
              if (node.children && isTuple(node.data)) {
                out.rem.push(node.data);
              }
            });
          }
          this.value = tree2 = hierarchy({
            values: array$2(_.keys).reduce((n, k) => {
              n.key(k);
              return n;
            }, nest()).entries(out.source)
          }, children$1);
          if (gen) {
            tree2.each((node) => {
              if (node.children) {
                node = ingest$1(node.data);
                out.add.push(node);
                out.source.push(node);
              }
            });
          }
          lookup$2(tree2, tupleid, tupleid);
        }
        out.source.root = tree2;
        return out;
      }
    });
    function nest() {
      const keys2 = [], nest2 = {
        entries: (array2) => entries2(apply2(array2, 0), 0),
        key: (d) => (keys2.push(d), nest2)
      };
      function apply2(array2, depth) {
        if (depth >= keys2.length) {
          return array2;
        }
        const n = array2.length, key2 = keys2[depth++], valuesByKey = {}, result = {};
        let i = -1, keyValue, value2, values2;
        while (++i < n) {
          keyValue = key2(value2 = array2[i]) + "";
          if (values2 = valuesByKey[keyValue]) {
            values2.push(value2);
          } else {
            valuesByKey[keyValue] = [value2];
          }
        }
        for (keyValue in valuesByKey) {
          result[keyValue] = apply2(valuesByKey[keyValue], depth);
        }
        return result;
      }
      function entries2(map2, depth) {
        if (++depth > keys2.length)
          return map2;
        const array2 = [];
        for (const key2 in map2) {
          array2.push({
            key: key2,
            values: entries2(map2[key2], depth)
          });
        }
        return array2;
      }
      return nest2;
    }
    function HierarchyLayout(params2) {
      Transform.call(this, null, params2);
    }
    const defaultSeparation = (a2, b2) => a2.parent === b2.parent ? 1 : 2;
    inherits(HierarchyLayout, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source || !pulse2.source.root) {
          error(this.constructor.name + " transform requires a backing tree data source.");
        }
        const layout = this.layout(_.method), fields = this.fields, root2 = pulse2.source.root, as = _.as || fields;
        if (_.field)
          root2.sum(_.field);
        else
          root2.count();
        if (_.sort)
          root2.sort(stableCompare(_.sort, (d) => d.data));
        setParams(layout, this.params, _);
        if (layout.separation) {
          layout.separation(_.separation !== false ? defaultSeparation : one$1);
        }
        try {
          this.value = layout(root2);
        } catch (err) {
          error(err);
        }
        root2.each((node) => setFields(node, fields, as));
        return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
      }
    });
    function setParams(layout, params2, _) {
      for (let p, i = 0, n = params2.length; i < n; ++i) {
        p = params2[i];
        if (p in _)
          layout[p](_[p]);
      }
    }
    function setFields(node, fields, as) {
      const t4 = node.data, n = fields.length - 1;
      for (let i = 0; i < n; ++i) {
        t4[as[i]] = node[fields[i]];
      }
      t4[as[n]] = node.children ? node.children.length : 0;
    }
    const Output$3 = ["x", "y", "r", "depth", "children"];
    function Pack(params2) {
      HierarchyLayout.call(this, params2);
    }
    Pack.Definition = {
      "type": "Pack",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "radius",
        "type": "field",
        "default": null
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$3.length,
        "default": Output$3
      }]
    };
    inherits(Pack, HierarchyLayout, {
      layout: pack,
      params: ["radius", "size", "padding"],
      fields: Output$3
    });
    const Output$2 = ["x0", "y0", "x1", "y1", "depth", "children"];
    function Partition(params2) {
      HierarchyLayout.call(this, params2);
    }
    Partition.Definition = {
      "type": "Partition",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "round",
        "type": "boolean",
        "default": false
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$2.length,
        "default": Output$2
      }]
    };
    inherits(Partition, HierarchyLayout, {
      layout: partition$4,
      params: ["size", "round", "padding"],
      fields: Output$2
    });
    function Stratify(params2) {
      Transform.call(this, null, params2);
    }
    Stratify.Definition = {
      "type": "Stratify",
      "metadata": {
        "treesource": true
      },
      "params": [{
        "name": "key",
        "type": "field",
        "required": true
      }, {
        "name": "parentKey",
        "type": "field",
        "required": true
      }]
    };
    inherits(Stratify, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source) {
          error("Stratify transform requires an upstream data source.");
        }
        let tree2 = this.value;
        const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree2 || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
        out.source = out.source.slice();
        if (run2) {
          tree2 = out.source.length ? lookup$2(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup$2(stratify()([{}]), _.key, _.key);
        }
        out.source.root = this.value = tree2;
        return out;
      }
    });
    const Layouts = {
      tidy: tree$1,
      cluster
    };
    const Output$1$1 = ["x", "y", "depth", "children"];
    function Tree(params2) {
      HierarchyLayout.call(this, params2);
    }
    Tree.Definition = {
      "type": "Tree",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "method",
        "type": "enum",
        "default": "tidy",
        "values": ["tidy", "cluster"]
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "nodeSize",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "separation",
        "type": "boolean",
        "default": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$1$1.length,
        "default": Output$1$1
      }]
    };
    inherits(Tree, HierarchyLayout, {
      /**
       * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
       */
      layout(method2) {
        const m2 = method2 || "tidy";
        if (has$1(Layouts, m2))
          return Layouts[m2]();
        else
          error("Unrecognized Tree layout method: " + m2);
      },
      params: ["size", "nodeSize"],
      fields: Output$1$1
    });
    function TreeLinks(params2) {
      Transform.call(this, [], params2);
    }
    TreeLinks.Definition = {
      "type": "TreeLinks",
      "metadata": {
        "tree": true,
        "generates": true,
        "changes": true
      },
      "params": []
    };
    inherits(TreeLinks, Transform, {
      transform(_, pulse2) {
        const links = this.value, tree2 = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
        if (!tree2)
          error("TreeLinks transform requires a tree data source.");
        if (pulse2.changed(pulse2.ADD_REM)) {
          out.rem = links;
          pulse2.visit(pulse2.SOURCE, (t4) => lut[tupleid(t4)] = 1);
          tree2.each((node) => {
            const t4 = node.data, p = node.parent && node.parent.data;
            if (p && lut[tupleid(t4)] && lut[tupleid(p)]) {
              out.add.push(ingest$1({
                source: p,
                target: t4
              }));
            }
          });
          this.value = out.add;
        } else if (pulse2.changed(pulse2.MOD)) {
          pulse2.visit(pulse2.MOD, (t4) => lut[tupleid(t4)] = 1);
          links.forEach((link2) => {
            if (lut[tupleid(link2.source)] || lut[tupleid(link2.target)]) {
              out.mod.push(link2);
            }
          });
        }
        return out;
      }
    });
    const Tiles = {
      binary: treemapBinary,
      dice: treemapDice,
      slice: treemapSlice,
      slicedice: treemapSliceDice,
      squarify: treemapSquarify,
      resquarify: treemapResquarify
    };
    const Output$4 = ["x0", "y0", "x1", "y1", "depth", "children"];
    function Treemap(params2) {
      HierarchyLayout.call(this, params2);
    }
    Treemap.Definition = {
      "type": "Treemap",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "method",
        "type": "enum",
        "default": "squarify",
        "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingInner",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingOuter",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingTop",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingRight",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingBottom",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingLeft",
        "type": "number",
        "default": 0
      }, {
        "name": "ratio",
        "type": "number",
        "default": 1.618033988749895
      }, {
        "name": "round",
        "type": "boolean",
        "default": false
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$4.length,
        "default": Output$4
      }]
    };
    inherits(Treemap, HierarchyLayout, {
      /**
       * Treemap layout generator. Adds 'method' and 'ratio' parameters
       * to configure the underlying tile method.
       */
      layout() {
        const x2 = treemap();
        x2.ratio = (_) => {
          const t4 = x2.tile();
          if (t4.ratio)
            x2.tile(t4.ratio(_));
        };
        x2.method = (_) => {
          if (has$1(Tiles, _))
            x2.tile(Tiles[_]);
          else
            error("Unrecognized Treemap layout method: " + _);
        };
        return x2;
      },
      params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      fields: Output$4
    });
    const tree = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      nest: Nest,
      pack: Pack,
      partition: Partition,
      stratify: Stratify,
      tree: Tree,
      treelinks: TreeLinks,
      treemap: Treemap
    }, Symbol.toStringTag, { value: "Module" }));
    const ALPHA_MASK = 4278190080;
    function baseBitmaps($2, data2) {
      const bitmap = $2.bitmap();
      (data2 || []).forEach((d) => bitmap.set($2(d.boundary[0]), $2(d.boundary[3])));
      return [bitmap, void 0];
    }
    function markBitmaps($2, baseMark, avoidMarks, labelInside, isGroupArea) {
      const width2 = $2.width, height2 = $2.height, border = labelInside || isGroupArea, context2 = domCanvas(width2, height2).getContext("2d"), baseMarkContext = domCanvas(width2, height2).getContext("2d"), strokeContext = border && domCanvas(width2, height2).getContext("2d");
      avoidMarks.forEach((items) => draw(context2, items, false));
      draw(baseMarkContext, baseMark, false);
      if (border) {
        draw(strokeContext, baseMark, true);
      }
      const buffer = getBuffer(context2, width2, height2), baseMarkBuffer = getBuffer(baseMarkContext, width2, height2), strokeBuffer = border && getBuffer(strokeContext, width2, height2), layer1 = $2.bitmap(), layer2 = border && $2.bitmap();
      let x2, y2, u2, v, index2, alpha, strokeAlpha, baseMarkAlpha;
      for (y2 = 0; y2 < height2; ++y2) {
        for (x2 = 0; x2 < width2; ++x2) {
          index2 = y2 * width2 + x2;
          alpha = buffer[index2] & ALPHA_MASK;
          baseMarkAlpha = baseMarkBuffer[index2] & ALPHA_MASK;
          strokeAlpha = border && strokeBuffer[index2] & ALPHA_MASK;
          if (alpha || strokeAlpha || baseMarkAlpha) {
            u2 = $2(x2);
            v = $2(y2);
            if (!isGroupArea && (alpha || baseMarkAlpha))
              layer1.set(u2, v);
            if (border && (alpha || strokeAlpha))
              layer2.set(u2, v);
          }
        }
      }
      return [layer1, layer2];
    }
    function getBuffer(context2, width2, height2) {
      return new Uint32Array(context2.getImageData(0, 0, width2, height2).data.buffer);
    }
    function draw(context2, items, interior) {
      if (!items.length)
        return;
      const type2 = items[0].mark.marktype;
      if (type2 === "group") {
        items.forEach((group2) => {
          group2.items.forEach((mark) => draw(context2, mark.items, interior));
        });
      } else {
        Marks[type2].draw(context2, {
          items: interior ? items.map(prepare) : items
        });
      }
    }
    function prepare(source2) {
      const item = rederive(source2, {});
      if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
        return {
          ...item,
          strokeOpacity: 1,
          stroke: "#000",
          fillOpacity: 0
        };
      }
      return item;
    }
    const DIV = 5, MOD = 31, SIZE$1 = 32, RIGHT0 = new Uint32Array(SIZE$1 + 1), RIGHT1 = new Uint32Array(SIZE$1 + 1);
    RIGHT1[0] = 0;
    RIGHT0[0] = ~RIGHT1[0];
    for (let i = 1; i <= SIZE$1; ++i) {
      RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
      RIGHT0[i] = ~RIGHT1[i];
    }
    function Bitmap(w2, h2) {
      const array2 = new Uint32Array(~~((w2 * h2 + SIZE$1) / SIZE$1));
      function _set(index2, mask) {
        array2[index2] |= mask;
      }
      function _clear(index2, mask) {
        array2[index2] &= mask;
      }
      return {
        array: array2,
        get: (x2, y2) => {
          const index2 = y2 * w2 + x2;
          return array2[index2 >>> DIV] & 1 << (index2 & MOD);
        },
        set: (x2, y2) => {
          const index2 = y2 * w2 + x2;
          _set(index2 >>> DIV, 1 << (index2 & MOD));
        },
        clear: (x2, y2) => {
          const index2 = y2 * w2 + x2;
          _clear(index2 >>> DIV, ~(1 << (index2 & MOD)));
        },
        getRange: (x2, y2, x22, y22) => {
          let r = y22, start2, end, indexStart, indexEnd;
          for (; r >= y2; --r) {
            start2 = r * w2 + x2;
            end = r * w2 + x22;
            indexStart = start2 >>> DIV;
            indexEnd = end >>> DIV;
            if (indexStart === indexEnd) {
              if (array2[indexStart] & RIGHT0[start2 & MOD] & RIGHT1[(end & MOD) + 1]) {
                return true;
              }
            } else {
              if (array2[indexStart] & RIGHT0[start2 & MOD])
                return true;
              if (array2[indexEnd] & RIGHT1[(end & MOD) + 1])
                return true;
              for (let i = indexStart + 1; i < indexEnd; ++i) {
                if (array2[i])
                  return true;
              }
            }
          }
          return false;
        },
        setRange: (x2, y2, x22, y22) => {
          let start2, end, indexStart, indexEnd, i;
          for (; y2 <= y22; ++y2) {
            start2 = y2 * w2 + x2;
            end = y2 * w2 + x22;
            indexStart = start2 >>> DIV;
            indexEnd = end >>> DIV;
            if (indexStart === indexEnd) {
              _set(indexStart, RIGHT0[start2 & MOD] & RIGHT1[(end & MOD) + 1]);
            } else {
              _set(indexStart, RIGHT0[start2 & MOD]);
              _set(indexEnd, RIGHT1[(end & MOD) + 1]);
              for (i = indexStart + 1; i < indexEnd; ++i)
                _set(i, 4294967295);
            }
          }
        },
        clearRange: (x2, y2, x22, y22) => {
          let start2, end, indexStart, indexEnd, i;
          for (; y2 <= y22; ++y2) {
            start2 = y2 * w2 + x2;
            end = y2 * w2 + x22;
            indexStart = start2 >>> DIV;
            indexEnd = end >>> DIV;
            if (indexStart === indexEnd) {
              _clear(indexStart, RIGHT1[start2 & MOD] | RIGHT0[(end & MOD) + 1]);
            } else {
              _clear(indexStart, RIGHT1[start2 & MOD]);
              _clear(indexEnd, RIGHT0[(end & MOD) + 1]);
              for (i = indexStart + 1; i < indexEnd; ++i)
                _clear(i, 0);
            }
          }
        },
        outOfBounds: (x2, y2, x22, y22) => x2 < 0 || y2 < 0 || y22 >= h2 || x22 >= w2
      };
    }
    function scaler(width2, height2, padding2) {
      const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w2 = ~~((width2 + 2 * padding2 + ratio) / ratio), h2 = ~~((height2 + 2 * padding2 + ratio) / ratio), scale2 = (_) => ~~((_ + padding2) / ratio);
      scale2.invert = (_) => _ * ratio - padding2;
      scale2.bitmap = () => Bitmap(w2, h2);
      scale2.ratio = ratio;
      scale2.padding = padding2;
      scale2.width = width2;
      scale2.height = height2;
      return scale2;
    }
    function placeAreaLabelNaive($2, bitmaps, avoidBaseMark, markIndex) {
      const width2 = $2.width, height2 = $2.height;
      return function(d) {
        const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
        let maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, areaWidth;
        for (let i = 0; i < n; ++i) {
          x12 = items[i].x;
          y12 = items[i].y;
          x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
          y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
          x3 = (x12 + x2) / 2;
          y3 = (y12 + y2) / 2;
          areaWidth = Math.abs(x2 - x12 + y2 - y12);
          if (areaWidth >= maxAreaWidth) {
            maxAreaWidth = areaWidth;
            d.x = x3;
            d.y = y3;
          }
        }
        x3 = textWidth / 2;
        y3 = textHeight / 2;
        x12 = d.x - x3;
        x2 = d.x + x3;
        y12 = d.y - y3;
        y2 = d.y + y3;
        d.align = "center";
        if (x12 < 0 && x2 <= width2) {
          d.align = "left";
        } else if (0 <= x12 && width2 < x2) {
          d.align = "right";
        }
        d.baseline = "middle";
        if (y12 < 0 && y2 <= height2) {
          d.baseline = "top";
        } else if (0 <= y12 && height2 < y2) {
          d.baseline = "bottom";
        }
        return true;
      };
    }
    function outOfBounds(x2, y2, textWidth, textHeight, width2, height2) {
      let r = textWidth / 2;
      return x2 - r < 0 || x2 + r > width2 || y2 - (r = textHeight / 2) < 0 || y2 + r > height2;
    }
    function collision($2, x2, y2, textHeight, textWidth, h2, bm0, bm1) {
      const w2 = textWidth * h2 / (textHeight * 2), x12 = $2(x2 - w2), x22 = $2(x2 + w2), y12 = $2(y2 - (h2 = h2 / 2)), y22 = $2(y2 + h2);
      return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
    }
    function placeAreaLabelReducedSearch($2, bitmaps, avoidBaseMark, markIndex) {
      const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
      function tryLabel(_x3, _y3, maxSize, textWidth, textHeight) {
        const x2 = $2.invert(_x3), y2 = $2.invert(_y3);
        let lo = maxSize, hi = height2, mid;
        if (!outOfBounds(x2, y2, textWidth, textHeight, width2, height2) && !collision($2, x2, y2, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x2, y2, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($2, x2, y2, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            return [x2, y2, lo, true];
          }
        }
      }
      return function(d) {
        const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
        let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, _x1, _xMid, _x22, _y1, _yMid, _y22, areaWidth, result, swapTmp;
        for (let i = 0; i < n; ++i) {
          x12 = items[i].x;
          y12 = items[i].y;
          x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
          y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
          if (x12 > x2) {
            swapTmp = x12;
            x12 = x2;
            x2 = swapTmp;
          }
          if (y12 > y2) {
            swapTmp = y12;
            y12 = y2;
            y2 = swapTmp;
          }
          _x1 = $2(x12);
          _x22 = $2(x2);
          _xMid = ~~((_x1 + _x22) / 2);
          _y1 = $2(y12);
          _y22 = $2(y2);
          _yMid = ~~((_y1 + _y22) / 2);
          for (_x3 = _xMid; _x3 >= _x1; --_x3) {
            for (_y3 = _yMid; _y3 >= _y1; --_y3) {
              result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
              if (result) {
                [d.x, d.y, maxSize, labelPlaced] = result;
              }
            }
          }
          for (_x3 = _xMid; _x3 <= _x22; ++_x3) {
            for (_y3 = _yMid; _y3 <= _y22; ++_y3) {
              result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
              if (result) {
                [d.x, d.y, maxSize, labelPlaced] = result;
              }
            }
          }
          if (!labelPlaced && !avoidBaseMark) {
            areaWidth = Math.abs(x2 - x12 + y2 - y12);
            x3 = (x12 + x2) / 2;
            y3 = (y12 + y2) / 2;
            if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
              maxAreaWidth = areaWidth;
              d.x = x3;
              d.y = y3;
              labelPlaced2 = true;
            }
          }
        }
        if (labelPlaced || labelPlaced2) {
          x3 = textWidth / 2;
          y3 = textHeight / 2;
          bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
          d.align = "center";
          d.baseline = "middle";
          return true;
        } else {
          return false;
        }
      };
    }
    const X_DIR = [-1, -1, 1, 1];
    const Y_DIR = [-1, 1, -1, 1];
    function placeAreaLabelFloodFill($2, bitmaps, avoidBaseMark, markIndex) {
      const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $2.bitmap();
      return function(d) {
        const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack2 = [];
        let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x3, _y3, lo, hi, mid, areaWidth;
        for (let i = 0; i < n; ++i) {
          x12 = items[i].x;
          y12 = items[i].y;
          x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
          y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
          stack2.push([$2((x12 + x2) / 2), $2((y12 + y2) / 2)]);
          while (stack2.length) {
            [_x3, _y3] = stack2.pop();
            if (bm0.get(_x3, _y3) || bm1.get(_x3, _y3) || bm2.get(_x3, _y3))
              continue;
            bm2.set(_x3, _y3);
            for (let j = 0; j < 4; ++j) {
              x3 = _x3 + X_DIR[j];
              y3 = _y3 + Y_DIR[j];
              if (!bm2.outOfBounds(x3, y3, x3, y3))
                stack2.push([x3, y3]);
            }
            x3 = $2.invert(_x3);
            y3 = $2.invert(_y3);
            lo = maxSize;
            hi = height2;
            if (!outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
              while (hi - lo >= 1) {
                mid = (lo + hi) / 2;
                if (collision($2, x3, y3, textHeight, textWidth, mid, bm0, bm1)) {
                  hi = mid;
                } else {
                  lo = mid;
                }
              }
              if (lo > maxSize) {
                d.x = x3;
                d.y = y3;
                maxSize = lo;
                labelPlaced = true;
              }
            }
          }
          if (!labelPlaced && !avoidBaseMark) {
            areaWidth = Math.abs(x2 - x12 + y2 - y12);
            x3 = (x12 + x2) / 2;
            y3 = (y12 + y2) / 2;
            if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
              maxAreaWidth = areaWidth;
              d.x = x3;
              d.y = y3;
              labelPlaced2 = true;
            }
          }
        }
        if (labelPlaced || labelPlaced2) {
          x3 = textWidth / 2;
          y3 = textHeight / 2;
          bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
          d.align = "center";
          d.baseline = "middle";
          return true;
        } else {
          return false;
        }
      };
    }
    const Aligns = ["right", "center", "left"], Baselines = ["bottom", "middle", "top"];
    function placeMarkLabel($2, bitmaps, anchors, offsets2) {
      const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
      return function(d) {
        const boundary = d.boundary, textHeight = d.datum.fontSize;
        if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
          return false;
        }
        let textWidth = d.textWidth ?? 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x2, y12, y2, xc, yc, _x1, _x22, _y1, _y22;
        for (let i = 0; i < n; ++i) {
          dx = (anchors[i] & 3) - 1;
          dy = (anchors[i] >>> 2 & 3) - 1;
          isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
          sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
          insideFactor = offsets2[i] < 0 ? -1 : 1;
          x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
          yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
          y12 = yc - textHeight / 2;
          y2 = yc + textHeight / 2;
          _x1 = $2(x12);
          _y1 = $2(y12);
          _y22 = $2(y2);
          if (!textWidth) {
            if (!test(_x1, _x1, _y1, _y22, bm0, bm1, x12, x12, y12, y2, boundary, isInside)) {
              continue;
            } else {
              textWidth = textMetrics.width(d.datum, d.datum.text);
            }
          }
          xc = x12 + insideFactor * textWidth * dx / 2;
          x12 = xc - textWidth / 2;
          x2 = xc + textWidth / 2;
          _x1 = $2(x12);
          _x22 = $2(x2);
          if (test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside)) {
            d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x12;
            d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y12;
            d.align = Aligns[dx * insideFactor + 1];
            d.baseline = Baselines[dy * insideFactor + 1];
            bm0.setRange(_x1, _y1, _x22, _y22);
            return true;
          }
        }
        return false;
      };
    }
    function test(_x1, _x22, _y1, _y22, bm0, bm1, x12, x2, y12, y2, boundary, isInside) {
      return !(bm0.outOfBounds(_x1, _y1, _x22, _y22) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x22, _y22));
    }
    const TOP = 0, MIDDLE = 4, BOTTOM = 8, LEFT = 0, CENTER$1 = 1, RIGHT = 2;
    const anchorCode = {
      "top-left": TOP + LEFT,
      "top": TOP + CENTER$1,
      "top-right": TOP + RIGHT,
      "left": MIDDLE + LEFT,
      "middle": MIDDLE + CENTER$1,
      "right": MIDDLE + RIGHT,
      "bottom-left": BOTTOM + LEFT,
      "bottom": BOTTOM + CENTER$1,
      "bottom-right": BOTTOM + RIGHT
    };
    const placeAreaLabel = {
      "naive": placeAreaLabelNaive,
      "reduced-search": placeAreaLabelReducedSearch,
      "floodfill": placeAreaLabelFloodFill
    };
    function labelLayout(texts, size2, compare2, offset2, anchor2, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding2, method2) {
      if (!texts.length)
        return texts;
      const positions = Math.max(offset2.length, anchor2.length), offsets2 = getOffsets(offset2, positions), anchors = getAnchors(anchor2, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), infPadding = padding2 === null || padding2 === Infinity, isNaiveGroupArea = isGroupArea && method2 === "naive";
      let maxTextWidth = -1, maxTextHeight = -1;
      const data2 = texts.map((d) => {
        const textWidth = infPadding ? textMetrics.width(d, d.text) : void 0;
        maxTextWidth = Math.max(maxTextWidth, textWidth);
        maxTextHeight = Math.max(maxTextHeight, d.fontSize);
        return {
          datum: d,
          opacity: 0,
          x: void 0,
          y: void 0,
          align: void 0,
          baseline: void 0,
          boundary: boundary(d),
          textWidth
        };
      });
      padding2 = padding2 === null || padding2 === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset2) : padding2;
      const $2 = scaler(size2[0], size2[1], padding2);
      let bitmaps;
      if (!isNaiveGroupArea) {
        if (compare2) {
          data2.sort((a2, b2) => compare2(a2.datum, b2.datum));
        }
        let labelInside = false;
        for (let i = 0; i < anchors.length && !labelInside; ++i) {
          labelInside = anchors[i] === 5 || offsets2[i] < 0;
        }
        const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map((d) => d.datum);
        bitmaps = avoidMarks.length || baseMark ? markBitmaps($2, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($2, avoidBaseMark && data2);
      }
      const place2 = isGroupArea ? placeAreaLabel[method2]($2, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($2, bitmaps, anchors, offsets2);
      data2.forEach((d) => d.opacity = +place2(d));
      return data2;
    }
    function getOffsets(_, count2) {
      const offsets2 = new Float64Array(count2), n = _.length;
      for (let i = 0; i < n; ++i)
        offsets2[i] = _[i] || 0;
      for (let i = n; i < count2; ++i)
        offsets2[i] = offsets2[n - 1];
      return offsets2;
    }
    function getAnchors(_, count2) {
      const anchors = new Int8Array(count2), n = _.length;
      for (let i = 0; i < n; ++i)
        anchors[i] |= anchorCode[_[i]];
      for (let i = n; i < count2; ++i)
        anchors[i] = anchors[n - 1];
      return anchors;
    }
    function markType(item) {
      return item && item.mark && item.mark.marktype;
    }
    function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
      const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
      if (!marktype) {
        return xy;
      } else if (marktype === "line" || marktype === "area") {
        return (d) => xy(d.datum);
      } else if (grouptype === "line") {
        return (d) => {
          const items = d.datum.items[markIndex].items;
          return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
            x: NaN,
            y: NaN
          });
        };
      } else {
        return (d) => {
          const b2 = d.datum.bounds;
          return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
        };
      }
    }
    const Output$1 = ["x", "y", "opacity", "align", "baseline"];
    const Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
    function Label$1(params2) {
      Transform.call(this, null, params2);
    }
    Label$1.Definition = {
      type: "Label",
      metadata: {
        modifies: true
      },
      params: [{
        name: "size",
        type: "number",
        array: true,
        length: 2,
        required: true
      }, {
        name: "sort",
        type: "compare"
      }, {
        name: "anchor",
        type: "string",
        array: true,
        default: Anchors
      }, {
        name: "offset",
        type: "number",
        array: true,
        default: [1]
      }, {
        name: "padding",
        type: "number",
        default: 0,
        null: true
      }, {
        name: "lineAnchor",
        type: "string",
        values: ["start", "end"],
        default: "end"
      }, {
        name: "markIndex",
        type: "number",
        default: 0
      }, {
        name: "avoidBaseMark",
        type: "boolean",
        default: true
      }, {
        name: "avoidMarks",
        type: "data",
        array: true
      }, {
        name: "method",
        type: "string",
        default: "naive"
      }, {
        name: "as",
        type: "string",
        array: true,
        length: Output$1.length,
        default: Output$1
      }]
    };
    inherits(Label$1, Transform, {
      transform(_, pulse2) {
        function modp(param2) {
          const p = _[param2];
          return isFunction(p) && pulse2.modified(p.fields);
        }
        const mod = _.modified();
        if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
          return;
        if (!_.size || _.size.length !== 2) {
          error("Size parameter should be specified as a [width, height] array.");
        }
        const as = _.as || Output$1;
        labelLayout(pulse2.materialize(pulse2.SOURCE).source || [], _.size, _.sort, array$2(_.offset == null ? 1 : _.offset), array$2(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || "end", _.markIndex || 0, _.padding === void 0 ? 0 : _.padding, _.method || "naive").forEach((l) => {
          const t4 = l.datum;
          t4[as[0]] = l.x;
          t4[as[1]] = l.y;
          t4[as[2]] = l.opacity;
          t4[as[3]] = l.align;
          t4[as[4]] = l.baseline;
        });
        return pulse2.reflow(mod).modifies(as);
      }
    });
    const label = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      label: Label$1
    }, Symbol.toStringTag, { value: "Module" }));
    function partition(data2, groupby) {
      var groups = [], get2 = function(f) {
        return f(t4);
      }, map2, i, n, t4, k, g;
      if (groupby == null) {
        groups.push(data2);
      } else {
        for (map2 = {}, i = 0, n = data2.length; i < n; ++i) {
          t4 = data2[i];
          k = groupby.map(get2);
          g = map2[k];
          if (!g) {
            map2[k] = g = [];
            g.dims = k;
            groups.push(g);
          }
          g.push(t4);
        }
      }
      return groups;
    }
    function Loess(params2) {
      Transform.call(this, null, params2);
    }
    Loess.Definition = {
      "type": "Loess",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0.3
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Loess, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source2, _.groupby), names = (_.groupby || []).map(accessorName), m2 = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values2 = [];
          groups.forEach((g) => {
            loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
              const t4 = {};
              for (let i = 0; i < m2; ++i) {
                t4[names[i]] = g.dims[i];
              }
              t4[as[0]] = p[0];
              t4[as[1]] = p[1];
              values2.push(ingest$1(t4));
            });
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values2;
        }
        return out;
      }
    });
    const Methods = {
      constant,
      linear,
      log: log$1,
      exp,
      pow,
      quad,
      poly
    };
    const degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
    function Regression(params2) {
      Transform.call(this, null, params2);
    }
    Regression.Definition = {
      "type": "Regression",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "method",
        "type": "string",
        "default": "linear",
        "values": Object.keys(Methods)
      }, {
        "name": "order",
        "type": "number",
        "default": 3
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "params",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Regression, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source2 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source2, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order == null ? 3 : _.order, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit2 = Methods[method2], values2 = [];
          let domain2 = _.extent;
          if (!has$1(Methods, method2)) {
            error("Invalid regression method: " + method2);
          }
          if (domain2 != null) {
            if (method2 === "log" && domain2[0] <= 0) {
              pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
              domain2 = null;
            }
          }
          groups.forEach((g) => {
            const n = g.length;
            if (n <= dof) {
              pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
              return;
            }
            const model = fit2(g, _.x, _.y, order);
            if (_.params) {
              values2.push(ingest$1({
                keys: g.dims,
                coef: model.coef,
                rSquared: model.rSquared
              }));
              return;
            }
            const dom = domain2 || extent(g, _.x), add2 = (p) => {
              const t4 = {};
              for (let i = 0; i < names.length; ++i) {
                t4[names[i]] = g.dims[i];
              }
              t4[as[0]] = p[0];
              t4[as[1]] = p[1];
              values2.push(ingest$1(t4));
            };
            if (method2 === "linear" || method2 === "constant") {
              dom.forEach((x2) => add2([x2, model.predict(x2)]));
            } else {
              sampleCurve(model.predict, dom, 25, 200).forEach(add2);
            }
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values2;
        }
        return out;
      }
    });
    const reg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      loess: Loess,
      regression: Regression
    }, Symbol.toStringTag, { value: "Module" }));
    function Voronoi(params2) {
      Transform.call(this, null, params2);
    }
    Voronoi.Definition = {
      "type": "Voronoi",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "extent",
        "type": "array",
        "array": true,
        "length": 2,
        "default": [[-1e5, -1e5], [1e5, 1e5]],
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
    inherits(Voronoi, Transform, {
      transform(_, pulse2) {
        const as = _.as || "path", data2 = pulse2.source;
        if (!data2 || !data2.length)
          return pulse2;
        let s = _.size;
        s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
        const voronoi2 = this.value = Delaunay.from(data2, _.x, _.y).voronoi(s);
        for (let i = 0, n = data2.length; i < n; ++i) {
          const polygon = voronoi2.cellPolygon(i);
          data2[i][as] = polygon && !isPoint(polygon) ? toPathString(polygon) : null;
        }
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    function toPathString(p) {
      const x2 = p[0][0], y2 = p[0][1];
      let n = p.length - 1;
      for (; p[n][0] === x2 && p[n][1] === y2; --n)
        ;
      return "M" + p.slice(0, n + 1).join("L") + "Z";
    }
    function isPoint(p) {
      return p.length === 2 && p[0][0] === p[1][0] && p[0][1] === p[1][1];
    }
    const voronoi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      voronoi: Voronoi
    }, Symbol.toStringTag, { value: "Module" }));
    var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
    function cloud() {
      var size2 = [256, 256], text2, font2, fontSize2, fontStyle, fontWeight2, rotate2, padding2, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
      cloud2.layout = function() {
        var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size2[0] >> 5) * size2[1]), bounds2 = null, n = words.length, i = -1, tags = [], data2 = words.map((d2) => ({
          text: text2(d2),
          font: font2(d2),
          style: fontStyle(d2),
          weight: fontWeight2(d2),
          rotate: rotate2(d2),
          size: ~~(fontSize2(d2) + 1e-14),
          padding: padding2(d2),
          xoff: 0,
          yoff: 0,
          x1: 0,
          y1: 0,
          x0: 0,
          y0: 0,
          hasText: false,
          sprite: null,
          datum: d2
        })).sort((a2, b2) => b2.size - a2.size);
        while (++i < n) {
          var d = data2[i];
          d.x = size2[0] * (random2() + 0.5) >> 1;
          d.y = size2[1] * (random2() + 0.5) >> 1;
          cloudSprite(contextAndRatio, d, data2, i);
          if (d.hasText && place2(board, d, bounds2)) {
            tags.push(d);
            if (bounds2)
              cloudBounds(bounds2, d);
            else
              bounds2 = [{
                x: d.x + d.x0,
                y: d.y + d.y0
              }, {
                x: d.x + d.x1,
                y: d.y + d.y1
              }];
            d.x -= size2[0] >> 1;
            d.y -= size2[1] >> 1;
          }
        }
        return tags;
      };
      function getContext2(canvas) {
        canvas.width = canvas.height = 1;
        var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
        canvas.width = (cw << 5) / ratio;
        canvas.height = ch / ratio;
        var context2 = canvas.getContext("2d");
        context2.fillStyle = context2.strokeStyle = "red";
        context2.textAlign = "center";
        return {
          context: context2,
          ratio
        };
      }
      function place2(board, tag2, bounds2) {
        var startX = tag2.x, startY = tag2.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s = spiral(size2), dt = random2() < 0.5 ? 1 : -1, t4 = -dt, dxdy, dx, dy;
        while (dxdy = s(t4 += dt)) {
          dx = ~~dxdy[0];
          dy = ~~dxdy[1];
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
            break;
          tag2.x = startX + dx;
          tag2.y = startY + dy;
          if (tag2.x + tag2.x0 < 0 || tag2.y + tag2.y0 < 0 || tag2.x + tag2.x1 > size2[0] || tag2.y + tag2.y1 > size2[1])
            continue;
          if (!bounds2 || !cloudCollide(tag2, board, size2[0])) {
            if (!bounds2 || collideRects(tag2, bounds2)) {
              var sprite = tag2.sprite, w2 = tag2.width >> 5, sw = size2[0] >> 5, lx2 = tag2.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag2.y1 - tag2.y0, x2 = (tag2.y + tag2.y0) * sw + (lx2 >> 5), last2;
              for (var j = 0; j < h2; j++) {
                last2 = 0;
                for (var i = 0; i <= w2; i++) {
                  board[x2 + i] |= last2 << msx | (i < w2 ? (last2 = sprite[j * w2 + i]) >>> sx : 0);
                }
                x2 += sw;
              }
              tag2.sprite = null;
              return true;
            }
          }
        }
        return false;
      }
      cloud2.words = function(_) {
        if (arguments.length) {
          words = _;
          return cloud2;
        } else {
          return words;
        }
      };
      cloud2.size = function(_) {
        if (arguments.length) {
          size2 = [+_[0], +_[1]];
          return cloud2;
        } else {
          return size2;
        }
      };
      cloud2.font = function(_) {
        if (arguments.length) {
          font2 = functor(_);
          return cloud2;
        } else {
          return font2;
        }
      };
      cloud2.fontStyle = function(_) {
        if (arguments.length) {
          fontStyle = functor(_);
          return cloud2;
        } else {
          return fontStyle;
        }
      };
      cloud2.fontWeight = function(_) {
        if (arguments.length) {
          fontWeight2 = functor(_);
          return cloud2;
        } else {
          return fontWeight2;
        }
      };
      cloud2.rotate = function(_) {
        if (arguments.length) {
          rotate2 = functor(_);
          return cloud2;
        } else {
          return rotate2;
        }
      };
      cloud2.text = function(_) {
        if (arguments.length) {
          text2 = functor(_);
          return cloud2;
        } else {
          return text2;
        }
      };
      cloud2.spiral = function(_) {
        if (arguments.length) {
          spiral = spirals[_] || _;
          return cloud2;
        } else {
          return spiral;
        }
      };
      cloud2.fontSize = function(_) {
        if (arguments.length) {
          fontSize2 = functor(_);
          return cloud2;
        } else {
          return fontSize2;
        }
      };
      cloud2.padding = function(_) {
        if (arguments.length) {
          padding2 = functor(_);
          return cloud2;
        } else {
          return padding2;
        }
      };
      cloud2.random = function(_) {
        if (arguments.length) {
          random2 = _;
          return cloud2;
        } else {
          return random2;
        }
      };
      return cloud2;
    }
    function cloudSprite(contextAndRatio, d, data2, di) {
      if (d.sprite)
        return;
      var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
      c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
      var x2 = 0, y2 = 0, maxh = 0, n = data2.length, w2, w32, h2, i, j;
      --di;
      while (++di < n) {
        d = data2[di];
        c2.save();
        c2.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
        w2 = c2.measureText(d.text + "m").width * ratio;
        h2 = d.size << 1;
        if (d.rotate) {
          var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w2 * cr2, wsr = w2 * sr, hcr = h2 * cr2, hsr = h2 * sr;
          w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
          h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
        } else {
          w2 = w2 + 31 >> 5 << 5;
        }
        if (h2 > maxh)
          maxh = h2;
        if (x2 + w2 >= cw << 5) {
          x2 = 0;
          y2 += maxh;
          maxh = 0;
        }
        if (y2 + h2 >= ch)
          break;
        c2.translate((x2 + (w2 >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
        if (d.rotate)
          c2.rotate(d.rotate * cloudRadians);
        c2.fillText(d.text, 0, 0);
        if (d.padding) {
          c2.lineWidth = 2 * d.padding;
          c2.strokeText(d.text, 0, 0);
        }
        c2.restore();
        d.width = w2;
        d.height = h2;
        d.xoff = x2;
        d.yoff = y2;
        d.x1 = w2 >> 1;
        d.y1 = h2 >> 1;
        d.x0 = -d.x1;
        d.y0 = -d.y1;
        d.hasText = true;
        x2 += w2;
      }
      var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
      while (--di >= 0) {
        d = data2[di];
        if (!d.hasText)
          continue;
        w2 = d.width;
        w32 = w2 >> 5;
        h2 = d.y1 - d.y0;
        for (i = 0; i < h2 * w32; i++)
          sprite[i] = 0;
        x2 = d.xoff;
        if (x2 == null)
          return;
        y2 = d.yoff;
        var seen = 0, seenRow = -1;
        for (j = 0; j < h2; j++) {
          for (i = 0; i < w2; i++) {
            var k = w32 * j + (i >> 5), m2 = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
            sprite[k] |= m2;
            seen |= m2;
          }
          if (seen)
            seenRow = j;
          else {
            d.y0++;
            h2--;
            j--;
            y2++;
          }
        }
        d.y1 = d.y0 + seenRow;
        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
      }
    }
    function cloudCollide(tag2, board, sw) {
      sw >>= 5;
      var sprite = tag2.sprite, w2 = tag2.width >> 5, lx2 = tag2.x - (w2 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag2.y1 - tag2.y0, x2 = (tag2.y + tag2.y0) * sw + (lx2 >> 5), last2;
      for (var j = 0; j < h2; j++) {
        last2 = 0;
        for (var i = 0; i <= w2; i++) {
          if ((last2 << msx | (i < w2 ? (last2 = sprite[j * w2 + i]) >>> sx : 0)) & board[x2 + i])
            return true;
        }
        x2 += sw;
      }
      return false;
    }
    function cloudBounds(bounds2, d) {
      var b0 = bounds2[0], b1 = bounds2[1];
      if (d.x + d.x0 < b0.x)
        b0.x = d.x + d.x0;
      if (d.y + d.y0 < b0.y)
        b0.y = d.y + d.y0;
      if (d.x + d.x1 > b1.x)
        b1.x = d.x + d.x1;
      if (d.y + d.y1 > b1.y)
        b1.y = d.y + d.y1;
    }
    function collideRects(a2, b2) {
      return a2.x + a2.x1 > b2[0].x && a2.x + a2.x0 < b2[1].x && a2.y + a2.y1 > b2[0].y && a2.y + a2.y0 < b2[1].y;
    }
    function archimedeanSpiral(size2) {
      var e3 = size2[0] / size2[1];
      return function(t4) {
        return [e3 * (t4 *= 0.1) * Math.cos(t4), t4 * Math.sin(t4)];
      };
    }
    function rectangularSpiral(size2) {
      var dy = 4, dx = dy * size2[0] / size2[1], x2 = 0, y2 = 0;
      return function(t4) {
        var sign2 = t4 < 0 ? -1 : 1;
        switch (Math.sqrt(1 + 4 * sign2 * t4) - sign2 & 3) {
          case 0:
            x2 += dx;
            break;
          case 1:
            y2 += dy;
            break;
          case 2:
            x2 -= dx;
            break;
          default:
            y2 -= dy;
            break;
        }
        return [x2, y2];
      };
    }
    function zeroArray(n) {
      var a2 = [], i = -1;
      while (++i < n)
        a2[i] = 0;
      return a2;
    }
    function functor(d) {
      return typeof d === "function" ? d : function() {
        return d;
      };
    }
    var spirals = {
      archimedean: archimedeanSpiral,
      rectangular: rectangularSpiral
    };
    const Output = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
    const Params$1 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
    function Wordcloud(params2) {
      Transform.call(this, cloud(), params2);
    }
    Wordcloud.Definition = {
      "type": "Wordcloud",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "font",
        "type": "string",
        "expr": true,
        "default": "sans-serif"
      }, {
        "name": "fontStyle",
        "type": "string",
        "expr": true,
        "default": "normal"
      }, {
        "name": "fontWeight",
        "type": "string",
        "expr": true,
        "default": "normal"
      }, {
        "name": "fontSize",
        "type": "number",
        "expr": true,
        "default": 14
      }, {
        "name": "fontSizeRange",
        "type": "number",
        "array": "nullable",
        "default": [10, 50]
      }, {
        "name": "rotate",
        "type": "number",
        "expr": true,
        "default": 0
      }, {
        "name": "text",
        "type": "field"
      }, {
        "name": "spiral",
        "type": "string",
        "values": ["archimedean", "rectangular"]
      }, {
        "name": "padding",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 7,
        "default": Output
      }]
    };
    inherits(Wordcloud, Transform, {
      transform(_, pulse2) {
        if (_.size && !(_.size[0] && _.size[1])) {
          error("Wordcloud size dimensions must be non-zero.");
        }
        function modp(param2) {
          const p = _[param2];
          return isFunction(p) && pulse2.modified(p.fields);
        }
        const mod = _.modified();
        if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params$1.some(modp)))
          return;
        const data2 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output;
        let fontSize2 = _.fontSize || 14, range2;
        isFunction(fontSize2) ? range2 = _.fontSizeRange : fontSize2 = constant$1(fontSize2);
        if (range2) {
          const fsize = fontSize2, sizeScale = scale$4("sqrt")().domain(extent(data2, fsize)).range(range2);
          fontSize2 = (x2) => sizeScale(fsize(x2));
        }
        data2.forEach((t4) => {
          t4[as[0]] = NaN;
          t4[as[1]] = NaN;
          t4[as[3]] = 0;
        });
        const words = layout.words(data2).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
        const size2 = layout.size(), dx = size2[0] >> 1, dy = size2[1] >> 1, n = words.length;
        for (let i = 0, w2, t4; i < n; ++i) {
          w2 = words[i];
          t4 = w2.datum;
          t4[as[0]] = w2.x + dx;
          t4[as[1]] = w2.y + dy;
          t4[as[2]] = w2.font;
          t4[as[3]] = w2.size;
          t4[as[4]] = w2.style;
          t4[as[5]] = w2.weight;
          t4[as[6]] = w2.rotate;
        }
        return pulse2.reflow(mod).modifies(as);
      }
    });
    const wordcloud = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      wordcloud: Wordcloud
    }, Symbol.toStringTag, { value: "Module" }));
    const array8 = (n) => new Uint8Array(n);
    const array16 = (n) => new Uint16Array(n);
    const array32 = (n) => new Uint32Array(n);
    function Bitmaps() {
      let width2 = 8, data2 = [], seen = array32(0), curr = array$1(0, width2), prev2 = array$1(0, width2);
      return {
        data: () => data2,
        seen: () => seen = lengthen(seen, data2.length),
        add(array2) {
          for (let i = 0, j = data2.length, n = array2.length, t4; i < n; ++i) {
            t4 = array2[i];
            t4._index = j++;
            data2.push(t4);
          }
        },
        remove(num, map2) {
          const n = data2.length, copy2 = Array(n - num), reindex = data2;
          let t4, i, j;
          for (i = 0; !map2[i] && i < n; ++i) {
            copy2[i] = data2[i];
            reindex[i] = i;
          }
          for (j = i; i < n; ++i) {
            t4 = data2[i];
            if (!map2[i]) {
              reindex[i] = j;
              curr[j] = curr[i];
              prev2[j] = prev2[i];
              copy2[j] = t4;
              t4._index = j++;
            } else {
              reindex[i] = -1;
            }
            curr[i] = 0;
          }
          data2 = copy2;
          return reindex;
        },
        size: () => data2.length,
        curr: () => curr,
        prev: () => prev2,
        reset: (k) => prev2[k] = curr[k],
        all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
        set(k, one2) {
          curr[k] |= one2;
        },
        clear(k, one2) {
          curr[k] &= ~one2;
        },
        resize(n, m2) {
          const k = curr.length;
          if (n > k || m2 > width2) {
            width2 = Math.max(m2, width2);
            curr = array$1(n, width2, curr);
            prev2 = array$1(n, width2);
          }
        }
      };
    }
    function lengthen(array2, length2, copy2) {
      if (array2.length >= length2)
        return array2;
      copy2 = copy2 || new array2.constructor(length2);
      copy2.set(array2);
      return copy2;
    }
    function array$1(n, m2, array2) {
      const copy2 = (m2 < 257 ? array8 : m2 < 65537 ? array16 : array32)(n);
      if (array2)
        copy2.set(array2);
      return copy2;
    }
    function Dimension(index2, i, query) {
      const bit = 1 << i;
      return {
        one: bit,
        zero: ~bit,
        range: query.slice(),
        bisect: index2.bisect,
        index: index2.index,
        size: index2.size,
        onAdd(added, curr) {
          const dim = this, range2 = dim.bisect(dim.range, added.value), idx = added.index, lo = range2[0], hi = range2[1], n1 = idx.length;
          let i2;
          for (i2 = 0; i2 < lo; ++i2)
            curr[idx[i2]] |= bit;
          for (i2 = hi; i2 < n1; ++i2)
            curr[idx[i2]] |= bit;
          return dim;
        }
      };
    }
    function SortedIndex() {
      let index2 = array32(0), value2 = [], size2 = 0;
      function insert2(key2, data2, base2) {
        if (!data2.length)
          return [];
        const n0 = size2, n1 = data2.length, addi = array32(n1);
        let addv = Array(n1), oldv, oldi, i;
        for (i = 0; i < n1; ++i) {
          addv[i] = key2(data2[i]);
          addi[i] = i;
        }
        addv = sort(addv, addi);
        if (n0) {
          oldv = value2;
          oldi = index2;
          value2 = Array(n0 + n1);
          index2 = array32(n0 + n1);
          merge$1(base2, oldv, oldi, n0, addv, addi, n1, value2, index2);
        } else {
          if (base2 > 0)
            for (i = 0; i < n1; ++i) {
              addi[i] += base2;
            }
          value2 = addv;
          index2 = addi;
        }
        size2 = n0 + n1;
        return {
          index: addi,
          value: addv
        };
      }
      function remove2(num, map2) {
        const n = size2;
        let idx, i, j;
        for (i = 0; !map2[index2[i]] && i < n; ++i)
          ;
        for (j = i; i < n; ++i) {
          if (!map2[idx = index2[i]]) {
            index2[j] = idx;
            value2[j] = value2[i];
            ++j;
          }
        }
        size2 = n - num;
      }
      function reindex(map2) {
        for (let i = 0, n = size2; i < n; ++i) {
          index2[i] = map2[index2[i]];
        }
      }
      function bisect2(range2, array2) {
        let n;
        if (array2) {
          n = array2.length;
        } else {
          array2 = value2;
          n = size2;
        }
        return [bisectLeft$1(array2, range2[0], 0, n), bisectRight$1(array2, range2[1], 0, n)];
      }
      return {
        insert: insert2,
        remove: remove2,
        bisect: bisect2,
        reindex,
        index: () => index2,
        size: () => size2
      };
    }
    function sort(values2, index2) {
      values2.sort.call(index2, (a2, b2) => {
        const x2 = values2[a2], y2 = values2[b2];
        return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
      });
      return permute(values2, index2);
    }
    function merge$1(base2, value0, index0, n0, value1, index1, n1, value2, index2) {
      let i0 = 0, i1 = 0, i;
      for (i = 0; i0 < n0 && i1 < n1; ++i) {
        if (value0[i0] < value1[i1]) {
          value2[i] = value0[i0];
          index2[i] = index0[i0++];
        } else {
          value2[i] = value1[i1];
          index2[i] = index1[i1++] + base2;
        }
      }
      for (; i0 < n0; ++i0, ++i) {
        value2[i] = value0[i0];
        index2[i] = index0[i0];
      }
      for (; i1 < n1; ++i1, ++i) {
        value2[i] = value1[i1];
        index2[i] = index1[i1] + base2;
      }
    }
    function CrossFilter(params2) {
      Transform.call(this, Bitmaps(), params2);
      this._indices = null;
      this._dims = null;
    }
    CrossFilter.Definition = {
      "type": "CrossFilter",
      "metadata": {},
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "query",
        "type": "array",
        "array": true,
        "required": true,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }]
    };
    inherits(CrossFilter, Transform, {
      transform(_, pulse2) {
        if (!this._dims) {
          return this.init(_, pulse2);
        } else {
          var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
          return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
        }
      },
      init(_, pulse2) {
        const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m2 = query.length;
        let i = 0, key2, index2;
        for (; i < m2; ++i) {
          key2 = fields[i].fname;
          index2 = indices[key2] || (indices[key2] = SortedIndex());
          dims.push(Dimension(index2, i, query[i]));
        }
        return this.eval(_, pulse2);
      },
      reinit(_, pulse2) {
        const output2 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev2 = bits.prev(), all = bits.all(), out = output2.rem = output2.add, mod = output2.mod, m2 = query.length, adds = {};
        let add2, index2, key2, mods, remMap, modMap, i, n, f;
        prev2.set(curr);
        if (pulse2.rem.length) {
          remMap = this.remove(_, pulse2, output2);
        }
        if (pulse2.add.length) {
          bits.add(pulse2.add);
        }
        if (pulse2.mod.length) {
          modMap = {};
          for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
            modMap[mods[i]._index] = 1;
          }
        }
        for (i = 0; i < m2; ++i) {
          f = fields[i];
          if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
            key2 = f.fname;
            if (!(add2 = adds[key2])) {
              indices[key2] = index2 = SortedIndex();
              adds[key2] = add2 = index2.insert(f, pulse2.source, 0);
            }
            dims[i] = Dimension(index2, i, query[i]).onAdd(add2, curr);
          }
        }
        for (i = 0, n = bits.data().length; i < n; ++i) {
          if (remMap[i]) {
            continue;
          } else if (prev2[i] !== curr[i]) {
            out.push(i);
          } else if (modMap[i] && curr[i] !== all) {
            mod.push(i);
          }
        }
        bits.mask = (1 << m2) - 1;
        return output2;
      },
      eval(_, pulse2) {
        const output2 = pulse2.materialize().fork(), m2 = this._dims.length;
        let mask = 0;
        if (pulse2.rem.length) {
          this.remove(_, pulse2, output2);
          mask |= (1 << m2) - 1;
        }
        if (_.modified("query") && !_.modified("fields")) {
          mask |= this.update(_, pulse2, output2);
        }
        if (pulse2.add.length) {
          this.insert(_, pulse2, output2);
          mask |= (1 << m2) - 1;
        }
        if (pulse2.mod.length) {
          this.modify(pulse2, output2);
          mask |= (1 << m2) - 1;
        }
        this.value.mask = mask;
        return output2;
      },
      insert(_, pulse2, output2) {
        const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output2.add, n = bits.size() + tuples.length, m2 = dims.length;
        let k = bits.size(), j, key2, add2;
        bits.resize(n, m2);
        bits.add(tuples);
        const curr = bits.curr(), prev2 = bits.prev(), all = bits.all();
        for (j = 0; j < m2; ++j) {
          key2 = fields[j].fname;
          add2 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k));
          dims[j].onAdd(add2, curr);
        }
        for (; k < n; ++k) {
          prev2[k] = all;
          if (curr[k] !== all)
            out.push(k);
        }
      },
      modify(pulse2, output2) {
        const out = output2.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
        let i, n, k;
        for (i = 0, n = tuples.length; i < n; ++i) {
          k = tuples[i]._index;
          if (curr[k] !== all)
            out.push(k);
        }
      },
      remove(_, pulse2, output2) {
        const indices = this._indices, bits = this.value, curr = bits.curr(), prev2 = bits.prev(), all = bits.all(), map2 = {}, out = output2.rem, tuples = pulse2.rem;
        let i, n, k, f;
        for (i = 0, n = tuples.length; i < n; ++i) {
          k = tuples[i]._index;
          map2[k] = 1;
          prev2[k] = f = curr[k];
          curr[k] = all;
          if (f !== all)
            out.push(k);
        }
        for (k in indices) {
          indices[k].remove(n, map2);
        }
        this.reindex(pulse2, n, map2);
        return map2;
      },
      // reindex filters and indices after propagation completes
      reindex(pulse2, num, map2) {
        const indices = this._indices, bits = this.value;
        pulse2.runAfter(() => {
          const indexMap = bits.remove(num, map2);
          for (const key2 in indices)
            indices[key2].reindex(indexMap);
        });
      },
      update(_, pulse2, output2) {
        const dims = this._dims, query = _.query, stamp = pulse2.stamp, m2 = dims.length;
        let mask = 0, i, q;
        output2.filters = 0;
        for (q = 0; q < m2; ++q) {
          if (_.modified("query", q)) {
            i = q;
            ++mask;
          }
        }
        if (mask === 1) {
          mask = dims[i].one;
          this.incrementOne(dims[i], query[i], output2.add, output2.rem);
        } else {
          for (q = 0, mask = 0; q < m2; ++q) {
            if (!_.modified("query", q))
              continue;
            mask |= dims[q].one;
            this.incrementAll(dims[q], query[q], stamp, output2.add);
            output2.rem = output2.add;
          }
        }
        return mask;
      },
      incrementAll(dim, query, stamp, out) {
        const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev2 = bits.prev(), index2 = dim.index(), old = dim.bisect(dim.range), range2 = dim.bisect(query), lo1 = range2[0], hi1 = range2[1], lo0 = old[0], hi0 = old[1], one2 = dim.one;
        let i, j, k;
        if (lo1 < lo0) {
          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
            k = index2[i];
            if (seen[k] !== stamp) {
              prev2[k] = curr[k];
              seen[k] = stamp;
              out.push(k);
            }
            curr[k] ^= one2;
          }
        } else if (lo1 > lo0) {
          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
            k = index2[i];
            if (seen[k] !== stamp) {
              prev2[k] = curr[k];
              seen[k] = stamp;
              out.push(k);
            }
            curr[k] ^= one2;
          }
        }
        if (hi1 > hi0) {
          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
            k = index2[i];
            if (seen[k] !== stamp) {
              prev2[k] = curr[k];
              seen[k] = stamp;
              out.push(k);
            }
            curr[k] ^= one2;
          }
        } else if (hi1 < hi0) {
          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
            k = index2[i];
            if (seen[k] !== stamp) {
              prev2[k] = curr[k];
              seen[k] = stamp;
              out.push(k);
            }
            curr[k] ^= one2;
          }
        }
        dim.range = query.slice();
      },
      incrementOne(dim, query, add2, rem2) {
        const bits = this.value, curr = bits.curr(), index2 = dim.index(), old = dim.bisect(dim.range), range2 = dim.bisect(query), lo1 = range2[0], hi1 = range2[1], lo0 = old[0], hi0 = old[1], one2 = dim.one;
        let i, j, k;
        if (lo1 < lo0) {
          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
            k = index2[i];
            curr[k] ^= one2;
            add2.push(k);
          }
        } else if (lo1 > lo0) {
          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
            k = index2[i];
            curr[k] ^= one2;
            rem2.push(k);
          }
        }
        if (hi1 > hi0) {
          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
            k = index2[i];
            curr[k] ^= one2;
            add2.push(k);
          }
        } else if (hi1 < hi0) {
          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
            k = index2[i];
            curr[k] ^= one2;
            rem2.push(k);
          }
        }
        dim.range = query.slice();
      }
    });
    function ResolveFilter(params2) {
      Transform.call(this, null, params2);
    }
    ResolveFilter.Definition = {
      "type": "ResolveFilter",
      "metadata": {},
      "params": [{
        "name": "ignore",
        "type": "number",
        "required": true,
        "description": "A bit mask indicating which filters to ignore."
      }, {
        "name": "filter",
        "type": "object",
        "required": true,
        "description": "Per-tuple filter bitmaps from a CrossFilter transform."
      }]
    };
    inherits(ResolveFilter, Transform, {
      transform(_, pulse2) {
        const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
        if ((mask & ignore) === 0)
          return pulse2.StopPropagation;
        const output2 = pulse2.fork(pulse2.ALL), data2 = bitmap.data(), curr = bitmap.curr(), prev2 = bitmap.prev(), pass = (k) => !(curr[k] & ignore) ? data2[k] : null;
        output2.filter(output2.MOD, pass);
        if (!(mask & mask - 1)) {
          output2.filter(output2.ADD, pass);
          output2.filter(output2.REM, (k) => (curr[k] & ignore) === mask ? data2[k] : null);
        } else {
          output2.filter(output2.ADD, (k) => {
            const c2 = curr[k] & ignore, f = !c2 && c2 ^ prev2[k] & ignore;
            return f ? data2[k] : null;
          });
          output2.filter(output2.REM, (k) => {
            const c2 = curr[k] & ignore, f = c2 && !(c2 ^ (c2 ^ prev2[k] & ignore));
            return f ? data2[k] : null;
          });
        }
        return output2.filter(output2.SOURCE, (t4) => pass(t4._index));
      }
    });
    const xf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      crossfilter: CrossFilter,
      resolvefilter: ResolveFilter
    }, Symbol.toStringTag, { value: "Module" }));
    const RawCode = "RawCode";
    const Literal = "Literal";
    const Property = "Property";
    const Identifier = "Identifier";
    const ArrayExpression = "ArrayExpression";
    const BinaryExpression = "BinaryExpression";
    const CallExpression = "CallExpression";
    const ConditionalExpression = "ConditionalExpression";
    const LogicalExpression = "LogicalExpression";
    const MemberExpression = "MemberExpression";
    const ObjectExpression = "ObjectExpression";
    const UnaryExpression = "UnaryExpression";
    function ASTNode(type2) {
      this.type = type2;
    }
    ASTNode.prototype.visit = function(visitor) {
      let c2, i, n;
      if (visitor(this))
        return 1;
      for (c2 = children(this), i = 0, n = c2.length; i < n; ++i) {
        if (c2[i].visit(visitor))
          return 1;
      }
    };
    function children(node) {
      switch (node.type) {
        case ArrayExpression:
          return node.elements;
        case BinaryExpression:
        case LogicalExpression:
          return [node.left, node.right];
        case CallExpression:
          return [node.callee].concat(node.arguments);
        case ConditionalExpression:
          return [node.test, node.consequent, node.alternate];
        case MemberExpression:
          return [node.object, node.property];
        case ObjectExpression:
          return node.properties;
        case Property:
          return [node.key, node.value];
        case UnaryExpression:
          return [node.argument];
        case Identifier:
        case Literal:
        case RawCode:
        default:
          return [];
      }
    }
    var TokenName, source, index, length, lookahead;
    var TokenBooleanLiteral = 1, TokenEOF = 2, TokenIdentifier = 3, TokenKeyword = 4, TokenNullLiteral = 5, TokenNumericLiteral = 6, TokenPunctuator = 7, TokenStringLiteral = 8, TokenRegularExpression = 9;
    TokenName = {};
    TokenName[TokenBooleanLiteral] = "Boolean";
    TokenName[TokenEOF] = "<end>";
    TokenName[TokenIdentifier] = "Identifier";
    TokenName[TokenKeyword] = "Keyword";
    TokenName[TokenNullLiteral] = "Null";
    TokenName[TokenNumericLiteral] = "Numeric";
    TokenName[TokenPunctuator] = "Punctuator";
    TokenName[TokenStringLiteral] = "String";
    TokenName[TokenRegularExpression] = "RegularExpression";
    var SyntaxArrayExpression = "ArrayExpression", SyntaxBinaryExpression = "BinaryExpression", SyntaxCallExpression = "CallExpression", SyntaxConditionalExpression = "ConditionalExpression", SyntaxIdentifier = "Identifier", SyntaxLiteral = "Literal", SyntaxLogicalExpression = "LogicalExpression", SyntaxMemberExpression = "MemberExpression", SyntaxObjectExpression = "ObjectExpression", SyntaxProperty = "Property", SyntaxUnaryExpression = "UnaryExpression";
    var MessageUnexpectedToken = "Unexpected token %0", MessageUnexpectedNumber = "Unexpected number", MessageUnexpectedString = "Unexpected string", MessageUnexpectedIdentifier = "Unexpected identifier", MessageUnexpectedReserved = "Unexpected reserved word", MessageUnexpectedEOS = "Unexpected end of input", MessageInvalidRegExp = "Invalid regular expression", MessageUnterminatedRegExp = "Invalid regular expression: missing /", MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.", MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
    var ILLEGAL$1 = "ILLEGAL", DISABLED = "Disabled.";
    var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    function assert(condition, message) {
      if (!condition) {
        throw new Error("ASSERT: " + message);
      }
    }
    function isDecimalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 57;
    }
    function isHexDigit(ch2) {
      return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
    }
    function isOctalDigit(ch2) {
      return "01234567".indexOf(ch2) >= 0;
    }
    function isWhiteSpace(ch2) {
      return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
    }
    function isLineTerminator(ch2) {
      return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
    }
    function isIdentifierStart(ch2) {
      return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
      ch2 >= 65 && ch2 <= 90 || // A..Z
      ch2 >= 97 && ch2 <= 122 || // a..z
      ch2 === 92 || // \ (backslash)
      ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
    }
    function isIdentifierPart(ch2) {
      return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
      ch2 >= 65 && ch2 <= 90 || // A..Z
      ch2 >= 97 && ch2 <= 122 || // a..z
      ch2 >= 48 && ch2 <= 57 || // 0..9
      ch2 === 92 || // \ (backslash)
      ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
    }
    const keywords$2 = {
      "if": 1,
      "in": 1,
      "do": 1,
      "var": 1,
      "for": 1,
      "new": 1,
      "try": 1,
      "let": 1,
      "this": 1,
      "else": 1,
      "case": 1,
      "void": 1,
      "with": 1,
      "enum": 1,
      "while": 1,
      "break": 1,
      "catch": 1,
      "throw": 1,
      "const": 1,
      "yield": 1,
      "class": 1,
      "super": 1,
      "return": 1,
      "typeof": 1,
      "delete": 1,
      "switch": 1,
      "export": 1,
      "import": 1,
      "public": 1,
      "static": 1,
      "default": 1,
      "finally": 1,
      "extends": 1,
      "package": 1,
      "private": 1,
      "function": 1,
      "continue": 1,
      "debugger": 1,
      "interface": 1,
      "protected": 1,
      "instanceof": 1,
      "implements": 1
    };
    function skipComment() {
      while (index < length) {
        const ch2 = source.charCodeAt(index);
        if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
          ++index;
        } else {
          break;
        }
      }
    }
    function scanHexEscape(prefix) {
      var i, len, ch2, code2 = 0;
      len = prefix === "u" ? 4 : 2;
      for (i = 0; i < len; ++i) {
        if (index < length && isHexDigit(source[index])) {
          ch2 = source[index++];
          code2 = code2 * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
        } else {
          throwError({}, MessageUnexpectedToken, ILLEGAL$1);
        }
      }
      return String.fromCharCode(code2);
    }
    function scanUnicodeCodePointEscape() {
      var ch2, code2, cu1, cu2;
      ch2 = source[index];
      code2 = 0;
      if (ch2 === "}") {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      while (index < length) {
        ch2 = source[index++];
        if (!isHexDigit(ch2)) {
          break;
        }
        code2 = code2 * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
      }
      if (code2 > 1114111 || ch2 !== "}") {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      if (code2 <= 65535) {
        return String.fromCharCode(code2);
      }
      cu1 = (code2 - 65536 >> 10) + 55296;
      cu2 = (code2 - 65536 & 1023) + 56320;
      return String.fromCharCode(cu1, cu2);
    }
    function getEscapedIdentifier() {
      var ch2, id2;
      ch2 = source.charCodeAt(index++);
      id2 = String.fromCharCode(ch2);
      if (ch2 === 92) {
        if (source.charCodeAt(index) !== 117) {
          throwError({}, MessageUnexpectedToken, ILLEGAL$1);
        }
        ++index;
        ch2 = scanHexEscape("u");
        if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
          throwError({}, MessageUnexpectedToken, ILLEGAL$1);
        }
        id2 = ch2;
      }
      while (index < length) {
        ch2 = source.charCodeAt(index);
        if (!isIdentifierPart(ch2)) {
          break;
        }
        ++index;
        id2 += String.fromCharCode(ch2);
        if (ch2 === 92) {
          id2 = id2.substr(0, id2.length - 1);
          if (source.charCodeAt(index) !== 117) {
            throwError({}, MessageUnexpectedToken, ILLEGAL$1);
          }
          ++index;
          ch2 = scanHexEscape("u");
          if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
            throwError({}, MessageUnexpectedToken, ILLEGAL$1);
          }
          id2 += ch2;
        }
      }
      return id2;
    }
    function getIdentifier() {
      var start2, ch2;
      start2 = index++;
      while (index < length) {
        ch2 = source.charCodeAt(index);
        if (ch2 === 92) {
          index = start2;
          return getEscapedIdentifier();
        }
        if (isIdentifierPart(ch2)) {
          ++index;
        } else {
          break;
        }
      }
      return source.slice(start2, index);
    }
    function scanIdentifier() {
      var start2, id2, type2;
      start2 = index;
      id2 = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
      if (id2.length === 1) {
        type2 = TokenIdentifier;
      } else if (keywords$2.hasOwnProperty(id2)) {
        type2 = TokenKeyword;
      } else if (id2 === "null") {
        type2 = TokenNullLiteral;
      } else if (id2 === "true" || id2 === "false") {
        type2 = TokenBooleanLiteral;
      } else {
        type2 = TokenIdentifier;
      }
      return {
        type: type2,
        value: id2,
        start: start2,
        end: index
      };
    }
    function scanPunctuator() {
      var start2 = index, code2 = source.charCodeAt(index), code22, ch1 = source[index], ch2, ch3, ch4;
      switch (code2) {
        case 46:
        case 40:
        case 41:
        case 59:
        case 44:
        case 123:
        case 125:
        case 91:
        case 93:
        case 58:
        case 63:
        case 126:
          ++index;
          return {
            type: TokenPunctuator,
            value: String.fromCharCode(code2),
            start: start2,
            end: index
          };
        default:
          code22 = source.charCodeAt(index + 1);
          if (code22 === 61) {
            switch (code2) {
              case 43:
              case 45:
              case 47:
              case 60:
              case 62:
              case 94:
              case 124:
              case 37:
              case 38:
              case 42:
                index += 2;
                return {
                  type: TokenPunctuator,
                  value: String.fromCharCode(code2) + String.fromCharCode(code22),
                  start: start2,
                  end: index
                };
              case 33:
              case 61:
                index += 2;
                if (source.charCodeAt(index) === 61) {
                  ++index;
                }
                return {
                  type: TokenPunctuator,
                  value: source.slice(start2, index),
                  start: start2,
                  end: index
                };
            }
          }
      }
      ch4 = source.substr(index, 4);
      if (ch4 === ">>>=") {
        index += 4;
        return {
          type: TokenPunctuator,
          value: ch4,
          start: start2,
          end: index
        };
      }
      ch3 = ch4.substr(0, 3);
      if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
        index += 3;
        return {
          type: TokenPunctuator,
          value: ch3,
          start: start2,
          end: index
        };
      }
      ch2 = ch3.substr(0, 2);
      if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
        index += 2;
        return {
          type: TokenPunctuator,
          value: ch2,
          start: start2,
          end: index
        };
      }
      if (ch2 === "//") {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
        ++index;
        return {
          type: TokenPunctuator,
          value: ch1,
          start: start2,
          end: index
        };
      }
      throwError({}, MessageUnexpectedToken, ILLEGAL$1);
    }
    function scanHexLiteral(start2) {
      let number2 = "";
      while (index < length) {
        if (!isHexDigit(source[index])) {
          break;
        }
        number2 += source[index++];
      }
      if (number2.length === 0) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      if (isIdentifierStart(source.charCodeAt(index))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      return {
        type: TokenNumericLiteral,
        value: parseInt("0x" + number2, 16),
        start: start2,
        end: index
      };
    }
    function scanOctalLiteral(start2) {
      let number2 = "0" + source[index++];
      while (index < length) {
        if (!isOctalDigit(source[index])) {
          break;
        }
        number2 += source[index++];
      }
      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      return {
        type: TokenNumericLiteral,
        value: parseInt(number2, 8),
        octal: true,
        start: start2,
        end: index
      };
    }
    function scanNumericLiteral() {
      var number2, start2, ch2;
      ch2 = source[index];
      assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
      start2 = index;
      number2 = "";
      if (ch2 !== ".") {
        number2 = source[index++];
        ch2 = source[index];
        if (number2 === "0") {
          if (ch2 === "x" || ch2 === "X") {
            ++index;
            return scanHexLiteral(start2);
          }
          if (isOctalDigit(ch2)) {
            return scanOctalLiteral(start2);
          }
          if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
            throwError({}, MessageUnexpectedToken, ILLEGAL$1);
          }
        }
        while (isDecimalDigit(source.charCodeAt(index))) {
          number2 += source[index++];
        }
        ch2 = source[index];
      }
      if (ch2 === ".") {
        number2 += source[index++];
        while (isDecimalDigit(source.charCodeAt(index))) {
          number2 += source[index++];
        }
        ch2 = source[index];
      }
      if (ch2 === "e" || ch2 === "E") {
        number2 += source[index++];
        ch2 = source[index];
        if (ch2 === "+" || ch2 === "-") {
          number2 += source[index++];
        }
        if (isDecimalDigit(source.charCodeAt(index))) {
          while (isDecimalDigit(source.charCodeAt(index))) {
            number2 += source[index++];
          }
        } else {
          throwError({}, MessageUnexpectedToken, ILLEGAL$1);
        }
      }
      if (isIdentifierStart(source.charCodeAt(index))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      return {
        type: TokenNumericLiteral,
        value: parseFloat(number2),
        start: start2,
        end: index
      };
    }
    function scanStringLiteral() {
      var str = "", quote, start2, ch2, code2, octal = false;
      quote = source[index];
      assert(quote === "'" || quote === '"', "String literal must starts with a quote");
      start2 = index;
      ++index;
      while (index < length) {
        ch2 = source[index++];
        if (ch2 === quote) {
          quote = "";
          break;
        } else if (ch2 === "\\") {
          ch2 = source[index++];
          if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
            switch (ch2) {
              case "u":
              case "x":
                if (source[index] === "{") {
                  ++index;
                  str += scanUnicodeCodePointEscape();
                } else {
                  str += scanHexEscape(ch2);
                }
                break;
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "b":
                str += "\b";
                break;
              case "f":
                str += "\f";
                break;
              case "v":
                str += "\v";
                break;
              default:
                if (isOctalDigit(ch2)) {
                  code2 = "01234567".indexOf(ch2);
                  if (code2 !== 0) {
                    octal = true;
                  }
                  if (index < length && isOctalDigit(source[index])) {
                    octal = true;
                    code2 = code2 * 8 + "01234567".indexOf(source[index++]);
                    if ("0123".indexOf(ch2) >= 0 && index < length && isOctalDigit(source[index])) {
                      code2 = code2 * 8 + "01234567".indexOf(source[index++]);
                    }
                  }
                  str += String.fromCharCode(code2);
                } else {
                  str += ch2;
                }
                break;
            }
          } else {
            if (ch2 === "\r" && source[index] === "\n") {
              ++index;
            }
          }
        } else if (isLineTerminator(ch2.charCodeAt(0))) {
          break;
        } else {
          str += ch2;
        }
      }
      if (quote !== "") {
        throwError({}, MessageUnexpectedToken, ILLEGAL$1);
      }
      return {
        type: TokenStringLiteral,
        value: str,
        octal,
        start: start2,
        end: index
      };
    }
    function testRegExp(pattern, flags) {
      let tmp = pattern;
      if (flags.indexOf("u") >= 0) {
        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
          if (parseInt($1, 16) <= 1114111) {
            return "x";
          }
          throwError({}, MessageInvalidRegExp);
        }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
      }
      try {
        new RegExp(tmp);
      } catch (e3) {
        throwError({}, MessageInvalidRegExp);
      }
      try {
        return new RegExp(pattern, flags);
      } catch (exception) {
        return null;
      }
    }
    function scanRegExpBody() {
      var ch2, str, classMarker, terminated, body;
      ch2 = source[index];
      assert(ch2 === "/", "Regular expression literal must start with a slash");
      str = source[index++];
      classMarker = false;
      terminated = false;
      while (index < length) {
        ch2 = source[index++];
        str += ch2;
        if (ch2 === "\\") {
          ch2 = source[index++];
          if (isLineTerminator(ch2.charCodeAt(0))) {
            throwError({}, MessageUnterminatedRegExp);
          }
          str += ch2;
        } else if (isLineTerminator(ch2.charCodeAt(0))) {
          throwError({}, MessageUnterminatedRegExp);
        } else if (classMarker) {
          if (ch2 === "]") {
            classMarker = false;
          }
        } else {
          if (ch2 === "/") {
            terminated = true;
            break;
          } else if (ch2 === "[") {
            classMarker = true;
          }
        }
      }
      if (!terminated) {
        throwError({}, MessageUnterminatedRegExp);
      }
      body = str.substr(1, str.length - 2);
      return {
        value: body,
        literal: str
      };
    }
    function scanRegExpFlags() {
      var ch2, str, flags;
      str = "";
      flags = "";
      while (index < length) {
        ch2 = source[index];
        if (!isIdentifierPart(ch2.charCodeAt(0))) {
          break;
        }
        ++index;
        if (ch2 === "\\" && index < length) {
          throwError({}, MessageUnexpectedToken, ILLEGAL$1);
        } else {
          flags += ch2;
          str += ch2;
        }
      }
      if (flags.search(/[^gimuy]/g) >= 0) {
        throwError({}, MessageInvalidRegExp, flags);
      }
      return {
        value: flags,
        literal: str
      };
    }
    function scanRegExp() {
      var start2, body, flags, value2;
      lookahead = null;
      skipComment();
      start2 = index;
      body = scanRegExpBody();
      flags = scanRegExpFlags();
      value2 = testRegExp(body.value, flags.value);
      return {
        literal: body.literal + flags.literal,
        value: value2,
        regex: {
          pattern: body.value,
          flags: flags.value
        },
        start: start2,
        end: index
      };
    }
    function isIdentifierName(token) {
      return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
    }
    function advance() {
      skipComment();
      if (index >= length) {
        return {
          type: TokenEOF,
          start: index,
          end: index
        };
      }
      const ch2 = source.charCodeAt(index);
      if (isIdentifierStart(ch2)) {
        return scanIdentifier();
      }
      if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
        return scanPunctuator();
      }
      if (ch2 === 39 || ch2 === 34) {
        return scanStringLiteral();
      }
      if (ch2 === 46) {
        if (isDecimalDigit(source.charCodeAt(index + 1))) {
          return scanNumericLiteral();
        }
        return scanPunctuator();
      }
      if (isDecimalDigit(ch2)) {
        return scanNumericLiteral();
      }
      return scanPunctuator();
    }
    function lex() {
      const token = lookahead;
      index = token.end;
      lookahead = advance();
      index = token.end;
      return token;
    }
    function peek() {
      const pos = index;
      lookahead = advance();
      index = pos;
    }
    function finishArrayExpression(elements) {
      const node = new ASTNode(SyntaxArrayExpression);
      node.elements = elements;
      return node;
    }
    function finishBinaryExpression(operator2, left2, right2) {
      const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
      node.operator = operator2;
      node.left = left2;
      node.right = right2;
      return node;
    }
    function finishCallExpression(callee, args) {
      const node = new ASTNode(SyntaxCallExpression);
      node.callee = callee;
      node.arguments = args;
      return node;
    }
    function finishConditionalExpression(test2, consequent, alternate) {
      const node = new ASTNode(SyntaxConditionalExpression);
      node.test = test2;
      node.consequent = consequent;
      node.alternate = alternate;
      return node;
    }
    function finishIdentifier(name2) {
      const node = new ASTNode(SyntaxIdentifier);
      node.name = name2;
      return node;
    }
    function finishLiteral(token) {
      const node = new ASTNode(SyntaxLiteral);
      node.value = token.value;
      node.raw = source.slice(token.start, token.end);
      if (token.regex) {
        if (node.raw === "//") {
          node.raw = "/(?:)/";
        }
        node.regex = token.regex;
      }
      return node;
    }
    function finishMemberExpression(accessor2, object2, property2) {
      const node = new ASTNode(SyntaxMemberExpression);
      node.computed = accessor2 === "[";
      node.object = object2;
      node.property = property2;
      if (!node.computed)
        property2.member = true;
      return node;
    }
    function finishObjectExpression(properties) {
      const node = new ASTNode(SyntaxObjectExpression);
      node.properties = properties;
      return node;
    }
    function finishProperty(kind, key2, value2) {
      const node = new ASTNode(SyntaxProperty);
      node.key = key2;
      node.value = value2;
      node.kind = kind;
      return node;
    }
    function finishUnaryExpression(operator2, argument) {
      const node = new ASTNode(SyntaxUnaryExpression);
      node.operator = operator2;
      node.argument = argument;
      node.prefix = true;
      return node;
    }
    function throwError(token, messageFormat) {
      var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index2) => {
        assert(index2 < args.length, "Message reference must be in range");
        return args[index2];
      });
      error2 = new Error(msg);
      error2.index = index;
      error2.description = msg;
      throw error2;
    }
    function throwUnexpected(token) {
      if (token.type === TokenEOF) {
        throwError(token, MessageUnexpectedEOS);
      }
      if (token.type === TokenNumericLiteral) {
        throwError(token, MessageUnexpectedNumber);
      }
      if (token.type === TokenStringLiteral) {
        throwError(token, MessageUnexpectedString);
      }
      if (token.type === TokenIdentifier) {
        throwError(token, MessageUnexpectedIdentifier);
      }
      if (token.type === TokenKeyword) {
        throwError(token, MessageUnexpectedReserved);
      }
      throwError(token, MessageUnexpectedToken, token.value);
    }
    function expect(value2) {
      const token = lex();
      if (token.type !== TokenPunctuator || token.value !== value2) {
        throwUnexpected(token);
      }
    }
    function match(value2) {
      return lookahead.type === TokenPunctuator && lookahead.value === value2;
    }
    function matchKeyword(keyword) {
      return lookahead.type === TokenKeyword && lookahead.value === keyword;
    }
    function parseArrayInitialiser() {
      const elements = [];
      index = lookahead.start;
      expect("[");
      while (!match("]")) {
        if (match(",")) {
          lex();
          elements.push(null);
        } else {
          elements.push(parseConditionalExpression());
          if (!match("]")) {
            expect(",");
          }
        }
      }
      lex();
      return finishArrayExpression(elements);
    }
    function parseObjectPropertyKey() {
      index = lookahead.start;
      const token = lex();
      if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
        if (token.octal) {
          throwError(token, MessageStrictOctalLiteral);
        }
        return finishLiteral(token);
      }
      return finishIdentifier(token.value);
    }
    function parseObjectProperty() {
      var token, key2, id2, value2;
      index = lookahead.start;
      token = lookahead;
      if (token.type === TokenIdentifier) {
        id2 = parseObjectPropertyKey();
        expect(":");
        value2 = parseConditionalExpression();
        return finishProperty("init", id2, value2);
      }
      if (token.type === TokenEOF || token.type === TokenPunctuator) {
        throwUnexpected(token);
      } else {
        key2 = parseObjectPropertyKey();
        expect(":");
        value2 = parseConditionalExpression();
        return finishProperty("init", key2, value2);
      }
    }
    function parseObjectInitialiser() {
      var properties = [], property2, name2, key2, map2 = {}, toString2 = String;
      index = lookahead.start;
      expect("{");
      while (!match("}")) {
        property2 = parseObjectProperty();
        if (property2.key.type === SyntaxIdentifier) {
          name2 = property2.key.name;
        } else {
          name2 = toString2(property2.key.value);
        }
        key2 = "$" + name2;
        if (Object.prototype.hasOwnProperty.call(map2, key2)) {
          throwError({}, MessageStrictDuplicateProperty);
        } else {
          map2[key2] = true;
        }
        properties.push(property2);
        if (!match("}")) {
          expect(",");
        }
      }
      expect("}");
      return finishObjectExpression(properties);
    }
    function parseGroupExpression() {
      expect("(");
      const expr2 = parseExpression$1();
      expect(")");
      return expr2;
    }
    const legalKeywords = {
      "if": 1
    };
    function parsePrimaryExpression() {
      var type2, token, expr2;
      if (match("(")) {
        return parseGroupExpression();
      }
      if (match("[")) {
        return parseArrayInitialiser();
      }
      if (match("{")) {
        return parseObjectInitialiser();
      }
      type2 = lookahead.type;
      index = lookahead.start;
      if (type2 === TokenIdentifier || legalKeywords[lookahead.value]) {
        expr2 = finishIdentifier(lex().value);
      } else if (type2 === TokenStringLiteral || type2 === TokenNumericLiteral) {
        if (lookahead.octal) {
          throwError(lookahead, MessageStrictOctalLiteral);
        }
        expr2 = finishLiteral(lex());
      } else if (type2 === TokenKeyword) {
        throw new Error(DISABLED);
      } else if (type2 === TokenBooleanLiteral) {
        token = lex();
        token.value = token.value === "true";
        expr2 = finishLiteral(token);
      } else if (type2 === TokenNullLiteral) {
        token = lex();
        token.value = null;
        expr2 = finishLiteral(token);
      } else if (match("/") || match("/=")) {
        expr2 = finishLiteral(scanRegExp());
        peek();
      } else {
        throwUnexpected(lex());
      }
      return expr2;
    }
    function parseArguments() {
      const args = [];
      expect("(");
      if (!match(")")) {
        while (index < length) {
          args.push(parseConditionalExpression());
          if (match(")")) {
            break;
          }
          expect(",");
        }
      }
      expect(")");
      return args;
    }
    function parseNonComputedProperty() {
      index = lookahead.start;
      const token = lex();
      if (!isIdentifierName(token)) {
        throwUnexpected(token);
      }
      return finishIdentifier(token.value);
    }
    function parseNonComputedMember() {
      expect(".");
      return parseNonComputedProperty();
    }
    function parseComputedMember() {
      expect("[");
      const expr2 = parseExpression$1();
      expect("]");
      return expr2;
    }
    function parseLeftHandSideExpressionAllowCall() {
      var expr2, args, property2;
      expr2 = parsePrimaryExpression();
      for (; ; ) {
        if (match(".")) {
          property2 = parseNonComputedMember();
          expr2 = finishMemberExpression(".", expr2, property2);
        } else if (match("(")) {
          args = parseArguments();
          expr2 = finishCallExpression(expr2, args);
        } else if (match("[")) {
          property2 = parseComputedMember();
          expr2 = finishMemberExpression("[", expr2, property2);
        } else {
          break;
        }
      }
      return expr2;
    }
    function parsePostfixExpression() {
      const expr2 = parseLeftHandSideExpressionAllowCall();
      if (lookahead.type === TokenPunctuator) {
        if (match("++") || match("--")) {
          throw new Error(DISABLED);
        }
      }
      return expr2;
    }
    function parseUnaryExpression() {
      var token, expr2;
      if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
        expr2 = parsePostfixExpression();
      } else if (match("++") || match("--")) {
        throw new Error(DISABLED);
      } else if (match("+") || match("-") || match("~") || match("!")) {
        token = lex();
        expr2 = parseUnaryExpression();
        expr2 = finishUnaryExpression(token.value, expr2);
      } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
        throw new Error(DISABLED);
      } else {
        expr2 = parsePostfixExpression();
      }
      return expr2;
    }
    function binaryPrecedence(token) {
      let prec = 0;
      if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
        return 0;
      }
      switch (token.value) {
        case "||":
          prec = 1;
          break;
        case "&&":
          prec = 2;
          break;
        case "|":
          prec = 3;
          break;
        case "^":
          prec = 4;
          break;
        case "&":
          prec = 5;
          break;
        case "==":
        case "!=":
        case "===":
        case "!==":
          prec = 6;
          break;
        case "<":
        case ">":
        case "<=":
        case ">=":
        case "instanceof":
        case "in":
          prec = 7;
          break;
        case "<<":
        case ">>":
        case ">>>":
          prec = 8;
          break;
        case "+":
        case "-":
          prec = 9;
          break;
        case "*":
        case "/":
        case "%":
          prec = 11;
          break;
      }
      return prec;
    }
    function parseBinaryExpression() {
      var marker, markers, expr2, token, prec, stack2, right2, operator2, left2, i;
      marker = lookahead;
      left2 = parseUnaryExpression();
      token = lookahead;
      prec = binaryPrecedence(token);
      if (prec === 0) {
        return left2;
      }
      token.prec = prec;
      lex();
      markers = [marker, lookahead];
      right2 = parseUnaryExpression();
      stack2 = [left2, token, right2];
      while ((prec = binaryPrecedence(lookahead)) > 0) {
        while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
          right2 = stack2.pop();
          operator2 = stack2.pop().value;
          left2 = stack2.pop();
          markers.pop();
          expr2 = finishBinaryExpression(operator2, left2, right2);
          stack2.push(expr2);
        }
        token = lex();
        token.prec = prec;
        stack2.push(token);
        markers.push(lookahead);
        expr2 = parseUnaryExpression();
        stack2.push(expr2);
      }
      i = stack2.length - 1;
      expr2 = stack2[i];
      markers.pop();
      while (i > 1) {
        markers.pop();
        expr2 = finishBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr2);
        i -= 2;
      }
      return expr2;
    }
    function parseConditionalExpression() {
      var expr2, consequent, alternate;
      expr2 = parseBinaryExpression();
      if (match("?")) {
        lex();
        consequent = parseConditionalExpression();
        expect(":");
        alternate = parseConditionalExpression();
        expr2 = finishConditionalExpression(expr2, consequent, alternate);
      }
      return expr2;
    }
    function parseExpression$1() {
      const expr2 = parseConditionalExpression();
      if (match(",")) {
        throw new Error(DISABLED);
      }
      return expr2;
    }
    function parser$1(code2) {
      source = code2;
      index = 0;
      length = source.length;
      lookahead = null;
      peek();
      const expr2 = parseExpression$1();
      if (lookahead.type !== TokenEOF) {
        throw new Error("Unexpect token after expression.");
      }
      return expr2;
    }
    var Constants$1 = {
      NaN: "NaN",
      E: "Math.E",
      LN2: "Math.LN2",
      LN10: "Math.LN10",
      LOG2E: "Math.LOG2E",
      LOG10E: "Math.LOG10E",
      PI: "Math.PI",
      SQRT1_2: "Math.SQRT1_2",
      SQRT2: "Math.SQRT2",
      MIN_VALUE: "Number.MIN_VALUE",
      MAX_VALUE: "Number.MAX_VALUE"
    };
    function Functions$1(codegen2) {
      function fncall(name2, args, cast, type2) {
        let obj = codegen2(args[0]);
        if (cast) {
          obj = cast + "(" + obj + ")";
          if (cast.lastIndexOf("new ", 0) === 0)
            obj = "(" + obj + ")";
        }
        return obj + "." + name2 + (type2 < 0 ? "" : type2 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
      }
      function fn(name2, cast, type2) {
        return (args) => fncall(name2, args, cast, type2);
      }
      const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
      return {
        // MATH functions
        isNaN: "Number.isNaN",
        isFinite: "Number.isFinite",
        abs: "Math.abs",
        acos: "Math.acos",
        asin: "Math.asin",
        atan: "Math.atan",
        atan2: "Math.atan2",
        ceil: "Math.ceil",
        cos: "Math.cos",
        exp: "Math.exp",
        floor: "Math.floor",
        hypot: "Math.hypot",
        log: "Math.log",
        max: "Math.max",
        min: "Math.min",
        pow: "Math.pow",
        random: "Math.random",
        round: "Math.round",
        sin: "Math.sin",
        sqrt: "Math.sqrt",
        tan: "Math.tan",
        clamp: function(args) {
          if (args.length < 3)
            error("Missing arguments to clamp function.");
          if (args.length > 3)
            error("Too many arguments to clamp function.");
          const a2 = args.map(codegen2);
          return "Math.max(" + a2[1] + ", Math.min(" + a2[2] + "," + a2[0] + "))";
        },
        // DATE functions
        now: "Date.now",
        utc: "Date.UTC",
        datetime: DATE2,
        date: fn("getDate", DATE2, 0),
        day: fn("getDay", DATE2, 0),
        year: fn("getFullYear", DATE2, 0),
        month: fn("getMonth", DATE2, 0),
        hours: fn("getHours", DATE2, 0),
        minutes: fn("getMinutes", DATE2, 0),
        seconds: fn("getSeconds", DATE2, 0),
        milliseconds: fn("getMilliseconds", DATE2, 0),
        time: fn("getTime", DATE2, 0),
        timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
        utcdate: fn("getUTCDate", DATE2, 0),
        utcday: fn("getUTCDay", DATE2, 0),
        utcyear: fn("getUTCFullYear", DATE2, 0),
        utcmonth: fn("getUTCMonth", DATE2, 0),
        utchours: fn("getUTCHours", DATE2, 0),
        utcminutes: fn("getUTCMinutes", DATE2, 0),
        utcseconds: fn("getUTCSeconds", DATE2, 0),
        utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
        // sequence functions
        length: fn("length", null, -1),
        // STRING functions
        parseFloat: "parseFloat",
        parseInt: "parseInt",
        upper: fn("toUpperCase", STRING, 0),
        lower: fn("toLowerCase", STRING, 0),
        substring: fn("substring", STRING),
        split: fn("split", STRING),
        trim: fn("trim", STRING, 0),
        // REGEXP functions
        regexp: REGEXP,
        test: fn("test", REGEXP),
        // Control Flow functions
        if: function(args) {
          if (args.length < 3)
            error("Missing arguments to if function.");
          if (args.length > 3)
            error("Too many arguments to if function.");
          const a2 = args.map(codegen2);
          return "(" + a2[0] + "?" + a2[1] + ":" + a2[2] + ")";
        }
      };
    }
    function stripQuotes(s) {
      const n = s && s.length - 1;
      return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
    }
    function codegen(opt) {
      opt = opt || {};
      const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants2 = opt.constants || Constants$1, functions2 = (opt.functions || Functions$1)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id2) => `${globalvar}["${id2}"]`;
      let globals = {}, fields = {}, memberDepth = 0;
      function visit2(ast) {
        if (isString(ast))
          return ast;
        const generator = Generators[ast.type];
        if (generator == null)
          error("Unsupported type: " + ast.type);
        return generator(ast);
      }
      const Generators = {
        Literal: (n) => n.raw,
        Identifier: (n) => {
          const id2 = n.name;
          if (memberDepth > 0) {
            return id2;
          } else if (has$1(forbidden, id2)) {
            return error("Illegal identifier: " + id2);
          } else if (has$1(constants2, id2)) {
            return constants2[id2];
          } else if (has$1(allowed, id2)) {
            return id2;
          } else {
            globals[id2] = 1;
            return outputGlobal(id2);
          }
        },
        MemberExpression: (n) => {
          const d = !n.computed, o = visit2(n.object);
          if (d)
            memberDepth += 1;
          const p = visit2(n.property);
          if (o === fieldvar) {
            fields[stripQuotes(p)] = 1;
          }
          if (d)
            memberDepth -= 1;
          return o + (d ? "." + p : "[" + p + "]");
        },
        CallExpression: (n) => {
          if (n.callee.type !== "Identifier") {
            error("Illegal callee type: " + n.callee.type);
          }
          const callee = n.callee.name, args = n.arguments, fn = has$1(functions2, callee) && functions2[callee];
          if (!fn)
            error("Unrecognized function: " + callee);
          return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
        },
        ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
        BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
        UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
        ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
        LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
        ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
        Property: (n) => {
          memberDepth += 1;
          const k = visit2(n.key);
          memberDepth -= 1;
          return k + ":" + visit2(n.value);
        }
      };
      function codegen2(ast) {
        const result = {
          code: visit2(ast),
          globals: Object.keys(globals),
          fields: Object.keys(fields)
        };
        globals = {};
        fields = {};
        return result;
      }
      codegen2.functions = functions2;
      codegen2.constants = constants2;
      return codegen2;
    }
    const SELECTION_GETTER = Symbol("vega_selection_getter");
    function getter(f) {
      if (!f.getter || !f.getter[SELECTION_GETTER]) {
        f.getter = field$1(f.field);
        f.getter[SELECTION_GETTER] = true;
      }
      return f.getter;
    }
    const Intersect = "intersect";
    const Union = "union";
    const VlMulti = "vlMulti";
    const VlPoint = "vlPoint";
    const Or = "or";
    const And = "and";
    const SelectionId = "_vgsid_";
    const $selectionId = field$1(SelectionId);
    const TYPE_ENUM = "E", TYPE_RANGE_INC = "R", TYPE_RANGE_EXC = "R-E", TYPE_RANGE_LE = "R-LE", TYPE_RANGE_RE = "R-RE", UNIT_INDEX = "index:unit";
    function testPoint(datum2, entry2) {
      var fields = entry2.fields, values2 = entry2.values, n = fields.length, i = 0, dval, f;
      for (; i < n; ++i) {
        f = fields[i];
        dval = getter(f)(datum2);
        if (isDate$1(dval))
          dval = toNumber(dval);
        if (isDate$1(values2[i]))
          values2[i] = toNumber(values2[i]);
        if (isArray(values2[i]) && isDate$1(values2[i][0]))
          values2[i] = values2[i].map(toNumber);
        if (f.type === TYPE_ENUM) {
          if (isArray(values2[i]) ? values2[i].indexOf(dval) < 0 : dval !== values2[i]) {
            return false;
          }
        } else {
          if (f.type === TYPE_RANGE_INC) {
            if (!inrange(dval, values2[i]))
              return false;
          } else if (f.type === TYPE_RANGE_RE) {
            if (!inrange(dval, values2[i], true, false))
              return false;
          } else if (f.type === TYPE_RANGE_EXC) {
            if (!inrange(dval, values2[i], false, false))
              return false;
          } else if (f.type === TYPE_RANGE_LE) {
            if (!inrange(dval, values2[i], false, true))
              return false;
          }
        }
      }
      return true;
    }
    function selectionTest(name2, datum2, op) {
      var data2 = this.context.data[name2], entries2 = data2 ? data2.values.value : [], unitIdx = data2 ? data2[UNIT_INDEX] && data2[UNIT_INDEX].value : void 0, intersect2 = op === Intersect, n = entries2.length, i = 0, entry2, miss, count2, unit2, b2;
      for (; i < n; ++i) {
        entry2 = entries2[i];
        if (unitIdx && intersect2) {
          miss = miss || {};
          count2 = miss[unit2 = entry2.unit] || 0;
          if (count2 === -1)
            continue;
          b2 = testPoint(datum2, entry2);
          miss[unit2] = b2 ? -1 : ++count2;
          if (b2 && unitIdx.size === 1)
            return true;
          if (!b2 && count2 === unitIdx.get(unit2).count)
            return false;
        } else {
          b2 = testPoint(datum2, entry2);
          if (intersect2 ^ b2)
            return b2;
        }
      }
      return n && intersect2;
    }
    const bisect = bisector($selectionId), bisectLeft = bisect.left, bisectRight = bisect.right;
    function selectionIdTest(name2, datum2, op) {
      const data2 = this.context.data[name2], entries2 = data2 ? data2.values.value : [], unitIdx = data2 ? data2[UNIT_INDEX] && data2[UNIT_INDEX].value : void 0, intersect2 = op === Intersect, value2 = $selectionId(datum2), index2 = bisectLeft(entries2, value2);
      if (index2 === entries2.length)
        return false;
      if ($selectionId(entries2[index2]) !== value2)
        return false;
      if (unitIdx && intersect2) {
        if (unitIdx.size === 1)
          return true;
        if (bisectRight(entries2, value2) - index2 < unitIdx.size)
          return false;
      }
      return true;
    }
    function selectionTuples(array2, base2) {
      return array2.map((x2) => extend(base2.fields ? {
        values: base2.fields.map((f) => getter(f)(x2.datum))
      } : {
        [SelectionId]: $selectionId(x2.datum)
      }, base2));
    }
    function selectionResolve(name2, op, isMulti, vl5) {
      var data2 = this.context.data[name2], entries2 = data2 ? data2.values.value : [], resolved = {}, multiRes = {}, types2 = {}, entry2, fields, values2, unit2, field2, value2, res, resUnit, type2, union2, n = entries2.length, i = 0, j, m2;
      for (; i < n; ++i) {
        entry2 = entries2[i];
        unit2 = entry2.unit;
        fields = entry2.fields;
        values2 = entry2.values;
        if (fields && values2) {
          for (j = 0, m2 = fields.length; j < m2; ++j) {
            field2 = fields[j];
            res = resolved[field2.field] || (resolved[field2.field] = {});
            resUnit = res[unit2] || (res[unit2] = []);
            types2[field2.field] = type2 = field2.type.charAt(0);
            union2 = ops[`${type2}_union`];
            res[unit2] = union2(resUnit, array$2(values2[j]));
          }
          if (isMulti) {
            resUnit = multiRes[unit2] || (multiRes[unit2] = []);
            resUnit.push(array$2(values2).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
          }
        } else {
          field2 = SelectionId;
          value2 = $selectionId(entry2);
          res = resolved[field2] || (resolved[field2] = {});
          resUnit = res[unit2] || (res[unit2] = []);
          resUnit.push(value2);
          if (isMulti) {
            resUnit = multiRes[unit2] || (multiRes[unit2] = []);
            resUnit.push({
              [SelectionId]: value2
            });
          }
        }
      }
      op = op || Union;
      if (resolved[SelectionId]) {
        resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
      } else {
        Object.keys(resolved).forEach((field3) => {
          resolved[field3] = Object.keys(resolved[field3]).map((unit3) => resolved[field3][unit3]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types2[field3]}_${op}`](acc, curr));
        });
      }
      entries2 = Object.keys(multiRes);
      if (isMulti && entries2.length) {
        const key2 = vl5 ? VlPoint : VlMulti;
        resolved[key2] = op === Union ? {
          [Or]: entries2.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
        } : {
          [And]: entries2.map((k) => ({
            [Or]: multiRes[k]
          }))
        };
      }
      return resolved;
    }
    var ops = {
      [`${SelectionId}_union`]: union,
      [`${SelectionId}_intersect`]: intersection,
      E_union: function(base2, value2) {
        if (!base2.length)
          return value2;
        var i = 0, n = value2.length;
        for (; i < n; ++i)
          if (base2.indexOf(value2[i]) < 0)
            base2.push(value2[i]);
        return base2;
      },
      E_intersect: function(base2, value2) {
        return !base2.length ? value2 : base2.filter((v) => value2.indexOf(v) >= 0);
      },
      R_union: function(base2, value2) {
        var lo = toNumber(value2[0]), hi = toNumber(value2[1]);
        if (lo > hi) {
          lo = value2[1];
          hi = value2[0];
        }
        if (!base2.length)
          return [lo, hi];
        if (base2[0] > lo)
          base2[0] = lo;
        if (base2[1] < hi)
          base2[1] = hi;
        return base2;
      },
      R_intersect: function(base2, value2) {
        var lo = toNumber(value2[0]), hi = toNumber(value2[1]);
        if (lo > hi) {
          lo = value2[1];
          hi = value2[0];
        }
        if (!base2.length)
          return [lo, hi];
        if (hi < base2[0] || base2[1] < lo) {
          return [];
        } else {
          if (base2[0] < lo)
            base2[0] = lo;
          if (base2[1] > hi)
            base2[1] = hi;
        }
        return base2;
      }
    };
    const DataPrefix$1 = ":", IndexPrefix$1 = "@";
    function selectionVisitor(name2, args, scope, params2) {
      if (args[0].type !== Literal)
        error("First argument to selection functions must be a string literal.");
      const data2 = args[0].value, op = args.length >= 2 && peek$1(args).value, field2 = "unit", indexName = IndexPrefix$1 + field2, dataName = DataPrefix$1 + data2;
      if (op === Intersect && !has$1(params2, indexName)) {
        params2[indexName] = scope.getData(data2).indataRef(scope, field2);
      }
      if (!has$1(params2, dataName)) {
        params2[dataName] = scope.getData(data2).tuplesRef();
      }
    }
    function data$1(name2) {
      const data2 = this.context.data[name2];
      return data2 ? data2.values.value : [];
    }
    function indata(name2, field2, value2) {
      const index2 = this.context.data[name2]["index:" + field2], entry2 = index2 ? index2.value.get(value2) : void 0;
      return entry2 ? entry2.count : entry2;
    }
    function setdata(name2, tuples) {
      const df = this.context.dataflow, data2 = this.context.data[name2], input = data2.input;
      df.pulse(input, df.changeset().remove(truthy).insert(tuples));
      return 1;
    }
    function encode(item, name2, retval) {
      if (item) {
        const df = this.context.dataflow, target2 = item.mark.source;
        df.pulse(target2, df.changeset().encode(item, name2));
      }
      return retval !== void 0 ? retval : item;
    }
    const wrap = (method2) => function(value2, spec) {
      const locale2 = this.context.dataflow.locale();
      return locale2[method2](spec)(value2);
    };
    const format = wrap("format");
    const timeFormat$1 = wrap("timeFormat");
    const utcFormat = wrap("utcFormat");
    const timeParse = wrap("timeParse");
    const utcParse = wrap("utcParse");
    const dateObj = new Date(2e3, 0, 1);
    function time(month, day, specifier) {
      if (!Number.isInteger(month) || !Number.isInteger(day))
        return "";
      dateObj.setYear(2e3);
      dateObj.setMonth(month);
      dateObj.setDate(day);
      return timeFormat$1.call(this, dateObj, specifier);
    }
    function monthFormat(month) {
      return time.call(this, month, 1, "%B");
    }
    function monthAbbrevFormat(month) {
      return time.call(this, month, 1, "%b");
    }
    function dayFormat(day) {
      return time.call(this, 0, 2 + day, "%A");
    }
    function dayAbbrevFormat(day) {
      return time.call(this, 0, 2 + day, "%a");
    }
    const DataPrefix = ":";
    const IndexPrefix = "@";
    const ScalePrefix = "%";
    const SignalPrefix = "$";
    function dataVisitor(name2, args, scope, params2) {
      if (args[0].type !== Literal) {
        error("First argument to data functions must be a string literal.");
      }
      const data2 = args[0].value, dataName = DataPrefix + data2;
      if (!has$1(dataName, params2)) {
        try {
          params2[dataName] = scope.getData(data2).tuplesRef();
        } catch (err) {
        }
      }
    }
    function indataVisitor(name2, args, scope, params2) {
      if (args[0].type !== Literal)
        error("First argument to indata must be a string literal.");
      if (args[1].type !== Literal)
        error("Second argument to indata must be a string literal.");
      const data2 = args[0].value, field2 = args[1].value, indexName = IndexPrefix + field2;
      if (!has$1(indexName, params2)) {
        params2[indexName] = scope.getData(data2).indataRef(scope, field2);
      }
    }
    function scaleVisitor(name2, args, scope, params2) {
      if (args[0].type === Literal) {
        addScaleDependency(scope, params2, args[0].value);
      } else {
        for (name2 in scope.scales) {
          addScaleDependency(scope, params2, name2);
        }
      }
    }
    function addScaleDependency(scope, params2, name2) {
      const scaleName = ScalePrefix + name2;
      if (!has$1(params2, scaleName)) {
        try {
          params2[scaleName] = scope.scaleRef(name2);
        } catch (err) {
        }
      }
    }
    function getScale(nameOrFunction, ctx) {
      if (isFunction(nameOrFunction)) {
        return nameOrFunction;
      }
      if (isString(nameOrFunction)) {
        const maybeScale = ctx.scales[nameOrFunction];
        return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : void 0;
      }
      return void 0;
    }
    function internalScaleFunctions(codegen2, fnctx, visitors) {
      fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
      visitors._bandwidth = scaleVisitor;
      visitors._range = scaleVisitor;
      visitors._scale = scaleVisitor;
      const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
      return {
        _bandwidth: (args) => `this.__bandwidth(${ref2(args[0])})`,
        _range: (args) => `${ref2(args[0])}.range()`,
        _scale: (args) => `${ref2(args[0])}(${codegen2(args[1])})`
      };
    }
    function geoMethod(methodName, globalMethod) {
      return function(projection2, geojson, group2) {
        if (projection2) {
          const p = getScale(projection2, (group2 || this).context);
          return p && p.path[methodName](geojson);
        } else {
          return globalMethod(geojson);
        }
      };
    }
    const geoArea = geoMethod("area", geoArea$1);
    const geoBounds = geoMethod("bounds", geoBounds$1);
    const geoCentroid = geoMethod("centroid", geoCentroid$1);
    function geoScale(projection2, group2) {
      const p = getScale(projection2, (group2 || this).context);
      return p && p.scale();
    }
    function inScope(item) {
      const group2 = this.context.group;
      let value2 = false;
      if (group2)
        while (item) {
          if (item === group2) {
            value2 = true;
            break;
          }
          item = item.mark.group;
        }
      return value2;
    }
    function log(df, method2, args) {
      try {
        df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
      } catch (err) {
        df.warn(err);
      }
      return args[args.length - 1];
    }
    function warn$1() {
      return log(this.context.dataflow, "warn", arguments);
    }
    function info() {
      return log(this.context.dataflow, "info", arguments);
    }
    function debug$3() {
      return log(this.context.dataflow, "debug", arguments);
    }
    function channel_luminance_value(channelValue) {
      const val = channelValue / 255;
      if (val <= 0.03928) {
        return val / 12.92;
      }
      return Math.pow((val + 0.055) / 1.055, 2.4);
    }
    function luminance(color2) {
      const c2 = rgb(color2), r = channel_luminance_value(c2.r), g = channel_luminance_value(c2.g), b2 = channel_luminance_value(c2.b);
      return 0.2126 * r + 0.7152 * g + 0.0722 * b2;
    }
    function contrast(color1, color2) {
      const lum1 = luminance(color1), lum2 = luminance(color2), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
      return (lumL + 0.05) / (lumD + 0.05);
    }
    function merge() {
      const args = [].slice.call(arguments);
      args.unshift({});
      return extend(...args);
    }
    function equal(a2, b2) {
      return a2 === b2 || a2 !== a2 && b2 !== b2 ? true : isArray(a2) ? isArray(b2) && a2.length === b2.length ? equalArray(a2, b2) : false : isObject(a2) && isObject(b2) ? equalObject(a2, b2) : false;
    }
    function equalArray(a2, b2) {
      for (let i = 0, n = a2.length; i < n; ++i) {
        if (!equal(a2[i], b2[i]))
          return false;
      }
      return true;
    }
    function equalObject(a2, b2) {
      for (const key2 in a2) {
        if (!equal(a2[key2], b2[key2]))
          return false;
      }
      return true;
    }
    function removePredicate(props) {
      return (_) => equalObject(props, _);
    }
    function modify(name2, insert2, remove2, toggle2, modify2, values2) {
      const df = this.context.dataflow, data2 = this.context.data[name2], input = data2.input, stamp = df.stamp();
      let changes = data2.changes, predicate, key2;
      if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
        return 0;
      }
      if (!changes || changes.stamp < stamp) {
        data2.changes = changes = df.changeset();
        changes.stamp = stamp;
        df.runAfter(() => {
          data2.modified = true;
          df.pulse(input, changes).run();
        }, true, 1);
      }
      if (remove2) {
        predicate = remove2 === true ? truthy : isArray(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
        changes.remove(predicate);
      }
      if (insert2) {
        changes.insert(insert2);
      }
      if (toggle2) {
        predicate = removePredicate(toggle2);
        if (input.value.some(predicate)) {
          changes.remove(predicate);
        } else {
          changes.insert(toggle2);
        }
      }
      if (modify2) {
        for (key2 in values2) {
          changes.modify(modify2, key2, values2[key2]);
        }
      }
      return 1;
    }
    function pinchDistance(event2) {
      const t4 = event2.touches, dx = t4[0].clientX - t4[1].clientX, dy = t4[0].clientY - t4[1].clientY;
      return Math.hypot(dx, dy);
    }
    function pinchAngle(event2) {
      const t4 = event2.touches;
      return Math.atan2(t4[0].clientY - t4[1].clientY, t4[0].clientX - t4[1].clientX);
    }
    const accessors = {};
    function pluck(data2, name2) {
      const accessor2 = accessors[name2] || (accessors[name2] = field$1(name2));
      return isArray(data2) ? data2.map(accessor2) : accessor2(data2);
    }
    function array(seq) {
      return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
    }
    function sequence(seq) {
      return array(seq) || (isString(seq) ? seq : null);
    }
    function join(seq) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return array(seq).join(...args);
    }
    function indexof(seq) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return sequence(seq).indexOf(...args);
    }
    function lastindexof(seq) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return sequence(seq).lastIndexOf(...args);
    }
    function slice$1(seq) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return sequence(seq).slice(...args);
    }
    function replace(str, pattern, repl) {
      if (isFunction(repl))
        error("Function argument passed to replace.");
      return String(str).replace(pattern, repl);
    }
    function reverse$1(seq) {
      return array(seq).slice().reverse();
    }
    function bandspace(count2, paddingInner2, paddingOuter2) {
      return bandSpace(count2 || 0, paddingInner2 || 0, paddingOuter2 || 0);
    }
    function bandwidth(name2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return s && s.bandwidth ? s.bandwidth() : 0;
    }
    function copy(name2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return s ? s.copy() : void 0;
    }
    function domain$2(name2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return s ? s.domain() : [];
    }
    function invert(name2, range2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return !s ? void 0 : isArray(range2) ? (s.invertRange || s.invert)(range2) : (s.invert || s.invertExtent)(range2);
    }
    function range$3(name2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return s && s.range ? s.range() : [];
    }
    function scale$2(name2, value2, group2) {
      const s = getScale(name2, (group2 || this).context);
      return s ? s(value2) : void 0;
    }
    function scaleGradient(scale2, p02, p1, count2, group2) {
      scale2 = getScale(scale2, (group2 || this).context);
      const gradient2 = Gradient$1(p02, p1);
      let stops = scale2.domain(), min2 = stops[0], max2 = peek$1(stops), fraction = identity$1;
      if (!(max2 - min2)) {
        scale2 = (scale2.interpolator ? scale$4("sequential")().interpolator(scale2.interpolator()) : scale$4("linear")().interpolate(scale2.interpolate()).range(scale2.range())).domain([min2 = 0, max2 = 1]);
      } else {
        fraction = scaleFraction(scale2, min2, max2);
      }
      if (scale2.ticks) {
        stops = scale2.ticks(+count2 || 15);
        if (min2 !== stops[0])
          stops.unshift(min2);
        if (max2 !== peek$1(stops))
          stops.push(max2);
      }
      stops.forEach((_) => gradient2.stop(fraction(_), scale2(_)));
      return gradient2;
    }
    function geoShape(projection2, geojson, group2) {
      const p = getScale(projection2, (group2 || this).context);
      return function(context2) {
        return p ? p.path.context(context2)(geojson) : "";
      };
    }
    function pathShape(path2) {
      let p = null;
      return function(context2) {
        return context2 ? pathRender(context2, p = p || parse$3(path2)) : path2;
      };
    }
    const datum = (d) => d.data;
    function treeNodes(name2, context2) {
      const tree2 = data$1.call(context2, name2);
      return tree2.root && tree2.root.lookup || {};
    }
    function treePath(name2, source2, target2) {
      const nodes = treeNodes(name2, this), s = nodes[source2], t4 = nodes[target2];
      return s && t4 ? s.path(t4).map(datum) : void 0;
    }
    function treeAncestors(name2, node) {
      const n = treeNodes(name2, this)[node];
      return n ? n.ancestors().map(datum) : void 0;
    }
    const _window = () => typeof window !== "undefined" && window || null;
    function screen() {
      const w2 = _window();
      return w2 ? w2.screen : {};
    }
    function windowSize() {
      const w2 = _window();
      return w2 ? [w2.innerWidth, w2.innerHeight] : [void 0, void 0];
    }
    function containerSize() {
      const view = this.context.dataflow, el = view.container && view.container();
      return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
    }
    function intersect(b2, opt, group2) {
      if (!b2)
        return [];
      const [u2, v] = b2, box = new Bounds().set(u2[0], u2[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
      return intersect$2(scene, box, filter(opt));
    }
    function filter(opt) {
      let p = null;
      if (opt) {
        const types2 = array$2(opt.marktype), names = array$2(opt.markname);
        p = (_) => (!types2.length || types2.some((t4) => _.marktype === t4)) && (!names.length || names.some((s) => _.name === s));
      }
      return p;
    }
    function lassoAppend(lasso, x2, y2) {
      let minDist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
      lasso = array$2(lasso);
      const last2 = lasso[lasso.length - 1];
      return last2 === void 0 || Math.hypot(last2[0] - x2, last2[1] - y2) > minDist ? [...lasso, [x2, y2]] : lasso;
    }
    function lassoPath(lasso) {
      return array$2(lasso).reduce((svg, _ref, i) => {
        let [x2, y2] = _ref;
        return svg += i == 0 ? `M ${x2},${y2} ` : i === lasso.length - 1 ? " Z" : `L ${x2},${y2} `;
      }, "");
    }
    function intersectLasso(markname, pixelLasso, unit2) {
      const {
        x: x2,
        y: y2,
        mark
      } = unit2;
      const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
      for (const [px2, py2] of pixelLasso) {
        if (px2 < bb.x1)
          bb.x1 = px2;
        if (px2 > bb.x2)
          bb.x2 = px2;
        if (py2 < bb.y1)
          bb.y1 = py2;
        if (py2 > bb.y2)
          bb.y2 = py2;
      }
      bb.translate(x2, y2);
      const intersection2 = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark);
      return intersection2.filter((tuple) => pointInPolygon(tuple.x, tuple.y, pixelLasso));
    }
    function pointInPolygon(testx, testy, polygon) {
      let intersections = 0;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [prevX, prevY] = polygon[j];
        const [x2, y2] = polygon[i];
        if (y2 > testy != prevY > testy && testx < (prevX - x2) * (testy - y2) / (prevY - y2) + x2) {
          intersections++;
        }
      }
      return intersections & 1;
    }
    const functionContext = {
      random() {
        return random();
      },
      // override default
      cumulativeNormal,
      cumulativeLogNormal,
      cumulativeUniform,
      densityNormal,
      densityLogNormal,
      densityUniform,
      quantileNormal,
      quantileLogNormal,
      quantileUniform,
      sampleNormal,
      sampleLogNormal,
      sampleUniform,
      isArray,
      isBoolean: isBoolean$2,
      isDate: isDate$1,
      isDefined(_) {
        return _ !== void 0;
      },
      isNumber: isNumber$1,
      isObject,
      isRegExp,
      isString,
      isTuple,
      isValid(_) {
        return _ != null && _ === _;
      },
      toBoolean,
      toDate(_) {
        return toDate(_);
      },
      // suppress extra arguments
      toNumber,
      toString,
      indexof,
      join,
      lastindexof,
      replace,
      reverse: reverse$1,
      slice: slice$1,
      flush,
      lerp,
      merge,
      pad,
      peek: peek$1,
      pluck,
      span,
      inrange,
      truncate: truncate$1,
      rgb,
      lab: lab$1,
      hcl: hcl$2,
      hsl: hsl$2,
      luminance,
      contrast,
      sequence: range$5,
      format,
      utcFormat,
      utcParse,
      utcOffset,
      utcSequence,
      timeFormat: timeFormat$1,
      timeParse,
      timeOffset,
      timeSequence,
      timeUnitSpecifier,
      monthFormat,
      monthAbbrevFormat,
      dayFormat,
      dayAbbrevFormat,
      quarter,
      utcquarter,
      week,
      utcweek,
      dayofyear,
      utcdayofyear,
      warn: warn$1,
      info,
      debug: debug$3,
      extent(_) {
        return extent(_);
      },
      // suppress extra arguments
      inScope,
      intersect,
      clampRange,
      pinchDistance,
      pinchAngle,
      screen,
      containerSize,
      windowSize,
      bandspace,
      setdata,
      pathShape,
      panLinear,
      panLog,
      panPow,
      panSymlog,
      zoomLinear,
      zoomLog,
      zoomPow,
      zoomSymlog,
      encode,
      modify,
      lassoAppend,
      lassoPath,
      intersectLasso
    };
    const eventFunctions = ["view", "item", "group", "xy", "x", "y"], eventPrefix = "event.vega.", thisPrefix = "this.", astVisitors = {};
    const codegenParams = {
      forbidden: ["_"],
      allowed: ["datum", "event", "item"],
      fieldvar: "datum",
      globalvar: (id2) => `_[${$(SignalPrefix + id2)}]`,
      functions: buildFunctions,
      constants: Constants$1,
      visitors: astVisitors
    };
    const codeGenerator = codegen(codegenParams);
    function buildFunctions(codegen2) {
      const fn = Functions$1(codegen2);
      eventFunctions.forEach((name2) => fn[name2] = eventPrefix + name2);
      for (const name2 in functionContext) {
        fn[name2] = thisPrefix + name2;
      }
      extend(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
      return fn;
    }
    function expressionFunction(name2, fn, visitor) {
      if (arguments.length === 1) {
        return functionContext[name2];
      }
      functionContext[name2] = fn;
      if (visitor)
        astVisitors[name2] = visitor;
      if (codeGenerator)
        codeGenerator.functions[name2] = thisPrefix + name2;
      return this;
    }
    expressionFunction("bandwidth", bandwidth, scaleVisitor);
    expressionFunction("copy", copy, scaleVisitor);
    expressionFunction("domain", domain$2, scaleVisitor);
    expressionFunction("range", range$3, scaleVisitor);
    expressionFunction("invert", invert, scaleVisitor);
    expressionFunction("scale", scale$2, scaleVisitor);
    expressionFunction("gradient", scaleGradient, scaleVisitor);
    expressionFunction("geoArea", geoArea, scaleVisitor);
    expressionFunction("geoBounds", geoBounds, scaleVisitor);
    expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
    expressionFunction("geoShape", geoShape, scaleVisitor);
    expressionFunction("geoScale", geoScale, scaleVisitor);
    expressionFunction("indata", indata, indataVisitor);
    expressionFunction("data", data$1, dataVisitor);
    expressionFunction("treePath", treePath, dataVisitor);
    expressionFunction("treeAncestors", treeAncestors, dataVisitor);
    expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
    expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
    expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
    expressionFunction("vlSelectionTuples", selectionTuples);
    function parser(expr2, scope) {
      const params2 = {};
      let ast;
      try {
        expr2 = isString(expr2) ? expr2 : $(expr2) + "";
        ast = parser$1(expr2);
      } catch (err) {
        error("Expression parse error: " + expr2);
      }
      ast.visit((node) => {
        if (node.type !== CallExpression)
          return;
        const name2 = node.callee.name, visit2 = codegenParams.visitors[name2];
        if (visit2)
          visit2(name2, node.arguments, scope, params2);
      });
      const gen = codeGenerator(ast);
      gen.globals.forEach((name2) => {
        const signalName = SignalPrefix + name2;
        if (!has$1(params2, signalName) && scope.getSignal(name2)) {
          params2[signalName] = scope.signalRef(name2);
        }
      });
      return {
        $expr: extend({
          code: gen.code
        }, scope.options.ast ? {
          ast
        } : null),
        $fields: gen.fields,
        $params: params2
      };
    }
    function parse$2(spec) {
      const ctx = this, operators = spec.operators || [];
      if (spec.background) {
        ctx.background = spec.background;
      }
      if (spec.eventConfig) {
        ctx.eventConfig = spec.eventConfig;
      }
      if (spec.locale) {
        ctx.locale = spec.locale;
      }
      operators.forEach((entry2) => ctx.parseOperator(entry2));
      operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
      (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
      (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
      return ctx.resolve();
    }
    const Skip$2 = toSet(["rule"]), Swap = toSet(["group", "image", "rect"]);
    function adjustSpatial$1(encode2, marktype) {
      let code2 = "";
      if (Skip$2[marktype])
        return code2;
      if (encode2.x2) {
        if (encode2.x) {
          if (Swap[marktype]) {
            code2 += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
          }
          code2 += "o.width=o.x2-o.x;";
        } else {
          code2 += "o.x=o.x2-(o.width||0);";
        }
      }
      if (encode2.xc) {
        code2 += "o.x=o.xc-(o.width||0)/2;";
      }
      if (encode2.y2) {
        if (encode2.y) {
          if (Swap[marktype]) {
            code2 += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
          }
          code2 += "o.height=o.y2-o.y;";
        } else {
          code2 += "o.y=o.y2-(o.height||0);";
        }
      }
      if (encode2.yc) {
        code2 += "o.y=o.yc-(o.height||0)/2;";
      }
      return code2;
    }
    function canonicalType(type2) {
      return (type2 + "").toLowerCase();
    }
    function isOperator(type2) {
      return canonicalType(type2) === "operator";
    }
    function isCollect(type2) {
      return canonicalType(type2) === "collect";
    }
    function expression$2(ctx, args, code2) {
      if (!code2.endsWith(";")) {
        code2 = "return(" + code2 + ");";
      }
      const fn = Function(...args.concat(code2));
      return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
    }
    function _compare(u2, v, lt2, gt2) {
      return `((u = ${u2}) < (v = ${v}) || u == null) && v != null ? ${lt2}
  : (u > v || v == null) && u != null ? ${gt2}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt2}
  : v !== v && u === u ? ${gt2} : `;
    }
    var expressionCodegen = {
      /**
       * Parse an expression used to update an operator value.
       */
      operator: (ctx, expr2) => expression$2(ctx, ["_"], expr2.code),
      /**
       * Parse an expression provided as an operator parameter value.
       */
      parameter: (ctx, expr2) => expression$2(ctx, ["datum", "_"], expr2.code),
      /**
       * Parse an expression applied to an event stream.
       */
      event: (ctx, expr2) => expression$2(ctx, ["event"], expr2.code),
      /**
       * Parse an expression used to handle an event-driven operator update.
       */
      handler: (ctx, expr2) => {
        const code2 = `var datum=event.item&&event.item.datum;return ${expr2.code};`;
        return expression$2(ctx, ["_", "event"], code2);
      },
      /**
       * Parse an expression that performs visual encoding.
       */
      encode: (ctx, encode2) => {
        const {
          marktype,
          channels
        } = encode2;
        let code2 = "var o=item,datum=o.datum,m=0,$;";
        for (const name2 in channels) {
          const o = "o[" + $(name2) + "]";
          code2 += `$=${channels[name2].code};if(${o}!==$)${o}=$,m=1;`;
        }
        code2 += adjustSpatial$1(channels, marktype);
        code2 += "return m;";
        return expression$2(ctx, ["item", "_"], code2);
      },
      /**
       * Optimized code generators for access and comparison.
       */
      codegen: {
        get(path2) {
          const ref2 = `[${path2.map($).join("][")}]`;
          const get2 = Function("_", `return _${ref2};`);
          get2.path = ref2;
          return get2;
        },
        comparator(fields, orders) {
          let t4;
          const map2 = (f, i) => {
            const o = orders[i];
            let u2, v;
            if (f.path) {
              u2 = `a${f.path}`;
              v = `b${f.path}`;
            } else {
              (t4 = t4 || {})["f" + i] = f;
              u2 = `this.f${i}(a)`;
              v = `this.f${i}(b)`;
            }
            return _compare(u2, v, -o, o);
          };
          const fn = Function("a", "b", "var u, v; return " + fields.map(map2).join("") + "0;");
          return t4 ? fn.bind(t4) : fn;
        }
      }
    };
    function parseOperator(spec) {
      const ctx = this;
      if (isOperator(spec.type) || !spec.type) {
        ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
      } else {
        ctx.transform(spec, spec.type);
      }
    }
    function parseOperatorParameters(spec) {
      const ctx = this;
      if (spec.params) {
        const op = ctx.get(spec.id);
        if (!op)
          error("Invalid operator id: " + spec.id);
        ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
      }
    }
    function parseParameters$1(spec, params2) {
      params2 = params2 || {};
      const ctx = this;
      for (const key2 in spec) {
        const value2 = spec[key2];
        params2[key2] = isArray(value2) ? value2.map((v) => parseParameter$2(v, ctx, params2)) : parseParameter$2(value2, ctx, params2);
      }
      return params2;
    }
    function parseParameter$2(spec, ctx, params2) {
      if (!spec || !isObject(spec))
        return spec;
      for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
        p = PARSERS[i];
        if (has$1(spec, p.key)) {
          return p.parse(spec, ctx, params2);
        }
      }
      return spec;
    }
    var PARSERS = [{
      key: "$ref",
      parse: getOperator
    }, {
      key: "$key",
      parse: getKey
    }, {
      key: "$expr",
      parse: getExpression
    }, {
      key: "$field",
      parse: getField
    }, {
      key: "$encode",
      parse: getEncode
    }, {
      key: "$compare",
      parse: getCompare
    }, {
      key: "$context",
      parse: getContext
    }, {
      key: "$subflow",
      parse: getSubflow
    }, {
      key: "$tupleid",
      parse: getTupleId
    }];
    function getOperator(_, ctx) {
      return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
    }
    function getExpression(_, ctx, params2) {
      if (_.$params) {
        ctx.parseParameters(_.$params, params2);
      }
      const k = "e:" + _.$expr.code;
      return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields));
    }
    function getKey(_, ctx) {
      const k = "k:" + _.$key + "_" + !!_.$flat;
      return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));
    }
    function getField(_, ctx) {
      if (!_.$field)
        return null;
      const k = "f:" + _.$field + "_" + _.$name;
      return ctx.fn[k] || (ctx.fn[k] = field$1(_.$field, _.$name, ctx.expr.codegen));
    }
    function getCompare(_, ctx) {
      const k = "c:" + _.$compare + "_" + _.$order, c2 = array$2(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
      return ctx.fn[k] || (ctx.fn[k] = compare$8(c2, _.$order, ctx.expr.codegen));
    }
    function getEncode(_, ctx) {
      const spec = _.$encode, encode2 = {};
      for (const name2 in spec) {
        const enc = spec[name2];
        encode2[name2] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
        encode2[name2].output = enc.$output;
      }
      return encode2;
    }
    function getContext(_, ctx) {
      return ctx;
    }
    function getSubflow(_, ctx) {
      const spec = _.$subflow;
      return function(dataflow, key2, parent) {
        const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
        if (p)
          p.set(parent);
        op.detachSubflow = () => ctx.detach(subctx);
        return op;
      };
    }
    function getTupleId() {
      return tupleid;
    }
    function parseStream$2(spec) {
      var ctx = this, filter2 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
      if (spec.source) {
        stream2 = ctx.events(spec.source, spec.type, filter2);
      } else if (spec.merge) {
        args = spec.merge.map((_) => ctx.get(_));
        stream2 = args[0].merge.apply(args[0], args.slice(1));
      }
      if (spec.between) {
        args = spec.between.map((_) => ctx.get(_));
        stream2 = stream2.between(args[0], args[1]);
      }
      if (spec.filter) {
        stream2 = stream2.filter(filter2);
      }
      if (spec.throttle != null) {
        stream2 = stream2.throttle(+spec.throttle);
      }
      if (spec.debounce != null) {
        stream2 = stream2.debounce(+spec.debounce);
      }
      if (stream2 == null) {
        error("Invalid stream definition: " + JSON.stringify(spec));
      }
      if (spec.consume)
        stream2.consume(true);
      ctx.stream(spec, stream2);
    }
    function parseUpdate$1(spec) {
      var ctx = this, srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid, source2 = ctx.get(srcid), target2 = null, update2 = spec.update, params2 = void 0;
      if (!source2)
        error("Source not defined: " + spec.source);
      target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
      if (update2 && update2.$expr) {
        if (update2.$params) {
          params2 = ctx.parseParameters(update2.$params);
        }
        update2 = ctx.handlerExpression(update2.$expr);
      }
      ctx.update(spec, source2, target2, update2, params2);
    }
    const SKIP = {
      skip: true
    };
    function getState$1(options) {
      var ctx = this, state = {};
      if (options.signals) {
        var signals = state.signals = {};
        Object.keys(ctx.signals).forEach((key2) => {
          const op = ctx.signals[key2];
          if (options.signals(key2, op)) {
            signals[key2] = op.value;
          }
        });
      }
      if (options.data) {
        var data2 = state.data = {};
        Object.keys(ctx.data).forEach((key2) => {
          const dataset = ctx.data[key2];
          if (options.data(key2, dataset)) {
            data2[key2] = dataset.input.value;
          }
        });
      }
      if (ctx.subcontext && options.recurse !== false) {
        state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
      }
      return state;
    }
    function setState$1(state) {
      var ctx = this, df = ctx.dataflow, data2 = state.data, signals = state.signals;
      Object.keys(signals || {}).forEach((key2) => {
        df.update(ctx.signals[key2], signals[key2], SKIP);
      });
      Object.keys(data2 || {}).forEach((key2) => {
        df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data2[key2]));
      });
      (state.subcontext || []).forEach((substate, i) => {
        const subctx = ctx.subcontext[i];
        if (subctx)
          subctx.setState(substate);
      });
    }
    function context(df, transforms2, functions2, expr2) {
      return new Context(df, transforms2, functions2, expr2);
    }
    function Context(df, transforms2, functions2, expr2) {
      this.dataflow = df;
      this.transforms = transforms2;
      this.events = df.events.bind(df);
      this.expr = expr2 || expressionCodegen, this.signals = {};
      this.scales = {};
      this.nodes = {};
      this.data = {};
      this.fn = {};
      if (functions2) {
        this.functions = Object.create(functions2);
        this.functions.context = this;
      }
    }
    function Subcontext(ctx) {
      this.dataflow = ctx.dataflow;
      this.transforms = ctx.transforms;
      this.events = ctx.events;
      this.expr = ctx.expr;
      this.signals = Object.create(ctx.signals);
      this.scales = Object.create(ctx.scales);
      this.nodes = Object.create(ctx.nodes);
      this.data = Object.create(ctx.data);
      this.fn = Object.create(ctx.fn);
      if (ctx.functions) {
        this.functions = Object.create(ctx.functions);
        this.functions.context = this;
      }
    }
    Context.prototype = Subcontext.prototype = {
      fork() {
        const ctx = new Subcontext(this);
        (this.subcontext || (this.subcontext = [])).push(ctx);
        return ctx;
      },
      detach(ctx) {
        this.subcontext = this.subcontext.filter((c2) => c2 !== ctx);
        const keys2 = Object.keys(ctx.nodes);
        for (const key2 of keys2)
          ctx.nodes[key2]._targets = null;
        for (const key2 of keys2)
          ctx.nodes[key2].detach();
        ctx.nodes = null;
      },
      get(id2) {
        return this.nodes[id2];
      },
      set(id2, node) {
        return this.nodes[id2] = node;
      },
      add(spec, op) {
        const ctx = this, df = ctx.dataflow, data2 = spec.value;
        ctx.set(spec.id, op);
        if (isCollect(spec.type) && data2) {
          if (data2.$ingest) {
            df.ingest(op, data2.$ingest, data2.$format);
          } else if (data2.$request) {
            df.preload(op, data2.$request, data2.$format);
          } else {
            df.pulse(op, df.changeset().insert(data2));
          }
        }
        if (spec.root) {
          ctx.root = op;
        }
        if (spec.parent) {
          let p = ctx.get(spec.parent.$ref);
          if (p) {
            df.connect(p, [op]);
            op.targets().add(p);
          } else {
            (ctx.unresolved = ctx.unresolved || []).push(() => {
              p = ctx.get(spec.parent.$ref);
              df.connect(p, [op]);
              op.targets().add(p);
            });
          }
        }
        if (spec.signal) {
          ctx.signals[spec.signal] = op;
        }
        if (spec.scale) {
          ctx.scales[spec.scale] = op;
        }
        if (spec.data) {
          for (const name2 in spec.data) {
            const data3 = ctx.data[name2] || (ctx.data[name2] = {});
            spec.data[name2].forEach((role) => data3[role] = op);
          }
        }
      },
      resolve() {
        (this.unresolved || []).forEach((fn) => fn());
        delete this.unresolved;
        return this;
      },
      operator(spec, update2) {
        this.add(spec, this.dataflow.add(spec.value, update2));
      },
      transform(spec, type2) {
        this.add(spec, this.dataflow.add(this.transforms[canonicalType(type2)]));
      },
      stream(spec, stream2) {
        this.set(spec.id, stream2);
      },
      update(spec, stream2, target2, update2, params2) {
        this.dataflow.on(stream2, target2, update2, params2, spec.options);
      },
      // expression parsing
      operatorExpression(expr2) {
        return this.expr.operator(this, expr2);
      },
      parameterExpression(expr2) {
        return this.expr.parameter(this, expr2);
      },
      eventExpression(expr2) {
        return this.expr.event(this, expr2);
      },
      handlerExpression(expr2) {
        return this.expr.handler(this, expr2);
      },
      encodeExpression(encode2) {
        return this.expr.encode(this, encode2);
      },
      // parse methods
      parse: parse$2,
      parseOperator,
      parseOperatorParameters,
      parseParameters: parseParameters$1,
      parseStream: parseStream$2,
      parseUpdate: parseUpdate$1,
      // state methods
      getState: getState$1,
      setState: setState$1
    };
    function initializeAria(view) {
      const el = view.container();
      if (el) {
        el.setAttribute("role", "graphics-document");
        el.setAttribute("aria-roleDescription", "visualization");
        ariaLabel(el, view.description());
      }
    }
    function ariaLabel(el, desc) {
      if (el)
        desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
    }
    function background(view) {
      view.add(null, (_) => {
        view._background = _.bg;
        view._resize = 1;
        return _.bg;
      }, {
        bg: view._signals.background
      });
    }
    const Default = "default";
    function cursor$1(view) {
      const cursor2 = view._signals.cursor || (view._signals.cursor = view.add({
        user: Default,
        item: null
      }));
      view.on(view.events("view", "pointermove"), cursor2, (_, event2) => {
        const value2 = cursor2.value, user = value2 ? isString(value2) ? value2 : value2.user : Default, item = event2.item && event2.item.cursor || null;
        return value2 && user === value2.user && item == value2.item ? value2 : {
          user,
          item
        };
      });
      view.add(null, function(_) {
        let user = _.cursor, item = this.value;
        if (!isString(user)) {
          item = user.item;
          user = user.user;
        }
        setCursor(view, user && user !== Default ? user : item || user);
        return item;
      }, {
        cursor: cursor2
      });
    }
    function setCursor(view, cursor2) {
      const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
      if (el) {
        return cursor2 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor2;
      }
    }
    function dataref(view, name2) {
      var data2 = view._runtime.data;
      if (!has$1(data2, name2)) {
        error("Unrecognized data set: " + name2);
      }
      return data2[name2];
    }
    function data(name2, values2) {
      return arguments.length < 2 ? dataref(this, name2).values.value : change.call(this, name2, changeset().remove(truthy).insert(values2));
    }
    function change(name2, changes) {
      if (!isChangeSet(changes)) {
        error("Second argument to changes must be a changeset.");
      }
      const dataset = dataref(this, name2);
      dataset.modified = true;
      return this.pulse(dataset.input, changes);
    }
    function insert$1(name2, _) {
      return change.call(this, name2, changeset().insert(_));
    }
    function remove(name2, _) {
      return change.call(this, name2, changeset().remove(_));
    }
    function width(view) {
      var padding2 = view.padding();
      return Math.max(0, view._viewWidth + padding2.left + padding2.right);
    }
    function height(view) {
      var padding2 = view.padding();
      return Math.max(0, view._viewHeight + padding2.top + padding2.bottom);
    }
    function offset(view) {
      var padding2 = view.padding(), origin = view._origin;
      return [padding2.left + origin[0], padding2.top + origin[1]];
    }
    function resizeRenderer(view) {
      var origin = offset(view), w2 = width(view), h2 = height(view);
      view._renderer.background(view.background());
      view._renderer.resize(w2, h2, origin);
      view._handler.origin(origin);
      view._resizeListeners.forEach((handler) => {
        try {
          handler(w2, h2);
        } catch (error2) {
          view.error(error2);
        }
      });
    }
    function eventExtend(view, event2, item) {
      var r = view._renderer, el = r && r.canvas(), p, e3, translate2;
      if (el) {
        translate2 = offset(view);
        e3 = event2.changedTouches ? event2.changedTouches[0] : event2;
        p = point$2(e3, el);
        p[0] -= translate2[0];
        p[1] -= translate2[1];
      }
      event2.dataflow = view;
      event2.item = item;
      event2.vega = extension(view, item, p);
      return event2;
    }
    function extension(view, item, point2) {
      const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
      function group2(name2) {
        var g = itemGroup, i;
        if (name2)
          for (i = item; i; i = i.mark.group) {
            if (i.mark.name === name2) {
              g = i;
              break;
            }
          }
        return g && g.mark && g.mark.interactive ? g : {};
      }
      function xy(item2) {
        if (!item2)
          return point2;
        if (isString(item2))
          item2 = group2(item2);
        const p = point2.slice();
        while (item2) {
          p[0] -= item2.x || 0;
          p[1] -= item2.y || 0;
          item2 = item2.mark && item2.mark.group;
        }
        return p;
      }
      return {
        view: constant$1(view),
        item: constant$1(item || {}),
        group: group2,
        xy,
        x: (item2) => xy(item2)[0],
        y: (item2) => xy(item2)[1]
      };
    }
    const VIEW$1 = "view", TIMER = "timer", WINDOW = "window", NO_TRAP = {
      trap: false
    };
    function initializeEventConfig(config) {
      const events2 = extend({
        defaults: {}
      }, config);
      const unpack = (obj, keys2) => {
        keys2.forEach((k) => {
          if (isArray(obj[k]))
            obj[k] = toSet(obj[k]);
        });
      };
      unpack(events2.defaults, ["prevent", "allow"]);
      unpack(events2, ["view", "window", "selector"]);
      return events2;
    }
    function trackEventListener(view, sources, type2, handler) {
      view._eventListeners.push({
        type: type2,
        sources: array$2(sources),
        handler
      });
    }
    function prevent(view, type2) {
      var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
      return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type2] : allow ? !allow[type2] : view.preventDefault();
    }
    function permit(view, key2, type2) {
      const rule2 = view._eventConfig && view._eventConfig[key2];
      if (rule2 === false || isObject(rule2) && !rule2[type2]) {
        view.warn(`Blocked ${key2} ${type2} event listener.`);
        return false;
      }
      return true;
    }
    function events(source2, type2, filter2) {
      var view = this, s = new EventStream(filter2), send2 = function(e3, item) {
        view.runAsync(null, () => {
          if (source2 === VIEW$1 && prevent(view, type2)) {
            e3.preventDefault();
          }
          s.receive(eventExtend(view, e3, item));
        });
      }, sources;
      if (source2 === TIMER) {
        if (permit(view, "timer", type2)) {
          view.timer(send2, type2);
        }
      } else if (source2 === VIEW$1) {
        if (permit(view, "view", type2)) {
          view.addEventListener(type2, send2, NO_TRAP);
        }
      } else {
        if (source2 === WINDOW) {
          if (permit(view, "window", type2) && typeof window !== "undefined") {
            sources = [window];
          }
        } else if (typeof document !== "undefined") {
          if (permit(view, "selector", type2)) {
            sources = Array.from(document.querySelectorAll(source2));
          }
        }
        if (!sources) {
          view.warn("Can not resolve event source: " + source2);
        } else {
          for (var i = 0, n = sources.length; i < n; ++i) {
            sources[i].addEventListener(type2, send2);
          }
          trackEventListener(view, sources, type2, send2);
        }
      }
      return s;
    }
    function itemFilter(event2) {
      return event2.item;
    }
    function markTarget(event2) {
      return event2.item.mark.source;
    }
    function invoke(name2) {
      return function(_, event2) {
        return event2.vega.view().changeset().encode(event2.item, name2);
      };
    }
    function hover(hoverSet, leaveSet) {
      hoverSet = [hoverSet || "hover"];
      leaveSet = [leaveSet || "update", hoverSet[0]];
      this.on(this.events("view", "pointerover", itemFilter), markTarget, invoke(hoverSet));
      this.on(this.events("view", "pointerout", itemFilter), markTarget, invoke(leaveSet));
      return this;
    }
    function finalize() {
      var tooltip2 = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m2, e3;
      n = timers.length;
      while (--n >= 0) {
        timers[n].stop();
      }
      n = listeners.length;
      while (--n >= 0) {
        e3 = listeners[n];
        m2 = e3.sources.length;
        while (--m2 >= 0) {
          e3.sources[m2].removeEventListener(e3.type, e3.handler);
        }
      }
      if (tooltip2) {
        tooltip2.call(this, this._handler, null, null, null);
      }
      return this;
    }
    function element(tag2, attr2, text2) {
      const el = document.createElement(tag2);
      for (const key2 in attr2)
        el.setAttribute(key2, attr2[key2]);
      if (text2 != null)
        el.textContent = text2;
      return el;
    }
    const BindClass = "vega-bind", NameClass = "vega-bind-name", RadioClass = "vega-bind-radio";
    function bind(view, el, binding) {
      if (!el)
        return;
      const param2 = binding.param;
      let bind2 = binding.state;
      if (!bind2) {
        bind2 = binding.state = {
          elements: null,
          active: false,
          set: null,
          update: (value2) => {
            if (value2 != view.signal(param2.signal)) {
              view.runAsync(null, () => {
                bind2.source = true;
                view.signal(param2.signal, value2);
              });
            }
          }
        };
        if (param2.debounce) {
          bind2.update = debounce(param2.debounce, bind2.update);
        }
      }
      const create2 = param2.input == null && param2.element ? target : generate;
      create2(bind2, el, param2, view);
      if (!bind2.active) {
        view.on(view._signals[param2.signal], null, () => {
          bind2.source ? bind2.source = false : bind2.set(view.signal(param2.signal));
        });
        bind2.active = true;
      }
      return bind2;
    }
    function target(bind2, node, param2, view) {
      const type2 = param2.event || "input";
      const handler = () => bind2.update(node.value);
      view.signal(param2.signal, node.value);
      node.addEventListener(type2, handler);
      trackEventListener(view, node, type2, handler);
      bind2.set = (value2) => {
        node.value = value2;
        node.dispatchEvent(event(type2));
      };
    }
    function event(type2) {
      return typeof Event !== "undefined" ? new Event(type2) : {
        type: type2
      };
    }
    function generate(bind2, el, param2, view) {
      const value2 = view.signal(param2.signal);
      const div = element("div", {
        "class": BindClass
      });
      const wrapper = param2.input === "radio" ? div : div.appendChild(element("label"));
      wrapper.appendChild(element("span", {
        "class": NameClass
      }, param2.name || param2.signal));
      el.appendChild(div);
      let input = form;
      switch (param2.input) {
        case "checkbox":
          input = checkbox;
          break;
        case "select":
          input = select;
          break;
        case "radio":
          input = radio;
          break;
        case "range":
          input = range$2;
          break;
      }
      input(bind2, wrapper, param2, value2);
    }
    function form(bind2, el, param2, value2) {
      const node = element("input");
      for (const key2 in param2) {
        if (key2 !== "signal" && key2 !== "element") {
          node.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
        }
      }
      node.setAttribute("name", param2.signal);
      node.value = value2;
      el.appendChild(node);
      node.addEventListener("input", () => bind2.update(node.value));
      bind2.elements = [node];
      bind2.set = (value3) => node.value = value3;
    }
    function checkbox(bind2, el, param2, value2) {
      const attr2 = {
        type: "checkbox",
        name: param2.signal
      };
      if (value2)
        attr2.checked = true;
      const node = element("input", attr2);
      el.appendChild(node);
      node.addEventListener("change", () => bind2.update(node.checked));
      bind2.elements = [node];
      bind2.set = (value3) => node.checked = !!value3 || null;
    }
    function select(bind2, el, param2, value2) {
      const node = element("select", {
        name: param2.signal
      }), labels2 = param2.labels || [];
      param2.options.forEach((option, i) => {
        const attr2 = {
          value: option
        };
        if (valuesEqual(option, value2))
          attr2.selected = true;
        node.appendChild(element("option", attr2, (labels2[i] || option) + ""));
      });
      el.appendChild(node);
      node.addEventListener("change", () => {
        bind2.update(param2.options[node.selectedIndex]);
      });
      bind2.elements = [node];
      bind2.set = (value3) => {
        for (let i = 0, n = param2.options.length; i < n; ++i) {
          if (valuesEqual(param2.options[i], value3)) {
            node.selectedIndex = i;
            return;
          }
        }
      };
    }
    function radio(bind2, el, param2, value2) {
      const group2 = element("span", {
        "class": RadioClass
      }), labels2 = param2.labels || [];
      el.appendChild(group2);
      bind2.elements = param2.options.map((option, i) => {
        const attr2 = {
          type: "radio",
          name: param2.signal,
          value: option
        };
        if (valuesEqual(option, value2))
          attr2.checked = true;
        const input = element("input", attr2);
        input.addEventListener("change", () => bind2.update(option));
        const label2 = element("label", {}, (labels2[i] || option) + "");
        label2.prepend(input);
        group2.appendChild(label2);
        return input;
      });
      bind2.set = (value3) => {
        const nodes = bind2.elements, n = nodes.length;
        for (let i = 0; i < n; ++i) {
          if (valuesEqual(nodes[i].value, value3))
            nodes[i].checked = true;
        }
      };
    }
    function range$2(bind2, el, param2, value2) {
      value2 = value2 !== void 0 ? value2 : (+param2.max + +param2.min) / 2;
      const max2 = param2.max != null ? param2.max : Math.max(100, +value2) || 100, min2 = param2.min || Math.min(0, max2, +value2) || 0, step = param2.step || tickStep(min2, max2, 100);
      const node = element("input", {
        type: "range",
        name: param2.signal,
        min: min2,
        max: max2,
        step
      });
      node.value = value2;
      const span2 = element("span", {}, +value2);
      el.appendChild(node);
      el.appendChild(span2);
      const update2 = () => {
        span2.textContent = node.value;
        bind2.update(+node.value);
      };
      node.addEventListener("input", update2);
      node.addEventListener("change", update2);
      bind2.elements = [node];
      bind2.set = (value3) => {
        node.value = value3;
        span2.textContent = value3;
      };
    }
    function valuesEqual(a2, b2) {
      return a2 === b2 || a2 + "" === b2 + "";
    }
    function initializeRenderer(view, r, el, constructor, scaleFactor, opt) {
      r = r || new constructor(view.loader());
      return r.initialize(el, width(view), height(view), offset(view), scaleFactor, opt).background(view.background());
    }
    function trap(view, fn) {
      return !fn ? null : function() {
        try {
          fn.apply(this, arguments);
        } catch (error2) {
          view.error(error2);
        }
      };
    }
    function initializeHandler(view, prevHandler, el, constructor) {
      const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset(view), view);
      if (prevHandler) {
        prevHandler.handlers().forEach((h2) => {
          handler.on(h2.type, h2.handler);
        });
      }
      return handler;
    }
    function initialize(el, elBind) {
      const view = this, type2 = view._renderType, config = view._eventConfig.bind, module2 = renderModule(type2);
      el = view._el = el ? lookup$1(view, el, true) : null;
      initializeAria(view);
      if (!module2)
        view.error("Unrecognized renderer type: " + type2);
      const Handler2 = module2.handler || CanvasHandler, Renderer2 = el ? module2.renderer : module2.headless;
      view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
      view._handler = initializeHandler(view, view._handler, el, Handler2);
      view._redraw = true;
      if (el && config !== "none") {
        elBind = elBind ? view._elBind = lookup$1(view, elBind, true) : el.appendChild(element("form", {
          "class": "vega-bindings"
        }));
        view._bind.forEach((_) => {
          if (_.param.element && config !== "container") {
            _.element = lookup$1(view, _.param.element, !!_.param.input);
          }
        });
        view._bind.forEach((_) => {
          bind(view, _.element || elBind, _);
        });
      }
      return view;
    }
    function lookup$1(view, el, clear2) {
      if (typeof el === "string") {
        if (typeof document !== "undefined") {
          el = document.querySelector(el);
          if (!el) {
            view.error("Signal bind element not found: " + el);
            return null;
          }
        } else {
          view.error("DOM document instance not found.");
          return null;
        }
      }
      if (el && clear2) {
        try {
          el.textContent = "";
        } catch (e3) {
          el = null;
          view.error(e3);
        }
      }
      return el;
    }
    const number$1 = (_) => +_ || 0;
    const paddingObject$1 = (_) => ({
      top: _,
      bottom: _,
      left: _,
      right: _
    });
    function padding$1(_) {
      return isObject(_) ? {
        top: number$1(_.top),
        bottom: number$1(_.bottom),
        left: number$1(_.left),
        right: number$1(_.right)
      } : paddingObject$1(number$1(_));
    }
    async function renderHeadless(view, type2, scaleFactor, opt) {
      const module2 = renderModule(type2), ctr = module2 && module2.headless;
      if (!ctr)
        error("Unrecognized renderer type: " + type2);
      await view.runAsync();
      return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
    }
    async function renderToImageURL(type2, scaleFactor) {
      if (type2 !== RenderType.Canvas && type2 !== RenderType.SVG && type2 !== RenderType.PNG) {
        error("Unrecognized image type: " + type2);
      }
      const r = await renderHeadless(this, type2, scaleFactor);
      return type2 === RenderType.SVG ? toBlobURL(r.svg(), "image/svg+xml") : r.canvas().toDataURL("image/png");
    }
    function toBlobURL(data2, mime) {
      const blob = new Blob([data2], {
        type: mime
      });
      return window.URL.createObjectURL(blob);
    }
    async function renderToCanvas(scaleFactor, opt) {
      const r = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
      return r.canvas();
    }
    async function renderToSVG(scaleFactor) {
      const r = await renderHeadless(this, RenderType.SVG, scaleFactor);
      return r.svg();
    }
    function runtime(view, spec, expr2) {
      return context(view, transforms, functionContext, expr2).parse(spec);
    }
    function scale$1(name2) {
      var scales2 = this._runtime.scales;
      if (!has$1(scales2, name2)) {
        error("Unrecognized scale or projection: " + name2);
      }
      return scales2[name2].value;
    }
    var Width = "width", Height = "height", Padding = "padding", Skip$1 = {
      skip: true
    };
    function viewWidth(view, width2) {
      var a2 = view.autosize(), p = view.padding();
      return width2 - (a2 && a2.contains === Padding ? p.left + p.right : 0);
    }
    function viewHeight(view, height2) {
      var a2 = view.autosize(), p = view.padding();
      return height2 - (a2 && a2.contains === Padding ? p.top + p.bottom : 0);
    }
    function initializeResize(view) {
      var s = view._signals, w2 = s[Width], h2 = s[Height], p = s[Padding];
      function resetSize() {
        view._autosize = view._resize = 1;
      }
      view._resizeWidth = view.add(null, (_) => {
        view._width = _.size;
        view._viewWidth = viewWidth(view, _.size);
        resetSize();
      }, {
        size: w2
      });
      view._resizeHeight = view.add(null, (_) => {
        view._height = _.size;
        view._viewHeight = viewHeight(view, _.size);
        resetSize();
      }, {
        size: h2
      });
      const resizePadding = view.add(null, resetSize, {
        pad: p
      });
      view._resizeWidth.rank = w2.rank + 1;
      view._resizeHeight.rank = h2.rank + 1;
      resizePadding.rank = p.rank + 1;
    }
    function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
      this.runAfter((view) => {
        let rerun2 = 0;
        view._autosize = 0;
        if (view.width() !== width2) {
          rerun2 = 1;
          view.signal(Width, width2, Skip$1);
          view._resizeWidth.skip(true);
        }
        if (view.height() !== height2) {
          rerun2 = 1;
          view.signal(Height, height2, Skip$1);
          view._resizeHeight.skip(true);
        }
        if (view._viewWidth !== viewWidth2) {
          view._resize = 1;
          view._viewWidth = viewWidth2;
        }
        if (view._viewHeight !== viewHeight2) {
          view._resize = 1;
          view._viewHeight = viewHeight2;
        }
        if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
          view._resize = 1;
          view._origin = origin;
        }
        if (rerun2)
          view.run("enter");
        if (auto)
          view.runAfter((v) => v.resize());
      }, false, 1);
    }
    function getState(options) {
      return this._runtime.getState(options || {
        data: dataTest,
        signals: signalTest,
        recurse: true
      });
    }
    function dataTest(name2, data2) {
      return data2.modified && isArray(data2.input.value) && !name2.startsWith("_:vega:_");
    }
    function signalTest(name2, op) {
      return !(name2 === "parent" || op instanceof transforms.proxy);
    }
    function setState(state) {
      this.runAsync(null, (v) => {
        v._trigger = false;
        v._runtime.setState(state);
      }, (v) => {
        v._trigger = true;
      });
      return this;
    }
    function timer(callback, delay2) {
      function tick2(elapsed) {
        callback({
          timestamp: Date.now(),
          elapsed
        });
      }
      this._timers.push(interval$1(tick2, delay2));
    }
    function defaultTooltip(handler, event2, item, value2) {
      const el = handler.element();
      if (el)
        el.setAttribute("title", formatTooltip(value2));
    }
    function formatTooltip(value2) {
      return value2 == null ? "" : isArray(value2) ? formatArray(value2) : isObject(value2) && !isDate$1(value2) ? formatObject(value2) : value2 + "";
    }
    function formatObject(obj) {
      return Object.keys(obj).map((key2) => {
        const v = obj[key2];
        return key2 + ": " + (isArray(v) ? formatArray(v) : formatValue$1(v));
      }).join("\n");
    }
    function formatArray(value2) {
      return "[" + value2.map(formatValue$1).join(", ") + "]";
    }
    function formatValue$1(value2) {
      return isArray(value2) ? "[]" : isObject(value2) && !isDate$1(value2) ? "{}" : value2;
    }
    function watchPixelRatio() {
      if (this.renderer() === "canvas" && this._renderer._canvas) {
        let remove2 = null;
        const updatePixelRatio = () => {
          if (remove2 != null) {
            remove2();
          }
          const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
          media.addEventListener("change", updatePixelRatio);
          remove2 = () => {
            media.removeEventListener("change", updatePixelRatio);
          };
          this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1;
          this._redraw = true;
          this._resize = 1;
          this.resize().runAsync();
        };
        updatePixelRatio();
      }
    }
    function View$1(spec, options) {
      const view = this;
      options = options || {};
      Dataflow.call(view);
      if (options.loader)
        view.loader(options.loader);
      if (options.logger)
        view.logger(options.logger);
      if (options.logLevel != null)
        view.logLevel(options.logLevel);
      if (options.locale || spec.locale) {
        const loc = extend({}, spec.locale, options.locale);
        view.locale(locale(loc.number, loc.time));
      }
      view._el = null;
      view._elBind = null;
      view._renderType = options.renderer || RenderType.Canvas;
      view._scenegraph = new Scenegraph();
      const root2 = view._scenegraph.root;
      view._renderer = null;
      view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
      view._handler = new CanvasHandler().scene(root2);
      view._globalCursor = false;
      view._preventDefault = false;
      view._timers = [];
      view._eventListeners = [];
      view._resizeListeners = [];
      view._eventConfig = initializeEventConfig(spec.eventConfig);
      view.globalCursor(view._eventConfig.globalCursor);
      const ctx = runtime(view, spec, options.expr);
      view._runtime = ctx;
      view._signals = ctx.signals;
      view._bind = (spec.bindings || []).map((_) => ({
        state: null,
        param: extend({}, _)
      }));
      if (ctx.root)
        ctx.root.set(root2);
      root2.source = ctx.data.root.input;
      view.pulse(ctx.data.root.input, view.changeset().insert(root2.items));
      view._width = view.width();
      view._height = view.height();
      view._viewWidth = viewWidth(view, view._width);
      view._viewHeight = viewHeight(view, view._height);
      view._origin = [0, 0];
      view._resize = 0;
      view._autosize = 1;
      initializeResize(view);
      background(view);
      cursor$1(view);
      view.description(spec.description);
      if (options.hover)
        view.hover();
      if (options.container)
        view.initialize(options.container, options.bind);
      if (options.watchPixelRatio)
        view._watchPixelRatio();
    }
    function lookupSignal(view, name2) {
      return has$1(view._signals, name2) ? view._signals[name2] : error("Unrecognized signal name: " + $(name2));
    }
    function findOperatorHandler(op, handler) {
      const h2 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
      return h2.length ? h2[0] : null;
    }
    function addOperatorListener(view, name2, op, handler) {
      let h2 = findOperatorHandler(op, handler);
      if (!h2) {
        h2 = trap(view, () => handler(name2, op.value));
        h2.handler = handler;
        view.on(op, null, h2);
      }
      return view;
    }
    function removeOperatorListener(view, op, handler) {
      const h2 = findOperatorHandler(op, handler);
      if (h2)
        op._targets.remove(h2);
      return view;
    }
    inherits(View$1, Dataflow, {
      // -- DATAFLOW / RENDERING ----
      async evaluate(encode2, prerun, postrun) {
        await Dataflow.prototype.evaluate.call(this, encode2, prerun);
        if (this._redraw || this._resize) {
          try {
            if (this._renderer) {
              if (this._resize) {
                this._resize = 0;
                resizeRenderer(this);
              }
              await this._renderer.renderAsync(this._scenegraph.root);
            }
            this._redraw = false;
          } catch (e3) {
            this.error(e3);
          }
        }
        if (postrun)
          asyncCallback(this, postrun);
        return this;
      },
      dirty(item) {
        this._redraw = true;
        this._renderer && this._renderer.dirty(item);
      },
      // -- GET / SET ----
      description(text2) {
        if (arguments.length) {
          const desc = text2 != null ? text2 + "" : null;
          if (desc !== this._desc)
            ariaLabel(this._el, this._desc = desc);
          return this;
        }
        return this._desc;
      },
      container() {
        return this._el;
      },
      scenegraph() {
        return this._scenegraph;
      },
      origin() {
        return this._origin.slice();
      },
      signal(name2, value2, options) {
        const op = lookupSignal(this, name2);
        return arguments.length === 1 ? op.value : this.update(op, value2, options);
      },
      width(_) {
        return arguments.length ? this.signal("width", _) : this.signal("width");
      },
      height(_) {
        return arguments.length ? this.signal("height", _) : this.signal("height");
      },
      padding(_) {
        return arguments.length ? this.signal("padding", padding$1(_)) : padding$1(this.signal("padding"));
      },
      autosize(_) {
        return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
      },
      background(_) {
        return arguments.length ? this.signal("background", _) : this.signal("background");
      },
      renderer(type2) {
        if (!arguments.length)
          return this._renderType;
        if (!renderModule(type2))
          error("Unrecognized renderer type: " + type2);
        if (type2 !== this._renderType) {
          this._renderType = type2;
          this._resetRenderer();
        }
        return this;
      },
      tooltip(handler) {
        if (!arguments.length)
          return this._tooltip;
        if (handler !== this._tooltip) {
          this._tooltip = handler;
          this._resetRenderer();
        }
        return this;
      },
      loader(loader2) {
        if (!arguments.length)
          return this._loader;
        if (loader2 !== this._loader) {
          Dataflow.prototype.loader.call(this, loader2);
          this._resetRenderer();
        }
        return this;
      },
      resize() {
        this._autosize = 1;
        return this.touch(lookupSignal(this, "autosize"));
      },
      _resetRenderer() {
        if (this._renderer) {
          this._renderer = null;
          this.initialize(this._el, this._elBind);
        }
      },
      // -- SIZING ----
      _resizeView: resizeView,
      // -- EVENT HANDLING ----
      addEventListener(type2, handler, options) {
        let callback = handler;
        if (!(options && options.trap === false)) {
          callback = trap(this, handler);
          callback.raw = handler;
        }
        this._handler.on(type2, callback);
        return this;
      },
      removeEventListener(type2, handler) {
        var handlers = this._handler.handlers(type2), i = handlers.length, h2, t4;
        while (--i >= 0) {
          t4 = handlers[i].type;
          h2 = handlers[i].handler;
          if (type2 === t4 && (handler === h2 || handler === h2.raw)) {
            this._handler.off(t4, h2);
            break;
          }
        }
        return this;
      },
      addResizeListener(handler) {
        const l = this._resizeListeners;
        if (!l.includes(handler)) {
          l.push(handler);
        }
        return this;
      },
      removeResizeListener(handler) {
        var l = this._resizeListeners, i = l.indexOf(handler);
        if (i >= 0) {
          l.splice(i, 1);
        }
        return this;
      },
      addSignalListener(name2, handler) {
        return addOperatorListener(this, name2, lookupSignal(this, name2), handler);
      },
      removeSignalListener(name2, handler) {
        return removeOperatorListener(this, lookupSignal(this, name2), handler);
      },
      addDataListener(name2, handler) {
        return addOperatorListener(this, name2, dataref(this, name2).values, handler);
      },
      removeDataListener(name2, handler) {
        return removeOperatorListener(this, dataref(this, name2).values, handler);
      },
      globalCursor(_) {
        if (arguments.length) {
          if (this._globalCursor !== !!_) {
            const prev2 = setCursor(this, null);
            this._globalCursor = !!_;
            if (prev2)
              setCursor(this, prev2);
          }
          return this;
        } else {
          return this._globalCursor;
        }
      },
      preventDefault(_) {
        if (arguments.length) {
          this._preventDefault = _;
          return this;
        } else {
          return this._preventDefault;
        }
      },
      timer,
      events,
      finalize,
      hover,
      // -- DATA ----
      data,
      change,
      insert: insert$1,
      remove,
      // -- SCALES --
      scale: scale$1,
      // -- INITIALIZATION ----
      initialize,
      // -- HEADLESS RENDERING ----
      toImageURL: renderToImageURL,
      toCanvas: renderToCanvas,
      toSVG: renderToSVG,
      // -- SAVE / RESTORE STATE ----
      getState,
      setState,
      // RE-RENDER ON ZOOM
      _watchPixelRatio: watchPixelRatio
    });
    const VIEW = "view", LBRACK = "[", RBRACK = "]", LBRACE = "{", RBRACE = "}", COLON = ":", COMMA = ",", NAME = "@", GT = ">", ILLEGAL = /[[\]{}]/, DEFAULT_MARKS = {
      "*": 1,
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };
    let DEFAULT_SOURCE, MARKS;
    function eventSelector(selector2, source2, marks) {
      DEFAULT_SOURCE = source2 || VIEW;
      MARKS = marks || DEFAULT_MARKS;
      return parseMerge(selector2.trim()).map(parseSelector);
    }
    function isMarkType(type2) {
      return MARKS[type2];
    }
    function find(s, i, endChar, pushChar, popChar) {
      const n = s.length;
      let count2 = 0, c2;
      for (; i < n; ++i) {
        c2 = s[i];
        if (!count2 && c2 === endChar)
          return i;
        else if (popChar && popChar.indexOf(c2) >= 0)
          --count2;
        else if (pushChar && pushChar.indexOf(c2) >= 0)
          ++count2;
      }
      return i;
    }
    function parseMerge(s) {
      const output2 = [], n = s.length;
      let start2 = 0, i = 0;
      while (i < n) {
        i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
        output2.push(s.substring(start2, i).trim());
        start2 = ++i;
      }
      if (output2.length === 0) {
        throw "Empty event selector: " + s;
      }
      return output2;
    }
    function parseSelector(s) {
      return s[0] === "[" ? parseBetween(s) : parseStream$1(s);
    }
    function parseBetween(s) {
      const n = s.length;
      let i = 1, b2;
      i = find(s, i, RBRACK, LBRACK, RBRACK);
      if (i === n) {
        throw "Empty between selector: " + s;
      }
      b2 = parseMerge(s.substring(1, i));
      if (b2.length !== 2) {
        throw "Between selector must have two elements: " + s;
      }
      s = s.slice(i + 1).trim();
      if (s[0] !== GT) {
        throw "Expected '>' after between selector: " + s;
      }
      b2 = b2.map(parseSelector);
      const stream2 = parseSelector(s.slice(1).trim());
      if (stream2.between) {
        return {
          between: b2,
          stream: stream2
        };
      } else {
        stream2.between = b2;
      }
      return stream2;
    }
    function parseStream$1(s) {
      const stream2 = {
        source: DEFAULT_SOURCE
      }, source2 = [];
      let throttle = [0, 0], markname = 0, start2 = 0, n = s.length, i = 0, j, filter2;
      if (s[n - 1] === RBRACE) {
        i = s.lastIndexOf(LBRACE);
        if (i >= 0) {
          try {
            throttle = parseThrottle(s.substring(i + 1, n - 1));
          } catch (e3) {
            throw "Invalid throttle specification: " + s;
          }
          s = s.slice(0, i).trim();
          n = s.length;
        } else
          throw "Unmatched right brace: " + s;
        i = 0;
      }
      if (!n)
        throw s;
      if (s[0] === NAME)
        markname = ++i;
      j = find(s, i, COLON);
      if (j < n) {
        source2.push(s.substring(start2, j).trim());
        start2 = i = ++j;
      }
      i = find(s, i, LBRACK);
      if (i === n) {
        source2.push(s.substring(start2, n).trim());
      } else {
        source2.push(s.substring(start2, i).trim());
        filter2 = [];
        start2 = ++i;
        if (start2 === n)
          throw "Unmatched left bracket: " + s;
      }
      while (i < n) {
        i = find(s, i, RBRACK);
        if (i === n)
          throw "Unmatched left bracket: " + s;
        filter2.push(s.substring(start2, i).trim());
        if (i < n - 1 && s[++i] !== LBRACK)
          throw "Expected left bracket: " + s;
        start2 = ++i;
      }
      if (!(n = source2.length) || ILLEGAL.test(source2[n - 1])) {
        throw "Invalid event selector: " + s;
      }
      if (n > 1) {
        stream2.type = source2[1];
        if (markname) {
          stream2.markname = source2[0].slice(1);
        } else if (isMarkType(source2[0])) {
          stream2.marktype = source2[0];
        } else {
          stream2.source = source2[0];
        }
      } else {
        stream2.type = source2[0];
      }
      if (stream2.type.slice(-1) === "!") {
        stream2.consume = true;
        stream2.type = stream2.type.slice(0, -1);
      }
      if (filter2 != null)
        stream2.filter = filter2;
      if (throttle[0])
        stream2.throttle = throttle[0];
      if (throttle[1])
        stream2.debounce = throttle[1];
      return stream2;
    }
    function parseThrottle(s) {
      const a2 = s.split(COMMA);
      if (!s.length || a2.length > 2)
        throw s;
      return a2.map((_) => {
        const x2 = +_;
        if (x2 !== x2)
          throw s;
        return x2;
      });
    }
    function parseAutosize(spec) {
      return isObject(spec) ? spec : {
        type: spec || "pad"
      };
    }
    const number = (_) => +_ || 0;
    const paddingObject = (_) => ({
      top: _,
      bottom: _,
      left: _,
      right: _
    });
    function parsePadding(spec) {
      return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {
        top: number(spec.top),
        bottom: number(spec.bottom),
        left: number(spec.left),
        right: number(spec.right)
      };
    }
    const encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
      value: _
    };
    function addEncode(object2, name2, value2, set2) {
      if (value2 != null) {
        const isEncoder = isObject(value2) && !isArray(value2) || isArray(value2) && value2.length && isObject(value2[0]);
        if (isEncoder) {
          object2.update[name2] = value2;
        } else {
          object2[set2 || "enter"][name2] = {
            value: value2
          };
        }
        return 1;
      } else {
        return 0;
      }
    }
    function addEncoders(object2, enter, update2) {
      for (const name2 in enter) {
        addEncode(object2, name2, enter[name2]);
      }
      for (const name2 in update2) {
        addEncode(object2, name2, update2[name2], "update");
      }
    }
    function extendEncode(encode2, extra, skip) {
      for (const name2 in extra) {
        if (skip && has$1(skip, name2))
          continue;
        encode2[name2] = extend(encode2[name2] || {}, extra[name2]);
      }
      return encode2;
    }
    function has(key2, encode2) {
      return encode2 && (encode2.enter && encode2.enter[key2] || encode2.update && encode2.update[key2]);
    }
    const MarkRole = "mark";
    const FrameRole = "frame";
    const ScopeRole = "scope";
    const AxisRole = "axis";
    const AxisDomainRole = "axis-domain";
    const AxisGridRole = "axis-grid";
    const AxisLabelRole = "axis-label";
    const AxisTickRole = "axis-tick";
    const AxisTitleRole = "axis-title";
    const LegendRole = "legend";
    const LegendBandRole = "legend-band";
    const LegendEntryRole = "legend-entry";
    const LegendGradientRole = "legend-gradient";
    const LegendLabelRole = "legend-label";
    const LegendSymbolRole = "legend-symbol";
    const LegendTitleRole = "legend-title";
    const TitleRole = "title";
    const TitleTextRole = "title-text";
    const TitleSubtitleRole = "title-subtitle";
    function applyDefaults(encode2, type2, role, style2, config) {
      const defaults2 = {}, enter = {};
      let update2, key2, skip, props;
      key2 = "lineBreak";
      if (type2 === "text" && config[key2] != null && !has(key2, encode2)) {
        applyDefault(defaults2, key2, config[key2]);
      }
      if (role == "legend" || String(role).startsWith("axis")) {
        role = null;
      }
      props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type2]) : null;
      for (key2 in props) {
        skip = has(key2, encode2) || (key2 === "fill" || key2 === "stroke") && (has("fill", encode2) || has("stroke", encode2));
        if (!skip)
          applyDefault(defaults2, key2, props[key2]);
      }
      array$2(style2).forEach((name2) => {
        const props2 = config.style && config.style[name2];
        for (const key3 in props2) {
          if (!has(key3, encode2)) {
            applyDefault(defaults2, key3, props2[key3]);
          }
        }
      });
      encode2 = extend({}, encode2);
      for (key2 in defaults2) {
        props = defaults2[key2];
        if (props.signal) {
          (update2 = update2 || {})[key2] = props;
        } else {
          enter[key2] = props;
        }
      }
      encode2.enter = extend(enter, encode2.enter);
      if (update2)
        encode2.update = extend(update2, encode2.update);
      return encode2;
    }
    function applyDefault(defaults2, key2, value2) {
      defaults2[key2] = value2 && value2.signal ? {
        signal: value2.signal
      } : {
        value: value2
      };
    }
    const scaleRef = (scale2) => isString(scale2) ? $(scale2) : scale2.signal ? `(${scale2.signal})` : field(scale2);
    function entry$1(enc) {
      if (enc.gradient != null) {
        return gradient$1(enc);
      }
      let value2 = enc.signal ? `(${enc.signal})` : enc.color ? color$1(enc.color) : enc.field != null ? field(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
      if (enc.scale != null) {
        value2 = scale(enc, value2);
      }
      if (value2 === void 0) {
        value2 = null;
      }
      if (enc.exponent != null) {
        value2 = `pow(${value2},${property(enc.exponent)})`;
      }
      if (enc.mult != null) {
        value2 += `*${property(enc.mult)}`;
      }
      if (enc.offset != null) {
        value2 += `+${property(enc.offset)}`;
      }
      if (enc.round) {
        value2 = `round(${value2})`;
      }
      return value2;
    }
    const _color = (type2, x2, y2, z) => `(${type2}(${[x2, y2, z].map(entry$1).join(",")})+'')`;
    function color$1(enc) {
      return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
    }
    function gradient$1(enc) {
      const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
      while (args.length && peek$1(args) == null)
        args.pop();
      args.unshift(scaleRef(enc.gradient));
      return `gradient(${args.join(",")})`;
    }
    function property(property2) {
      return isObject(property2) ? "(" + entry$1(property2) + ")" : property2;
    }
    function field(ref2) {
      return resolveField(isObject(ref2) ? ref2 : {
        datum: ref2
      });
    }
    function resolveField(ref2) {
      let object2, level, field2;
      if (ref2.signal) {
        object2 = "datum";
        field2 = ref2.signal;
      } else if (ref2.group || ref2.parent) {
        level = Math.max(1, ref2.level || 1);
        object2 = "item";
        while (level-- > 0) {
          object2 += ".mark.group";
        }
        if (ref2.parent) {
          field2 = ref2.parent;
          object2 += ".datum";
        } else {
          field2 = ref2.group;
        }
      } else if (ref2.datum) {
        object2 = "datum";
        field2 = ref2.datum;
      } else {
        error("Invalid field reference: " + $(ref2));
      }
      if (!ref2.signal) {
        field2 = isString(field2) ? splitAccessPath(field2).map($).join("][") : resolveField(field2);
      }
      return object2 + "[" + field2 + "]";
    }
    function scale(enc, value2) {
      const scale2 = scaleRef(enc.scale);
      if (enc.range != null) {
        value2 = `lerp(_range(${scale2}), ${+enc.range})`;
      } else {
        if (value2 !== void 0)
          value2 = `_scale(${scale2}, ${value2})`;
        if (enc.band) {
          value2 = (value2 ? value2 + "+" : "") + `_bandwidth(${scale2})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
          if (enc.extra) {
            value2 = `(datum.extra ? _scale(${scale2}, datum.extra.value) : ${value2})`;
          }
        }
        if (value2 == null)
          value2 = "0";
      }
      return value2;
    }
    function rule$1(enc) {
      let code2 = "";
      enc.forEach((rule2) => {
        const value2 = entry$1(rule2);
        code2 += rule2.test ? `(${rule2.test})?${value2}:` : value2;
      });
      if (peek$1(code2) === ":") {
        code2 += "null";
      }
      return code2;
    }
    function parseEncode(encode2, type2, role, style2, scope, params2) {
      const enc = {};
      params2 = params2 || {};
      params2.encoders = {
        $encode: enc
      };
      encode2 = applyDefaults(encode2, type2, role, style2, scope.config);
      for (const key2 in encode2) {
        enc[key2] = parseBlock(encode2[key2], type2, params2, scope);
      }
      return params2;
    }
    function parseBlock(block2, marktype, params2, scope) {
      const channels = {}, fields = {};
      for (const name2 in block2) {
        if (block2[name2] != null) {
          channels[name2] = parse$1(expr(block2[name2]), scope, params2, fields);
        }
      }
      return {
        $expr: {
          marktype,
          channels
        },
        $fields: Object.keys(fields),
        $output: Object.keys(block2)
      };
    }
    function expr(enc) {
      return isArray(enc) ? rule$1(enc) : entry$1(enc);
    }
    function parse$1(code2, scope, params2, fields) {
      const expr2 = parser(code2, scope);
      expr2.$fields.forEach((name2) => fields[name2] = 1);
      extend(params2, expr2.$params);
      return expr2.$expr;
    }
    const OUTER = "outer", OUTER_INVALID = ["value", "update", "init", "react", "bind"];
    function outerError(prefix, name2) {
      error(prefix + ' for "outer" push: ' + $(name2));
    }
    function parseSignal(signal, scope) {
      const name2 = signal.name;
      if (signal.push === OUTER) {
        if (!scope.signals[name2])
          outerError("No prior signal definition", name2);
        OUTER_INVALID.forEach((prop) => {
          if (signal[prop] !== void 0)
            outerError("Invalid property ", prop);
        });
      } else {
        const op = scope.addSignal(name2, signal.value);
        if (signal.react === false)
          op.react = false;
        if (signal.bind)
          scope.addBinding(name2, signal.bind);
      }
    }
    function Entry$1(type2, value2, params2, parent) {
      this.id = -1;
      this.type = type2;
      this.value = value2;
      this.params = params2;
      if (parent)
        this.parent = parent;
    }
    function entry(type2, value2, params2, parent) {
      return new Entry$1(type2, value2, params2, parent);
    }
    function operator(value2, params2) {
      return entry("operator", value2, params2);
    }
    function ref(op) {
      const ref2 = {
        $ref: op.id
      };
      if (op.id < 0)
        (op.refs = op.refs || []).push(ref2);
      return ref2;
    }
    function fieldRef$1(field2, name2) {
      return name2 ? {
        $field: field2,
        $name: name2
      } : {
        $field: field2
      };
    }
    const keyFieldRef = fieldRef$1("key");
    function compareRef(fields, orders) {
      return {
        $compare: fields,
        $order: orders
      };
    }
    function keyRef(fields, flat) {
      const ref2 = {
        $key: fields
      };
      if (flat)
        ref2.$flat = true;
      return ref2;
    }
    const Ascending = "ascending";
    const Descending = "descending";
    function sortKey(sort2) {
      return !isObject(sort2) ? "" : (sort2.order === Descending ? "-" : "+") + aggrField(sort2.op, sort2.field);
    }
    function aggrField(op, field2) {
      return (op && op.signal ? "$" + op.signal : op || "") + (op && field2 ? "_" : "") + (field2 && field2.signal ? "$" + field2.signal : field2 || "");
    }
    const Scope$1 = "scope";
    const View = "view";
    function isSignal(_) {
      return _ && _.signal;
    }
    function isExpr$1(_) {
      return _ && _.expr;
    }
    function hasSignal(_) {
      if (isSignal(_))
        return true;
      if (isObject(_))
        for (const key2 in _) {
          if (hasSignal(_[key2]))
            return true;
        }
      return false;
    }
    function value(specValue, defaultValue) {
      return specValue != null ? specValue : defaultValue;
    }
    function deref(v) {
      return v && v.signal || v;
    }
    const Timer = "timer";
    function parseStream(stream2, scope) {
      const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
      return method2(stream2, scope);
    }
    function eventSource(source2) {
      return source2 === Scope$1 ? View : source2 || View;
    }
    function mergeStream(stream2, scope) {
      const list2 = stream2.merge.map((s) => parseStream(s, scope)), entry2 = streamParameters({
        merge: list2
      }, stream2, scope);
      return scope.addStream(entry2).id;
    }
    function nestedStream(stream2, scope) {
      const id2 = parseStream(stream2.stream, scope), entry2 = streamParameters({
        stream: id2
      }, stream2, scope);
      return scope.addStream(entry2).id;
    }
    function eventStream(stream2, scope) {
      let id2;
      if (stream2.type === Timer) {
        id2 = scope.event(Timer, stream2.throttle);
        stream2 = {
          between: stream2.between,
          filter: stream2.filter
        };
      } else {
        id2 = scope.event(eventSource(stream2.source), stream2.type);
      }
      const entry2 = streamParameters({
        stream: id2
      }, stream2, scope);
      return Object.keys(entry2).length === 1 ? id2 : scope.addStream(entry2).id;
    }
    function streamParameters(entry2, stream2, scope) {
      let param2 = stream2.between;
      if (param2) {
        if (param2.length !== 2) {
          error('Stream "between" parameter must have 2 entries: ' + $(stream2));
        }
        entry2.between = [parseStream(param2[0], scope), parseStream(param2[1], scope)];
      }
      param2 = stream2.filter ? [].concat(stream2.filter) : [];
      if (stream2.marktype || stream2.markname || stream2.markrole) {
        param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
      }
      if (stream2.source === Scope$1) {
        param2.push("inScope(event.item)");
      }
      if (param2.length) {
        entry2.filter = parser("(" + param2.join(")&&(") + ")", scope).$expr;
      }
      if ((param2 = stream2.throttle) != null) {
        entry2.throttle = +param2;
      }
      if ((param2 = stream2.debounce) != null) {
        entry2.debounce = +param2;
      }
      if (stream2.consume) {
        entry2.consume = true;
      }
      return entry2;
    }
    function filterMark(type2, name2, role) {
      const item = "event.item";
      return item + (type2 && type2 !== "*" ? "&&" + item + ".mark.marktype==='" + type2 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name2 ? "&&" + item + ".mark.name==='" + name2 + "'" : "");
    }
    const OP_VALUE_EXPR = {
      code: "_.$value",
      ast: {
        type: "Identifier",
        value: "value"
      }
    };
    function parseUpdate(spec, scope, target2) {
      const encode2 = spec.encode, entry2 = {
        target: target2
      };
      let events2 = spec.events, update2 = spec.update, sources = [];
      if (!events2) {
        error("Signal update missing events specification.");
      }
      if (isString(events2)) {
        events2 = eventSelector(events2, scope.isSubscope() ? Scope$1 : View);
      }
      events2 = array$2(events2).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
      if (sources.length > 1) {
        sources = [mergeSources(sources)];
      }
      if (events2.length) {
        sources.push(events2.length > 1 ? {
          merge: events2
        } : events2[0]);
      }
      if (encode2 != null) {
        if (update2)
          error("Signal encode and update are mutually exclusive.");
        update2 = "encode(item()," + $(encode2) + ")";
      }
      entry2.update = isString(update2) ? parser(update2, scope) : update2.expr != null ? parser(update2.expr, scope) : update2.value != null ? update2.value : update2.signal != null ? {
        $expr: OP_VALUE_EXPR,
        $params: {
          $value: scope.signalRef(update2.signal)
        }
      } : error("Invalid signal update specification.");
      if (spec.force) {
        entry2.options = {
          force: true
        };
      }
      sources.forEach((source2) => scope.addUpdate(extend(streamSource(source2, scope), entry2)));
    }
    function streamSource(stream2, scope) {
      return {
        source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream(stream2, scope)
      };
    }
    function mergeSources(sources) {
      return {
        signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
      };
    }
    function parseSignalUpdates(signal, scope) {
      const op = scope.getSignal(signal.name);
      let expr2 = signal.update;
      if (signal.init) {
        if (expr2) {
          error("Signals can not include both init and update expressions.");
        } else {
          expr2 = signal.init;
          op.initonly = true;
        }
      }
      if (expr2) {
        expr2 = parser(expr2, scope);
        op.update = expr2.$expr;
        op.params = expr2.$params;
      }
      if (signal.on) {
        signal.on.forEach((_) => parseUpdate(_, scope, op.id));
      }
    }
    const transform = (name2) => (params2, value2, parent) => entry(name2, value2, params2 || void 0, parent);
    const Aggregate = transform("aggregate");
    const AxisTicks = transform("axisticks");
    const Bound = transform("bound");
    const Collect = transform("collect");
    const Compare = transform("compare");
    const DataJoin = transform("datajoin");
    const Encode = transform("encode");
    const Expression = transform("expression");
    const Facet = transform("facet");
    const Field = transform("field");
    const Key = transform("key");
    const LegendEntries = transform("legendentries");
    const Load = transform("load");
    const Mark$1 = transform("mark");
    const MultiExtent = transform("multiextent");
    const MultiValues = transform("multivalues");
    const Overlap = transform("overlap");
    const Params = transform("params");
    const PreFacet = transform("prefacet");
    const Projection = transform("projection");
    const Proxy$1 = transform("proxy");
    const Relay = transform("relay");
    const Render = transform("render");
    const Scale = transform("scale");
    const Sieve = transform("sieve");
    const SortItems = transform("sortitems");
    const ViewLayout = transform("viewlayout");
    const Values = transform("values");
    let FIELD_REF_ID = 0;
    const MULTIDOMAIN_SORT_OPS = {
      min: "min",
      max: "max",
      count: "sum"
    };
    function initScale(spec, scope) {
      const type2 = spec.type || "linear";
      if (!isValidScaleType(type2)) {
        error("Unrecognized scale type: " + $(type2));
      }
      scope.addScale(spec.name, {
        type: type2,
        domain: void 0
      });
    }
    function parseScale(spec, scope) {
      const params2 = scope.getScale(spec.name).params;
      let key2;
      params2.domain = parseScaleDomain$1(spec.domain, spec, scope);
      if (spec.range != null) {
        params2.range = parseScaleRange$1(spec, scope, params2);
      }
      if (spec.interpolate != null) {
        parseScaleInterpolate(spec.interpolate, params2);
      }
      if (spec.nice != null) {
        params2.nice = parseScaleNice(spec.nice);
      }
      if (spec.bins != null) {
        params2.bins = parseScaleBins(spec.bins, scope);
      }
      for (key2 in spec) {
        if (has$1(params2, key2) || key2 === "name")
          continue;
        params2[key2] = parseLiteral(spec[key2], scope);
      }
    }
    function parseLiteral(v, scope) {
      return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
    }
    function parseArray(v, scope) {
      return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
    }
    function dataLookupError(name2) {
      error("Can not find data set: " + $(name2));
    }
    function parseScaleDomain$1(domain2, spec, scope) {
      if (!domain2) {
        if (spec.domainMin != null || spec.domainMax != null) {
          error("No scale domain defined for domainMin/domainMax to override.");
        }
        return;
      }
      return domain2.signal ? scope.signalRef(domain2.signal) : (isArray(domain2) ? explicitDomain : domain2.fields ? multipleDomain : singularDomain)(domain2, spec, scope);
    }
    function explicitDomain(domain2, spec, scope) {
      return domain2.map((v) => parseLiteral(v, scope));
    }
    function singularDomain(domain2, spec, scope) {
      const data2 = scope.getData(domain2.data);
      if (!data2)
        dataLookupError(domain2.data);
      return isDiscrete$2(spec.type) ? data2.valuesRef(scope, domain2.field, parseSort(domain2.sort, false)) : isQuantile$1(spec.type) ? data2.domainRef(scope, domain2.field) : data2.extentRef(scope, domain2.field);
    }
    function multipleDomain(domain2, spec, scope) {
      const data2 = domain2.data, fields = domain2.fields.reduce((dom, d) => {
        d = isString(d) ? {
          data: data2,
          field: d
        } : isArray(d) || d.signal ? fieldRef(d, scope) : d;
        dom.push(d);
        return dom;
      }, []);
      return (isDiscrete$2(spec.type) ? ordinalMultipleDomain : isQuantile$1(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain2, scope, fields);
    }
    function fieldRef(data2, scope) {
      const name2 = "_:vega:_" + FIELD_REF_ID++, coll = Collect({});
      if (isArray(data2)) {
        coll.value = {
          $ingest: data2
        };
      } else if (data2.signal) {
        const code2 = "setdata(" + $(name2) + "," + data2.signal + ")";
        coll.params.input = scope.signalRef(code2);
      }
      scope.addDataPipeline(name2, [coll, Sieve({})]);
      return {
        data: name2,
        field: "data"
      };
    }
    function ordinalMultipleDomain(domain2, scope, fields) {
      const sort2 = parseSort(domain2.sort, true);
      let a2, v;
      const counts = fields.map((f) => {
        const data2 = scope.getData(f.data);
        if (!data2)
          dataLookupError(f.data);
        return data2.countsRef(scope, f.field, sort2);
      });
      const p = {
        groupby: keyFieldRef,
        pulse: counts
      };
      if (sort2) {
        a2 = sort2.op || "count";
        v = sort2.field ? aggrField(a2, sort2.field) : "count";
        p.ops = [MULTIDOMAIN_SORT_OPS[a2]];
        p.fields = [scope.fieldRef(v)];
        p.as = [v];
      }
      a2 = scope.add(Aggregate(p));
      const c2 = scope.add(Collect({
        pulse: ref(a2)
      }));
      v = scope.add(Values({
        field: keyFieldRef,
        sort: scope.sortRef(sort2),
        pulse: ref(c2)
      }));
      return ref(v);
    }
    function parseSort(sort2, multidomain) {
      if (sort2) {
        if (!sort2.field && !sort2.op) {
          if (isObject(sort2))
            sort2.field = "key";
          else
            sort2 = {
              field: "key"
            };
        } else if (!sort2.field && sort2.op !== "count") {
          error("No field provided for sort aggregate op: " + sort2.op);
        } else if (multidomain && sort2.field) {
          if (sort2.op && !MULTIDOMAIN_SORT_OPS[sort2.op]) {
            error("Multiple domain scales can not be sorted using " + sort2.op);
          }
        }
      }
      return sort2;
    }
    function quantileMultipleDomain(domain2, scope, fields) {
      const values2 = fields.map((f) => {
        const data2 = scope.getData(f.data);
        if (!data2)
          dataLookupError(f.data);
        return data2.domainRef(scope, f.field);
      });
      return ref(scope.add(MultiValues({
        values: values2
      })));
    }
    function numericMultipleDomain(domain2, scope, fields) {
      const extents = fields.map((f) => {
        const data2 = scope.getData(f.data);
        if (!data2)
          dataLookupError(f.data);
        return data2.extentRef(scope, f.field);
      });
      return ref(scope.add(MultiExtent({
        extents
      })));
    }
    function parseScaleBins(v, scope) {
      return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
    }
    function parseScaleNice(nice2) {
      return isObject(nice2) ? {
        interval: parseLiteral(nice2.interval),
        step: parseLiteral(nice2.step)
      } : parseLiteral(nice2);
    }
    function parseScaleInterpolate(interpolate2, params2) {
      params2.interpolate = parseLiteral(interpolate2.type || interpolate2);
      if (interpolate2.gamma != null) {
        params2.interpolateGamma = parseLiteral(interpolate2.gamma);
      }
    }
    function parseScaleRange$1(spec, scope, params2) {
      const config = scope.config.range;
      let range2 = spec.range;
      if (range2.signal) {
        return scope.signalRef(range2.signal);
      } else if (isString(range2)) {
        if (config && has$1(config, range2)) {
          spec = extend({}, spec, {
            range: config[range2]
          });
          return parseScaleRange$1(spec, scope, params2);
        } else if (range2 === "width") {
          range2 = [0, {
            signal: "width"
          }];
        } else if (range2 === "height") {
          range2 = isDiscrete$2(spec.type) ? [0, {
            signal: "height"
          }] : [{
            signal: "height"
          }, 0];
        } else {
          error("Unrecognized scale range value: " + $(range2));
        }
      } else if (range2.scheme) {
        params2.scheme = isArray(range2.scheme) ? parseArray(range2.scheme, scope) : parseLiteral(range2.scheme, scope);
        if (range2.extent)
          params2.schemeExtent = parseArray(range2.extent, scope);
        if (range2.count)
          params2.schemeCount = parseLiteral(range2.count, scope);
        return;
      } else if (range2.step) {
        params2.rangeStep = parseLiteral(range2.step, scope);
        return;
      } else if (isDiscrete$2(spec.type) && !isArray(range2)) {
        return parseScaleDomain$1(range2, spec, scope);
      } else if (!isArray(range2)) {
        error("Unsupported range type: " + $(range2));
      }
      return range2.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
    }
    function parseProjection$1(proj, scope) {
      const config = scope.config.projection || {}, params2 = {};
      for (const name2 in proj) {
        if (name2 === "name")
          continue;
        params2[name2] = parseParameter$1(proj[name2], name2, scope);
      }
      for (const name2 in config) {
        if (params2[name2] == null) {
          params2[name2] = parseParameter$1(config[name2], name2, scope);
        }
      }
      scope.addProjection(proj.name, params2);
    }
    function parseParameter$1(_, name2, scope) {
      return isArray(_) ? _.map((_2) => parseParameter$1(_2, name2, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name2 === "fit" ? _ : error("Unsupported parameter object: " + $(_));
    }
    const Top = "top";
    const Left = "left";
    const Right = "right";
    const Bottom = "bottom";
    const Center = "center";
    const Vertical = "vertical";
    const Start = "start";
    const Middle = "middle";
    const End = "end";
    const Index = "index";
    const Label = "label";
    const Offset = "offset";
    const Perc = "perc";
    const Perc2 = "perc2";
    const Value = "value";
    const GuideLabelStyle = "guide-label";
    const GuideTitleStyle = "guide-title";
    const GroupTitleStyle = "group-title";
    const GroupSubtitleStyle = "group-subtitle";
    const Symbols = "symbol";
    const Gradient = "gradient";
    const Discrete = "discrete";
    const Size = "size";
    const Shape = "shape";
    const Fill = "fill";
    const Stroke = "stroke";
    const StrokeWidth = "strokeWidth";
    const StrokeDash = "strokeDash";
    const Opacity = "opacity";
    const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
    const Skip = {
      name: 1,
      style: 1,
      interactive: 1
    };
    const zero$1 = {
      value: 0
    };
    const one = {
      value: 1
    };
    const GroupMark = "group";
    const RectMark = "rect";
    const RuleMark = "rule";
    const SymbolMark = "symbol";
    const TextMark = "text";
    function guideGroup(mark) {
      mark.type = GroupMark;
      mark.interactive = mark.interactive || false;
      return mark;
    }
    function lookup(spec, config) {
      const _ = (name2, dflt) => value(spec[name2], value(config[name2], dflt));
      _.isVertical = (s) => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
      _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);
      _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
      _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));
      return _;
    }
    function getEncoding(name2, encode2) {
      const v = encode2 && (encode2.update && encode2.update[name2] || encode2.enter && encode2.enter[name2]);
      return v && v.signal ? v : v ? v.value : null;
    }
    function getStyle(name2, scope, style2) {
      const s = scope.config.style[style2];
      return s && s[name2];
    }
    function anchorExpr(s, e3, m2) {
      return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e3} : ${m2}`;
    }
    const alignExpr$1 = anchorExpr($(Left), $(Right), $(Center));
    function tickBand(_) {
      const v = _("tickBand");
      let offset2 = _("tickOffset"), band2, extra;
      if (!v) {
        band2 = _("bandPosition");
        extra = _("tickExtra");
      } else if (v.signal) {
        band2 = {
          signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
        };
        extra = {
          signal: `(${v.signal}) === 'extent'`
        };
        if (!isObject(offset2)) {
          offset2 = {
            signal: `(${v.signal}) === 'extent' ? 0 : ${offset2}`
          };
        }
      } else if (v === "extent") {
        band2 = 1;
        extra = true;
        offset2 = 0;
      } else {
        band2 = 0.5;
        extra = false;
      }
      return {
        extra,
        band: band2,
        offset: offset2
      };
    }
    function extendOffset(value2, offset2) {
      return !offset2 ? value2 : !value2 ? offset2 : !isObject(value2) ? {
        value: value2,
        offset: offset2
      } : Object.assign({}, value2, {
        offset: extendOffset(value2.offset, offset2)
      });
    }
    function guideMark(mark, extras) {
      if (extras) {
        mark.name = extras.name;
        mark.style = extras.style || mark.style;
        mark.interactive = !!extras.interactive;
        mark.encode = extendEncode(mark.encode, extras, Skip);
      } else {
        mark.interactive = false;
      }
      return mark;
    }
    function legendGradient(spec, scale2, config, userEncode) {
      const _ = lookup(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
      let enter, start2, stop2, width2, height2;
      if (vertical) {
        start2 = [0, 1];
        stop2 = [0, 0];
        width2 = thickness;
        height2 = length2;
      } else {
        start2 = [0, 0];
        stop2 = [1, 0];
        width2 = length2;
        height2 = thickness;
      }
      const encode2 = {
        enter: enter = {
          opacity: zero$1,
          x: zero$1,
          y: zero$1,
          width: encoder(width2),
          height: encoder(height2)
        },
        update: extend({}, enter, {
          opacity: one,
          fill: {
            gradient: scale2,
            start: start2,
            stop: stop2
          }
        }),
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        stroke: _("gradientStrokeColor"),
        strokeWidth: _("gradientStrokeWidth")
      }, {
        // update
        opacity: _("gradientOpacity")
      });
      return guideMark({
        type: RectMark,
        role: LegendGradientRole,
        encode: encode2
      }, userEncode);
    }
    function legendGradientDiscrete(spec, scale2, config, userEncode, dataRef) {
      const _ = lookup(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
      let u2, v, uu, vv, adjust = "";
      vertical ? (u2 = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u2 = "x", uu = "x2", v = "y", vv = "height");
      const enter = {
        opacity: zero$1,
        fill: {
          scale: scale2,
          field: Value
        }
      };
      enter[u2] = {
        signal: adjust + "datum." + Perc,
        mult: length2
      };
      enter[v] = zero$1;
      enter[uu] = {
        signal: adjust + "datum." + Perc2,
        mult: length2
      };
      enter[vv] = encoder(thickness);
      const encode2 = {
        enter,
        update: extend({}, enter, {
          opacity: one
        }),
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        stroke: _("gradientStrokeColor"),
        strokeWidth: _("gradientStrokeWidth")
      }, {
        // update
        opacity: _("gradientOpacity")
      });
      return guideMark({
        type: RectMark,
        role: LegendBandRole,
        key: Value,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`, baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
    function legendGradientLabels(spec, config, userEncode, dataRef) {
      const _ = lookup(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length2 = _.gradientLength();
      let overlap = _("labelOverlap"), enter, update2, u2, v, adjust = "";
      const encode2 = {
        enter: enter = {
          opacity: zero$1
        },
        update: update2 = {
          opacity: one,
          text: {
            field: Label
          }
        },
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        fill: _("labelColor"),
        fillOpacity: _("labelOpacity"),
        font: _("labelFont"),
        fontSize: _("labelFontSize"),
        fontStyle: _("labelFontStyle"),
        fontWeight: _("labelFontWeight"),
        limit: value(spec.labelLimit, config.gradientLabelLimit)
      });
      if (vertical) {
        enter.align = {
          value: "left"
        };
        enter.baseline = update2.baseline = {
          signal: baselineExpr
        };
        u2 = "y";
        v = "x";
        adjust = "1-";
      } else {
        enter.align = update2.align = {
          signal: alignExpr
        };
        enter.baseline = {
          value: "top"
        };
        u2 = "x";
        v = "y";
      }
      enter[u2] = update2[u2] = {
        signal: adjust + "datum." + Perc,
        mult: length2
      };
      enter[v] = update2[v] = thickness;
      thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
      overlap = overlap ? {
        separation: _("labelSeparation"),
        method: overlap,
        order: "datum." + Index
      } : void 0;
      return guideMark({
        type: TextMark,
        role: LegendLabelRole,
        style: GuideLabelStyle,
        key: Value,
        from: dataRef,
        encode: encode2,
        overlap
      }, userEncode);
    }
    function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
      const _ = lookup(spec, config), entries2 = userEncode.entries, interactive2 = !!(entries2 && entries2.interactive), name2 = entries2 ? entries2.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
        data: "value"
      }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
        field: Size
      }, index2 = `datum.${Index}`, ncols = `max(1, ${columns})`;
      let encode2, enter, update2, nrows, sort2;
      yEncode.mult = 0.5;
      encode2 = {
        enter: enter = {
          opacity: zero$1,
          x: {
            signal: xSignal,
            mult: 0.5,
            offset: symbolOffset
          },
          y: yEncode
        },
        update: update2 = {
          opacity: one,
          x: enter.x,
          y: enter.y
        },
        exit: {
          opacity: zero$1
        }
      };
      let baseFill = null, baseStroke = null;
      if (!spec.fill) {
        baseFill = config.symbolBaseFillColor;
        baseStroke = config.symbolBaseStrokeColor;
      }
      addEncoders(encode2, {
        fill: _("symbolFillColor", baseFill),
        shape: _("symbolType"),
        size: _("symbolSize"),
        stroke: _("symbolStrokeColor", baseStroke),
        strokeDash: _("symbolDash"),
        strokeDashOffset: _("symbolDashOffset"),
        strokeWidth: _("symbolStrokeWidth")
      }, {
        // update
        opacity: _("symbolOpacity")
      });
      LegendScales.forEach((scale2) => {
        if (spec[scale2]) {
          update2[scale2] = enter[scale2] = {
            scale: spec[scale2],
            field: Value
          };
        }
      });
      const symbols2 = guideMark({
        type: SymbolMark,
        role: LegendSymbolRole,
        key: Value,
        from: valueRef,
        clip: height2 ? true : void 0,
        encode: encode2
      }, userEncode.symbols);
      const labelOffset = encoder(symbolOffset);
      labelOffset.offset = _("labelOffset");
      encode2 = {
        enter: enter = {
          opacity: zero$1,
          x: {
            signal: xSignal,
            offset: labelOffset
          },
          y: yEncode
        },
        update: update2 = {
          opacity: one,
          text: {
            field: Label
          },
          x: enter.x,
          y: enter.y
        },
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        align: _("labelAlign"),
        baseline: _("labelBaseline"),
        fill: _("labelColor"),
        fillOpacity: _("labelOpacity"),
        font: _("labelFont"),
        fontSize: _("labelFontSize"),
        fontStyle: _("labelFontStyle"),
        fontWeight: _("labelFontWeight"),
        limit: _("labelLimit")
      });
      const labels2 = guideMark({
        type: TextMark,
        role: LegendLabelRole,
        style: GuideLabelStyle,
        key: Value,
        from: valueRef,
        encode: encode2
      }, userEncode.labels);
      encode2 = {
        enter: {
          noBound: {
            value: !height2
          },
          // ignore width/height in bounds calc
          width: zero$1,
          height: height2 ? encoder(height2) : zero$1,
          opacity: zero$1
        },
        exit: {
          opacity: zero$1
        },
        update: update2 = {
          opacity: one,
          row: {
            signal: null
          },
          column: {
            signal: null
          }
        }
      };
      if (_.isVertical(true)) {
        nrows = `ceil(item.mark.items.length / ${ncols})`;
        update2.row.signal = `${index2}%${nrows}`;
        update2.column.signal = `floor(${index2} / ${nrows})`;
        sort2 = {
          field: ["row", index2]
        };
      } else {
        update2.row.signal = `floor(${index2} / ${ncols})`;
        update2.column.signal = `${index2} % ${ncols}`;
        sort2 = {
          field: index2
        };
      }
      update2.column.signal = `(${columns})?${update2.column.signal}:${index2}`;
      dataRef = {
        facet: {
          data: dataRef,
          name: "value",
          groupby: Index
        }
      };
      return guideGroup({
        role: ScopeRole,
        from: dataRef,
        encode: extendEncode(encode2, entries2, Skip),
        marks: [symbols2, labels2],
        name: name2,
        interactive: interactive2,
        sort: sort2
      });
    }
    function legendSymbolLayout(spec, config) {
      const _ = lookup(spec, config);
      return {
        align: _("gridAlign"),
        columns: _.entryColumns(),
        center: {
          row: true,
          column: false
        },
        padding: {
          row: _("rowPadding"),
          column: _("columnPadding")
        }
      };
    }
    const isL = 'item.orient === "left"', isR = 'item.orient === "right"', isLR = `(${isL} || ${isR})`, isVG = `datum.vgrad && ${isLR}`, baseline$1 = anchorExpr('"top"', '"bottom"', '"middle"'), alignFlip = anchorExpr('"right"', '"left"', '"center"'), exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`, exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`, exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`, exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline$1}) : "top"`;
    function legendTitle(spec, config, userEncode, dataRef) {
      const _ = lookup(spec, config);
      const encode2 = {
        enter: {
          opacity: zero$1
        },
        update: {
          opacity: one,
          x: {
            field: {
              group: "padding"
            }
          },
          y: {
            field: {
              group: "padding"
            }
          }
        },
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        orient: _("titleOrient"),
        _anchor: _("titleAnchor"),
        anchor: {
          signal: exprAnchor
        },
        angle: {
          signal: exprAngle
        },
        align: {
          signal: exprAlign
        },
        baseline: {
          signal: exprBaseline
        },
        text: spec.title,
        fill: _("titleColor"),
        fillOpacity: _("titleOpacity"),
        font: _("titleFont"),
        fontSize: _("titleFontSize"),
        fontStyle: _("titleFontStyle"),
        fontWeight: _("titleFontWeight"),
        limit: _("titleLimit"),
        lineHeight: _("titleLineHeight")
      }, {
        // require update
        align: _("titleAlign"),
        baseline: _("titleBaseline")
      });
      return guideMark({
        type: TextMark,
        role: LegendTitleRole,
        style: GuideTitleStyle,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function clip(clip2, scope) {
      let expr2;
      if (isObject(clip2)) {
        if (clip2.signal) {
          expr2 = clip2.signal;
        } else if (clip2.path) {
          expr2 = "pathShape(" + param(clip2.path) + ")";
        } else if (clip2.sphere) {
          expr2 = "geoShape(" + param(clip2.sphere) + ', {type: "Sphere"})';
        }
      }
      return expr2 ? scope.signalRef(expr2) : !!clip2;
    }
    function param(value2) {
      return isObject(value2) && value2.signal ? value2.signal : $(value2);
    }
    function getRole(spec) {
      const role = spec.role || "";
      return !role.indexOf("axis") || !role.indexOf("legend") || !role.indexOf("title") ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
    }
    function definition(spec) {
      return {
        marktype: spec.type,
        name: spec.name || void 0,
        role: spec.role || getRole(spec),
        zindex: +spec.zindex || void 0,
        aria: spec.aria,
        description: spec.description
      };
    }
    function interactive(spec, scope) {
      return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
    }
    function parseTransform(spec, scope) {
      const def2 = definition$1(spec.type);
      if (!def2)
        error("Unrecognized transform type: " + $(spec.type));
      const t4 = entry(def2.type.toLowerCase(), null, parseParameters(def2, spec, scope));
      if (spec.signal)
        scope.addSignal(spec.signal, scope.proxy(t4));
      t4.metadata = def2.metadata || {};
      return t4;
    }
    function parseParameters(def2, spec, scope) {
      const params2 = {}, n = def2.params.length;
      for (let i = 0; i < n; ++i) {
        const pdef = def2.params[i];
        params2[pdef.name] = parseParameter(pdef, spec, scope);
      }
      return params2;
    }
    function parseParameter(def2, spec, scope) {
      const type2 = def2.type, value2 = spec[def2.name];
      if (type2 === "index") {
        return parseIndexParameter(def2, spec, scope);
      } else if (value2 === void 0) {
        if (def2.required) {
          error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
        }
        return;
      } else if (type2 === "param") {
        return parseSubParameters(def2, spec, scope);
      } else if (type2 === "projection") {
        return scope.projectionRef(spec[def2.name]);
      }
      return def2.array && !isSignal(value2) ? value2.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value2, scope);
    }
    function parameterValue(def2, value2, scope) {
      const type2 = def2.type;
      if (isSignal(value2)) {
        return isExpr(type2) ? error("Expression references can not be signals.") : isField(type2) ? scope.fieldRef(value2) : isCompare(type2) ? scope.compareRef(value2) : scope.signalRef(value2.signal);
      } else {
        const expr2 = def2.expr || isField(type2);
        return expr2 && outerExpr(value2) ? scope.exprRef(value2.expr, value2.as) : expr2 && outerField(value2) ? fieldRef$1(value2.field, value2.as) : isExpr(type2) ? parser(value2, scope) : isData(type2) ? ref(scope.getData(value2).values) : isField(type2) ? fieldRef$1(value2) : isCompare(type2) ? scope.compareRef(value2) : value2;
      }
    }
    function parseIndexParameter(def2, spec, scope) {
      if (!isString(spec.from)) {
        error('Lookup "from" parameter must be a string literal.');
      }
      return scope.getData(spec.from).lookupRef(scope, spec.key);
    }
    function parseSubParameters(def2, spec, scope) {
      const value2 = spec[def2.name];
      if (def2.array) {
        if (!isArray(value2)) {
          error("Expected an array of sub-parameters. Instead: " + $(value2));
        }
        return value2.map((v) => parseSubParameter(def2, v, scope));
      } else {
        return parseSubParameter(def2, value2, scope);
      }
    }
    function parseSubParameter(def2, value2, scope) {
      const n = def2.params.length;
      let pdef;
      for (let i = 0; i < n; ++i) {
        pdef = def2.params[i];
        for (const k in pdef.key) {
          if (pdef.key[k] !== value2[k]) {
            pdef = null;
            break;
          }
        }
        if (pdef)
          break;
      }
      if (!pdef)
        error("Unsupported parameter: " + $(value2));
      const params2 = extend(parseParameters(pdef, value2, scope), pdef.key);
      return ref(scope.add(Params(params2)));
    }
    const outerExpr = (_) => _ && _.expr;
    const outerField = (_) => _ && _.field;
    const isData = (_) => _ === "data";
    const isExpr = (_) => _ === "expr";
    const isField = (_) => _ === "field";
    const isCompare = (_) => _ === "compare";
    function parseData$1(from, group2, scope) {
      let facet, key2, op, dataRef, parent;
      if (!from) {
        dataRef = ref(scope.add(Collect(null, [{}])));
      } else if (facet = from.facet) {
        if (!group2)
          error("Only group marks can be faceted.");
        if (facet.field != null) {
          dataRef = parent = getDataRef(facet, scope);
        } else {
          if (!from.data) {
            op = parseTransform(extend({
              type: "aggregate",
              groupby: array$2(facet.groupby)
            }, facet.aggregate), scope);
            op.params.key = scope.keyRef(facet.groupby);
            op.params.pulse = getDataRef(facet, scope);
            dataRef = parent = ref(scope.add(op));
          } else {
            parent = ref(scope.getData(from.data).aggregate);
          }
          key2 = scope.keyRef(facet.groupby, true);
        }
      }
      if (!dataRef) {
        dataRef = getDataRef(from, scope);
      }
      return {
        key: key2,
        pulse: dataRef,
        parent
      };
    }
    function getDataRef(from, scope) {
      return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
    }
    function DataScope(scope, input, output2, values2, aggr) {
      this.scope = scope;
      this.input = input;
      this.output = output2;
      this.values = values2;
      this.aggregate = aggr;
      this.index = {};
    }
    DataScope.fromEntries = function(scope, entries2) {
      const n = entries2.length, values2 = entries2[n - 1], output2 = entries2[n - 2];
      let input = entries2[0], aggr = null, i = 1;
      if (input && input.type === "load") {
        input = entries2[1];
      }
      scope.add(entries2[0]);
      for (; i < n; ++i) {
        entries2[i].params.pulse = ref(entries2[i - 1]);
        scope.add(entries2[i]);
        if (entries2[i].type === "aggregate")
          aggr = entries2[i];
      }
      return new DataScope(scope, input, output2, values2, aggr);
    };
    function fieldKey(field2) {
      return isString(field2) ? field2 : null;
    }
    function addSortField(scope, p, sort2) {
      const as = aggrField(sort2.op, sort2.field);
      let s;
      if (p.ops) {
        for (let i = 0, n = p.as.length; i < n; ++i) {
          if (p.as[i] === as)
            return;
        }
      } else {
        p.ops = ["count"];
        p.fields = [null];
        p.as = ["count"];
      }
      if (sort2.op) {
        p.ops.push((s = sort2.op.signal) ? scope.signalRef(s) : sort2.op);
        p.fields.push(scope.fieldRef(sort2.field));
        p.as.push(as);
      }
    }
    function cache(scope, ds, name2, optype, field2, counts, index2) {
      const cache2 = ds[name2] || (ds[name2] = {}), sort2 = sortKey(counts);
      let k = fieldKey(field2), v, op;
      if (k != null) {
        scope = ds.scope;
        k = k + (sort2 ? "|" + sort2 : "");
        v = cache2[k];
      }
      if (!v) {
        const params2 = counts ? {
          field: keyFieldRef,
          pulse: ds.countsRef(scope, field2, counts)
        } : {
          field: scope.fieldRef(field2),
          pulse: ref(ds.output)
        };
        if (sort2)
          params2.sort = scope.sortRef(counts);
        op = scope.add(entry(optype, void 0, params2));
        if (index2)
          ds.index[field2] = op;
        v = ref(op);
        if (k != null)
          cache2[k] = v;
      }
      return v;
    }
    DataScope.prototype = {
      countsRef(scope, field2, sort2) {
        const ds = this, cache2 = ds.counts || (ds.counts = {}), k = fieldKey(field2);
        let v, a2, p;
        if (k != null) {
          scope = ds.scope;
          v = cache2[k];
        }
        if (!v) {
          p = {
            groupby: scope.fieldRef(field2, "key"),
            pulse: ref(ds.output)
          };
          if (sort2 && sort2.field)
            addSortField(scope, p, sort2);
          a2 = scope.add(Aggregate(p));
          v = scope.add(Collect({
            pulse: ref(a2)
          }));
          v = {
            agg: a2,
            ref: ref(v)
          };
          if (k != null)
            cache2[k] = v;
        } else if (sort2 && sort2.field) {
          addSortField(scope, v.agg.params, sort2);
        }
        return v.ref;
      },
      tuplesRef() {
        return ref(this.values);
      },
      extentRef(scope, field2) {
        return cache(scope, this, "extent", "extent", field2, false);
      },
      domainRef(scope, field2) {
        return cache(scope, this, "domain", "values", field2, false);
      },
      valuesRef(scope, field2, sort2) {
        return cache(scope, this, "vals", "values", field2, sort2 || true);
      },
      lookupRef(scope, field2) {
        return cache(scope, this, "lookup", "tupleindex", field2, false);
      },
      indataRef(scope, field2) {
        return cache(scope, this, "indata", "tupleindex", field2, true, true);
      }
    };
    function parseFacet(spec, scope, group2) {
      const facet = spec.from.facet, name2 = facet.name, data2 = getDataRef(facet, scope);
      let op;
      if (!facet.name) {
        error("Facet must have a name: " + $(facet));
      }
      if (!facet.data) {
        error("Facet must reference a data set: " + $(facet));
      }
      if (facet.field) {
        op = scope.add(PreFacet({
          field: scope.fieldRef(facet.field),
          pulse: data2
        }));
      } else if (facet.groupby) {
        op = scope.add(Facet({
          key: scope.keyRef(facet.groupby),
          group: ref(scope.proxy(group2.parent)),
          pulse: data2
        }));
      } else {
        error("Facet must specify groupby or field: " + $(facet));
      }
      const subscope = scope.fork(), source2 = subscope.add(Collect()), values2 = subscope.add(Sieve({
        pulse: ref(source2)
      }));
      subscope.addData(name2, new DataScope(subscope, source2, source2, values2));
      subscope.addSignal("parent", null);
      op.params.subflow = {
        $subflow: subscope.parse(spec).toRuntime()
      };
    }
    function parseSubflow(spec, scope, input) {
      const op = scope.add(PreFacet({
        pulse: input.pulse
      })), subscope = scope.fork();
      subscope.add(Sieve());
      subscope.addSignal("parent", null);
      op.params.subflow = {
        $subflow: subscope.parse(spec).toRuntime()
      };
    }
    function parseTrigger(spec, scope, name2) {
      const remove2 = spec.remove, insert2 = spec.insert, toggle2 = spec.toggle, modify2 = spec.modify, values2 = spec.values, op = scope.add(operator());
      const update2 = "if(" + spec.trigger + ',modify("' + name2 + '",' + [insert2, remove2, toggle2, modify2, values2].map((_) => _ == null ? "null" : _).join(",") + "),0)";
      const expr2 = parser(update2, scope);
      op.update = expr2.$expr;
      op.params = expr2.$params;
    }
    function parseMark(spec, scope) {
      const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
      let layout = spec.layout || role === ScopeRole || role === FrameRole, ops2, op, store2, enc, name2, layoutRef, boundRef;
      const nested = role === MarkRole || layout || facet;
      const input = parseData$1(spec.from, group2, scope);
      op = scope.add(DataJoin({
        key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
        pulse: input.pulse,
        clean: !group2
      }));
      const joinRef = ref(op);
      op = store2 = scope.add(Collect({
        pulse: joinRef
      }));
      op = scope.add(Mark$1({
        markdef: definition(spec),
        interactive: interactive(spec.interactive, scope),
        clip: clip(spec.clip, scope),
        context: {
          $context: true
        },
        groups: scope.lookup(),
        parent: scope.signals.parent ? scope.signalRef("parent") : null,
        index: scope.markpath(),
        pulse: ref(op)
      }));
      const markRef = ref(op);
      op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
        mod: false,
        pulse: markRef
      })));
      op.params.parent = scope.encode();
      if (spec.transform) {
        spec.transform.forEach((_) => {
          const tx2 = parseTransform(_, scope), md2 = tx2.metadata;
          if (md2.generates || md2.changes) {
            error("Mark transforms should not generate new data.");
          }
          if (!md2.nomod)
            enc.params.mod = true;
          tx2.params.pulse = ref(op);
          scope.add(op = tx2);
        });
      }
      if (spec.sort) {
        op = scope.add(SortItems({
          sort: scope.compareRef(spec.sort),
          pulse: ref(op)
        }));
      }
      const encodeRef = ref(op);
      if (facet || layout) {
        layout = scope.add(ViewLayout({
          layout: scope.objectProperty(spec.layout),
          legends: scope.legends,
          mark: markRef,
          pulse: encodeRef
        }));
        layoutRef = ref(layout);
      }
      const bound2 = scope.add(Bound({
        mark: markRef,
        pulse: layoutRef || encodeRef
      }));
      boundRef = ref(bound2);
      if (group2) {
        if (nested) {
          ops2 = scope.operators;
          ops2.pop();
          if (layout)
            ops2.pop();
        }
        scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
        facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
        scope.popState();
        if (nested) {
          if (layout)
            ops2.push(layout);
          ops2.push(bound2);
        }
      }
      if (overlap) {
        boundRef = parseOverlap(overlap, boundRef, scope);
      }
      const render = scope.add(Render({
        pulse: boundRef
      })), sieve = scope.add(Sieve({
        pulse: ref(render)
      }, void 0, scope.parent()));
      if (spec.name != null) {
        name2 = spec.name;
        scope.addData(name2, new DataScope(scope, store2, render, sieve));
        if (spec.on)
          spec.on.forEach((on2) => {
            if (on2.insert || on2.remove || on2.toggle) {
              error("Marks only support modify triggers.");
            }
            parseTrigger(on2, scope, name2);
          });
      }
    }
    function parseOverlap(overlap, source2, scope) {
      const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
      const params2 = {
        separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
        method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
        pulse: source2
      };
      if (overlap.order) {
        params2.sort = scope.compareRef({
          field: overlap.order
        });
      }
      if (bound2) {
        const tol = bound2.tolerance;
        params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
        params2.boundScale = scope.scaleRef(bound2.scale);
        params2.boundOrient = bound2.orient;
      }
      return ref(scope.add(Overlap(params2)));
    }
    function parseLegend$1(spec, scope) {
      const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup(spec, config), legendEncode = encode2.legend || {}, name2 = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
      let scale2 = 0, entryLayout, params2, children2;
      LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale2 = scale2 || spec[s]) : 0);
      if (!scale2)
        error("Missing valid scale for legend.");
      const type2 = legendType(spec, scope.scaleType(scale2));
      const datum2 = {
        title: spec.title != null,
        scales: scales2,
        type: type2,
        vgrad: type2 !== "symbol" && _.isVertical()
      };
      const dataRef = ref(scope.add(Collect(null, [datum2])));
      const entryEncode = {
        enter: {
          x: {
            value: 0
          },
          y: {
            value: 0
          }
        }
      };
      const entryRef = ref(scope.add(LegendEntries(params2 = {
        type: type2,
        scale: scope.scaleRef(scale2),
        count: scope.objectProperty(_("tickCount")),
        limit: scope.property(_("symbolLimit")),
        values: scope.objectProperty(spec.values),
        minstep: scope.property(spec.tickMinStep),
        formatType: scope.property(spec.formatType),
        formatSpecifier: scope.property(spec.format)
      })));
      if (type2 === Gradient) {
        children2 = [legendGradient(spec, scale2, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
        params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
      } else if (type2 === Discrete) {
        children2 = [legendGradientDiscrete(spec, scale2, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
      } else {
        entryLayout = legendSymbolLayout(spec, config);
        children2 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
        params2.size = sizeExpression(spec, scope, children2[0].marks);
      }
      children2 = [guideGroup({
        role: LegendEntryRole,
        from: dataRef,
        encode: entryEncode,
        marks: children2,
        layout: entryLayout,
        interactive: interactive2
      })];
      if (datum2.title) {
        children2.push(legendTitle(spec, config, encode2.title, dataRef));
      }
      return parseMark(guideGroup({
        role: LegendRole,
        from: dataRef,
        encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
        marks: children2,
        aria: _("aria"),
        description: _("description"),
        zindex: _("zindex"),
        name: name2,
        interactive: interactive2,
        style: style2
      }), scope);
    }
    function legendType(spec, scaleType2) {
      let type2 = spec.type || Symbols;
      if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
        type2 = isContinuous$1(scaleType2) ? Gradient : isDiscretizing$1(scaleType2) ? Discrete : Symbols;
      }
      return type2 !== Gradient ? type2 : isDiscretizing$1(scaleType2) ? Discrete : Gradient;
    }
    function scaleCount(spec) {
      return LegendScales.reduce((count2, type2) => count2 + (spec[type2] ? 1 : 0), 0);
    }
    function buildLegendEncode(_, spec, config) {
      const encode2 = {
        enter: {},
        update: {}
      };
      addEncoders(encode2, {
        orient: _("orient"),
        offset: _("offset"),
        padding: _("padding"),
        titlePadding: _("titlePadding"),
        cornerRadius: _("cornerRadius"),
        fill: _("fillColor"),
        stroke: _("strokeColor"),
        strokeWidth: config.strokeWidth,
        strokeDash: config.strokeDash,
        x: _("legendX"),
        y: _("legendY"),
        // accessibility support
        format: spec.format,
        formatType: spec.formatType
      });
      return encode2;
    }
    function sizeExpression(spec, scope, marks) {
      const size2 = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
      return parser(`max(ceil(sqrt(${size2})+${strokeWidth}),${fontSize2})`, scope);
    }
    function getChannel(name2, spec, marks) {
      return spec[name2] ? `scale("${spec[name2]}",datum)` : getEncoding(name2, marks[0].encode);
    }
    function getFontSize(encode2, scope, style2) {
      return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style2);
    }
    const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
    function parseTitle(spec, scope) {
      spec = isString(spec) ? {
        text: spec
      } : spec;
      const _ = lookup(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name2 = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children2 = [];
      const datum2 = {}, dataRef = ref(scope.add(Collect(null, [datum2])));
      children2.push(buildTitle(spec, _, titleEncode(spec), dataRef));
      if (spec.subtitle) {
        children2.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
      }
      return parseMark(guideGroup({
        role: TitleRole,
        from: dataRef,
        encode: groupEncode(_, userEncode),
        marks: children2,
        aria: _("aria"),
        description: _("description"),
        zindex: _("zindex"),
        name: name2,
        interactive: interactive2,
        style: style2
      }), scope);
    }
    function titleEncode(spec) {
      const encode2 = spec.encode;
      return encode2 && encode2.title || extend({
        name: spec.name,
        interactive: spec.interactive,
        style: spec.style
      }, encode2);
    }
    function groupEncode(_, userEncode) {
      const encode2 = {
        enter: {},
        update: {}
      };
      addEncoders(encode2, {
        orient: _("orient"),
        anchor: _("anchor"),
        align: {
          signal: alignExpr$1
        },
        angle: {
          signal: angleExpr
        },
        limit: _("limit"),
        frame: _("frame"),
        offset: _("offset") || 0,
        padding: _("subtitlePadding")
      });
      return extendEncode(encode2, userEncode, Skip);
    }
    function buildTitle(spec, _, userEncode, dataRef) {
      const zero2 = {
        value: 0
      }, text2 = spec.text, encode2 = {
        enter: {
          opacity: zero2
        },
        update: {
          opacity: {
            value: 1
          }
        },
        exit: {
          opacity: zero2
        }
      };
      addEncoders(encode2, {
        text: text2,
        align: {
          signal: "item.mark.group.align"
        },
        angle: {
          signal: "item.mark.group.angle"
        },
        limit: {
          signal: "item.mark.group.limit"
        },
        baseline: "top",
        dx: _("dx"),
        dy: _("dy"),
        fill: _("color"),
        font: _("font"),
        fontSize: _("fontSize"),
        fontStyle: _("fontStyle"),
        fontWeight: _("fontWeight"),
        lineHeight: _("lineHeight")
      }, {
        // update
        align: _("align"),
        angle: _("angle"),
        baseline: _("baseline")
      });
      return guideMark({
        type: TextMark,
        role: TitleTextRole,
        style: GroupTitleStyle,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function buildSubTitle(spec, _, userEncode, dataRef) {
      const zero2 = {
        value: 0
      }, text2 = spec.subtitle, encode2 = {
        enter: {
          opacity: zero2
        },
        update: {
          opacity: {
            value: 1
          }
        },
        exit: {
          opacity: zero2
        }
      };
      addEncoders(encode2, {
        text: text2,
        align: {
          signal: "item.mark.group.align"
        },
        angle: {
          signal: "item.mark.group.angle"
        },
        limit: {
          signal: "item.mark.group.limit"
        },
        baseline: "top",
        dx: _("dx"),
        dy: _("dy"),
        fill: _("subtitleColor"),
        font: _("subtitleFont"),
        fontSize: _("subtitleFontSize"),
        fontStyle: _("subtitleFontStyle"),
        fontWeight: _("subtitleFontWeight"),
        lineHeight: _("subtitleLineHeight")
      }, {
        // update
        align: _("align"),
        angle: _("angle"),
        baseline: _("baseline")
      });
      return guideMark({
        type: TextMark,
        role: TitleSubtitleRole,
        style: GroupSubtitleStyle,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function parseData$2(data2, scope) {
      const transforms2 = [];
      if (data2.transform) {
        data2.transform.forEach((tx2) => {
          transforms2.push(parseTransform(tx2, scope));
        });
      }
      if (data2.on) {
        data2.on.forEach((on2) => {
          parseTrigger(on2, scope, data2.name);
        });
      }
      scope.addDataPipeline(data2.name, analyze(data2, scope, transforms2));
    }
    function analyze(data2, scope, ops2) {
      const output2 = [];
      let source2 = null, modify2 = false, generate2 = false, upstream, i, n, t4, m2;
      if (data2.values) {
        if (isSignal(data2.values) || hasSignal(data2.format)) {
          output2.push(load(scope, data2));
          output2.push(source2 = collect());
        } else {
          output2.push(source2 = collect({
            $ingest: data2.values,
            $format: data2.format
          }));
        }
      } else if (data2.url) {
        if (hasSignal(data2.url) || hasSignal(data2.format)) {
          output2.push(load(scope, data2));
          output2.push(source2 = collect());
        } else {
          output2.push(source2 = collect({
            $request: data2.url,
            $format: data2.format
          }));
        }
      } else if (data2.source) {
        source2 = upstream = array$2(data2.source).map((d) => ref(scope.getData(d).output));
        output2.push(null);
      }
      for (i = 0, n = ops2.length; i < n; ++i) {
        t4 = ops2[i];
        m2 = t4.metadata;
        if (!source2 && !m2.source) {
          output2.push(source2 = collect());
        }
        output2.push(t4);
        if (m2.generates)
          generate2 = true;
        if (m2.modifies && !generate2)
          modify2 = true;
        if (m2.source)
          source2 = t4;
        else if (m2.changes)
          source2 = null;
      }
      if (upstream) {
        n = upstream.length - 1;
        output2[0] = Relay({
          derive: modify2,
          pulse: n ? upstream : upstream[0]
        });
        if (modify2 || n) {
          output2.splice(1, 0, collect());
        }
      }
      if (!source2)
        output2.push(collect());
      output2.push(Sieve({}));
      return output2;
    }
    function collect(values2) {
      const s = Collect({}, values2);
      s.metadata = {
        source: true
      };
      return s;
    }
    function load(scope, data2) {
      return Load({
        url: data2.url ? scope.property(data2.url) : void 0,
        async: data2.async ? scope.property(data2.async) : void 0,
        values: data2.values ? scope.property(data2.values) : void 0,
        format: scope.objectProperty(data2.format)
      });
    }
    const isX = (orient2) => orient2 === Bottom || orient2 === Top;
    const getSign = (orient2, a2, b2) => isSignal(orient2) ? ifLeftTopExpr(orient2.signal, a2, b2) : orient2 === Left || orient2 === Top ? a2 : b2;
    const ifX = (orient2, a2, b2) => isSignal(orient2) ? ifXEnc(orient2.signal, a2, b2) : isX(orient2) ? a2 : b2;
    const ifY = (orient2, a2, b2) => isSignal(orient2) ? ifYEnc(orient2.signal, a2, b2) : isX(orient2) ? b2 : a2;
    const ifTop = (orient2, a2, b2) => isSignal(orient2) ? ifTopExpr(orient2.signal, a2, b2) : orient2 === Top ? {
      value: a2
    } : {
      value: b2
    };
    const ifRight = (orient2, a2, b2) => isSignal(orient2) ? ifRightExpr(orient2.signal, a2, b2) : orient2 === Right ? {
      value: a2
    } : {
      value: b2
    };
    const ifXEnc = ($orient, a2, b2) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a2, b2);
    const ifYEnc = ($orient, a2, b2) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a2, b2);
    const ifLeftTopExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a2, b2);
    const ifTopExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Top}'`, a2, b2);
    const ifRightExpr = ($orient, a2, b2) => ifExpr(`${$orient} === '${Right}'`, a2, b2);
    const ifEnc = (test2, a2, b2) => {
      a2 = a2 != null ? encoder(a2) : a2;
      b2 = b2 != null ? encoder(b2) : b2;
      if (isSimple(a2) && isSimple(b2)) {
        a2 = a2 ? a2.signal || $(a2.value) : null;
        b2 = b2 ? b2.signal || $(b2.value) : null;
        return {
          signal: `${test2} ? (${a2}) : (${b2})`
        };
      } else {
        return [extend({
          test: test2
        }, a2)].concat(b2 || []);
      }
    };
    const isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
    const ifExpr = (test2, a2, b2) => ({
      signal: `${test2} ? (${toExpr(a2)}) : (${toExpr(b2)})`
    });
    const ifOrient = ($orient, t4, b2, l, r) => ({
      signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : "") + (b2 != null ? `${$orient} === '${Bottom}' ? (${toExpr(b2)}) : ` : "") + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : "") + (t4 != null ? `${$orient} === '${Top}' ? (${toExpr(t4)}) : ` : "") + "(null)"
    });
    const toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
    const mult = (sign2, value2) => value2 === 0 ? 0 : isSignal(sign2) ? {
      signal: `(${sign2.signal}) * ${value2}`
    } : {
      value: sign2 * value2
    };
    const patch = (value2, base2) => {
      const s = value2.signal;
      return s && s.endsWith("(null)") ? {
        signal: s.slice(0, -6) + base2.signal
      } : value2;
    };
    function fallback(prop, config, axisConfig2, style2) {
      let styleProp;
      if (config && has$1(config, prop)) {
        return config[prop];
      } else if (has$1(axisConfig2, prop)) {
        return axisConfig2[prop];
      } else if (prop.startsWith("title")) {
        switch (prop) {
          case "titleColor":
            styleProp = "fill";
            break;
          case "titleFont":
          case "titleFontSize":
          case "titleFontWeight":
            styleProp = prop[5].toLowerCase() + prop.slice(6);
        }
        return style2[GuideTitleStyle][styleProp];
      } else if (prop.startsWith("label")) {
        switch (prop) {
          case "labelColor":
            styleProp = "fill";
            break;
          case "labelFont":
          case "labelFontSize":
            styleProp = prop[5].toLowerCase() + prop.slice(6);
        }
        return style2[GuideLabelStyle][styleProp];
      }
      return null;
    }
    function keys$1(objects) {
      const map2 = {};
      for (const obj of objects) {
        if (!obj)
          continue;
        for (const key2 in obj)
          map2[key2] = 1;
      }
      return Object.keys(map2);
    }
    function axisConfig(spec, scope) {
      var config = scope.config, style2 = config.style, axis2 = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient2 = spec.orient, xy, or2, key2;
      if (isSignal(orient2)) {
        const xyKeys = keys$1([config.axisX, config.axisY]), orientKeys = keys$1([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
        xy = {};
        for (key2 of xyKeys) {
          xy[key2] = ifX(orient2, fallback(key2, config.axisX, axis2, style2), fallback(key2, config.axisY, axis2, style2));
        }
        or2 = {};
        for (key2 of orientKeys) {
          or2[key2] = ifOrient(orient2.signal, fallback(key2, config.axisTop, axis2, style2), fallback(key2, config.axisBottom, axis2, style2), fallback(key2, config.axisLeft, axis2, style2), fallback(key2, config.axisRight, axis2, style2));
        }
      } else {
        xy = orient2 === Top || orient2 === Bottom ? config.axisX : config.axisY;
        or2 = config["axis" + orient2[0].toUpperCase() + orient2.slice(1)];
      }
      const result = xy || or2 || band2 ? extend({}, axis2, xy, or2, band2) : axis2;
      return result;
    }
    function axisDomain(spec, config, userEncode, dataRef) {
      const _ = lookup(spec, config), orient2 = spec.orient;
      let enter, update2;
      const encode2 = {
        enter: enter = {
          opacity: zero$1
        },
        update: update2 = {
          opacity: one
        },
        exit: {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        stroke: _("domainColor"),
        strokeCap: _("domainCap"),
        strokeDash: _("domainDash"),
        strokeDashOffset: _("domainDashOffset"),
        strokeWidth: _("domainWidth"),
        strokeOpacity: _("domainOpacity")
      });
      const pos0 = position(spec, 0);
      const pos1 = position(spec, 1);
      enter.x = update2.x = ifX(orient2, pos0, zero$1);
      enter.x2 = update2.x2 = ifX(orient2, pos1);
      enter.y = update2.y = ifY(orient2, pos0, zero$1);
      enter.y2 = update2.y2 = ifY(orient2, pos1);
      return guideMark({
        type: RuleMark,
        role: AxisDomainRole,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function position(spec, pos) {
      return {
        scale: spec.scale,
        range: pos
      };
    }
    function axisGrid(spec, config, userEncode, dataRef, band2) {
      const _ = lookup(spec, config), orient2 = spec.orient, vscale = spec.gridScale, sign2 = getSign(orient2, 1, -1), offset2 = offsetValue(spec.offset, sign2);
      let enter, exit, update2;
      const encode2 = {
        enter: enter = {
          opacity: zero$1
        },
        update: update2 = {
          opacity: one
        },
        exit: exit = {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        stroke: _("gridColor"),
        strokeCap: _("gridCap"),
        strokeDash: _("gridDash"),
        strokeDashOffset: _("gridDashOffset"),
        strokeOpacity: _("gridOpacity"),
        strokeWidth: _("gridWidth")
      });
      const tickPos = {
        scale: spec.scale,
        field: Value,
        band: band2.band,
        extra: band2.extra,
        offset: band2.offset,
        round: _("tickRound")
      };
      const sz2 = ifX(orient2, {
        signal: "height"
      }, {
        signal: "width"
      });
      const gridStart = vscale ? {
        scale: vscale,
        range: 0,
        mult: sign2,
        offset: offset2
      } : {
        value: 0,
        offset: offset2
      };
      const gridEnd = vscale ? {
        scale: vscale,
        range: 1,
        mult: sign2,
        offset: offset2
      } : extend(sz2, {
        mult: sign2,
        offset: offset2
      });
      enter.x = update2.x = ifX(orient2, tickPos, gridStart);
      enter.y = update2.y = ifY(orient2, tickPos, gridStart);
      enter.x2 = update2.x2 = ifY(orient2, gridEnd);
      enter.y2 = update2.y2 = ifX(orient2, gridEnd);
      exit.x = ifX(orient2, tickPos);
      exit.y = ifY(orient2, tickPos);
      return guideMark({
        type: RuleMark,
        role: AxisGridRole,
        key: Value,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function offsetValue(offset2, sign2) {
      if (sign2 === 1)
        ;
      else if (!isObject(offset2)) {
        offset2 = isSignal(sign2) ? {
          signal: `(${sign2.signal}) * (${offset2 || 0})`
        } : sign2 * (offset2 || 0);
      } else {
        let entry2 = offset2 = extend({}, offset2);
        while (entry2.mult != null) {
          if (!isObject(entry2.mult)) {
            entry2.mult = isSignal(sign2) ? {
              signal: `(${entry2.mult}) * (${sign2.signal})`
            } : entry2.mult * sign2;
            return offset2;
          } else {
            entry2 = entry2.mult = extend({}, entry2.mult);
          }
        }
        entry2.mult = sign2;
      }
      return offset2;
    }
    function axisTicks(spec, config, userEncode, dataRef, size2, band2) {
      const _ = lookup(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
      let enter, exit, update2;
      const encode2 = {
        enter: enter = {
          opacity: zero$1
        },
        update: update2 = {
          opacity: one
        },
        exit: exit = {
          opacity: zero$1
        }
      };
      addEncoders(encode2, {
        stroke: _("tickColor"),
        strokeCap: _("tickCap"),
        strokeDash: _("tickDash"),
        strokeDashOffset: _("tickDashOffset"),
        strokeOpacity: _("tickOpacity"),
        strokeWidth: _("tickWidth")
      });
      const tickSize = encoder(size2);
      tickSize.mult = sign2;
      const tickPos = {
        scale: spec.scale,
        field: Value,
        band: band2.band,
        extra: band2.extra,
        offset: band2.offset,
        round: _("tickRound")
      };
      update2.y = enter.y = ifX(orient2, zero$1, tickPos);
      update2.y2 = enter.y2 = ifX(orient2, tickSize);
      exit.x = ifX(orient2, tickPos);
      update2.x = enter.x = ifY(orient2, zero$1, tickPos);
      update2.x2 = enter.x2 = ifY(orient2, tickSize);
      exit.y = ifY(orient2, tickPos);
      return guideMark({
        type: RuleMark,
        role: AxisTickRole,
        key: Value,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function flushExpr(scale2, threshold2, a2, b2, c2) {
      return {
        signal: 'flush(range("' + scale2 + '"), scale("' + scale2 + '", datum.value), ' + threshold2 + "," + a2 + "," + b2 + "," + c2 + ")"
      };
    }
    function axisLabels(spec, config, userEncode, dataRef, size2, band2) {
      const _ = lookup(spec, config), orient2 = spec.orient, scale2 = spec.scale, sign2 = getSign(orient2, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
      let flushOn = flush2 === 0 || !!flush2, update2;
      const tickSize = encoder(size2);
      tickSize.mult = sign2;
      tickSize.offset = encoder(_("labelPadding") || 0);
      tickSize.offset.mult = sign2;
      const tickPos = {
        scale: scale2,
        field: Value,
        band: 0.5,
        offset: extendOffset(band2.offset, _("labelOffset"))
      };
      const align2 = ifX(orient2, flushOn ? flushExpr(scale2, flush2, '"left"', '"right"', '"center"') : {
        value: "center"
      }, ifRight(orient2, "left", "right"));
      const baseline2 = ifX(orient2, ifTop(orient2, "bottom", "top"), flushOn ? flushExpr(scale2, flush2, '"top"', '"bottom"', '"middle"') : {
        value: "middle"
      });
      const offsetExpr2 = flushExpr(scale2, flush2, `-(${flushOffset})`, flushOffset, 0);
      flushOn = flushOn && flushOffset;
      const enter = {
        opacity: zero$1,
        x: ifX(orient2, tickPos, tickSize),
        y: ifY(orient2, tickPos, tickSize)
      };
      const encode2 = {
        enter,
        update: update2 = {
          opacity: one,
          text: {
            field: Label
          },
          x: enter.x,
          y: enter.y,
          align: align2,
          baseline: baseline2
        },
        exit: {
          opacity: zero$1,
          x: enter.x,
          y: enter.y
        }
      };
      addEncoders(encode2, {
        dx: !labelAlign && flushOn ? ifX(orient2, offsetExpr2) : null,
        dy: !labelBaseline && flushOn ? ifY(orient2, offsetExpr2) : null
      });
      addEncoders(encode2, {
        angle: _("labelAngle"),
        fill: _("labelColor"),
        fillOpacity: _("labelOpacity"),
        font: _("labelFont"),
        fontSize: _("labelFontSize"),
        fontWeight: _("labelFontWeight"),
        fontStyle: _("labelFontStyle"),
        limit: _("labelLimit"),
        lineHeight: _("labelLineHeight")
      }, {
        align: labelAlign,
        baseline: labelBaseline
      });
      const bound2 = _("labelBound");
      let overlap = _("labelOverlap");
      overlap = overlap || bound2 ? {
        separation: _("labelSeparation"),
        method: overlap,
        order: "datum.index",
        bound: bound2 ? {
          scale: scale2,
          orient: orient2,
          tolerance: bound2
        } : null
      } : void 0;
      if (update2.align !== align2) {
        update2.align = patch(update2.align, align2);
      }
      if (update2.baseline !== baseline2) {
        update2.baseline = patch(update2.baseline, baseline2);
      }
      return guideMark({
        type: TextMark,
        role: AxisLabelRole,
        style: GuideLabelStyle,
        key: Value,
        from: dataRef,
        encode: encode2,
        overlap
      }, userEncode);
    }
    function axisTitle(spec, config, userEncode, dataRef) {
      const _ = lookup(spec, config), orient2 = spec.orient, sign2 = getSign(orient2, -1, 1);
      let enter, update2;
      const encode2 = {
        enter: enter = {
          opacity: zero$1,
          anchor: encoder(_("titleAnchor", null)),
          align: {
            signal: alignExpr$1
          }
        },
        update: update2 = extend({}, enter, {
          opacity: one,
          text: encoder(spec.title)
        }),
        exit: {
          opacity: zero$1
        }
      };
      const titlePos = {
        signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
      };
      update2.x = ifX(orient2, titlePos);
      update2.y = ifY(orient2, titlePos);
      enter.angle = ifX(orient2, zero$1, mult(sign2, 90));
      enter.baseline = ifX(orient2, ifTop(orient2, Bottom, Top), {
        value: Bottom
      });
      update2.angle = enter.angle;
      update2.baseline = enter.baseline;
      addEncoders(encode2, {
        fill: _("titleColor"),
        fillOpacity: _("titleOpacity"),
        font: _("titleFont"),
        fontSize: _("titleFontSize"),
        fontStyle: _("titleFontStyle"),
        fontWeight: _("titleFontWeight"),
        limit: _("titleLimit"),
        lineHeight: _("titleLineHeight")
      }, {
        // require update
        align: _("titleAlign"),
        angle: _("titleAngle"),
        baseline: _("titleBaseline")
      });
      autoLayout(_, orient2, encode2, userEncode);
      encode2.update.align = patch(encode2.update.align, enter.align);
      encode2.update.angle = patch(encode2.update.angle, enter.angle);
      encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
      return guideMark({
        type: TextMark,
        role: AxisTitleRole,
        style: GuideTitleStyle,
        from: dataRef,
        encode: encode2
      }, userEncode);
    }
    function autoLayout(_, orient2, encode2, userEncode) {
      const auto = (value2, dim) => value2 != null ? (encode2.update[dim] = patch(encoder(value2), encode2.update[dim]), false) : !has(dim, userEncode) ? true : false;
      const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
      encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient2, encoder(autoX), encoder(autoY));
    }
    function parseAxis$1(spec, scope) {
      const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name2 = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup(spec, config), band2 = tickBand(_);
      const datum2 = {
        scale: spec.scale,
        ticks: !!_("ticks"),
        labels: !!_("labels"),
        grid: !!_("grid"),
        domain: !!_("domain"),
        title: spec.title != null
      };
      const dataRef = ref(scope.add(Collect({}, [datum2])));
      const ticksRef = ref(scope.add(AxisTicks({
        scale: scope.scaleRef(spec.scale),
        extra: scope.property(band2.extra),
        count: scope.objectProperty(spec.tickCount),
        values: scope.objectProperty(spec.values),
        minstep: scope.property(spec.tickMinStep),
        formatType: scope.property(spec.formatType),
        formatSpecifier: scope.property(spec.format)
      })));
      const children2 = [];
      let size2;
      if (datum2.grid) {
        children2.push(axisGrid(spec, config, encode2.grid, ticksRef, band2));
      }
      if (datum2.ticks) {
        size2 = _("tickSize");
        children2.push(axisTicks(spec, config, encode2.ticks, ticksRef, size2, band2));
      }
      if (datum2.labels) {
        size2 = datum2.ticks ? size2 : 0;
        children2.push(axisLabels(spec, config, encode2.labels, ticksRef, size2, band2));
      }
      if (datum2.domain) {
        children2.push(axisDomain(spec, config, encode2.domain, dataRef));
      }
      if (datum2.title) {
        children2.push(axisTitle(spec, config, encode2.title, dataRef));
      }
      return parseMark(guideGroup({
        role: AxisRole,
        from: dataRef,
        encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
        marks: children2,
        aria: _("aria"),
        description: _("description"),
        zindex: _("zindex"),
        name: name2,
        interactive: interactive2,
        style: style2
      }), scope);
    }
    function buildAxisEncode(_, spec) {
      const encode2 = {
        enter: {},
        update: {}
      };
      addEncoders(encode2, {
        orient: _("orient"),
        offset: _("offset") || 0,
        position: value(spec.position, 0),
        titlePadding: _("titlePadding"),
        minExtent: _("minExtent"),
        maxExtent: _("maxExtent"),
        range: {
          signal: `abs(span(range("${spec.scale}")))`
        },
        translate: _("translate"),
        // accessibility support
        format: spec.format,
        formatType: spec.formatType
      });
      return encode2;
    }
    function parseScope(spec, scope, preprocessed) {
      const signals = array$2(spec.signals), scales2 = array$2(spec.scales);
      if (!preprocessed)
        signals.forEach((_) => parseSignal(_, scope));
      array$2(spec.projections).forEach((_) => parseProjection$1(_, scope));
      scales2.forEach((_) => initScale(_, scope));
      array$2(spec.data).forEach((_) => parseData$2(_, scope));
      scales2.forEach((_) => parseScale(_, scope));
      (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
      array$2(spec.axes).forEach((_) => parseAxis$1(_, scope));
      array$2(spec.marks).forEach((_) => parseMark(_, scope));
      array$2(spec.legends).forEach((_) => parseLegend$1(_, scope));
      if (spec.title)
        parseTitle(spec.title, scope);
      scope.parseLambdas();
      return scope;
    }
    const rootEncode = (spec) => extendEncode({
      enter: {
        x: {
          value: 0
        },
        y: {
          value: 0
        }
      },
      update: {
        width: {
          signal: "width"
        },
        height: {
          signal: "height"
        }
      }
    }, spec);
    function parseView(spec, scope) {
      const config = scope.config;
      const root2 = ref(scope.root = scope.add(operator()));
      const signals = collectSignals(spec, config);
      signals.forEach((_) => parseSignal(_, scope));
      scope.description = spec.description || config.description;
      scope.eventConfig = config.events;
      scope.legends = scope.objectProperty(config.legend && config.legend.layout);
      scope.locale = config.locale;
      const input = scope.add(Collect());
      const encode2 = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
        pulse: ref(input)
      })));
      const parent = scope.add(ViewLayout({
        layout: scope.objectProperty(spec.layout),
        legends: scope.legends,
        autosize: scope.signalRef("autosize"),
        mark: root2,
        pulse: ref(encode2)
      }));
      scope.operators.pop();
      scope.pushState(ref(encode2), ref(parent), null);
      parseScope(spec, scope, signals);
      scope.operators.push(parent);
      let op = scope.add(Bound({
        mark: root2,
        pulse: ref(parent)
      }));
      op = scope.add(Render({
        pulse: ref(op)
      }));
      op = scope.add(Sieve({
        pulse: ref(op)
      }));
      scope.addData("root", new DataScope(scope, input, input, op));
      return scope;
    }
    function signalObject(name2, value2) {
      return value2 && value2.signal ? {
        name: name2,
        update: value2.signal
      } : {
        name: name2,
        value: value2
      };
    }
    function collectSignals(spec, config) {
      const _ = (name2) => value(spec[name2], config[name2]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map2 = {};
      array$2(spec.signals).forEach((s) => {
        if (has$1(pre, s.name)) {
          s = extend(pre[s.name], s);
        } else {
          signals.push(s);
        }
        map2[s.name] = s;
      });
      array$2(config.signals).forEach((s) => {
        if (!has$1(map2, s.name) && !has$1(pre, s.name)) {
          signals.push(s);
        }
      });
      return signals;
    }
    function Scope(config, options) {
      this.config = config || {};
      this.options = options || {};
      this.bindings = [];
      this.field = {};
      this.signals = {};
      this.lambdas = {};
      this.scales = {};
      this.events = {};
      this.data = {};
      this.streams = [];
      this.updates = [];
      this.operators = [];
      this.eventConfig = null;
      this.locale = null;
      this._id = 0;
      this._subid = 0;
      this._nextsub = [0];
      this._parent = [];
      this._encode = [];
      this._lookup = [];
      this._markpath = [];
    }
    function Subscope(scope) {
      this.config = scope.config;
      this.options = scope.options;
      this.legends = scope.legends;
      this.field = Object.create(scope.field);
      this.signals = Object.create(scope.signals);
      this.lambdas = Object.create(scope.lambdas);
      this.scales = Object.create(scope.scales);
      this.events = Object.create(scope.events);
      this.data = Object.create(scope.data);
      this.streams = [];
      this.updates = [];
      this.operators = [];
      this._id = 0;
      this._subid = ++scope._nextsub[0];
      this._nextsub = scope._nextsub;
      this._parent = scope._parent.slice();
      this._encode = scope._encode.slice();
      this._lookup = scope._lookup.slice();
      this._markpath = scope._markpath;
    }
    Scope.prototype = Subscope.prototype = {
      parse(spec) {
        return parseScope(spec, this);
      },
      fork() {
        return new Subscope(this);
      },
      isSubscope() {
        return this._subid > 0;
      },
      toRuntime() {
        this.finish();
        return {
          description: this.description,
          operators: this.operators,
          streams: this.streams,
          updates: this.updates,
          bindings: this.bindings,
          eventConfig: this.eventConfig,
          locale: this.locale
        };
      },
      id() {
        return (this._subid ? this._subid + ":" : 0) + this._id++;
      },
      add(op) {
        this.operators.push(op);
        op.id = this.id();
        if (op.refs) {
          op.refs.forEach((ref2) => {
            ref2.$ref = op.id;
          });
          op.refs = null;
        }
        return op;
      },
      proxy(op) {
        const vref = op instanceof Entry$1 ? ref(op) : op;
        return this.add(Proxy$1({
          value: vref
        }));
      },
      addStream(stream2) {
        this.streams.push(stream2);
        stream2.id = this.id();
        return stream2;
      },
      addUpdate(update2) {
        this.updates.push(update2);
        return update2;
      },
      // Apply metadata
      finish() {
        let name2, ds;
        if (this.root)
          this.root.root = true;
        for (name2 in this.signals) {
          this.signals[name2].signal = name2;
        }
        for (name2 in this.scales) {
          this.scales[name2].scale = name2;
        }
        function annotate(op, name3, type2) {
          let data2, list2;
          if (op) {
            data2 = op.data || (op.data = {});
            list2 = data2[name3] || (data2[name3] = []);
            list2.push(type2);
          }
        }
        for (name2 in this.data) {
          ds = this.data[name2];
          annotate(ds.input, name2, "input");
          annotate(ds.output, name2, "output");
          annotate(ds.values, name2, "values");
          for (const field2 in ds.index) {
            annotate(ds.index[field2], name2, "index:" + field2);
          }
        }
        return this;
      },
      // ----
      pushState(encode2, parent, lookup2) {
        this._encode.push(ref(this.add(Sieve({
          pulse: encode2
        }))));
        this._parent.push(parent);
        this._lookup.push(lookup2 ? ref(this.proxy(lookup2)) : null);
        this._markpath.push(-1);
      },
      popState() {
        this._encode.pop();
        this._parent.pop();
        this._lookup.pop();
        this._markpath.pop();
      },
      parent() {
        return peek$1(this._parent);
      },
      encode() {
        return peek$1(this._encode);
      },
      lookup() {
        return peek$1(this._lookup);
      },
      markpath() {
        const p = this._markpath;
        return ++p[p.length - 1];
      },
      // ----
      fieldRef(field2, name2) {
        if (isString(field2))
          return fieldRef$1(field2, name2);
        if (!field2.signal) {
          error("Unsupported field reference: " + $(field2));
        }
        const s = field2.signal;
        let f = this.field[s];
        if (!f) {
          const params2 = {
            name: this.signalRef(s)
          };
          if (name2)
            params2.as = name2;
          this.field[s] = f = ref(this.add(Field(params2)));
        }
        return f;
      },
      compareRef(cmp2) {
        let signal = false;
        const check2 = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
        const fields = array$2(cmp2.field).map(check2), orders = array$2(cmp2.order).map(check2);
        return signal ? ref(this.add(Compare({
          fields,
          orders
        }))) : compareRef(fields, orders);
      },
      keyRef(fields, flat) {
        let signal = false;
        const check2 = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
        const sig = this.signals;
        fields = array$2(fields).map(check2);
        return signal ? ref(this.add(Key({
          fields,
          flat
        }))) : keyRef(fields, flat);
      },
      sortRef(sort2) {
        if (!sort2)
          return sort2;
        const a2 = aggrField(sort2.op, sort2.field), o = sort2.order || Ascending;
        return o.signal ? ref(this.add(Compare({
          fields: a2,
          orders: this.signalRef(o.signal)
        }))) : compareRef(a2, o);
      },
      // ----
      event(source2, type2) {
        const key2 = source2 + ":" + type2;
        if (!this.events[key2]) {
          const id2 = this.id();
          this.streams.push({
            id: id2,
            source: source2,
            type: type2
          });
          this.events[key2] = id2;
        }
        return this.events[key2];
      },
      // ----
      hasOwnSignal(name2) {
        return has$1(this.signals, name2);
      },
      addSignal(name2, value2) {
        if (this.hasOwnSignal(name2)) {
          error("Duplicate signal name: " + $(name2));
        }
        const op = value2 instanceof Entry$1 ? value2 : this.add(operator(value2));
        return this.signals[name2] = op;
      },
      getSignal(name2) {
        if (!this.signals[name2]) {
          error("Unrecognized signal name: " + $(name2));
        }
        return this.signals[name2];
      },
      signalRef(s) {
        if (this.signals[s]) {
          return ref(this.signals[s]);
        } else if (!has$1(this.lambdas, s)) {
          this.lambdas[s] = this.add(operator(null));
        }
        return ref(this.lambdas[s]);
      },
      parseLambdas() {
        const code2 = Object.keys(this.lambdas);
        for (let i = 0, n = code2.length; i < n; ++i) {
          const s = code2[i], e3 = parser(s, this), op = this.lambdas[s];
          op.params = e3.$params;
          op.update = e3.$expr;
        }
      },
      property(spec) {
        return spec && spec.signal ? this.signalRef(spec.signal) : spec;
      },
      objectProperty(spec) {
        return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
      },
      exprRef(code2, name2) {
        const params2 = {
          expr: parser(code2, this)
        };
        if (name2)
          params2.expr.$name = name2;
        return ref(this.add(Expression(params2)));
      },
      addBinding(name2, bind2) {
        if (!this.bindings) {
          error("Nested signals do not support binding: " + $(name2));
        }
        this.bindings.push(extend({
          signal: name2
        }, bind2));
      },
      // ----
      addScaleProj(name2, transform2) {
        if (has$1(this.scales, name2)) {
          error("Duplicate scale or projection name: " + $(name2));
        }
        this.scales[name2] = this.add(transform2);
      },
      addScale(name2, params2) {
        this.addScaleProj(name2, Scale(params2));
      },
      addProjection(name2, params2) {
        this.addScaleProj(name2, Projection(params2));
      },
      getScale(name2) {
        if (!this.scales[name2]) {
          error("Unrecognized scale name: " + $(name2));
        }
        return this.scales[name2];
      },
      scaleRef(name2) {
        return ref(this.getScale(name2));
      },
      scaleType(name2) {
        return this.getScale(name2).params.type;
      },
      projectionRef(name2) {
        return this.scaleRef(name2);
      },
      projectionType(name2) {
        return this.scaleType(name2);
      },
      // ----
      addData(name2, dataScope) {
        if (has$1(this.data, name2)) {
          error("Duplicate data set name: " + $(name2));
        }
        return this.data[name2] = dataScope;
      },
      getData(name2) {
        if (!this.data[name2]) {
          error("Undefined data set name: " + $(name2));
        }
        return this.data[name2];
      },
      addDataPipeline(name2, entries2) {
        if (has$1(this.data, name2)) {
          error("Duplicate data set name: " + $(name2));
        }
        return this.addData(name2, DataScope.fromEntries(this, entries2));
      }
    };
    function propertyLambda(spec) {
      return (isArray(spec) ? arrayLambda : objectLambda)(spec);
    }
    function arrayLambda(array2) {
      const n = array2.length;
      let code2 = "[";
      for (let i = 0; i < n; ++i) {
        const value2 = array2[i];
        code2 += (i > 0 ? "," : "") + (isObject(value2) ? value2.signal || propertyLambda(value2) : $(value2));
      }
      return code2 + "]";
    }
    function objectLambda(obj) {
      let code2 = "{", i = 0, key2, value2;
      for (key2 in obj) {
        value2 = obj[key2];
        code2 += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject(value2) ? value2.signal || propertyLambda(value2) : $(value2));
      }
      return code2 + "}";
    }
    function defaults() {
      const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray = "#888", lightGray = "#ddd";
      return {
        // default visualization description
        description: "Vega visualization",
        // default padding around visualization
        padding: 0,
        // default for automatic sizing; options: 'none', 'pad', 'fit'
        // or provide an object (e.g., {'type': 'pad', 'resize': true})
        autosize: "pad",
        // default view background color
        // covers the entire view component
        background: null,
        // default event handling configuration
        // preventDefault for view-sourced event types except 'wheel'
        events: {
          defaults: {
            allow: ["wheel"]
          }
        },
        // defaults for top-level group marks
        // accepts mark properties (fill, stroke, etc)
        // covers the data rectangle within group width/height
        group: null,
        // defaults for basic mark types
        // each subset accepts mark properties (fill, stroke, etc)
        mark: null,
        arc: {
          fill: defaultColor
        },
        area: {
          fill: defaultColor
        },
        image: null,
        line: {
          stroke: defaultColor,
          strokeWidth: defaultStrokeWidth
        },
        path: {
          stroke: defaultColor
        },
        rect: {
          fill: defaultColor
        },
        rule: {
          stroke: black
        },
        shape: {
          stroke: defaultColor
        },
        symbol: {
          fill: defaultColor,
          size: 64
        },
        text: {
          fill: black,
          font: defaultFont2,
          fontSize: 11
        },
        trail: {
          fill: defaultColor,
          size: defaultStrokeWidth
        },
        // style definitions
        style: {
          // axis & legend labels
          "guide-label": {
            fill: black,
            font: defaultFont2,
            fontSize: 10
          },
          // axis & legend titles
          "guide-title": {
            fill: black,
            font: defaultFont2,
            fontSize: 11,
            fontWeight: "bold"
          },
          // headers, including chart title
          "group-title": {
            fill: black,
            font: defaultFont2,
            fontSize: 13,
            fontWeight: "bold"
          },
          // chart subtitle
          "group-subtitle": {
            fill: black,
            font: defaultFont2,
            fontSize: 12
          },
          // defaults for styled point marks in Vega-Lite
          point: {
            size: defaultSymbolSize,
            strokeWidth: defaultStrokeWidth,
            shape: "circle"
          },
          circle: {
            size: defaultSymbolSize,
            strokeWidth: defaultStrokeWidth
          },
          square: {
            size: defaultSymbolSize,
            strokeWidth: defaultStrokeWidth,
            shape: "square"
          },
          // defaults for styled group marks in Vega-Lite
          cell: {
            fill: "transparent",
            stroke: lightGray
          },
          view: {
            fill: "transparent"
          }
        },
        // defaults for title
        title: {
          orient: "top",
          anchor: "middle",
          offset: 4,
          subtitlePadding: 3
        },
        // defaults for axes
        axis: {
          minExtent: 0,
          maxExtent: 200,
          bandPosition: 0.5,
          domain: true,
          domainWidth: 1,
          domainColor: gray,
          grid: false,
          gridWidth: 1,
          gridColor: lightGray,
          labels: true,
          labelAngle: 0,
          labelLimit: 180,
          labelOffset: 0,
          labelPadding: 2,
          ticks: true,
          tickColor: gray,
          tickOffset: 0,
          tickRound: true,
          tickSize: 5,
          tickWidth: 1,
          titlePadding: 4
        },
        // correction for centering bias
        axisBand: {
          tickOffset: -0.5
        },
        // defaults for cartographic projection
        projection: {
          type: "mercator"
        },
        // defaults for legends
        legend: {
          orient: "right",
          padding: 0,
          gridAlign: "each",
          columnPadding: 10,
          rowPadding: 2,
          symbolDirection: "vertical",
          gradientDirection: "vertical",
          gradientLength: 200,
          gradientThickness: 16,
          gradientStrokeColor: lightGray,
          gradientStrokeWidth: 0,
          gradientLabelOffset: 2,
          labelAlign: "left",
          labelBaseline: "middle",
          labelLimit: 160,
          labelOffset: 4,
          labelOverlap: true,
          symbolLimit: 30,
          symbolType: "circle",
          symbolSize: 100,
          symbolOffset: 0,
          symbolStrokeWidth: 1.5,
          symbolBaseFillColor: "transparent",
          symbolBaseStrokeColor: gray,
          titleLimit: 180,
          titleOrient: "top",
          titlePadding: 5,
          layout: {
            offset: 18,
            direction: "horizontal",
            left: {
              direction: "vertical"
            },
            right: {
              direction: "vertical"
            }
          }
        },
        // defaults for scale ranges
        range: {
          category: {
            scheme: "tableau10"
          },
          ordinal: {
            scheme: "blues"
          },
          heatmap: {
            scheme: "yellowgreenblue"
          },
          ramp: {
            scheme: "blues"
          },
          diverging: {
            scheme: "blueorange",
            extent: [1, 0]
          },
          symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
        }
      };
    }
    function parse(spec, config, options) {
      if (!isObject(spec)) {
        error("Input Vega specification must be an object.");
      }
      config = mergeConfig(defaults(), config, spec.config);
      return parseView(spec, new Scope(config, options)).toRuntime();
    }
    var version$4 = "5.27.0";
    extend(transforms, tx, vtx, encode$1, geo, force, label, tree, reg, voronoi, wordcloud, xf);
    const vegaImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Bounds,
      CanvasHandler,
      CanvasRenderer,
      DATE,
      DAY,
      DAYOFYEAR,
      Dataflow,
      Debug,
      Error: Error$1,
      EventStream,
      Gradient: Gradient$1,
      GroupItem,
      HOURS,
      Handler: Handler$1,
      HybridHandler,
      HybridRenderer,
      Info,
      Item,
      MILLISECONDS,
      MINUTES,
      MONTH,
      Marks,
      MultiPulse,
      None: None$2,
      Operator,
      Parameters,
      Pulse,
      QUARTER,
      RenderType,
      Renderer,
      ResourceLoader,
      SECONDS,
      SVGHandler,
      SVGRenderer,
      SVGStringRenderer,
      Scenegraph,
      TIME_UNITS,
      Transform,
      View: View$1,
      WEEK,
      Warn,
      YEAR,
      accessor,
      accessorFields,
      accessorName,
      array: array$2,
      ascending: ascending$1,
      bandwidthNRD: estimateBandwidth,
      bin: bin$1,
      bootstrapCI,
      boundClip,
      boundContext,
      boundItem: boundItem$1,
      boundMark,
      boundStroke,
      changeset,
      clampRange,
      codegenExpression: codegen,
      compare: compare$8,
      constant: constant$1,
      cumulativeLogNormal,
      cumulativeNormal,
      cumulativeUniform,
      dayofyear,
      debounce,
      defaultLocale,
      definition: definition$1,
      densityLogNormal,
      densityNormal,
      densityUniform,
      domChild,
      domClear,
      domCreate,
      domFind,
      dotbin,
      error,
      expressionFunction,
      extend,
      extent,
      extentIndex,
      falsy,
      fastmap,
      field: field$1,
      flush,
      font: font$1,
      fontFamily,
      fontSize,
      format: format$2,
      formatLocale: numberFormatDefaultLocale,
      formats: formats$1,
      hasOwnProperty: has$1,
      id,
      identity: identity$1,
      inferType,
      inferTypes,
      ingest: ingest$1,
      inherits,
      inrange,
      interpolate: interpolate$1,
      interpolateColors,
      interpolateRange: interpolateRange$1,
      intersect: intersect$2,
      intersectBoxLine,
      intersectPath,
      intersectPoint,
      intersectRule,
      isArray,
      isBoolean: isBoolean$2,
      isDate: isDate$1,
      isFunction,
      isIterable,
      isNumber: isNumber$1,
      isObject,
      isRegExp,
      isString,
      isTuple,
      key,
      lerp,
      lineHeight,
      loader,
      locale,
      logger,
      lruCache: lruCache$1,
      markup,
      merge: merge$2,
      mergeConfig,
      multiLineOffset,
      one: one$1,
      pad,
      panLinear,
      panLog,
      panPow,
      panSymlog,
      parse,
      parseExpression: parser$1,
      parseSelector: eventSelector,
      path: path$3,
      pathCurves: curves,
      pathEqual,
      pathParse: parse$3,
      pathRectangle: vg_rect,
      pathRender,
      pathSymbols: symbols$1,
      pathTrail: vg_trail,
      peek: peek$1,
      point: point$2,
      projection,
      quantileLogNormal,
      quantileNormal,
      quantileUniform,
      quantiles,
      quantizeInterpolator,
      quarter,
      quartiles,
      get random() {
        return random;
      },
      randomInteger: integer,
      randomKDE: kde,
      randomLCG: lcg,
      randomLogNormal: lognormal,
      randomMixture: mixture$1,
      randomNormal: gaussian,
      randomUniform: uniform,
      read,
      regressionConstant: constant,
      regressionExp: exp,
      regressionLinear: linear,
      regressionLoess: loess,
      regressionLog: log$1,
      regressionPoly: poly,
      regressionPow: pow,
      regressionQuad: quad,
      renderModule,
      repeat,
      resetDefaultLocale,
      resetSVGClipId,
      resetSVGDefIds,
      responseType,
      runtimeContext: context,
      sampleCurve,
      sampleLogNormal,
      sampleNormal,
      sampleUniform,
      scale: scale$4,
      sceneEqual,
      sceneFromJSON,
      scenePickVisit: pickVisit,
      sceneToJSON,
      sceneVisit: visit,
      sceneZOrder: zorder,
      scheme: scheme$1,
      serializeXML,
      setHybridRendererOptions,
      setRandom,
      span,
      splitAccessPath,
      stringValue: $,
      textMetrics,
      timeBin: bin$2,
      timeFloor,
      timeFormatLocale: timeFormatDefaultLocale,
      timeInterval,
      timeOffset,
      timeSequence,
      timeUnitSpecifier,
      timeUnits,
      toBoolean,
      toDate,
      toNumber,
      toSet,
      toString,
      transform: transform$2,
      transforms,
      truncate: truncate$1,
      truthy,
      tupleid,
      typeParsers,
      utcFloor,
      utcInterval,
      utcOffset,
      utcSequence,
      utcdayofyear,
      utcquarter,
      utcweek,
      version: version$4,
      visitArray,
      week,
      writeConfig,
      zero: zero$2,
      zoomLinear,
      zoomLog,
      zoomPow,
      zoomSymlog
    }, Symbol.toStringTag, { value: "Module" }));
    function adjustSpatial(item, encode2, swap2) {
      let t4;
      if (encode2.x2) {
        if (encode2.x) {
          if (swap2 && item.x > item.x2) {
            t4 = item.x;
            item.x = item.x2;
            item.x2 = t4;
          }
          item.width = item.x2 - item.x;
        } else {
          item.x = item.x2 - (item.width || 0);
        }
      }
      if (encode2.xc) {
        item.x = item.xc - (item.width || 0) / 2;
      }
      if (encode2.y2) {
        if (encode2.y) {
          if (swap2 && item.y > item.y2) {
            t4 = item.y;
            item.y = item.y2;
            item.y2 = t4;
          }
          item.height = item.y2 - item.y;
        } else {
          item.y = item.y2 - (item.height || 0);
        }
      }
      if (encode2.yc) {
        item.y = item.yc - (item.height || 0) / 2;
      }
    }
    var Constants = {
      NaN: NaN,
      E: Math.E,
      LN2: Math.LN2,
      LN10: Math.LN10,
      LOG2E: Math.LOG2E,
      LOG10E: Math.LOG10E,
      PI: Math.PI,
      SQRT1_2: Math.SQRT1_2,
      SQRT2: Math.SQRT2,
      MIN_VALUE: Number.MIN_VALUE,
      MAX_VALUE: Number.MAX_VALUE
    };
    var Ops = {
      "*": (a2, b2) => a2 * b2,
      "+": (a2, b2) => a2 + b2,
      "-": (a2, b2) => a2 - b2,
      "/": (a2, b2) => a2 / b2,
      "%": (a2, b2) => a2 % b2,
      ">": (a2, b2) => a2 > b2,
      "<": (a2, b2) => a2 < b2,
      "<=": (a2, b2) => a2 <= b2,
      ">=": (a2, b2) => a2 >= b2,
      "==": (a2, b2) => a2 == b2,
      "!=": (a2, b2) => a2 != b2,
      "===": (a2, b2) => a2 === b2,
      "!==": (a2, b2) => a2 !== b2,
      "&": (a2, b2) => a2 & b2,
      "|": (a2, b2) => a2 | b2,
      "^": (a2, b2) => a2 ^ b2,
      "<<": (a2, b2) => a2 << b2,
      ">>": (a2, b2) => a2 >> b2,
      ">>>": (a2, b2) => a2 >>> b2
    };
    var Unary = {
      "+": (a2) => +a2,
      "-": (a2) => -a2,
      "~": (a2) => ~a2,
      "!": (a2) => !a2
    };
    const slice = Array.prototype.slice;
    const apply = (m2, args, cast) => {
      const obj = cast ? cast(args[0]) : args[0];
      return obj[m2].apply(obj, slice.call(args, 1));
    };
    const datetime = (y2, m2, d, H, M2, S, ms) => new Date(y2, m2 || 0, d != null ? d : 1, H || 0, M2 || 0, S || 0, ms || 0);
    var Functions = {
      // math functions
      isNaN: Number.isNaN,
      isFinite: Number.isFinite,
      abs: Math.abs,
      acos: Math.acos,
      asin: Math.asin,
      atan: Math.atan,
      atan2: Math.atan2,
      ceil: Math.ceil,
      cos: Math.cos,
      exp: Math.exp,
      floor: Math.floor,
      log: Math.log,
      max: Math.max,
      min: Math.min,
      pow: Math.pow,
      random: Math.random,
      round: Math.round,
      sin: Math.sin,
      sqrt: Math.sqrt,
      tan: Math.tan,
      clamp: (a2, b2, c2) => Math.max(b2, Math.min(c2, a2)),
      // date functions
      now: Date.now,
      utc: Date.UTC,
      datetime,
      date: (d) => new Date(d).getDate(),
      day: (d) => new Date(d).getDay(),
      year: (d) => new Date(d).getFullYear(),
      month: (d) => new Date(d).getMonth(),
      hours: (d) => new Date(d).getHours(),
      minutes: (d) => new Date(d).getMinutes(),
      seconds: (d) => new Date(d).getSeconds(),
      milliseconds: (d) => new Date(d).getMilliseconds(),
      time: (d) => new Date(d).getTime(),
      timezoneoffset: (d) => new Date(d).getTimezoneOffset(),
      utcdate: (d) => new Date(d).getUTCDate(),
      utcday: (d) => new Date(d).getUTCDay(),
      utcyear: (d) => new Date(d).getUTCFullYear(),
      utcmonth: (d) => new Date(d).getUTCMonth(),
      utchours: (d) => new Date(d).getUTCHours(),
      utcminutes: (d) => new Date(d).getUTCMinutes(),
      utcseconds: (d) => new Date(d).getUTCSeconds(),
      utcmilliseconds: (d) => new Date(d).getUTCMilliseconds(),
      // sequence functions
      length: (x2) => x2.length,
      join: function() {
        return apply("join", arguments);
      },
      indexof: function() {
        return apply("indexOf", arguments);
      },
      lastindexof: function() {
        return apply("lastIndexOf", arguments);
      },
      slice: function() {
        return apply("slice", arguments);
      },
      reverse: (x2) => x2.slice().reverse(),
      // string functions
      parseFloat,
      parseInt,
      upper: (x2) => String(x2).toUpperCase(),
      lower: (x2) => String(x2).toLowerCase(),
      substring: function() {
        return apply("substring", arguments, String);
      },
      split: function() {
        return apply("split", arguments, String);
      },
      replace: function() {
        return apply("replace", arguments, String);
      },
      trim: (x2) => String(x2).trim(),
      // regexp functions
      regexp: RegExp,
      test: (r, t4) => RegExp(r).test(t4)
    };
    const EventFunctions = ["view", "item", "group", "xy", "x", "y"];
    const DisallowedMethods = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
    if (typeof setImmediate === "function")
      DisallowedMethods.add(setImmediate);
    const Visitors = {
      Literal: ($2, n) => n.value,
      Identifier: ($2, n) => {
        const id2 = n.name;
        return $2.memberDepth > 0 ? id2 : id2 === "datum" ? $2.datum : id2 === "event" ? $2.event : id2 === "item" ? $2.item : Constants[id2] || $2.params["$" + id2];
      },
      MemberExpression: ($2, n) => {
        const d = !n.computed, o = $2(n.object);
        if (d)
          $2.memberDepth += 1;
        const p = $2(n.property);
        if (d)
          $2.memberDepth -= 1;
        if (DisallowedMethods.has(o[p])) {
          console.error(`Prevented interpretation of member "${p}" which could lead to insecure code execution`);
          return;
        }
        return o[p];
      },
      CallExpression: ($2, n) => {
        const args = n.arguments;
        let name2 = n.callee.name;
        if (name2.startsWith("_")) {
          name2 = name2.slice(1);
        }
        return name2 === "if" ? $2(args[0]) ? $2(args[1]) : $2(args[2]) : ($2.fn[name2] || Functions[name2]).apply($2.fn, args.map($2));
      },
      ArrayExpression: ($2, n) => n.elements.map($2),
      BinaryExpression: ($2, n) => Ops[n.operator]($2(n.left), $2(n.right)),
      UnaryExpression: ($2, n) => Unary[n.operator]($2(n.argument)),
      ConditionalExpression: ($2, n) => $2(n.test) ? $2(n.consequent) : $2(n.alternate),
      LogicalExpression: ($2, n) => n.operator === "&&" ? $2(n.left) && $2(n.right) : $2(n.left) || $2(n.right),
      ObjectExpression: ($2, n) => n.properties.reduce((o, p) => {
        $2.memberDepth += 1;
        const k = $2(p.key);
        $2.memberDepth -= 1;
        if (DisallowedMethods.has($2(p.value))) {
          console.error(`Prevented interpretation of property "${k}" which could lead to insecure code execution`);
        } else {
          o[k] = $2(p.value);
        }
        return o;
      }, {})
    };
    function interpret(ast, fn, params2, datum2, event2, item) {
      const $2 = (n) => Visitors[n.type]($2, n);
      $2.memberDepth = 0;
      $2.fn = Object.create(fn);
      $2.params = params2;
      $2.datum = datum2;
      $2.event = event2;
      $2.item = item;
      EventFunctions.forEach((f) => $2.fn[f] = function() {
        return event2.vega[f](...arguments);
      });
      return $2(ast);
    }
    var expression$1 = {
      /**
       * Parse an expression used to update an operator value.
       */
      operator(ctx, expr2) {
        const ast = expr2.ast, fn = ctx.functions;
        return (_) => interpret(ast, fn, _);
      },
      /**
       * Parse an expression provided as an operator parameter value.
       */
      parameter(ctx, expr2) {
        const ast = expr2.ast, fn = ctx.functions;
        return (datum2, _) => interpret(ast, fn, _, datum2);
      },
      /**
       * Parse an expression applied to an event stream.
       */
      event(ctx, expr2) {
        const ast = expr2.ast, fn = ctx.functions;
        return (event2) => interpret(ast, fn, void 0, void 0, event2);
      },
      /**
       * Parse an expression used to handle an event-driven operator update.
       */
      handler(ctx, expr2) {
        const ast = expr2.ast, fn = ctx.functions;
        return (_, event2) => {
          const datum2 = event2.item && event2.item.datum;
          return interpret(ast, fn, _, datum2, event2);
        };
      },
      /**
       * Parse an expression that performs visual encoding.
       */
      encode(ctx, encode2) {
        const {
          marktype,
          channels
        } = encode2, fn = ctx.functions, swap2 = marktype === "group" || marktype === "image" || marktype === "rect";
        return (item, _) => {
          const datum2 = item.datum;
          let m2 = 0, v;
          for (const name2 in channels) {
            v = interpret(channels[name2].ast, fn, _, datum2, void 0, item);
            if (item[name2] !== v) {
              item[name2] = v;
              m2 = 1;
            }
          }
          if (marktype !== "rule") {
            adjustSpatial(item, channels, swap2);
          }
          return m2;
        };
      }
    };
    const name$1 = "vega-lite";
    const author$1 = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer';
    const version$3 = "5.16.3";
    const collaborators = [
      "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
      "Dominik Moritz (https://www.domoritz.de)",
      "Arvind Satyanarayan (https://arvindsatya.com)",
      "Jeffrey Heer (https://jheer.org)"
    ];
    const homepage = "https://vega.github.io/vega-lite/";
    const description$2 = "Vega-Lite is a concise high-level language for interactive visualization.";
    const keywords$1 = [
      "vega",
      "chart",
      "visualization"
    ];
    const main$2 = "build/vega-lite.js";
    const unpkg$1 = "build/vega-lite.min.js";
    const jsdelivr$1 = "build/vega-lite.min.js";
    const module$1 = "build/src/index";
    const types$1 = "build/src/index.d.ts";
    const bin = {
      vl2pdf: "./bin/vl2pdf",
      vl2png: "./bin/vl2png",
      vl2svg: "./bin/vl2svg",
      vl2vg: "./bin/vl2vg"
    };
    const files$1 = [
      "bin",
      "build",
      "src",
      "vega-lite*",
      "tsconfig.json"
    ];
    const scripts$1 = {
      changelog: "conventional-changelog -p angular -r 2",
      prebuild: "yarn clean:build",
      build: "yarn build:only",
      "build:only": "tsc -p tsconfig.build.json && rollup -c",
      "prebuild:examples": "yarn build:only",
      "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
      "prebuild:examples-full": "yarn build:only",
      "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
      "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
      "build:toc": "yarn build:jekyll && scripts/generate-toc",
      "build:site": "rollup -c site/rollup.config.mjs",
      "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
      "build:versions": "scripts/update-version.sh",
      clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
      "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
      data: "rsync -r node_modules/vega-datasets/data/* site/data",
      schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
      renameschema: "scripts/rename-schema.sh",
      presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
      site: "yarn site:only",
      "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
      prettierbase: "prettier '**/*.{md,css,yml}'",
      format: "eslint . --fix && yarn prettierbase --write",
      lint: "eslint . && yarn prettierbase --check",
      jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
      test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
      "test:cover": "yarn jest --collectCoverage test/",
      "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
      "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
      "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
      watch: "tsc -p tsconfig.build.json -w",
      "watch:site": "yarn build:site -w",
      "watch:test": "yarn jest --watch test/",
      "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
      release: "release-it"
    };
    const repository$1 = {
      type: "git",
      url: "https://github.com/vega/vega-lite.git"
    };
    const license$1 = "BSD-3-Clause";
    const bugs = {
      url: "https://github.com/vega/vega-lite/issues"
    };
    const devDependencies$1 = {
      "@babel/core": "^7.22.10",
      "@babel/plugin-proposal-class-properties": "^7.18.6",
      "@babel/preset-env": "^7.22.10",
      "@babel/preset-typescript": "^7.22.5",
      "@release-it/conventional-changelog": "^7.0.0",
      "@rollup/plugin-alias": "^5.0.0",
      "@rollup/plugin-babel": "^6.0.3",
      "@rollup/plugin-commonjs": "^25.0.4",
      "@rollup/plugin-json": "^6.0.0",
      "@rollup/plugin-node-resolve": "^15.2.1",
      "@rollup/plugin-terser": "^0.4.3",
      "@types/chai": "^4.3.5",
      "@types/d3": "^7.4.0",
      "@types/jest": "^29.5.4",
      "@types/pako": "^2.0.0",
      "@typescript-eslint/eslint-plugin": "^6.4.1",
      "@typescript-eslint/parser": "^6.4.1",
      ajv: "^8.12.0",
      "ajv-formats": "^2.1.1",
      chai: "^4.3.7",
      cheerio: "^1.0.0-rc.12",
      "conventional-changelog-cli": "^4.0.0",
      d3: "^7.8.5",
      "del-cli": "^5.0.0",
      eslint: "^8.47.0",
      "eslint-config-prettier": "^9.0.0",
      "eslint-plugin-jest": "^27.2.3",
      "eslint-plugin-prettier": "^5.0.0",
      "fast-json-stable-stringify": "~2.1.0",
      "highlight.js": "^11.8.0",
      jest: "^29.6.3",
      "jest-dev-server": "^9.0.0",
      mkdirp: "^3.0.1",
      pako: "^2.1.0",
      prettier: "^3.0.2",
      puppeteer: "^15.0.0",
      "release-it": "^16.1.5",
      rollup: "^3.28.1",
      "rollup-plugin-bundle-size": "^1.0.3",
      "rollup-plugin-sourcemaps": "^0.6.3",
      serve: "^14.2.1",
      terser: "^5.19.2",
      "ts-jest": "^29.1.1",
      "ts-json-schema-generator": "^1.3.0",
      typescript: "~5.2.2",
      "vega-cli": "^5.25.0",
      "vega-datasets": "^2.7.0",
      "vega-embed": "^6.22.2",
      "vega-tooltip": "^0.33.0",
      "yaml-front-matter": "^4.1.1"
    };
    const dependencies$1 = {
      "json-stringify-pretty-compact": "~3.0.0",
      tslib: "~2.6.2",
      "vega-event-selector": "~3.0.1",
      "vega-expression": "~5.1.0",
      "vega-util": "~1.17.2",
      yargs: "~17.7.2"
    };
    const peerDependencies$1 = {
      vega: "^5.24.0"
    };
    const engines = {
      node: ">=18"
    };
    const pkg$1 = {
      name: name$1,
      author: author$1,
      version: version$3,
      collaborators,
      homepage,
      description: description$2,
      keywords: keywords$1,
      main: main$2,
      unpkg: unpkg$1,
      jsdelivr: jsdelivr$1,
      module: module$1,
      types: types$1,
      bin,
      files: files$1,
      scripts: scripts$1,
      repository: repository$1,
      license: license$1,
      bugs,
      devDependencies: devDependencies$1,
      dependencies: dependencies$1,
      peerDependencies: peerDependencies$1,
      engines
    };
    function isLogicalOr(op) {
      return !!op.or;
    }
    function isLogicalAnd(op) {
      return !!op.and;
    }
    function isLogicalNot(op) {
      return !!op.not;
    }
    function forEachLeaf(op, fn) {
      if (isLogicalNot(op)) {
        forEachLeaf(op.not, fn);
      } else if (isLogicalAnd(op)) {
        for (const subop of op.and) {
          forEachLeaf(subop, fn);
        }
      } else if (isLogicalOr(op)) {
        for (const subop of op.or) {
          forEachLeaf(subop, fn);
        }
      } else {
        fn(op);
      }
    }
    function normalizeLogicalComposition(op, normalizer) {
      if (isLogicalNot(op)) {
        return { not: normalizeLogicalComposition(op.not, normalizer) };
      } else if (isLogicalAnd(op)) {
        return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer)) };
      } else if (isLogicalOr(op)) {
        return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer)) };
      } else {
        return normalizer(op);
      }
    }
    const duplicate = structuredClone;
    function never(message) {
      throw new Error(message);
    }
    function pick(obj, props) {
      const copy2 = {};
      for (const prop of props) {
        if (has$1(obj, prop)) {
          copy2[prop] = obj[prop];
        }
      }
      return copy2;
    }
    function omit(obj, props) {
      const copy2 = { ...obj };
      for (const prop of props) {
        delete copy2[prop];
      }
      return copy2;
    }
    Set.prototype["toJSON"] = function() {
      return `Set(${[...this].map((x2) => stringify$1(x2)).join(",")})`;
    };
    function hash(a2) {
      if (isNumber$1(a2)) {
        return a2;
      }
      const str = isString(a2) ? a2 : stringify$1(a2);
      if (str.length < 250) {
        return str;
      }
      let h2 = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        h2 = (h2 << 5) - h2 + char;
        h2 = h2 & h2;
      }
      return h2;
    }
    function isNullOrFalse(x2) {
      return x2 === false || x2 === null;
    }
    function contains(array2, item) {
      return array2.includes(item);
    }
    function some(arr, f) {
      let i = 0;
      for (const [k, a2] of arr.entries()) {
        if (f(a2, k, i++)) {
          return true;
        }
      }
      return false;
    }
    function every(arr, f) {
      let i = 0;
      for (const [k, a2] of arr.entries()) {
        if (!f(a2, k, i++)) {
          return false;
        }
      }
      return true;
    }
    function mergeDeep$1(dest, ...src) {
      for (const s of src) {
        deepMerge_$1(dest, s ?? {});
      }
      return dest;
    }
    function deepMerge_$1(dest, src) {
      for (const property2 of keys(src)) {
        writeConfig(dest, property2, src[property2], true);
      }
    }
    function unique(values2, f) {
      const results = [];
      const u2 = {};
      let v;
      for (const val of values2) {
        v = f(val);
        if (v in u2) {
          continue;
        }
        u2[v] = 1;
        results.push(val);
      }
      return results;
    }
    function isEqual(dict, other) {
      const dictKeys = keys(dict);
      const otherKeys = keys(other);
      if (dictKeys.length !== otherKeys.length) {
        return false;
      }
      for (const key2 of dictKeys) {
        if (dict[key2] !== other[key2]) {
          return false;
        }
      }
      return true;
    }
    function setEqual(a2, b2) {
      if (a2.size !== b2.size) {
        return false;
      }
      for (const e3 of a2) {
        if (!b2.has(e3)) {
          return false;
        }
      }
      return true;
    }
    function hasIntersection(a2, b2) {
      for (const key2 of a2) {
        if (b2.has(key2)) {
          return true;
        }
      }
      return false;
    }
    function prefixGenerator(a2) {
      const prefixes2 = /* @__PURE__ */ new Set();
      for (const x2 of a2) {
        const splitField = splitAccessPath(x2);
        const wrappedWithAccessors = splitField.map((y2, i) => i === 0 ? y2 : `[${y2}]`);
        const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
        for (const y2 of computedPrefixes) {
          prefixes2.add(y2);
        }
      }
      return prefixes2;
    }
    function fieldIntersection(a2, b2) {
      if (a2 === void 0 || b2 === void 0) {
        return true;
      }
      return hasIntersection(prefixGenerator(a2), prefixGenerator(b2));
    }
    function isEmpty(obj) {
      return keys(obj).length === 0;
    }
    const keys = Object.keys;
    const vals = Object.values;
    const entries$1 = Object.entries;
    function isBoolean(b2) {
      return b2 === true || b2 === false;
    }
    function varName(s) {
      const alphanumericS = s.replace(/\W/g, "_");
      return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
    }
    function logicalExpr(op, cb) {
      if (isLogicalNot(op)) {
        return `!(${logicalExpr(op.not, cb)})`;
      } else if (isLogicalAnd(op)) {
        return `(${op.and.map((and) => logicalExpr(and, cb)).join(") && (")})`;
      } else if (isLogicalOr(op)) {
        return `(${op.or.map((or2) => logicalExpr(or2, cb)).join(") || (")})`;
      } else {
        return cb(op);
      }
    }
    function deleteNestedProperty(obj, orderedProps) {
      if (orderedProps.length === 0) {
        return true;
      }
      const prop = orderedProps.shift();
      if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
        delete obj[prop];
      }
      return isEmpty(obj);
    }
    function titleCase(s) {
      return s.charAt(0).toUpperCase() + s.substr(1);
    }
    function accessPathWithDatum(path2, datum2 = "datum") {
      const pieces = splitAccessPath(path2);
      const prefixes2 = [];
      for (let i = 1; i <= pieces.length; i++) {
        const prefix = `[${pieces.slice(0, i).map($).join("][")}]`;
        prefixes2.push(`${datum2}${prefix}`);
      }
      return prefixes2.join(" && ");
    }
    function flatAccessWithDatum(path2, datum2 = "datum") {
      return `${datum2}[${$(splitAccessPath(path2).join("."))}]`;
    }
    function escapePathAccess(string) {
      return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
    }
    function replacePathInField(path2) {
      return `${splitAccessPath(path2).map(escapePathAccess).join("\\.")}`;
    }
    function replaceAll(string, find2, replacement) {
      return string.replace(new RegExp(find2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
    }
    function removePathFromField(path2) {
      return `${splitAccessPath(path2).join(".")}`;
    }
    function accessPathDepth(path2) {
      if (!path2) {
        return 0;
      }
      return splitAccessPath(path2).length;
    }
    function getFirstDefined(...args) {
      for (const arg of args) {
        if (arg !== void 0) {
          return arg;
        }
      }
      return void 0;
    }
    let idCounter = 42;
    function uniqueId(prefix) {
      const id2 = ++idCounter;
      return prefix ? String(prefix) + id2 : id2;
    }
    function resetIdCounter() {
      idCounter = 42;
    }
    function internalField(name2) {
      return isInternalField(name2) ? name2 : `__${name2}`;
    }
    function isInternalField(name2) {
      return name2.startsWith("__");
    }
    function normalizeAngle(angle2) {
      if (angle2 === void 0) {
        return void 0;
      }
      return (angle2 % 360 + 360) % 360;
    }
    function isNumeric(value2) {
      if (isNumber$1(value2)) {
        return true;
      }
      return !isNaN(value2) && !isNaN(parseFloat(value2));
    }
    const clonedProto = Object.getPrototypeOf(structuredClone({}));
    function deepEqual(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor.name !== b2.constructor.name)
          return false;
        let length2;
        let i;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (!deepEqual(a2[i], b2[i]))
              return false;
          return true;
        }
        if (a2 instanceof Map && b2 instanceof Map) {
          if (a2.size !== b2.size)
            return false;
          for (i of a2.entries())
            if (!b2.has(i[0]))
              return false;
          for (i of a2.entries())
            if (!deepEqual(i[1], b2.get(i[0])))
              return false;
          return true;
        }
        if (a2 instanceof Set && b2 instanceof Set) {
          if (a2.size !== b2.size)
            return false;
          for (i of a2.entries())
            if (!b2.has(i[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i = length2; i-- !== 0; )
            if (a2[i] !== b2[i])
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf && a2.valueOf !== clonedProto.valueOf)
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString && a2.toString !== clonedProto.toString)
          return a2.toString() === b2.toString();
        const ks = Object.keys(a2);
        length2 = ks.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, ks[i]))
            return false;
        for (i = length2; i-- !== 0; ) {
          const key2 = ks[i];
          if (!deepEqual(a2[key2], b2[key2]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    }
    function stringify$1(data2) {
      const seen = [];
      return function _stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return void 0;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        let i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += _stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.includes(node)) {
          throw new TypeError("Converting circular structure to JSON");
        }
        const seenIndex = seen.push(node) - 1;
        const ks = Object.keys(node).sort();
        out = "";
        for (i = 0; i < ks.length; i++) {
          const key2 = ks[i];
          const value2 = _stringify(node[key2]);
          if (!value2)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key2) + ":" + value2;
        }
        seen.splice(seenIndex, 1);
        return `{${out}}`;
      }(data2);
    }
    const ROW = "row";
    const COLUMN = "column";
    const FACET = "facet";
    const X = "x";
    const Y = "y";
    const X2 = "x2";
    const Y2 = "y2";
    const XOFFSET = "xOffset";
    const YOFFSET = "yOffset";
    const RADIUS = "radius";
    const RADIUS2 = "radius2";
    const THETA = "theta";
    const THETA2 = "theta2";
    const LATITUDE = "latitude";
    const LONGITUDE = "longitude";
    const LATITUDE2 = "latitude2";
    const LONGITUDE2 = "longitude2";
    const COLOR = "color";
    const FILL = "fill";
    const STROKE = "stroke";
    const SHAPE = "shape";
    const SIZE = "size";
    const ANGLE = "angle";
    const OPACITY = "opacity";
    const FILLOPACITY = "fillOpacity";
    const STROKEOPACITY = "strokeOpacity";
    const STROKEWIDTH = "strokeWidth";
    const STROKEDASH = "strokeDash";
    const TEXT$1 = "text";
    const ORDER = "order";
    const DETAIL = "detail";
    const KEY = "key";
    const TOOLTIP = "tooltip";
    const HREF = "href";
    const URL$1 = "url";
    const DESCRIPTION = "description";
    const POSITION_CHANNEL_INDEX = {
      x: 1,
      y: 1,
      x2: 1,
      y2: 1
    };
    const POLAR_POSITION_CHANNEL_INDEX = {
      theta: 1,
      theta2: 1,
      radius: 1,
      radius2: 1
    };
    function isPolarPositionChannel(c2) {
      return c2 in POLAR_POSITION_CHANNEL_INDEX;
    }
    const GEO_POSIITON_CHANNEL_INDEX = {
      longitude: 1,
      longitude2: 1,
      latitude: 1,
      latitude2: 1
    };
    function getPositionChannelFromLatLong(channel) {
      switch (channel) {
        case LATITUDE:
          return "y";
        case LATITUDE2:
          return "y2";
        case LONGITUDE:
          return "x";
        case LONGITUDE2:
          return "x2";
      }
    }
    function isGeoPositionChannel(c2) {
      return c2 in GEO_POSIITON_CHANNEL_INDEX;
    }
    const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);
    const UNIT_CHANNEL_INDEX = {
      ...POSITION_CHANNEL_INDEX,
      ...POLAR_POSITION_CHANNEL_INDEX,
      ...GEO_POSIITON_CHANNEL_INDEX,
      xOffset: 1,
      yOffset: 1,
      // color
      color: 1,
      fill: 1,
      stroke: 1,
      // other non-position with scale
      opacity: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeDash: 1,
      size: 1,
      angle: 1,
      shape: 1,
      // channels without scales
      order: 1,
      text: 1,
      detail: 1,
      key: 1,
      tooltip: 1,
      href: 1,
      url: 1,
      description: 1
    };
    function isColorChannel(channel) {
      return channel === COLOR || channel === FILL || channel === STROKE;
    }
    const FACET_CHANNEL_INDEX = {
      row: 1,
      column: 1,
      facet: 1
    };
    const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);
    const CHANNEL_INDEX = {
      ...UNIT_CHANNEL_INDEX,
      ...FACET_CHANNEL_INDEX
    };
    const CHANNELS = keys(CHANNEL_INDEX);
    const { order: _o, detail: _d, tooltip: _tt1, ...SINGLE_DEF_CHANNEL_INDEX } = CHANNEL_INDEX;
    const { row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX } = SINGLE_DEF_CHANNEL_INDEX;
    function isSingleDefUnitChannel(str) {
      return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];
    }
    function isChannel(str) {
      return !!CHANNEL_INDEX[str];
    }
    const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
    function isSecondaryRangeChannel(c2) {
      const main2 = getMainRangeChannel(c2);
      return main2 !== c2;
    }
    function getMainRangeChannel(channel) {
      switch (channel) {
        case X2:
          return X;
        case Y2:
          return Y;
        case LATITUDE2:
          return LATITUDE;
        case LONGITUDE2:
          return LONGITUDE;
        case THETA2:
          return THETA;
        case RADIUS2:
          return RADIUS;
      }
      return channel;
    }
    function getVgPositionChannel(channel) {
      if (isPolarPositionChannel(channel)) {
        switch (channel) {
          case THETA:
            return "startAngle";
          case THETA2:
            return "endAngle";
          case RADIUS:
            return "outerRadius";
          case RADIUS2:
            return "innerRadius";
        }
      }
      return channel;
    }
    function getSecondaryRangeChannel(channel) {
      switch (channel) {
        case X:
          return X2;
        case Y:
          return Y2;
        case LATITUDE:
          return LATITUDE2;
        case LONGITUDE:
          return LONGITUDE2;
        case THETA:
          return THETA2;
        case RADIUS:
          return RADIUS2;
      }
      return void 0;
    }
    function getSizeChannel(channel) {
      switch (channel) {
        case X:
        case X2:
          return "width";
        case Y:
        case Y2:
          return "height";
      }
      return void 0;
    }
    function getOffsetChannel(channel) {
      switch (channel) {
        case X:
          return "xOffset";
        case Y:
          return "yOffset";
        case X2:
          return "x2Offset";
        case Y2:
          return "y2Offset";
        case THETA:
          return "thetaOffset";
        case RADIUS:
          return "radiusOffset";
        case THETA2:
          return "theta2Offset";
        case RADIUS2:
          return "radius2Offset";
      }
      return void 0;
    }
    function getOffsetScaleChannel(channel) {
      switch (channel) {
        case X:
          return "xOffset";
        case Y:
          return "yOffset";
      }
      return void 0;
    }
    function getMainChannelFromOffsetChannel(channel) {
      switch (channel) {
        case "xOffset":
          return "x";
        case "yOffset":
          return "y";
      }
    }
    const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);
    const {
      x: _x,
      y: _y,
      // x2 and y2 share the same scale as x and y
      x2: _x2,
      y2: _y2,
      //
      xOffset: _xo,
      yOffset: _yo,
      latitude: _latitude,
      longitude: _longitude,
      latitude2: _latitude2,
      longitude2: _longitude2,
      theta: _theta,
      theta2: _theta2,
      radius: _radius,
      radius2: _radius2,
      // The rest of unit channels then have scale
      ...NONPOSITION_CHANNEL_INDEX
    } = UNIT_CHANNEL_INDEX;
    const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);
    const POSITION_SCALE_CHANNEL_INDEX = {
      x: 1,
      y: 1
    };
    const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);
    function isXorY(channel) {
      return channel in POSITION_SCALE_CHANNEL_INDEX;
    }
    const POLAR_POSITION_SCALE_CHANNEL_INDEX = {
      theta: 1,
      radius: 1
    };
    const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);
    function getPositionScaleChannel(sizeType) {
      return sizeType === "width" ? X : Y;
    }
    const OFFSET_SCALE_CHANNEL_INDEX = { xOffset: 1, yOffset: 1 };
    function isXorYOffset(channel) {
      return channel in OFFSET_SCALE_CHANNEL_INDEX;
    }
    const {
      // x2 and y2 share the same scale as x and y
      // text and tooltip have format instead of scale,
      // href has neither format, nor scale
      text: _t,
      tooltip: _tt,
      href: _hr,
      url: _u,
      description: _al,
      // detail and order have no scale
      detail: _dd,
      key: _k,
      order: _oo,
      ...NONPOSITION_SCALE_CHANNEL_INDEX
    } = NONPOSITION_CHANNEL_INDEX;
    const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);
    function isNonPositionScaleChannel(channel) {
      return !!NONPOSITION_CHANNEL_INDEX[channel];
    }
    function supportLegend(channel) {
      switch (channel) {
        case COLOR:
        case FILL:
        case STROKE:
        case SIZE:
        case SHAPE:
        case OPACITY:
        case STROKEWIDTH:
        case STROKEDASH:
          return true;
        case FILLOPACITY:
        case STROKEOPACITY:
        case ANGLE:
          return false;
      }
    }
    const SCALE_CHANNEL_INDEX = {
      ...POSITION_SCALE_CHANNEL_INDEX,
      ...POLAR_POSITION_SCALE_CHANNEL_INDEX,
      ...OFFSET_SCALE_CHANNEL_INDEX,
      ...NONPOSITION_SCALE_CHANNEL_INDEX
    };
    const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);
    function isScaleChannel(channel) {
      return !!SCALE_CHANNEL_INDEX[channel];
    }
    function supportMark(channel, mark) {
      return getSupportedMark(channel)[mark];
    }
    const ALL_MARKS = {
      // all marks
      arc: "always",
      area: "always",
      bar: "always",
      circle: "always",
      geoshape: "always",
      image: "always",
      line: "always",
      rule: "always",
      point: "always",
      rect: "always",
      square: "always",
      trail: "always",
      text: "always",
      tick: "always"
    };
    const { geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE } = ALL_MARKS;
    function getSupportedMark(channel) {
      switch (channel) {
        case COLOR:
        case FILL:
        case STROKE:
        case DESCRIPTION:
        case DETAIL:
        case KEY:
        case TOOLTIP:
        case HREF:
        case ORDER:
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
        case STROKEWIDTH:
        case FACET:
        case ROW:
        case COLUMN:
          return ALL_MARKS;
        case X:
        case Y:
        case XOFFSET:
        case YOFFSET:
        case LATITUDE:
        case LONGITUDE:
          return ALL_MARKS_EXCEPT_GEOSHAPE;
        case X2:
        case Y2:
        case LATITUDE2:
        case LONGITUDE2:
          return {
            area: "always",
            bar: "always",
            image: "always",
            rect: "always",
            rule: "always",
            circle: "binned",
            point: "binned",
            square: "binned",
            tick: "binned",
            line: "binned",
            trail: "binned"
          };
        case SIZE:
          return {
            point: "always",
            tick: "always",
            rule: "always",
            circle: "always",
            square: "always",
            bar: "always",
            text: "always",
            line: "always",
            trail: "always"
          };
        case STROKEDASH:
          return {
            line: "always",
            point: "always",
            tick: "always",
            rule: "always",
            circle: "always",
            square: "always",
            bar: "always",
            geoshape: "always"
          };
        case SHAPE:
          return { point: "always", geoshape: "always" };
        case TEXT$1:
          return { text: "always" };
        case ANGLE:
          return { point: "always", square: "always", text: "always" };
        case URL$1:
          return { image: "always" };
        case THETA:
          return { text: "always", arc: "always" };
        case RADIUS:
          return { text: "always", arc: "always" };
        case THETA2:
        case RADIUS2:
          return { arc: "always" };
      }
    }
    function rangeType(channel) {
      switch (channel) {
        case X:
        case Y:
        case THETA:
        case RADIUS:
        case XOFFSET:
        case YOFFSET:
        case SIZE:
        case ANGLE:
        case STROKEWIDTH:
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
        case X2:
        case Y2:
        case THETA2:
        case RADIUS2:
          return void 0;
        case FACET:
        case ROW:
        case COLUMN:
        case SHAPE:
        case STROKEDASH:
        case TEXT$1:
        case TOOLTIP:
        case HREF:
        case URL$1:
        case DESCRIPTION:
          return "discrete";
        case COLOR:
        case FILL:
        case STROKE:
          return "flexible";
        case LATITUDE:
        case LONGITUDE:
        case LATITUDE2:
        case LONGITUDE2:
        case DETAIL:
        case KEY:
        case ORDER:
          return void 0;
      }
    }
    const AGGREGATE_OP_INDEX = {
      argmax: 1,
      argmin: 1,
      average: 1,
      count: 1,
      distinct: 1,
      product: 1,
      max: 1,
      mean: 1,
      median: 1,
      min: 1,
      missing: 1,
      q1: 1,
      q3: 1,
      ci0: 1,
      ci1: 1,
      stderr: 1,
      stdev: 1,
      stdevp: 1,
      sum: 1,
      valid: 1,
      values: 1,
      variance: 1,
      variancep: 1
    };
    const MULTIDOMAIN_SORT_OP_INDEX = {
      count: 1,
      min: 1,
      max: 1
    };
    function isArgminDef(a2) {
      return !!a2 && !!a2["argmin"];
    }
    function isArgmaxDef(a2) {
      return !!a2 && !!a2["argmax"];
    }
    function isAggregateOp(a2) {
      return isString(a2) && !!AGGREGATE_OP_INDEX[a2];
    }
    const COUNTING_OPS = /* @__PURE__ */ new Set([
      "count",
      "valid",
      "missing",
      "distinct"
    ]);
    function isCountingAggregateOp(aggregate) {
      return isString(aggregate) && COUNTING_OPS.has(aggregate);
    }
    function isMinMaxOp(aggregate) {
      return isString(aggregate) && contains(["min", "max"], aggregate);
    }
    const SUM_OPS = /* @__PURE__ */ new Set([
      "count",
      "sum",
      "distinct",
      "valid",
      "missing"
    ]);
    const SHARED_DOMAIN_OPS = /* @__PURE__ */ new Set([
      "mean",
      "average",
      "median",
      "q1",
      "q3",
      "min",
      "max"
    ]);
    function binToString(bin2) {
      if (isBoolean$2(bin2)) {
        bin2 = normalizeBin(bin2, void 0);
      }
      return "bin" + keys(bin2).map((p) => isParameterExtent(bin2[p]) ? varName(`_${p}_${entries$1(bin2[p])}`) : varName(`_${p}_${bin2[p]}`)).join("");
    }
    function isBinning(bin2) {
      return bin2 === true || isBinParams(bin2) && !bin2.binned;
    }
    function isBinned(bin2) {
      return bin2 === "binned" || isBinParams(bin2) && bin2.binned === true;
    }
    function isBinParams(bin2) {
      return isObject(bin2);
    }
    function isParameterExtent(extent2) {
      return extent2 == null ? void 0 : extent2["param"];
    }
    function autoMaxBins(channel) {
      switch (channel) {
        case ROW:
        case COLUMN:
        case SIZE:
        case COLOR:
        case FILL:
        case STROKE:
        case STROKEWIDTH:
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
        case SHAPE:
          return 6;
        case STROKEDASH:
          return 4;
        default:
          return 10;
      }
    }
    function isExprRef(o) {
      return !!(o == null ? void 0 : o.expr);
    }
    function replaceExprRef(index2) {
      const props = keys(index2 || {});
      const newIndex = {};
      for (const prop of props) {
        newIndex[prop] = signalRefOrValue(index2[prop]);
      }
      return newIndex;
    }
    function extractTitleConfig(titleConfig) {
      const {
        // These are non-mark title config that need to be hardcoded
        anchor: anchor2,
        frame: frame2,
        offset: offset2,
        orient: orient2,
        angle: angle2,
        limit,
        // color needs to be redirect to fill
        color: color2,
        // subtitle properties
        subtitleColor,
        subtitleFont,
        subtitleFontSize,
        subtitleFontStyle,
        subtitleFontWeight,
        subtitleLineHeight,
        subtitlePadding,
        // The rest are mark config.
        ...rest
      } = titleConfig;
      const titleMarkConfig = {
        ...rest,
        ...color2 ? { fill: color2 } : {}
      };
      const nonMarkTitleProperties = {
        ...anchor2 ? { anchor: anchor2 } : {},
        ...frame2 ? { frame: frame2 } : {},
        ...offset2 ? { offset: offset2 } : {},
        ...orient2 ? { orient: orient2 } : {},
        ...angle2 !== void 0 ? { angle: angle2 } : {},
        ...limit !== void 0 ? { limit } : {}
      };
      const subtitle = {
        ...subtitleColor ? { subtitleColor } : {},
        ...subtitleFont ? { subtitleFont } : {},
        ...subtitleFontSize ? { subtitleFontSize } : {},
        ...subtitleFontStyle ? { subtitleFontStyle } : {},
        ...subtitleFontWeight ? { subtitleFontWeight } : {},
        ...subtitleLineHeight ? { subtitleLineHeight } : {},
        ...subtitlePadding ? { subtitlePadding } : {}
      };
      const subtitleMarkConfig = pick(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
      return { titleMarkConfig, subtitleMarkConfig, nonMarkTitleProperties, subtitle };
    }
    function isText(v) {
      return isString(v) || isArray(v) && isString(v[0]);
    }
    function isSignalRef(o) {
      return !!(o == null ? void 0 : o.signal);
    }
    function isVgRangeStep(range2) {
      return !!range2["step"];
    }
    function isDataRefUnionedDomain(domain2) {
      if (!isArray(domain2)) {
        return "fields" in domain2 && !("data" in domain2);
      }
      return false;
    }
    function isFieldRefUnionDomain(domain2) {
      if (!isArray(domain2)) {
        return "fields" in domain2 && "data" in domain2;
      }
      return false;
    }
    function isDataRefDomain(domain2) {
      if (!isArray(domain2)) {
        return "field" in domain2 && "data" in domain2;
      }
      return false;
    }
    const VG_MARK_CONFIG_INDEX = {
      aria: 1,
      description: 1,
      ariaRole: 1,
      ariaRoleDescription: 1,
      blend: 1,
      opacity: 1,
      fill: 1,
      fillOpacity: 1,
      stroke: 1,
      strokeCap: 1,
      strokeWidth: 1,
      strokeOpacity: 1,
      strokeDash: 1,
      strokeDashOffset: 1,
      strokeJoin: 1,
      strokeOffset: 1,
      strokeMiterLimit: 1,
      startAngle: 1,
      endAngle: 1,
      padAngle: 1,
      innerRadius: 1,
      outerRadius: 1,
      size: 1,
      shape: 1,
      interpolate: 1,
      tension: 1,
      orient: 1,
      align: 1,
      baseline: 1,
      text: 1,
      dir: 1,
      dx: 1,
      dy: 1,
      ellipsis: 1,
      limit: 1,
      radius: 1,
      theta: 1,
      angle: 1,
      font: 1,
      fontSize: 1,
      fontWeight: 1,
      fontStyle: 1,
      lineBreak: 1,
      lineHeight: 1,
      cursor: 1,
      href: 1,
      tooltip: 1,
      cornerRadius: 1,
      cornerRadiusTopLeft: 1,
      cornerRadiusTopRight: 1,
      cornerRadiusBottomLeft: 1,
      cornerRadiusBottomRight: 1,
      aspect: 1,
      width: 1,
      height: 1,
      url: 1,
      smooth: 1
      // commented below are vg channel that do not have mark config.
      // x: 1,
      // y: 1,
      // x2: 1,
      // y2: 1,
      // xc'|'yc'
      // clip: 1,
      // path: 1,
      // url: 1,
    };
    const VG_MARK_CONFIGS = keys(VG_MARK_CONFIG_INDEX);
    const VG_MARK_INDEX = {
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };
    const VG_CORNERRADIUS_CHANNELS = [
      "cornerRadius",
      "cornerRadiusTopLeft",
      "cornerRadiusTopRight",
      "cornerRadiusBottomLeft",
      "cornerRadiusBottomRight"
    ];
    function signalOrValueRefWithCondition(val) {
      const condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
      return {
        ...signalRefOrValue(val),
        condition
      };
    }
    function signalRefOrValue(value2) {
      if (isExprRef(value2)) {
        const { expr: expr2, ...rest } = value2;
        return { signal: expr2, ...rest };
      }
      return value2;
    }
    function conditionalSignalRefOrValue(value2) {
      if (isExprRef(value2)) {
        const { expr: expr2, ...rest } = value2;
        return { signal: expr2, ...rest };
      }
      return value2;
    }
    function signalOrValueRef(value2) {
      if (isExprRef(value2)) {
        const { expr: expr2, ...rest } = value2;
        return { signal: expr2, ...rest };
      }
      if (isSignalRef(value2)) {
        return value2;
      }
      return value2 !== void 0 ? { value: value2 } : void 0;
    }
    function exprFromSignalRefOrValue(ref2) {
      if (isSignalRef(ref2)) {
        return ref2.signal;
      }
      return $(ref2);
    }
    function exprFromValueRefOrSignalRef(ref2) {
      if (isSignalRef(ref2)) {
        return ref2.signal;
      }
      return $(ref2.value);
    }
    function signalOrStringValue(v) {
      if (isSignalRef(v)) {
        return v.signal;
      }
      return v == null ? null : $(v);
    }
    function applyMarkConfig(e3, model, propsList) {
      for (const property2 of propsList) {
        const value2 = getMarkConfig(property2, model.markDef, model.config);
        if (value2 !== void 0) {
          e3[property2] = signalOrValueRef(value2);
        }
      }
      return e3;
    }
    function getStyles(mark) {
      return [].concat(mark.type, mark.style ?? []);
    }
    function getMarkPropOrConfig(channel, mark, config, opt = {}) {
      const { vgChannel, ignoreVgConfig } = opt;
      if (vgChannel && mark[vgChannel] !== void 0) {
        return mark[vgChannel];
      } else if (mark[channel] !== void 0) {
        return mark[channel];
      } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
        return void 0;
      }
      return getMarkConfig(channel, mark, config, opt);
    }
    function getMarkConfig(channel, mark, config, { vgChannel } = {}) {
      return getFirstDefined(
        // style config has highest precedence
        vgChannel ? getMarkStyleConfig(channel, mark, config.style) : void 0,
        getMarkStyleConfig(channel, mark, config.style),
        // then mark-specific config
        vgChannel ? config[mark.type][vgChannel] : void 0,
        config[mark.type][channel],
        // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
        // If there is vgChannel, skip vl channel.
        // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
        vgChannel ? config.mark[vgChannel] : config.mark[channel]
        // Need to cast for the same reason as above
      );
    }
    function getMarkStyleConfig(prop, mark, styleConfigIndex) {
      return getStyleConfig(prop, getStyles(mark), styleConfigIndex);
    }
    function getStyleConfig(p, styles, styleConfigIndex) {
      styles = array$2(styles);
      let value2;
      for (const style2 of styles) {
        const styleConfig = styleConfigIndex[style2];
        if (styleConfig && styleConfig[p] !== void 0) {
          value2 = styleConfig[p];
        }
      }
      return value2;
    }
    function sortParams(orderDef, fieldRefOption) {
      return array$2(orderDef).reduce((s, orderChannelDef) => {
        s.field.push(vgField(orderChannelDef, fieldRefOption));
        s.order.push(orderChannelDef.sort ?? "ascending");
        return s;
      }, { field: [], order: [] });
    }
    function mergeTitleFieldDefs(f1, f2) {
      const merged = [...f1];
      f2.forEach((fdToMerge) => {
        for (const fieldDef1 of merged) {
          if (deepEqual(fieldDef1, fdToMerge)) {
            return;
          }
        }
        merged.push(fdToMerge);
      });
      return merged;
    }
    function mergeTitle(title1, title2) {
      if (deepEqual(title1, title2) || !title2) {
        return title1;
      } else if (!title1) {
        return title2;
      } else {
        return [...array$2(title1), ...array$2(title2)].join(", ");
      }
    }
    function mergeTitleComponent(v1, v2) {
      const v1Val = v1.value;
      const v2Val = v2.value;
      if (v1Val == null || v2Val === null) {
        return {
          explicit: v1.explicit,
          value: null
        };
      } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
        return {
          explicit: v1.explicit,
          value: mergeTitle(v1Val, v2Val)
        };
      } else if (isText(v1Val) || isSignalRef(v1Val)) {
        return {
          explicit: v1.explicit,
          value: v1Val
        };
      } else if (isText(v2Val) || isSignalRef(v2Val)) {
        return {
          explicit: v1.explicit,
          value: v2Val
        };
      } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
        return {
          explicit: v1.explicit,
          value: mergeTitleFieldDefs(v1Val, v2Val)
        };
      }
      throw new Error("It should never reach here");
    }
    function invalidSpec(spec) {
      return `Invalid specification ${stringify$1(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
    }
    const FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
    function containerSizeNonSingle(name2) {
      const uName = name2 == "width" ? "Width" : "Height";
      return `${uName} "container" only works for single views and layered views.`;
    }
    function containerSizeNotCompatibleWithAutosize(name2) {
      const uName = name2 == "width" ? "Width" : "Height";
      const fitDirection = name2 == "width" ? "x" : "y";
      return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
    }
    function droppingFit(channel) {
      return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
    }
    function unknownField(channel) {
      return `Unknown field for ${channel}. Cannot calculate view size.`;
    }
    function cannotProjectOnChannelWithoutField(channel) {
      return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
    }
    function cannotProjectAggregate(channel, aggregate) {
      return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
    }
    function nearestNotSupportForContinuous(mark) {
      return `The "nearest" transform is not supported for ${mark} marks.`;
    }
    function selectionNotSupported(mark) {
      return `Selection not supported for ${mark} yet.`;
    }
    function selectionNotFound(name2) {
      return `Cannot find a selection named "${name2}".`;
    }
    const SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
    const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = "Legend bindings are only supported for selections over an individual field or encoding channel.";
    function cannotLookupVariableParameter(name2) {
      return `Lookups can only be performed on selection parameters. "${name2}" is a variable parameter.`;
    }
    function noSameUnitLookup(name2) {
      return `Cannot define and lookup the "${name2}" selection in the same view. Try moving the lookup into a second, layered view?`;
    }
    const NEEDS_SAME_SELECTION = "The same selection must be used to override scale domains in a layered view.";
    const INTERVAL_INITIALIZED_WITH_POS = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
    function noSuchRepeatedValue(field2) {
      return `Unknown repeated value "${field2}".`;
    }
    function columnsNotSupportByRowCol(type2) {
      return `The "columns" property cannot be used when "${type2}" has nested row/column.`;
    }
    const CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
    function unrecognizedParse(p) {
      return `Unrecognized parse "${p}".`;
    }
    function differentParse(field2, local, ancestor) {
      return `An ancestor parsed field "${field2}" as ${ancestor} but a child wants to parse the field as ${local}.`;
    }
    const ADD_SAME_CHILD_TWICE = "Attempt to add the same child twice.";
    function invalidTransformIgnored(transform2) {
      return `Ignoring an invalid transform: ${stringify$1(transform2)}.`;
    }
    const NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
    function customFormatTypeNotAllowed(channel) {
      return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
    }
    function projectionOverridden(opt) {
      const { parentProjection, projection: projection2 } = opt;
      return `Layer's shared projection ${stringify$1(parentProjection)} is overridden by a child projection ${stringify$1(projection2)}.`;
    }
    const REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
    function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {
      return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;
    }
    function primitiveChannelDef(channel, type2, value2) {
      return `Channel ${channel} is a ${type2}. Converted to {value: ${stringify$1(value2)}}.`;
    }
    function invalidFieldType(type2) {
      return `Invalid field type "${type2}".`;
    }
    function invalidFieldTypeForCountAggregate(type2, aggregate) {
      return `Invalid field type "${type2}" for aggregate: "${aggregate}", using "quantitative" instead.`;
    }
    function invalidAggregate(aggregate) {
      return `Invalid aggregation operator "${aggregate}".`;
    }
    function droppingColor(type2, opt) {
      const { fill: fill2, stroke: stroke2 } = opt;
      return `Dropping color ${type2} as the plot also has ${fill2 && stroke2 ? "fill and stroke" : fill2 ? "fill" : "stroke"}.`;
    }
    function relativeBandSizeNotSupported(sizeChannel) {
      return `Position range does not support relative band size for ${sizeChannel}.`;
    }
    function emptyFieldDef(fieldDef, channel) {
      return `Dropping ${stringify$1(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
    }
    const LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
    function incompatibleChannel(channel, markOrFacet, when) {
      return `${channel} dropped as it is incompatible with "${markOrFacet}"${when ? ` when ${when}` : ""}.`;
    }
    function invalidEncodingChannel(channel) {
      return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
    }
    function channelShouldBeDiscrete(channel) {
      return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
    }
    function channelShouldBeDiscreteOrDiscretizing(channel) {
      return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
    }
    function facetChannelDropped(channels) {
      return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
    }
    function discreteChannelCannotEncode(channel, type2) {
      return `Using discrete channel "${channel}" to encode "${type2}" field can be misleading as it does not encode ${type2 === "ordinal" ? "order" : "magnitude"}.`;
    }
    function rangeMarkAlignmentCannotBeExpression(align2) {
      return `The ${align2} for range marks cannot be an expression`;
    }
    function lineWithRange(hasX2, hasY2) {
      const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
      return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
    }
    function orientOverridden(original, actual) {
      return `Specified orient "${original}" overridden with "${actual}".`;
    }
    function cannotUseScalePropertyWithNonColor(prop) {
      return `Cannot use the scale property "${prop}" with non-color channel.`;
    }
    function cannotUseRelativeBandSizeWithNonBandScale(scaleType2) {
      return `Cannot use the relative band size with ${scaleType2} scale.`;
    }
    function unaggregateDomainHasNoEffectForRawField(fieldDef) {
      return `Using unaggregated domain with raw field has no effect (${stringify$1(fieldDef)}).`;
    }
    function unaggregateDomainWithNonSharedDomainOp(aggregate) {
      return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
    }
    function unaggregatedDomainWithLogScale(fieldDef) {
      return `Unaggregated domain is currently unsupported for log scale (${stringify$1(fieldDef)}).`;
    }
    function cannotApplySizeToNonOrientedMark(mark) {
      return `Cannot apply size to non-oriented mark "${mark}".`;
    }
    function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
      return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
    }
    function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
      return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
    }
    function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
      return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
    }
    function stepDropped(channel) {
      return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
    }
    function mergeConflictingProperty(property2, propertyOf, v1, v2) {
      return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify$1(v1)} and ${stringify$1(v2)}). Using ${stringify$1(v1)}.`;
    }
    function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
      return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify$1(v1)} and ${stringify$1(v2)}). Using the union of the two domains.`;
    }
    function independentScaleMeansIndependentGuide(channel) {
      return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
    }
    function domainSortDropped(sort2) {
      return `Dropping sort property ${stringify$1(sort2)} as unioned domains only support boolean or op "count", "min", and "max".`;
    }
    const MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
    const FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
    const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
    const FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
    function cannotStackRangedMark(channel) {
      return `Cannot stack "${channel}" if there is already "${channel}2".`;
    }
    function cannotStackNonLinearScale(scaleType2) {
      return `Cannot stack non-linear scale (${scaleType2}).`;
    }
    function stackNonSummativeAggregate(aggregate) {
      return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
    }
    function invalidTimeUnit(unitName2, value2) {
      return `Invalid ${unitName2}: ${stringify$1(value2)}.`;
    }
    function droppedDay(d) {
      return `Dropping day from datetime ${stringify$1(d)} as day cannot be combined with other units.`;
    }
    function errorBarCenterAndExtentAreNotNeeded(center2, extent2) {
      return `${extent2 ? "extent " : ""}${extent2 && center2 ? "and " : ""}${center2 ? "center " : ""}${extent2 && center2 ? "are " : "is "}not needed when data are aggregated.`;
    }
    function errorBarCenterIsUsedWithWrongExtent(center2, extent2, mark) {
      return `${center2} is not usually used with ${extent2} for ${mark}.`;
    }
    function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
      return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
    }
    function errorBand1DNotSupport(property2) {
      return `1D error band does not support ${property2}.`;
    }
    function channelRequiredForBinned(channel) {
      return `Channel ${channel} is required for "binned" bin.`;
    }
    function channelShouldNotBeUsedForBinned(channel) {
      return `Channel ${channel} should not be used with "binned" bin.`;
    }
    function domainRequiredForThresholdScale(channel) {
      return `Domain for ${channel} is required for threshold scale.`;
    }
    (function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    });
    (function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    });
    const main$1 = logger(Warn);
    let current = main$1;
    function set(newLogger) {
      current = newLogger;
      return current;
    }
    function reset() {
      current = main$1;
      return current;
    }
    function warn(...args) {
      current.warn(...args);
    }
    function debug$2(...args) {
      current.debug(...args);
    }
    function isDateTime(o) {
      if (o && isObject(o)) {
        for (const part of TIMEUNIT_PARTS) {
          if (part in o) {
            return true;
          }
        }
      }
      return false;
    }
    const MONTHS = [
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"
    ];
    const SHORT_MONTHS = MONTHS.map((m2) => m2.substr(0, 3));
    const DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    const SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
    function normalizeQuarter(q) {
      if (isNumeric(q)) {
        q = +q;
      }
      if (isNumber$1(q)) {
        if (q > 4) {
          warn(invalidTimeUnit("quarter", q));
        }
        return q - 1;
      } else {
        throw new Error(invalidTimeUnit("quarter", q));
      }
    }
    function normalizeMonth(m2) {
      if (isNumeric(m2)) {
        m2 = +m2;
      }
      if (isNumber$1(m2)) {
        return m2 - 1;
      } else {
        const lowerM = m2.toLowerCase();
        const monthIndex = MONTHS.indexOf(lowerM);
        if (monthIndex !== -1) {
          return monthIndex;
        }
        const shortM = lowerM.substr(0, 3);
        const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
        if (shortMonthIndex !== -1) {
          return shortMonthIndex;
        }
        throw new Error(invalidTimeUnit("month", m2));
      }
    }
    function normalizeDay(d) {
      if (isNumeric(d)) {
        d = +d;
      }
      if (isNumber$1(d)) {
        return d % 7;
      } else {
        const lowerD = d.toLowerCase();
        const dayIndex = DAYS.indexOf(lowerD);
        if (dayIndex !== -1) {
          return dayIndex;
        }
        const shortD = lowerD.substr(0, 3);
        const shortDayIndex = SHORT_DAYS.indexOf(shortD);
        if (shortDayIndex !== -1) {
          return shortDayIndex;
        }
        throw new Error(invalidTimeUnit("day", d));
      }
    }
    function dateTimeParts(d, normalize2) {
      const parts = [];
      if (normalize2 && d.day !== void 0) {
        if (keys(d).length > 1) {
          warn(droppedDay(d));
          d = duplicate(d);
          delete d.day;
        }
      }
      if (d.year !== void 0) {
        parts.push(d.year);
      } else {
        parts.push(2012);
      }
      if (d.month !== void 0) {
        const month = normalize2 ? normalizeMonth(d.month) : d.month;
        parts.push(month);
      } else if (d.quarter !== void 0) {
        const quarter2 = normalize2 ? normalizeQuarter(d.quarter) : d.quarter;
        parts.push(isNumber$1(quarter2) ? quarter2 * 3 : `${quarter2}*3`);
      } else {
        parts.push(0);
      }
      if (d.date !== void 0) {
        parts.push(d.date);
      } else if (d.day !== void 0) {
        const day = normalize2 ? normalizeDay(d.day) : d.day;
        parts.push(isNumber$1(day) ? day + 1 : `${day}+1`);
      } else {
        parts.push(1);
      }
      for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
        const unit2 = d[timeUnit];
        parts.push(typeof unit2 === "undefined" ? 0 : unit2);
      }
      return parts;
    }
    function dateTimeToExpr(d) {
      const parts = dateTimeParts(d, true);
      const string = parts.join(", ");
      if (d.utc) {
        return `utc(${string})`;
      } else {
        return `datetime(${string})`;
      }
    }
    function dateTimeExprToExpr(d) {
      const parts = dateTimeParts(d, false);
      const string = parts.join(", ");
      if (d.utc) {
        return `utc(${string})`;
      } else {
        return `datetime(${string})`;
      }
    }
    function dateTimeToTimestamp(d) {
      const parts = dateTimeParts(d, true);
      if (d.utc) {
        return +new Date(Date.UTC(...parts));
      } else {
        return +new Date(...parts);
      }
    }
    const LOCAL_SINGLE_TIMEUNIT_INDEX = {
      year: 1,
      quarter: 1,
      month: 1,
      week: 1,
      day: 1,
      dayofyear: 1,
      date: 1,
      hours: 1,
      minutes: 1,
      seconds: 1,
      milliseconds: 1
    };
    const TIMEUNIT_PARTS = keys(LOCAL_SINGLE_TIMEUNIT_INDEX);
    function isLocalSingleTimeUnit(timeUnit) {
      return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
    }
    function isBinnedTimeUnit(timeUnit) {
      if (isObject(timeUnit)) {
        return timeUnit.binned;
      }
      return isBinnedTimeUnitString(timeUnit);
    }
    function isBinnedTimeUnitString(timeUnit) {
      return timeUnit && timeUnit.startsWith("binned");
    }
    function isUTCTimeUnit(t4) {
      return t4.startsWith("utc");
    }
    function getLocalTimeUnitFromUTCTimeUnit(t4) {
      return t4.substring(3);
    }
    const VEGALITE_TIMEFORMAT = {
      "year-month": "%b %Y ",
      "year-month-date": "%b %d, %Y "
    };
    function getTimeUnitParts(timeUnit) {
      return TIMEUNIT_PARTS.filter((part) => containsTimeUnit(timeUnit, part));
    }
    function getSmallestTimeUnitPart(timeUnit) {
      const parts = getTimeUnitParts(timeUnit);
      return parts[parts.length - 1];
    }
    function containsTimeUnit(fullTimeUnit, timeUnit) {
      const index2 = fullTimeUnit.indexOf(timeUnit);
      if (index2 < 0) {
        return false;
      }
      if (index2 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index2 - 1) === "i") {
        return false;
      }
      if (fullTimeUnit.length > index2 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index2 + 3) === "o") {
        return false;
      }
      if (index2 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index2 - 1) === "f") {
        return false;
      }
      return true;
    }
    function fieldExpr(fullTimeUnit, field2, { end } = { end: false }) {
      const fieldRef2 = accessPathWithDatum(field2);
      const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
      function func2(timeUnit) {
        if (timeUnit === "quarter") {
          return `(${utc}quarter(${fieldRef2})-1)`;
        } else {
          return `${utc}${timeUnit}(${fieldRef2})`;
        }
      }
      let lastTimeUnit;
      const dateExpr = {};
      for (const part of TIMEUNIT_PARTS) {
        if (containsTimeUnit(fullTimeUnit, part)) {
          dateExpr[part] = func2(part);
          lastTimeUnit = part;
        }
      }
      if (end) {
        dateExpr[lastTimeUnit] += "+1";
      }
      return dateTimeExprToExpr(dateExpr);
    }
    function timeUnitSpecifierExpression(timeUnit) {
      if (!timeUnit) {
        return void 0;
      }
      const timeUnitParts = getTimeUnitParts(timeUnit);
      return `timeUnitSpecifier(${stringify$1(timeUnitParts)}, ${stringify$1(VEGALITE_TIMEFORMAT)})`;
    }
    function formatExpression(timeUnit, field2, isUTCScale) {
      if (!timeUnit) {
        return void 0;
      }
      const expr2 = timeUnitSpecifierExpression(timeUnit);
      const utc = isUTCScale || isUTCTimeUnit(timeUnit);
      return `${utc ? "utc" : "time"}Format(${field2}, ${expr2})`;
    }
    function normalizeTimeUnit(timeUnit) {
      if (!timeUnit) {
        return void 0;
      }
      let params2;
      if (isString(timeUnit)) {
        if (isBinnedTimeUnitString(timeUnit)) {
          params2 = {
            unit: timeUnit.substring(6),
            binned: true
          };
        } else {
          params2 = {
            unit: timeUnit
          };
        }
      } else if (isObject(timeUnit)) {
        params2 = {
          ...timeUnit,
          ...timeUnit.unit ? { unit: timeUnit.unit } : {}
        };
      }
      if (isUTCTimeUnit(params2.unit)) {
        params2.utc = true;
        params2.unit = getLocalTimeUnitFromUTCTimeUnit(params2.unit);
      }
      return params2;
    }
    function timeUnitToString(tu) {
      const { utc, ...rest } = normalizeTimeUnit(tu);
      if (rest.unit) {
        return (utc ? "utc" : "") + keys(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
      } else {
        return (utc ? "utc" : "") + "timeunit" + keys(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
      }
    }
    function durationExpr(timeUnit, wrap2 = (x2) => x2) {
      const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
      const smallestUnitPart = getSmallestTimeUnitPart(normalizedTimeUnit.unit);
      if (smallestUnitPart && smallestUnitPart !== "day") {
        const startDate = {
          year: 2001,
          month: 1,
          date: 1,
          hours: 0,
          minutes: 0,
          seconds: 0,
          milliseconds: 0
        };
        const { step, part } = getDateTimePartAndStep(smallestUnitPart, normalizedTimeUnit.step);
        const endDate = {
          ...startDate,
          [part]: +startDate[part] + step
        };
        return `${wrap2(dateTimeToExpr(endDate))} - ${wrap2(dateTimeToExpr(startDate))}`;
      }
      return void 0;
    }
    const DATE_PARTS = {
      year: 1,
      month: 1,
      date: 1,
      hours: 1,
      minutes: 1,
      seconds: 1,
      milliseconds: 1
    };
    function isDatePart(timeUnit) {
      return !!DATE_PARTS[timeUnit];
    }
    function getDateTimePartAndStep(timeUnit, step = 1) {
      if (isDatePart(timeUnit)) {
        return { part: timeUnit, step };
      }
      switch (timeUnit) {
        case "day":
        case "dayofyear":
          return { part: "date", step };
        case "quarter":
          return { part: "month", step: step * 3 };
        case "week":
          return { part: "date", step: step * 7 };
      }
    }
    function isSelectionPredicate(predicate) {
      return predicate == null ? void 0 : predicate["param"];
    }
    function isFieldEqualPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.equal !== void 0;
    }
    function isFieldLTPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.lt !== void 0;
    }
    function isFieldLTEPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.lte !== void 0;
    }
    function isFieldGTPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.gt !== void 0;
    }
    function isFieldGTEPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.gte !== void 0;
    }
    function isFieldRangePredicate(predicate) {
      if (predicate == null ? void 0 : predicate.field) {
        if (isArray(predicate.range) && predicate.range.length === 2) {
          return true;
        } else if (isSignalRef(predicate.range)) {
          return true;
        }
      }
      return false;
    }
    function isFieldOneOfPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && (isArray(predicate.oneOf) || isArray(predicate.in));
    }
    function isFieldValidPredicate(predicate) {
      return !!(predicate == null ? void 0 : predicate.field) && predicate.valid !== void 0;
    }
    function isFieldPredicate(predicate) {
      return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
    }
    function predicateValueExpr(v, timeUnit) {
      return valueExpr(v, { timeUnit, wrapTime: true });
    }
    function predicateValuesExpr(vals2, timeUnit) {
      return vals2.map((v) => predicateValueExpr(v, timeUnit));
    }
    function fieldFilterExpression(predicate, useInRange = true) {
      const { field: field2 } = predicate;
      const normalizedTimeUnit = normalizeTimeUnit(predicate.timeUnit);
      const { unit: unit2, binned } = normalizedTimeUnit || {};
      const rawFieldExpr = vgField(predicate, { expr: "datum" });
      const fieldExpr$1 = unit2 ? (
        // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
        // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
        // TODO: support utc
        `time(${!binned ? fieldExpr(unit2, field2) : rawFieldExpr})`
      ) : rawFieldExpr;
      if (isFieldEqualPredicate(predicate)) {
        return `${fieldExpr$1}===${predicateValueExpr(predicate.equal, unit2)}`;
      } else if (isFieldLTPredicate(predicate)) {
        const upper = predicate.lt;
        return `${fieldExpr$1}<${predicateValueExpr(upper, unit2)}`;
      } else if (isFieldGTPredicate(predicate)) {
        const lower2 = predicate.gt;
        return `${fieldExpr$1}>${predicateValueExpr(lower2, unit2)}`;
      } else if (isFieldLTEPredicate(predicate)) {
        const upper = predicate.lte;
        return `${fieldExpr$1}<=${predicateValueExpr(upper, unit2)}`;
      } else if (isFieldGTEPredicate(predicate)) {
        const lower2 = predicate.gte;
        return `${fieldExpr$1}>=${predicateValueExpr(lower2, unit2)}`;
      } else if (isFieldOneOfPredicate(predicate)) {
        return `indexof([${predicateValuesExpr(predicate.oneOf, unit2).join(",")}], ${fieldExpr$1}) !== -1`;
      } else if (isFieldValidPredicate(predicate)) {
        return fieldValidPredicate(fieldExpr$1, predicate.valid);
      } else if (isFieldRangePredicate(predicate)) {
        const { range: range2 } = predicate;
        const lower2 = isSignalRef(range2) ? { signal: `${range2.signal}[0]` } : range2[0];
        const upper = isSignalRef(range2) ? { signal: `${range2.signal}[1]` } : range2[1];
        if (lower2 !== null && upper !== null && useInRange) {
          return "inrange(" + fieldExpr$1 + ", [" + predicateValueExpr(lower2, unit2) + ", " + predicateValueExpr(upper, unit2) + "])";
        }
        const exprs = [];
        if (lower2 !== null) {
          exprs.push(`${fieldExpr$1} >= ${predicateValueExpr(lower2, unit2)}`);
        }
        if (upper !== null) {
          exprs.push(`${fieldExpr$1} <= ${predicateValueExpr(upper, unit2)}`);
        }
        return exprs.length > 0 ? exprs.join(" && ") : "true";
      }
      throw new Error(`Invalid field predicate: ${stringify$1(predicate)}`);
    }
    function fieldValidPredicate(fieldExpr2, valid = true) {
      if (valid) {
        return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
      } else {
        return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
      }
    }
    function normalizePredicate$1(f) {
      if (isFieldPredicate(f) && f.timeUnit) {
        return {
          ...f,
          timeUnit: normalizeTimeUnit(f.timeUnit)
        };
      }
      return f;
    }
    const Type = {
      quantitative: "quantitative",
      ordinal: "ordinal",
      temporal: "temporal",
      nominal: "nominal",
      geojson: "geojson"
    };
    function isContinuous(type2) {
      return type2 === "quantitative" || type2 === "temporal";
    }
    function isDiscrete$1(type2) {
      return type2 === "ordinal" || type2 === "nominal";
    }
    const QUANTITATIVE = Type.quantitative;
    const ORDINAL = Type.ordinal;
    const TEMPORAL = Type.temporal;
    const NOMINAL = Type.nominal;
    const GEOJSON = Type.geojson;
    function getFullName(type2) {
      if (type2) {
        type2 = type2.toLowerCase();
        switch (type2) {
          case "q":
          case QUANTITATIVE:
            return "quantitative";
          case "t":
          case TEMPORAL:
            return "temporal";
          case "o":
          case ORDINAL:
            return "ordinal";
          case "n":
          case NOMINAL:
            return "nominal";
          case GEOJSON:
            return "geojson";
        }
      }
      return void 0;
    }
    const ScaleType = {
      // Continuous - Quantitative
      LINEAR: "linear",
      LOG: "log",
      POW: "pow",
      SQRT: "sqrt",
      SYMLOG: "symlog",
      IDENTITY: "identity",
      SEQUENTIAL: "sequential",
      // Continuous - Time
      TIME: "time",
      UTC: "utc",
      // Discretizing scales
      QUANTILE: "quantile",
      QUANTIZE: "quantize",
      THRESHOLD: "threshold",
      BIN_ORDINAL: "bin-ordinal",
      // Discrete scales
      ORDINAL: "ordinal",
      POINT: "point",
      BAND: "band"
    };
    const SCALE_CATEGORY_INDEX = {
      linear: "numeric",
      log: "numeric",
      pow: "numeric",
      sqrt: "numeric",
      symlog: "numeric",
      identity: "numeric",
      sequential: "numeric",
      time: "time",
      utc: "time",
      ordinal: "ordinal",
      "bin-ordinal": "bin-ordinal",
      point: "ordinal-position",
      band: "ordinal-position",
      quantile: "discretizing",
      quantize: "discretizing",
      threshold: "discretizing"
    };
    function scaleCompatible(scaleType1, scaleType2) {
      const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
      const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
      return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
    }
    const SCALE_PRECEDENCE_INDEX = {
      // numeric
      linear: 0,
      log: 1,
      pow: 1,
      sqrt: 1,
      symlog: 1,
      identity: 1,
      sequential: 1,
      // time
      time: 0,
      utc: 0,
      // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
      point: 10,
      band: 11,
      // non grouped types
      ordinal: 0,
      "bin-ordinal": 0,
      quantile: 0,
      quantize: 0,
      threshold: 0
    };
    function scaleTypePrecedence(scaleType2) {
      return SCALE_PRECEDENCE_INDEX[scaleType2];
    }
    const QUANTITATIVE_SCALES = /* @__PURE__ */ new Set([
      "linear",
      "log",
      "pow",
      "sqrt",
      "symlog"
    ]);
    const CONTINUOUS_TO_CONTINUOUS_SCALES = /* @__PURE__ */ new Set([
      ...QUANTITATIVE_SCALES,
      "time",
      "utc"
    ]);
    function isQuantitative(type2) {
      return QUANTITATIVE_SCALES.has(type2);
    }
    const CONTINUOUS_TO_DISCRETE_SCALES = /* @__PURE__ */ new Set([
      "quantile",
      "quantize",
      "threshold"
    ]);
    const CONTINUOUS_DOMAIN_SCALES = /* @__PURE__ */ new Set([
      ...CONTINUOUS_TO_CONTINUOUS_SCALES,
      ...CONTINUOUS_TO_DISCRETE_SCALES,
      "sequential",
      "identity"
    ]);
    const DISCRETE_DOMAIN_SCALES = /* @__PURE__ */ new Set([
      "ordinal",
      "bin-ordinal",
      "point",
      "band"
    ]);
    function hasDiscreteDomain(type2) {
      return DISCRETE_DOMAIN_SCALES.has(type2);
    }
    function hasContinuousDomain(type2) {
      return CONTINUOUS_DOMAIN_SCALES.has(type2);
    }
    function isContinuousToContinuous(type2) {
      return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type2);
    }
    function isContinuousToDiscrete(type2) {
      return CONTINUOUS_TO_DISCRETE_SCALES.has(type2);
    }
    const defaultScaleConfig = {
      pointPadding: 0.5,
      barBandPaddingInner: 0.1,
      rectBandPaddingInner: 0,
      bandWithNestedOffsetPaddingInner: 0.2,
      bandWithNestedOffsetPaddingOuter: 0.2,
      minBandSize: 2,
      minFontSize: 8,
      maxFontSize: 40,
      minOpacity: 0.3,
      maxOpacity: 0.8,
      // FIXME: revise if these *can* become ratios of width/height step
      minSize: 9,
      minStrokeWidth: 1,
      maxStrokeWidth: 4,
      quantileCount: 4,
      quantizeCount: 4,
      zero: true
    };
    function isExtendedScheme(scheme2) {
      return !isString(scheme2) && !!scheme2["name"];
    }
    function isParameterDomain(domain2) {
      return domain2 == null ? void 0 : domain2["param"];
    }
    function isDomainUnionWith(domain2) {
      return domain2 == null ? void 0 : domain2["unionWith"];
    }
    function isFieldRange(range2) {
      return isObject(range2) && "field" in range2;
    }
    const SCALE_PROPERTY_INDEX = {
      type: 1,
      domain: 1,
      domainMax: 1,
      domainMin: 1,
      domainMid: 1,
      domainRaw: 1,
      align: 1,
      range: 1,
      rangeMax: 1,
      rangeMin: 1,
      scheme: 1,
      bins: 1,
      // Other properties
      reverse: 1,
      round: 1,
      // quantitative / time
      clamp: 1,
      nice: 1,
      // quantitative
      base: 1,
      exponent: 1,
      constant: 1,
      interpolate: 1,
      zero: 1,
      // band/point
      padding: 1,
      paddingInner: 1,
      paddingOuter: 1
    };
    const { type, domain: domain$1, range: range$1, rangeMax, rangeMin, scheme, ...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX } = SCALE_PROPERTY_INDEX;
    const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
    function scaleTypeSupportProperty(scaleType2, propName) {
      switch (propName) {
        case "type":
        case "domain":
        case "reverse":
        case "range":
          return true;
        case "scheme":
        case "interpolate":
          return !["point", "band", "identity"].includes(scaleType2);
        case "bins":
          return !["point", "band", "identity", "ordinal"].includes(scaleType2);
        case "round":
          return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
        case "padding":
        case "rangeMin":
        case "rangeMax":
          return isContinuousToContinuous(scaleType2) || ["point", "band"].includes(scaleType2);
        case "paddingOuter":
        case "align":
          return ["point", "band"].includes(scaleType2);
        case "paddingInner":
          return scaleType2 === "band";
        case "domainMax":
        case "domainMid":
        case "domainMin":
        case "domainRaw":
        case "clamp":
          return isContinuousToContinuous(scaleType2);
        case "nice":
          return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
        case "exponent":
          return scaleType2 === "pow";
        case "base":
          return scaleType2 === "log";
        case "constant":
          return scaleType2 === "symlog";
        case "zero":
          return hasContinuousDomain(scaleType2) && !contains([
            "log",
            "time",
            "utc",
            "threshold",
            "quantile"
            // quantile depends on distribution so zero does not matter
          ], scaleType2);
      }
    }
    function channelScalePropertyIncompatability(channel, propName) {
      switch (propName) {
        case "interpolate":
        case "scheme":
        case "domainMid":
          if (!isColorChannel(channel)) {
            return cannotUseScalePropertyWithNonColor(propName);
          }
          return void 0;
        case "align":
        case "type":
        case "bins":
        case "domain":
        case "domainMax":
        case "domainMin":
        case "domainRaw":
        case "range":
        case "base":
        case "exponent":
        case "constant":
        case "nice":
        case "padding":
        case "paddingInner":
        case "paddingOuter":
        case "rangeMax":
        case "rangeMin":
        case "reverse":
        case "round":
        case "clamp":
        case "zero":
          return void 0;
      }
    }
    function scaleTypeSupportDataType(specifiedType, fieldDefType) {
      if (contains([ORDINAL, NOMINAL], fieldDefType)) {
        return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
      } else if (fieldDefType === TEMPORAL) {
        return contains([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
      } else if (fieldDefType === QUANTITATIVE) {
        return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === void 0;
      }
      return true;
    }
    function channelSupportScaleType(channel, scaleType2, hasNestedOffsetScale = false) {
      if (!isScaleChannel(channel)) {
        return false;
      }
      switch (channel) {
        case X:
        case Y:
        case XOFFSET:
        case YOFFSET:
        case THETA:
        case RADIUS:
          if (isContinuousToContinuous(scaleType2)) {
            return true;
          } else if (scaleType2 === "band") {
            return true;
          } else if (scaleType2 === "point") {
            return !hasNestedOffsetScale;
          }
          return false;
        case SIZE:
        case STROKEWIDTH:
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
        case ANGLE:
          return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains(["band", "point", "ordinal"], scaleType2);
        case COLOR:
        case FILL:
        case STROKE:
          return scaleType2 !== "band";
        case STROKEDASH:
        case SHAPE:
          return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
      }
    }
    const Mark = {
      arc: "arc",
      area: "area",
      bar: "bar",
      image: "image",
      line: "line",
      point: "point",
      rect: "rect",
      rule: "rule",
      text: "text",
      tick: "tick",
      trail: "trail",
      circle: "circle",
      square: "square",
      geoshape: "geoshape"
    };
    const ARC = Mark.arc;
    const AREA = Mark.area;
    const BAR = Mark.bar;
    const IMAGE = Mark.image;
    const LINE = Mark.line;
    const POINT = Mark.point;
    const RECT = Mark.rect;
    const RULE = Mark.rule;
    const TEXT = Mark.text;
    const TICK = Mark.tick;
    const TRAIL = Mark.trail;
    const CIRCLE = Mark.circle;
    const SQUARE = Mark.square;
    const GEOSHAPE = Mark.geoshape;
    function isPathMark(m2) {
      return ["line", "area", "trail"].includes(m2);
    }
    function isRectBasedMark(m2) {
      return [
        "rect",
        "bar",
        "image",
        "arc"
        /* arc is rect/interval in polar coordinate */
      ].includes(m2);
    }
    const PRIMITIVE_MARKS = new Set(keys(Mark));
    function isMarkDef(mark) {
      return mark["type"];
    }
    const STROKE_CONFIG = [
      "stroke",
      "strokeWidth",
      "strokeDash",
      "strokeDashOffset",
      "strokeOpacity",
      "strokeJoin",
      "strokeMiterLimit"
    ];
    const FILL_CONFIG = ["fill", "fillOpacity"];
    const FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
    const VL_ONLY_MARK_CONFIG_INDEX = {
      color: 1,
      filled: 1,
      invalid: 1,
      order: 1,
      radius2: 1,
      theta2: 1,
      timeUnitBandSize: 1,
      timeUnitBandPosition: 1
    };
    const VL_ONLY_MARK_CONFIG_PROPERTIES = keys(VL_ONLY_MARK_CONFIG_INDEX);
    const VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
      area: ["line", "point"],
      bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
      rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
      line: ["point"],
      tick: ["bandSize", "thickness"]
    };
    const defaultMarkConfig = {
      color: "#4c78a8",
      invalid: "filter",
      timeUnitBandSize: 1
    };
    const MARK_CONFIG_INDEX = {
      mark: 1,
      arc: 1,
      area: 1,
      bar: 1,
      circle: 1,
      image: 1,
      line: 1,
      point: 1,
      rect: 1,
      rule: 1,
      square: 1,
      text: 1,
      tick: 1,
      trail: 1,
      geoshape: 1
    };
    const MARK_CONFIGS = keys(MARK_CONFIG_INDEX);
    function isRelativeBandSize(o) {
      return o && o["band"] != void 0;
    }
    const BAR_CORNER_RADIUS_INDEX = {
      horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
      vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
    };
    const DEFAULT_RECT_BAND_SIZE = 5;
    const defaultBarConfig = {
      binSpacing: 1,
      continuousBandSize: DEFAULT_RECT_BAND_SIZE,
      minBandSize: 0.25,
      timeUnitBandPosition: 0.5
    };
    const defaultRectConfig = {
      binSpacing: 0,
      continuousBandSize: DEFAULT_RECT_BAND_SIZE,
      minBandSize: 0.25,
      timeUnitBandPosition: 0.5
    };
    const defaultTickConfig = {
      thickness: 1
    };
    function getMarkType(m2) {
      return isMarkDef(m2) ? m2.type : m2;
    }
    function midPointRefWithPositionInvalidTest(params2) {
      const { channel, channelDef, markDef, scale: scale2, config } = params2;
      const ref2 = midPoint(params2);
      if (
        // Only this for field def without counting aggregate (as count wouldn't be null)
        isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale
        scale2 && isContinuousToContinuous(scale2.get("type"))
      ) {
        return wrapPositionInvalidTest({
          fieldDef: channelDef,
          channel,
          markDef,
          ref: ref2,
          config
        });
      }
      return ref2;
    }
    function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref: ref2, config }) {
      if (isPathMark(markDef.type)) {
        return ref2;
      }
      const invalid = getMarkPropOrConfig("invalid", markDef, config);
      if (invalid === null) {
        return [fieldInvalidTestValueRef(fieldDef, channel), ref2];
      }
      return ref2;
    }
    function fieldInvalidTestValueRef(fieldDef, channel) {
      const test2 = fieldInvalidPredicate(fieldDef, true);
      const mainChannel = getMainRangeChannel(channel);
      const zeroValueRef = mainChannel === "y" ? { field: { group: "height" } } : (
        // x / angle / radius can all use 0
        { value: 0 }
      );
      return { test: test2, ...zeroValueRef };
    }
    function fieldInvalidPredicate(field2, invalid = true) {
      return fieldValidPredicate(isString(field2) ? field2 : vgField(field2, { expr: "datum" }), !invalid);
    }
    function datumDefToExpr(datumDef) {
      const { datum: datum2 } = datumDef;
      if (isDateTime(datum2)) {
        return dateTimeToExpr(datum2);
      }
      return `${stringify$1(datum2)}`;
    }
    function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode2) {
      const ref2 = {};
      if (scaleName) {
        ref2.scale = scaleName;
      }
      if (isDatumDef(fieldDef)) {
        const { datum: datum2 } = fieldDef;
        if (isDateTime(datum2)) {
          ref2.signal = dateTimeToExpr(datum2);
        } else if (isSignalRef(datum2)) {
          ref2.signal = datum2.signal;
        } else if (isExprRef(datum2)) {
          ref2.signal = datum2.expr;
        } else {
          ref2.value = datum2;
        }
      } else {
        ref2.field = vgField(fieldDef, opt);
      }
      if (encode2) {
        const { offset: offset2, band: band2 } = encode2;
        if (offset2) {
          ref2.offset = offset2;
        }
        if (band2) {
          ref2.band = band2;
        }
      }
      return ref2;
    }
    function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset2, startSuffix, endSuffix = "end", bandPosition = 0.5 }) {
      const expr2 = !isSignalRef(bandPosition) && 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
      const start2 = vgField(fieldOrDatumDef, { expr: expr2, suffix: startSuffix });
      const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr: expr2 }) : vgField(fieldOrDatumDef, { suffix: endSuffix, expr: expr2 });
      const ref2 = {};
      if (bandPosition === 0 || bandPosition === 1) {
        ref2.scale = scaleName;
        const field2 = bandPosition === 0 ? start2 : end;
        ref2.field = field2;
      } else {
        const datum2 = isSignalRef(bandPosition) ? `(1-${bandPosition.signal}) * ${start2} + ${bandPosition.signal} * ${end}` : `${1 - bandPosition} * ${start2} + ${bandPosition} * ${end}`;
        ref2.signal = `scale("${scaleName}", ${datum2})`;
      }
      if (offset2) {
        ref2.offset = offset2;
      }
      return ref2;
    }
    function binSizeExpr({ scaleName, fieldDef }) {
      const start2 = vgField(fieldDef, { expr: "datum" });
      const end = vgField(fieldDef, { expr: "datum", suffix: "end" });
      return `abs(scale("${scaleName}", ${end}) - scale("${scaleName}", ${start2}))`;
    }
    function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale2, stack: stack2, offset: offset2, defaultRef, bandPosition }) {
      if (channelDef) {
        if (isFieldOrDatumDef(channelDef)) {
          const scaleType2 = scale2 == null ? void 0 : scale2.get("type");
          if (isTypedFieldDef(channelDef)) {
            bandPosition ?? (bandPosition = getBandPosition({
              fieldDef: channelDef,
              fieldDef2: channel2Def,
              markDef,
              config
            }));
            const { bin: bin2, timeUnit, type: type2 } = channelDef;
            if (isBinning(bin2) || bandPosition && timeUnit && type2 === TEMPORAL) {
              if (stack2 == null ? void 0 : stack2.impute) {
                return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset: offset2 });
              }
              if (bandPosition && !hasDiscreteDomain(scaleType2)) {
                return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset: offset2 });
              }
              return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
                offset: offset2
              });
            } else if (isBinned(bin2)) {
              if (isFieldDef(channel2Def)) {
                return interpolatedSignalRef({
                  scaleName,
                  fieldOrDatumDef: channelDef,
                  fieldOrDatumDef2: channel2Def,
                  bandPosition,
                  offset: offset2
                });
              } else {
                const channel2 = channel === X ? X2 : Y2;
                warn(channelRequiredForBinned(channel2));
              }
            }
          }
          return valueRefForFieldOrDatumDef(
            channelDef,
            scaleName,
            hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {},
            // no need for bin suffix if there is no scale
            {
              offset: offset2,
              // For band, to get mid point, need to offset by half of the band
              band: scaleType2 === "band" ? bandPosition ?? channelDef.bandPosition ?? 0.5 : void 0
            }
          );
        } else if (isValueDef(channelDef)) {
          const value2 = channelDef.value;
          const offsetMixins = offset2 ? { offset: offset2 } : {};
          return { ...widthHeightValueOrSignalRef(channel, value2), ...offsetMixins };
        }
      }
      if (isFunction(defaultRef)) {
        defaultRef = defaultRef();
      }
      if (defaultRef) {
        return {
          ...defaultRef,
          // only include offset when it is non-zero (zero = no offset)
          ...offset2 ? { offset: offset2 } : {}
        };
      }
      return defaultRef;
    }
    function widthHeightValueOrSignalRef(channel, value2) {
      if (contains(["x", "x2"], channel) && value2 === "width") {
        return { field: { group: "width" } };
      } else if (contains(["y", "y2"], channel) && value2 === "height") {
        return { field: { group: "height" } };
      }
      return signalOrValueRef(value2);
    }
    function isCustomFormatType(formatType) {
      return formatType && formatType !== "number" && formatType !== "time";
    }
    function customFormatExpr(formatType, field2, format2) {
      return `${formatType}(${field2}${format2 ? `, ${stringify$1(format2)}` : ""})`;
    }
    const BIN_RANGE_DELIMITER = "  ";
    function formatSignalRef({ fieldOrDatumDef, format: format2, formatType, expr: expr2, normalizeStack, config }) {
      var _a2, _b;
      if (isCustomFormatType(formatType)) {
        return formatCustomType({
          fieldOrDatumDef,
          format: format2,
          formatType,
          expr: expr2,
          config
        });
      }
      const field2 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
      const type2 = channelDefType(fieldOrDatumDef);
      if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (type2 === "quantitative") {
          if (normalizeStack && config.normalizedNumberFormatType)
            return formatCustomType({
              fieldOrDatumDef,
              format: config.normalizedNumberFormat,
              formatType: config.normalizedNumberFormatType,
              expr: expr2,
              config
            });
          if (config.numberFormatType) {
            return formatCustomType({
              fieldOrDatumDef,
              format: config.numberFormat,
              formatType: config.numberFormatType,
              expr: expr2,
              config
            });
          }
        }
        if (type2 === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
          return formatCustomType({
            fieldOrDatumDef,
            format: config.timeFormat,
            formatType: config.timeFormatType,
            expr: expr2,
            config
          });
        }
      }
      if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
        const signal = timeFormatExpression({
          field: field2,
          timeUnit: isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit : void 0,
          format: format2,
          formatType: config.timeFormatType,
          rawTimeFormat: config.timeFormat,
          isUTCScale: isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) == null ? void 0 : _b.type) === ScaleType.UTC
        });
        return signal ? { signal } : void 0;
      }
      format2 = numberFormat({ type: type2, specifiedFormat: format2, config, normalizeStack });
      if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
        const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
        return {
          signal: binFormatExpression(field2, endField, format2, formatType, config)
        };
      } else if (format2 || channelDefType(fieldOrDatumDef) === "quantitative") {
        return {
          signal: `${formatExpr(field2, format2)}`
        };
      } else {
        return { signal: `isValid(${field2}) ? ${field2} : ""+${field2}` };
      }
    }
    function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
      if (isFieldDef(fieldOrDatumDef)) {
        if (normalizeStack) {
          return `${vgField(fieldOrDatumDef, { expr: expr2, suffix: "end" })}-${vgField(fieldOrDatumDef, {
            expr: expr2,
            suffix: "start"
          })}`;
        } else {
          return vgField(fieldOrDatumDef, { expr: expr2 });
        }
      } else {
        return datumDefToExpr(fieldOrDatumDef);
      }
    }
    function formatCustomType({ fieldOrDatumDef, format: format2, formatType, expr: expr2, normalizeStack, config, field: field2 }) {
      field2 ?? (field2 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack));
      if (field2 !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
      isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
        const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
        return {
          signal: binFormatExpression(field2, endField, format2, formatType, config)
        };
      }
      return { signal: customFormatExpr(formatType, field2, format2) };
    }
    function guideFormat(fieldOrDatumDef, type2, format2, formatType, config, omitTimeFormatConfig) {
      var _a2;
      if (isString(formatType) && isCustomFormatType(formatType)) {
        return void 0;
      } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (channelDefType(fieldOrDatumDef) === "quantitative") {
          if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize") {
            return void 0;
          }
          if (config.numberFormatType) {
            return void 0;
          }
        }
      }
      if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormat) {
        return numberFormat({
          type: "quantitative",
          config,
          normalizeStack: true
        });
      }
      if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
        const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit : void 0;
        if (timeUnit === void 0 && config.customFormatTypes && config.timeFormatType) {
          return void 0;
        }
        return timeFormat({ specifiedFormat: format2, timeUnit, config, omitTimeFormatConfig });
      }
      return numberFormat({ type: type2, specifiedFormat: format2, config });
    }
    function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
      var _a2;
      if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
        return formatType;
      }
      if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
        return isFieldDef(fieldOrDatumDef) && ((_a2 = normalizeTimeUnit(fieldOrDatumDef == null ? void 0 : fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.utc) ? "utc" : "time";
      }
      return void 0;
    }
    function numberFormat({ type: type2, specifiedFormat, config, normalizeStack }) {
      if (isString(specifiedFormat)) {
        return specifiedFormat;
      }
      if (type2 === QUANTITATIVE) {
        return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;
      }
      return void 0;
    }
    function timeFormat({ specifiedFormat, timeUnit, config, omitTimeFormatConfig }) {
      if (specifiedFormat) {
        return specifiedFormat;
      }
      if (timeUnit) {
        return {
          signal: timeUnitSpecifierExpression(timeUnit)
        };
      }
      return omitTimeFormatConfig ? void 0 : config.timeFormat;
    }
    function formatExpr(field2, format2) {
      return `format(${field2}, "${format2 || ""}")`;
    }
    function binNumberFormatExpr(field2, format2, formatType, config) {
      if (isCustomFormatType(formatType)) {
        return customFormatExpr(formatType, field2, format2);
      }
      return formatExpr(field2, (isString(format2) ? format2 : void 0) ?? config.numberFormat);
    }
    function binFormatExpression(startField, endField, format2, formatType, config) {
      if (format2 === void 0 && formatType === void 0 && config.customFormatTypes && config.numberFormatType) {
        return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);
      }
      const start2 = binNumberFormatExpr(startField, format2, formatType, config);
      const end = binNumberFormatExpr(endField, format2, formatType, config);
      return `${fieldValidPredicate(startField, false)} ? "null" : ${start2} + "${BIN_RANGE_DELIMITER}" + ${end}`;
    }
    function timeFormatExpression({ field: field2, timeUnit, format: format2, formatType, rawTimeFormat, isUTCScale }) {
      if (!timeUnit || format2) {
        if (!timeUnit && formatType) {
          return `${formatType}(${field2}, '${format2}')`;
        }
        format2 = isString(format2) ? format2 : rawTimeFormat;
        return `${isUTCScale ? "utc" : "time"}Format(${field2}, '${format2}')`;
      } else {
        return formatExpression(timeUnit, field2, isUTCScale);
      }
    }
    const DEFAULT_SORT_OP = "min";
    const SORT_BY_CHANNEL_INDEX = {
      x: 1,
      y: 1,
      color: 1,
      fill: 1,
      stroke: 1,
      strokeWidth: 1,
      size: 1,
      shape: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      opacity: 1,
      text: 1
    };
    function isSortByChannel(c2) {
      return c2 in SORT_BY_CHANNEL_INDEX;
    }
    function isSortByEncoding(sort2) {
      return !!(sort2 == null ? void 0 : sort2["encoding"]);
    }
    function isSortField(sort2) {
      return sort2 && (sort2["op"] === "count" || !!sort2["field"]);
    }
    function isSortArray(sort2) {
      return sort2 && isArray(sort2);
    }
    function isFacetMapping(f) {
      return "row" in f || "column" in f;
    }
    function isFacetFieldDef(channelDef) {
      return !!channelDef && "header" in channelDef;
    }
    function isFacetSpec(spec) {
      return "facet" in spec;
    }
    function isConditionalParameter(c2) {
      return c2["param"];
    }
    function isRepeatRef(field2) {
      return field2 && !isString(field2) && "repeat" in field2;
    }
    function toFieldDefBase(fieldDef) {
      const { field: field2, timeUnit, bin: bin2, aggregate } = fieldDef;
      return {
        ...timeUnit ? { timeUnit } : {},
        ...bin2 ? { bin: bin2 } : {},
        ...aggregate ? { aggregate } : {},
        field: field2
      };
    }
    function isSortableFieldDef(fieldDef) {
      return "sort" in fieldDef;
    }
    function getBandPosition({ fieldDef, fieldDef2, markDef: mark, config }) {
      if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
        return fieldDef.bandPosition;
      }
      if (isFieldDef(fieldDef)) {
        const { timeUnit, bin: bin2 } = fieldDef;
        if (timeUnit && !fieldDef2) {
          return getMarkConfig("timeUnitBandPosition", mark, config);
        } else if (isBinning(bin2)) {
          return 0.5;
        }
      }
      return void 0;
    }
    function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark, config, scaleType: scaleType2, useVlSizeChannel }) {
      var _a2, _b, _c2;
      const sizeChannel = getSizeChannel(channel);
      const size2 = getMarkPropOrConfig(useVlSizeChannel ? "size" : sizeChannel, mark, config, {
        vgChannel: sizeChannel
      });
      if (size2 !== void 0) {
        return size2;
      }
      if (isFieldDef(fieldDef)) {
        const { timeUnit, bin: bin2 } = fieldDef;
        if (timeUnit && !fieldDef2) {
          return { band: getMarkConfig("timeUnitBandSize", mark, config) };
        } else if (isBinning(bin2) && !hasDiscreteDomain(scaleType2)) {
          return { band: 1 };
        }
      }
      if (isRectBasedMark(mark.type)) {
        if (scaleType2) {
          if (hasDiscreteDomain(scaleType2)) {
            return ((_a2 = config[mark.type]) == null ? void 0 : _a2.discreteBandSize) || { band: 1 };
          } else {
            return (_b = config[mark.type]) == null ? void 0 : _b.continuousBandSize;
          }
        }
        return (_c2 = config[mark.type]) == null ? void 0 : _c2.discreteBandSize;
      }
      return void 0;
    }
    function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
      if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
        return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== void 0;
      }
      return false;
    }
    function isOrderOnlyDef(orderDef) {
      return orderDef && !!orderDef.sort && !orderDef["field"];
    }
    function isConditionalDef(channelDef) {
      return channelDef && "condition" in channelDef;
    }
    function hasConditionalFieldDef(channelDef) {
      const condition = channelDef == null ? void 0 : channelDef["condition"];
      return !!condition && !isArray(condition) && isFieldDef(condition);
    }
    function hasConditionalFieldOrDatumDef(channelDef) {
      const condition = channelDef == null ? void 0 : channelDef["condition"];
      return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);
    }
    function hasConditionalValueDef(channelDef) {
      const condition = channelDef == null ? void 0 : channelDef["condition"];
      return !!condition && (isArray(condition) || isValueDef(condition));
    }
    function isFieldDef(channelDef) {
      return channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
    }
    function channelDefType(channelDef) {
      return channelDef == null ? void 0 : channelDef["type"];
    }
    function isDatumDef(channelDef) {
      return channelDef && "datum" in channelDef;
    }
    function isContinuousFieldOrDatumDef(cd) {
      return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);
    }
    function isUnbinnedQuantitativeFieldOrDatumDef(cd) {
      return isTypedFieldDef(cd) && cd.type === "quantitative" && !cd.bin || isNumericDataDef(cd);
    }
    function isNumericDataDef(cd) {
      return isDatumDef(cd) && isNumber$1(cd.datum);
    }
    function isFieldOrDatumDef(channelDef) {
      return isFieldDef(channelDef) || isDatumDef(channelDef);
    }
    function isTypedFieldDef(channelDef) {
      return channelDef && ("field" in channelDef || channelDef["aggregate"] === "count") && "type" in channelDef;
    }
    function isValueDef(channelDef) {
      return channelDef && "value" in channelDef && "value" in channelDef;
    }
    function isScaleFieldDef(channelDef) {
      return channelDef && ("scale" in channelDef || "sort" in channelDef);
    }
    function isPositionFieldOrDatumDef(channelDef) {
      return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
    }
    function isMarkPropFieldOrDatumDef(channelDef) {
      return channelDef && "legend" in channelDef;
    }
    function isStringFieldOrDatumDef(channelDef) {
      return channelDef && ("format" in channelDef || "formatType" in channelDef);
    }
    function toStringFieldDef(fieldDef) {
      return omit(fieldDef, ["legend", "axis", "header", "scale"]);
    }
    function isOpFieldDef(fieldDef) {
      return "op" in fieldDef;
    }
    function vgField(fieldDef, opt = {}) {
      let field2 = fieldDef.field;
      const prefix = opt.prefix;
      let suffix = opt.suffix;
      let argAccessor = "";
      if (isCount(fieldDef)) {
        field2 = internalField("count");
      } else {
        let fn;
        if (!opt.nofn) {
          if (isOpFieldDef(fieldDef)) {
            fn = fieldDef.op;
          } else {
            const { bin: bin2, aggregate, timeUnit } = fieldDef;
            if (isBinning(bin2)) {
              fn = binToString(bin2);
              suffix = (opt.binSuffix ?? "") + (opt.suffix ?? "");
            } else if (aggregate) {
              if (isArgmaxDef(aggregate)) {
                argAccessor = `["${field2}"]`;
                field2 = `argmax_${aggregate.argmax}`;
              } else if (isArgminDef(aggregate)) {
                argAccessor = `["${field2}"]`;
                field2 = `argmin_${aggregate.argmin}`;
              } else {
                fn = String(aggregate);
              }
            } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
              fn = timeUnitToString(timeUnit);
              suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + (opt.suffix ?? "");
            }
          }
        }
        if (fn) {
          field2 = field2 ? `${fn}_${field2}` : fn;
        }
      }
      if (suffix) {
        field2 = `${field2}_${suffix}`;
      }
      if (prefix) {
        field2 = `${prefix}_${field2}`;
      }
      if (opt.forAs) {
        return removePathFromField(field2);
      } else if (opt.expr) {
        return flatAccessWithDatum(field2, opt.expr) + argAccessor;
      } else {
        return replacePathInField(field2) + argAccessor;
      }
    }
    function isDiscrete(def2) {
      switch (def2.type) {
        case "nominal":
        case "ordinal":
        case "geojson":
          return true;
        case "quantitative":
          return isFieldDef(def2) && !!def2.bin;
        case "temporal":
          return false;
      }
      throw new Error(invalidFieldType(def2.type));
    }
    function isDiscretizing(def2) {
      var _a2;
      return isScaleFieldDef(def2) && isContinuousToDiscrete((_a2 = def2.scale) == null ? void 0 : _a2.type);
    }
    function isCount(fieldDef) {
      return fieldDef.aggregate === "count";
    }
    function verbalTitleFormatter(fieldDef, config) {
      var _a2;
      const { field: field2, bin: bin2, timeUnit, aggregate } = fieldDef;
      if (aggregate === "count") {
        return config.countTitle;
      } else if (isBinning(bin2)) {
        return `${field2} (binned)`;
      } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
        const unit2 = (_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit;
        if (unit2) {
          return `${field2} (${getTimeUnitParts(unit2).join("-")})`;
        }
      } else if (aggregate) {
        if (isArgmaxDef(aggregate)) {
          return `${field2} for max ${aggregate.argmax}`;
        } else if (isArgminDef(aggregate)) {
          return `${field2} for min ${aggregate.argmin}`;
        } else {
          return `${titleCase(aggregate)} of ${field2}`;
        }
      }
      return field2;
    }
    function functionalTitleFormatter(fieldDef) {
      const { aggregate, bin: bin2, timeUnit, field: field2 } = fieldDef;
      if (isArgmaxDef(aggregate)) {
        return `${field2} for argmax(${aggregate.argmax})`;
      } else if (isArgminDef(aggregate)) {
        return `${field2} for argmin(${aggregate.argmin})`;
      }
      const timeUnitParams = timeUnit && !isBinnedTimeUnit(timeUnit) ? normalizeTimeUnit(timeUnit) : void 0;
      const fn = aggregate || (timeUnitParams == null ? void 0 : timeUnitParams.unit) || (timeUnitParams == null ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin2) && "bin";
      if (fn) {
        return `${fn.toUpperCase()}(${field2})`;
      } else {
        return field2;
      }
    }
    const defaultTitleFormatter = (fieldDef, config) => {
      switch (config.fieldTitle) {
        case "plain":
          return fieldDef.field;
        case "functional":
          return functionalTitleFormatter(fieldDef);
        default:
          return verbalTitleFormatter(fieldDef, config);
      }
    };
    let titleFormatter = defaultTitleFormatter;
    function setTitleFormatter(formatter) {
      titleFormatter = formatter;
    }
    function resetTitleFormatter() {
      setTitleFormatter(defaultTitleFormatter);
    }
    function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
      var _a2;
      const guideTitle = (_a2 = getGuide(fieldOrDatumDef)) == null ? void 0 : _a2.title;
      if (!isFieldDef(fieldOrDatumDef)) {
        return guideTitle ?? fieldOrDatumDef.title;
      }
      const fieldDef = fieldOrDatumDef;
      const def2 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
      if (allowDisabling) {
        return getFirstDefined(guideTitle, fieldDef.title, def2);
      } else {
        return guideTitle ?? fieldDef.title ?? def2;
      }
    }
    function getGuide(fieldDef) {
      if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
        return fieldDef.axis;
      } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
        return fieldDef.legend;
      } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
        return fieldDef.header;
      }
      return void 0;
    }
    function defaultTitle(fieldDef, config) {
      return titleFormatter(fieldDef, config);
    }
    function getFormatMixins(fieldDef) {
      if (isStringFieldOrDatumDef(fieldDef)) {
        const { format: format2, formatType } = fieldDef;
        return { format: format2, formatType };
      } else {
        const guide = getGuide(fieldDef) ?? {};
        const { format: format2, formatType } = guide;
        return { format: format2, formatType };
      }
    }
    function defaultType$2(fieldDef, channel) {
      var _a2;
      switch (channel) {
        case "latitude":
        case "longitude":
          return "quantitative";
        case "row":
        case "column":
        case "facet":
        case "shape":
        case "strokeDash":
          return "nominal";
        case "order":
          return "ordinal";
      }
      if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {
        return "ordinal";
      }
      const { aggregate, bin: bin2, timeUnit } = fieldDef;
      if (timeUnit) {
        return "temporal";
      }
      if (bin2 || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
        return "quantitative";
      }
      if (isScaleFieldDef(fieldDef) && ((_a2 = fieldDef.scale) == null ? void 0 : _a2.type)) {
        switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
          case "numeric":
          case "discretizing":
            return "quantitative";
          case "time":
            return "temporal";
        }
      }
      return "nominal";
    }
    function getFieldDef(channelDef) {
      if (isFieldDef(channelDef)) {
        return channelDef;
      } else if (hasConditionalFieldDef(channelDef)) {
        return channelDef.condition;
      }
      return void 0;
    }
    function getFieldOrDatumDef(channelDef) {
      if (isFieldOrDatumDef(channelDef)) {
        return channelDef;
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        return channelDef.condition;
      }
      return void 0;
    }
    function initChannelDef(channelDef, channel, config, opt = {}) {
      if (isString(channelDef) || isNumber$1(channelDef) || isBoolean$2(channelDef)) {
        const primitiveType = isString(channelDef) ? "string" : isNumber$1(channelDef) ? "number" : "boolean";
        warn(primitiveChannelDef(channel, primitiveType, channelDef));
        return { value: channelDef };
      }
      if (isFieldOrDatumDef(channelDef)) {
        return initFieldOrDatumDef(channelDef, channel, config, opt);
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        return {
          ...channelDef,
          // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
          condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)
        };
      }
      return channelDef;
    }
    function initFieldOrDatumDef(fd, channel, config, opt) {
      if (isStringFieldOrDatumDef(fd)) {
        const { format: format2, formatType, ...rest } = fd;
        if (isCustomFormatType(formatType) && !config.customFormatTypes) {
          warn(customFormatTypeNotAllowed(channel));
          return initFieldOrDatumDef(rest, channel, config, opt);
        }
      } else {
        const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
        if (guideType && fd[guideType]) {
          const { format: format2, formatType, ...newGuide } = fd[guideType];
          if (isCustomFormatType(formatType) && !config.customFormatTypes) {
            warn(customFormatTypeNotAllowed(channel));
            return initFieldOrDatumDef({ ...fd, [guideType]: newGuide }, channel, config, opt);
          }
        }
      }
      if (isFieldDef(fd)) {
        return initFieldDef(fd, channel, opt);
      }
      return initDatumDef(fd);
    }
    function initDatumDef(datumDef) {
      let type2 = datumDef["type"];
      if (type2) {
        return datumDef;
      }
      const { datum: datum2 } = datumDef;
      type2 = isNumber$1(datum2) ? "quantitative" : isString(datum2) ? "nominal" : isDateTime(datum2) ? "temporal" : void 0;
      return { ...datumDef, type: type2 };
    }
    function initFieldDef(fd, channel, { compositeMark = false } = {}) {
      const { aggregate, timeUnit, bin: bin2, field: field2 } = fd;
      const fieldDef = { ...fd };
      if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
        warn(invalidAggregate(aggregate));
        delete fieldDef.aggregate;
      }
      if (timeUnit) {
        fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
      }
      if (field2) {
        fieldDef.field = `${field2}`;
      }
      if (isBinning(bin2)) {
        fieldDef.bin = normalizeBin(bin2, channel);
      }
      if (isBinned(bin2) && !isXorY(channel)) {
        warn(channelShouldNotBeUsedForBinned(channel));
      }
      if (isTypedFieldDef(fieldDef)) {
        const { type: type2 } = fieldDef;
        const fullType = getFullName(type2);
        if (type2 !== fullType) {
          fieldDef.type = fullType;
        }
        if (type2 !== "quantitative") {
          if (isCountingAggregateOp(aggregate)) {
            warn(invalidFieldTypeForCountAggregate(type2, aggregate));
            fieldDef.type = "quantitative";
          }
        }
      } else if (!isSecondaryRangeChannel(channel)) {
        const newType = defaultType$2(fieldDef, channel);
        fieldDef["type"] = newType;
      }
      if (isTypedFieldDef(fieldDef)) {
        const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};
        if (compatible === false) {
          warn(warning);
        }
      }
      if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {
        const { sort: sort2 } = fieldDef;
        if (isSortByChannel(sort2)) {
          return {
            ...fieldDef,
            sort: { encoding: sort2 }
          };
        }
        const sub = sort2.substr(1);
        if (sort2.charAt(0) === "-" && isSortByChannel(sub)) {
          return {
            ...fieldDef,
            sort: { encoding: sub, order: "descending" }
          };
        }
      }
      if (isFacetFieldDef(fieldDef)) {
        const { header } = fieldDef;
        if (header) {
          const { orient: orient2, ...rest } = header;
          if (orient2) {
            return {
              ...fieldDef,
              header: {
                ...rest,
                labelOrient: header.labelOrient || orient2,
                titleOrient: header.titleOrient || orient2
              }
            };
          }
        }
      }
      return fieldDef;
    }
    function normalizeBin(bin2, channel) {
      if (isBoolean$2(bin2)) {
        return { maxbins: autoMaxBins(channel) };
      } else if (bin2 === "binned") {
        return {
          binned: true
        };
      } else if (!bin2.maxbins && !bin2.step) {
        return { ...bin2, maxbins: autoMaxBins(channel) };
      } else {
        return bin2;
      }
    }
    const COMPATIBLE = { compatible: true };
    function channelCompatibility(fieldDef, channel) {
      const type2 = fieldDef.type;
      if (type2 === "geojson" && channel !== "shape") {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with a geojson data.`
        };
      }
      switch (channel) {
        case ROW:
        case COLUMN:
        case FACET:
          if (!isDiscrete(fieldDef)) {
            return {
              compatible: false,
              warning: channelShouldBeDiscrete(channel)
            };
          }
          return COMPATIBLE;
        case X:
        case Y:
        case XOFFSET:
        case YOFFSET:
        case COLOR:
        case FILL:
        case STROKE:
        case TEXT$1:
        case DETAIL:
        case KEY:
        case TOOLTIP:
        case HREF:
        case URL$1:
        case ANGLE:
        case THETA:
        case RADIUS:
        case DESCRIPTION:
          return COMPATIBLE;
        case LONGITUDE:
        case LONGITUDE2:
        case LATITUDE:
        case LATITUDE2:
          if (type2 !== QUANTITATIVE) {
            return {
              compatible: false,
              warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
            };
          }
          return COMPATIBLE;
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
        case STROKEWIDTH:
        case SIZE:
        case THETA2:
        case RADIUS2:
        case X2:
        case Y2:
          if (type2 === "nominal" && !fieldDef["sort"]) {
            return {
              compatible: false,
              warning: `Channel ${channel} should not be used with an unsorted discrete field.`
            };
          }
          return COMPATIBLE;
        case SHAPE:
        case STROKEDASH:
          if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {
            return {
              compatible: false,
              warning: channelShouldBeDiscreteOrDiscretizing(channel)
            };
          }
          return COMPATIBLE;
        case ORDER:
          if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
            return {
              compatible: false,
              warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
            };
          }
          return COMPATIBLE;
      }
    }
    function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
      const { formatType } = getFormatMixins(fieldOrDatumDef);
      return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
    }
    function isTimeFieldDef(def2) {
      return def2 && (def2["type"] === "temporal" || isFieldDef(def2) && !!def2.timeUnit);
    }
    function valueExpr(v, { timeUnit, type: type2, wrapTime, undefinedIfExprNotRequired }) {
      var _a2;
      const unit2 = timeUnit && ((_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit);
      let isTime = unit2 || type2 === "temporal";
      let expr2;
      if (isExprRef(v)) {
        expr2 = v.expr;
      } else if (isSignalRef(v)) {
        expr2 = v.signal;
      } else if (isDateTime(v)) {
        isTime = true;
        expr2 = dateTimeToExpr(v);
      } else if (isString(v) || isNumber$1(v)) {
        if (isTime) {
          expr2 = `datetime(${stringify$1(v)})`;
          if (isLocalSingleTimeUnit(unit2)) {
            if (isNumber$1(v) && v < 1e4 || isString(v) && isNaN(Date.parse(v))) {
              expr2 = dateTimeToExpr({ [unit2]: v });
            }
          }
        }
      }
      if (expr2) {
        return wrapTime && isTime ? `time(${expr2})` : expr2;
      }
      return undefinedIfExprNotRequired ? void 0 : stringify$1(v);
    }
    function valueArray(fieldOrDatumDef, values2) {
      const { type: type2 } = fieldOrDatumDef;
      return values2.map((v) => {
        const timeUnit = isFieldDef(fieldOrDatumDef) && !isBinnedTimeUnit(fieldOrDatumDef.timeUnit) ? fieldOrDatumDef.timeUnit : void 0;
        const expr2 = valueExpr(v, {
          timeUnit,
          type: type2,
          undefinedIfExprNotRequired: true
        });
        if (expr2 !== void 0) {
          return { signal: expr2 };
        }
        return v;
      });
    }
    function binRequiresRange(fieldDef, channel) {
      if (!isBinning(fieldDef.bin)) {
        console.warn("Only call this method for binned field defs.");
        return false;
      }
      return isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type);
    }
    const CONDITIONAL_AXIS_PROP_INDEX = {
      labelAlign: {
        part: "labels",
        vgProp: "align"
      },
      labelBaseline: {
        part: "labels",
        vgProp: "baseline"
      },
      labelColor: {
        part: "labels",
        vgProp: "fill"
      },
      labelFont: {
        part: "labels",
        vgProp: "font"
      },
      labelFontSize: {
        part: "labels",
        vgProp: "fontSize"
      },
      labelFontStyle: {
        part: "labels",
        vgProp: "fontStyle"
      },
      labelFontWeight: {
        part: "labels",
        vgProp: "fontWeight"
      },
      labelOpacity: {
        part: "labels",
        vgProp: "opacity"
      },
      labelOffset: null,
      labelPadding: null,
      gridColor: {
        part: "grid",
        vgProp: "stroke"
      },
      gridDash: {
        part: "grid",
        vgProp: "strokeDash"
      },
      gridDashOffset: {
        part: "grid",
        vgProp: "strokeDashOffset"
      },
      gridOpacity: {
        part: "grid",
        vgProp: "opacity"
      },
      gridWidth: {
        part: "grid",
        vgProp: "strokeWidth"
      },
      tickColor: {
        part: "ticks",
        vgProp: "stroke"
      },
      tickDash: {
        part: "ticks",
        vgProp: "strokeDash"
      },
      tickDashOffset: {
        part: "ticks",
        vgProp: "strokeDashOffset"
      },
      tickOpacity: {
        part: "ticks",
        vgProp: "opacity"
      },
      tickSize: null,
      tickWidth: {
        part: "ticks",
        vgProp: "strokeWidth"
      }
    };
    function isConditionalAxisValue(v) {
      return v == null ? void 0 : v.condition;
    }
    const AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
    const AXIS_PROPERTY_TYPE = {
      grid: "grid",
      gridCap: "grid",
      gridColor: "grid",
      gridDash: "grid",
      gridDashOffset: "grid",
      gridOpacity: "grid",
      gridScale: "grid",
      gridWidth: "grid",
      orient: "main",
      bandPosition: "both",
      aria: "main",
      description: "main",
      domain: "main",
      domainCap: "main",
      domainColor: "main",
      domainDash: "main",
      domainDashOffset: "main",
      domainOpacity: "main",
      domainWidth: "main",
      format: "main",
      formatType: "main",
      labelAlign: "main",
      labelAngle: "main",
      labelBaseline: "main",
      labelBound: "main",
      labelColor: "main",
      labelFlush: "main",
      labelFlushOffset: "main",
      labelFont: "main",
      labelFontSize: "main",
      labelFontStyle: "main",
      labelFontWeight: "main",
      labelLimit: "main",
      labelLineHeight: "main",
      labelOffset: "main",
      labelOpacity: "main",
      labelOverlap: "main",
      labelPadding: "main",
      labels: "main",
      labelSeparation: "main",
      maxExtent: "main",
      minExtent: "main",
      offset: "both",
      position: "main",
      tickCap: "main",
      tickColor: "main",
      tickDash: "main",
      tickDashOffset: "main",
      tickMinStep: "both",
      tickOffset: "both",
      tickOpacity: "main",
      tickRound: "both",
      ticks: "main",
      tickSize: "main",
      tickWidth: "both",
      title: "main",
      titleAlign: "main",
      titleAnchor: "main",
      titleAngle: "main",
      titleBaseline: "main",
      titleColor: "main",
      titleFont: "main",
      titleFontSize: "main",
      titleFontStyle: "main",
      titleFontWeight: "main",
      titleLimit: "main",
      titleLineHeight: "main",
      titleOpacity: "main",
      titlePadding: "main",
      titleX: "main",
      titleY: "main",
      encode: "both",
      scale: "both",
      tickBand: "both",
      tickCount: "both",
      tickExtra: "both",
      translate: "both",
      values: "both",
      zindex: "both"
      // this is actually set afterward, so it doesn't matter
    };
    const COMMON_AXIS_PROPERTIES_INDEX = {
      orient: 1,
      aria: 1,
      bandPosition: 1,
      description: 1,
      domain: 1,
      domainCap: 1,
      domainColor: 1,
      domainDash: 1,
      domainDashOffset: 1,
      domainOpacity: 1,
      domainWidth: 1,
      format: 1,
      formatType: 1,
      grid: 1,
      gridCap: 1,
      gridColor: 1,
      gridDash: 1,
      gridDashOffset: 1,
      gridOpacity: 1,
      gridWidth: 1,
      labelAlign: 1,
      labelAngle: 1,
      labelBaseline: 1,
      labelBound: 1,
      labelColor: 1,
      labelFlush: 1,
      labelFlushOffset: 1,
      labelFont: 1,
      labelFontSize: 1,
      labelFontStyle: 1,
      labelFontWeight: 1,
      labelLimit: 1,
      labelLineHeight: 1,
      labelOffset: 1,
      labelOpacity: 1,
      labelOverlap: 1,
      labelPadding: 1,
      labels: 1,
      labelSeparation: 1,
      maxExtent: 1,
      minExtent: 1,
      offset: 1,
      position: 1,
      tickBand: 1,
      tickCap: 1,
      tickColor: 1,
      tickCount: 1,
      tickDash: 1,
      tickDashOffset: 1,
      tickExtra: 1,
      tickMinStep: 1,
      tickOffset: 1,
      tickOpacity: 1,
      tickRound: 1,
      ticks: 1,
      tickSize: 1,
      tickWidth: 1,
      title: 1,
      titleAlign: 1,
      titleAnchor: 1,
      titleAngle: 1,
      titleBaseline: 1,
      titleColor: 1,
      titleFont: 1,
      titleFontSize: 1,
      titleFontStyle: 1,
      titleFontWeight: 1,
      titleLimit: 1,
      titleLineHeight: 1,
      titleOpacity: 1,
      titlePadding: 1,
      titleX: 1,
      titleY: 1,
      translate: 1,
      values: 1,
      zindex: 1
    };
    const AXIS_PROPERTIES_INDEX = {
      ...COMMON_AXIS_PROPERTIES_INDEX,
      style: 1,
      labelExpr: 1,
      encoding: 1
    };
    function isAxisProperty(prop) {
      return !!AXIS_PROPERTIES_INDEX[prop];
    }
    const AXIS_CONFIGS_INDEX = {
      axis: 1,
      axisBand: 1,
      axisBottom: 1,
      axisDiscrete: 1,
      axisLeft: 1,
      axisPoint: 1,
      axisQuantitative: 1,
      axisRight: 1,
      axisTemporal: 1,
      axisTop: 1,
      axisX: 1,
      axisXBand: 1,
      axisXDiscrete: 1,
      axisXPoint: 1,
      axisXQuantitative: 1,
      axisXTemporal: 1,
      axisY: 1,
      axisYBand: 1,
      axisYDiscrete: 1,
      axisYPoint: 1,
      axisYQuantitative: 1,
      axisYTemporal: 1
    };
    const AXIS_CONFIGS = keys(AXIS_CONFIGS_INDEX);
    function isUnitSpec(spec) {
      return "mark" in spec;
    }
    class CompositeMarkNormalizer {
      constructor(name2, run2) {
        this.name = name2;
        this.run = run2;
      }
      hasMatchingType(spec) {
        if (isUnitSpec(spec)) {
          return getMarkType(spec.mark) === this.name;
        }
        return false;
      }
    }
    function channelHasField(encoding, channel) {
      const channelDef = encoding && encoding[channel];
      if (channelDef) {
        if (isArray(channelDef)) {
          return some(channelDef, (fieldDef) => !!fieldDef.field);
        } else {
          return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
        }
      }
      return false;
    }
    function channelHasFieldOrDatum(encoding, channel) {
      const channelDef = encoding && encoding[channel];
      if (channelDef) {
        if (isArray(channelDef)) {
          return some(channelDef, (fieldDef) => !!fieldDef.field);
        } else {
          return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);
        }
      }
      return false;
    }
    function channelHasNestedOffsetScale(encoding, channel) {
      if (isXorY(channel)) {
        const fieldDef = encoding[channel];
        if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && (isDiscrete$1(fieldDef.type) || isFieldDef(fieldDef) && fieldDef.timeUnit)) {
          const offsetChannel = getOffsetScaleChannel(channel);
          return channelHasFieldOrDatum(encoding, offsetChannel);
        }
      }
      return false;
    }
    function isAggregate$1(encoding) {
      return some(CHANNELS, (channel) => {
        if (channelHasField(encoding, channel)) {
          const channelDef = encoding[channel];
          if (isArray(channelDef)) {
            return some(channelDef, (fieldDef) => !!fieldDef.aggregate);
          } else {
            const fieldDef = getFieldDef(channelDef);
            return fieldDef && !!fieldDef.aggregate;
          }
        }
        return false;
      });
    }
    function extractTransformsFromEncoding(oldEncoding, config) {
      const groupby = [];
      const bins2 = [];
      const timeUnits2 = [];
      const aggregate = [];
      const encoding = {};
      forEach(oldEncoding, (channelDef, channel) => {
        if (isFieldDef(channelDef)) {
          const { field: field2, aggregate: aggOp, bin: bin2, timeUnit, ...remaining } = channelDef;
          if (aggOp || timeUnit || bin2) {
            const guide = getGuide(channelDef);
            const isTitleDefined = guide == null ? void 0 : guide.title;
            let newField = vgField(channelDef, { forAs: true });
            const newFieldDef = {
              // Only add title if it doesn't exist
              ...isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) },
              ...remaining,
              // Always overwrite field
              field: newField
            };
            if (aggOp) {
              let op;
              if (isArgmaxDef(aggOp)) {
                op = "argmax";
                newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
                newFieldDef.field = `${newField}.${field2}`;
              } else if (isArgminDef(aggOp)) {
                op = "argmin";
                newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
                newFieldDef.field = `${newField}.${field2}`;
              } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
                op = aggOp;
              }
              if (op) {
                const aggregateEntry = {
                  op,
                  as: newField
                };
                if (field2) {
                  aggregateEntry.field = field2;
                }
                aggregate.push(aggregateEntry);
              }
            } else {
              groupby.push(newField);
              if (isTypedFieldDef(channelDef) && isBinning(bin2)) {
                bins2.push({ bin: bin2, field: field2, as: newField });
                groupby.push(vgField(channelDef, { binSuffix: "end" }));
                if (binRequiresRange(channelDef, channel)) {
                  groupby.push(vgField(channelDef, { binSuffix: "range" }));
                }
                if (isXorY(channel)) {
                  const secondaryChannel = {
                    field: `${newField}_end`
                  };
                  encoding[`${channel}2`] = secondaryChannel;
                }
                newFieldDef.bin = "binned";
                if (!isSecondaryRangeChannel(channel)) {
                  newFieldDef["type"] = QUANTITATIVE;
                }
              } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
                timeUnits2.push({
                  timeUnit,
                  field: field2,
                  as: newField
                });
                const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
                if (formatType) {
                  if (channel === TEXT$1 || channel === TOOLTIP) {
                    newFieldDef["formatType"] = formatType;
                  } else if (isNonPositionScaleChannel(channel)) {
                    newFieldDef["legend"] = {
                      formatType,
                      ...newFieldDef["legend"]
                    };
                  } else if (isXorY(channel)) {
                    newFieldDef["axis"] = {
                      formatType,
                      ...newFieldDef["axis"]
                    };
                  }
                }
              }
            }
            encoding[channel] = newFieldDef;
          } else {
            groupby.push(field2);
            encoding[channel] = oldEncoding[channel];
          }
        } else {
          encoding[channel] = oldEncoding[channel];
        }
      });
      return {
        bins: bins2,
        timeUnits: timeUnits2,
        aggregate,
        groupby,
        encoding
      };
    }
    function markChannelCompatible(encoding, channel, mark) {
      const markSupported = supportMark(channel, mark);
      if (!markSupported) {
        return false;
      } else if (markSupported === "binned") {
        const primaryFieldDef = encoding[channel === X2 ? X : Y];
        if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    }
    function initEncoding(encoding, mark, filled, config) {
      const normalizedEncoding = {};
      for (const key2 of keys(encoding)) {
        if (!isChannel(key2)) {
          warn(invalidEncodingChannel(key2));
        }
      }
      for (let channel of UNIT_CHANNELS) {
        if (!encoding[channel]) {
          continue;
        }
        const channelDef = encoding[channel];
        if (isXorYOffset(channel)) {
          const mainChannel = getMainChannelFromOffsetChannel(channel);
          const positionDef = normalizedEncoding[mainChannel];
          if (isFieldDef(positionDef)) {
            if (isContinuous(positionDef.type)) {
              if (isFieldDef(channelDef) && !positionDef.timeUnit) {
                warn(offsetNestedInsideContinuousPositionScaleDropped(mainChannel));
                continue;
              }
            }
          }
        }
        if (channel === "angle" && mark === "arc" && !encoding.theta) {
          warn(REPLACE_ANGLE_WITH_THETA);
          channel = THETA;
        }
        if (!markChannelCompatible(encoding, channel, mark)) {
          warn(incompatibleChannel(channel, mark));
          continue;
        }
        if (channel === SIZE && mark === "line") {
          const fieldDef = getFieldDef(encoding[channel]);
          if (fieldDef == null ? void 0 : fieldDef.aggregate) {
            warn(LINE_WITH_VARYING_SIZE);
            continue;
          }
        }
        if (channel === COLOR && (filled ? "fill" in encoding : "stroke" in encoding)) {
          warn(droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
          continue;
        }
        if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {
          if (channelDef) {
            if (channel === ORDER) {
              const def2 = encoding[channel];
              if (isOrderOnlyDef(def2)) {
                normalizedEncoding[channel] = def2;
                continue;
              }
            }
            normalizedEncoding[channel] = array$2(channelDef).reduce((defs, fieldDef) => {
              if (!isFieldDef(fieldDef)) {
                warn(emptyFieldDef(fieldDef, channel));
              } else {
                defs.push(initFieldDef(fieldDef, channel));
              }
              return defs;
            }, []);
          }
        } else {
          if (channel === TOOLTIP && channelDef === null) {
            normalizedEncoding[channel] = null;
          } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
            warn(emptyFieldDef(channelDef, channel));
            continue;
          }
          normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
        }
      }
      return normalizedEncoding;
    }
    function normalizeEncoding(encoding, config) {
      const normalizedEncoding = {};
      for (const channel of keys(encoding)) {
        const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });
        normalizedEncoding[channel] = newChannelDef;
      }
      return normalizedEncoding;
    }
    function fieldDefs(encoding) {
      const arr = [];
      for (const channel of keys(encoding)) {
        if (channelHasField(encoding, channel)) {
          const channelDef = encoding[channel];
          const channelDefArray = array$2(channelDef);
          for (const def2 of channelDefArray) {
            if (isFieldDef(def2)) {
              arr.push(def2);
            } else if (hasConditionalFieldDef(def2)) {
              arr.push(def2.condition);
            }
          }
        }
      }
      return arr;
    }
    function forEach(mapping, f, thisArg) {
      if (!mapping) {
        return;
      }
      for (const channel of keys(mapping)) {
        const el = mapping[channel];
        if (isArray(el)) {
          for (const channelDef of el) {
            f.call(thisArg, channelDef, channel);
          }
        } else {
          f.call(thisArg, el, channel);
        }
      }
    }
    function reduce(mapping, f, init2, thisArg) {
      if (!mapping) {
        return init2;
      }
      return keys(mapping).reduce((r, channel) => {
        const map2 = mapping[channel];
        if (isArray(map2)) {
          return map2.reduce((r1, channelDef) => {
            return f.call(thisArg, r1, channelDef, channel);
          }, r);
        } else {
          return f.call(thisArg, r, map2, channel);
        }
      }, init2);
    }
    function pathGroupingFields(mark, encoding) {
      return keys(encoding).reduce((details2, channel) => {
        switch (channel) {
          case X:
          case Y:
          case HREF:
          case DESCRIPTION:
          case URL$1:
          case X2:
          case Y2:
          case XOFFSET:
          case YOFFSET:
          case THETA:
          case THETA2:
          case RADIUS:
          case RADIUS2:
          case LATITUDE:
          case LONGITUDE:
          case LATITUDE2:
          case LONGITUDE2:
          case TEXT$1:
          case SHAPE:
          case ANGLE:
          case TOOLTIP:
            return details2;
          case ORDER:
            if (mark === "line" || mark === "trail") {
              return details2;
            }
          case DETAIL:
          case KEY: {
            const channelDef = encoding[channel];
            if (isArray(channelDef) || isFieldDef(channelDef)) {
              for (const fieldDef of array$2(channelDef)) {
                if (!fieldDef.aggregate) {
                  details2.push(vgField(fieldDef, {}));
                }
              }
            }
            return details2;
          }
          case SIZE:
            if (mark === "trail") {
              return details2;
            }
          case COLOR:
          case FILL:
          case STROKE:
          case OPACITY:
          case FILLOPACITY:
          case STROKEOPACITY:
          case STROKEDASH:
          case STROKEWIDTH: {
            const fieldDef = getFieldDef(encoding[channel]);
            if (fieldDef && !fieldDef.aggregate) {
              details2.push(vgField(fieldDef, {}));
            }
            return details2;
          }
        }
      }, []);
    }
    function filterTooltipWithAggregatedField(oldEncoding) {
      const { tooltip: tooltip2, ...filteredEncoding } = oldEncoding;
      if (!tooltip2) {
        return { filteredEncoding };
      }
      let customTooltipWithAggregatedField;
      let customTooltipWithoutAggregatedField;
      if (isArray(tooltip2)) {
        for (const t4 of tooltip2) {
          if (t4.aggregate) {
            if (!customTooltipWithAggregatedField) {
              customTooltipWithAggregatedField = [];
            }
            customTooltipWithAggregatedField.push(t4);
          } else {
            if (!customTooltipWithoutAggregatedField) {
              customTooltipWithoutAggregatedField = [];
            }
            customTooltipWithoutAggregatedField.push(t4);
          }
        }
        if (customTooltipWithAggregatedField) {
          filteredEncoding.tooltip = customTooltipWithAggregatedField;
        }
      } else {
        if (tooltip2["aggregate"]) {
          filteredEncoding.tooltip = tooltip2;
        } else {
          customTooltipWithoutAggregatedField = tooltip2;
        }
      }
      if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
        customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
      }
      return { customTooltipWithoutAggregatedField, filteredEncoding };
    }
    function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
      if ("tooltip" in encodingWithoutContinuousAxis) {
        return { tooltip: encodingWithoutContinuousAxis.tooltip };
      }
      const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
        const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
        return {
          field: fieldPrefix + continuousAxisChannelDef.field,
          type: continuousAxisChannelDef.type,
          title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}"${escape(mainTitle)}"` } : titlePrefix + mainTitle
        };
      });
      const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
      return {
        tooltip: [
          ...fiveSummaryTooltip,
          // need to cast because TextFieldDef supports fewer types of bin
          ...unique(tooltipFieldDefs, hash)
        ]
      };
    }
    function getTitle(continuousAxisChannelDef) {
      const { title: title2, field: field2 } = continuousAxisChannelDef;
      return getFirstDefined(title2, field2);
    }
    function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
      const { scale: scale2, axis: axis2 } = continuousAxisChannelDef;
      return ({ partName, mark, positionPrefix, endPositionPrefix = void 0, extraEncoding = {} }) => {
        const title2 = getTitle(continuousAxisChannelDef);
        return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {
          mark,
          encoding: {
            [continuousAxis]: {
              field: `${positionPrefix}_${continuousAxisChannelDef.field}`,
              type: continuousAxisChannelDef.type,
              ...title2 !== void 0 ? { title: title2 } : {},
              ...scale2 !== void 0 ? { scale: scale2 } : {},
              ...axis2 !== void 0 ? { axis: axis2 } : {}
            },
            ...isString(endPositionPrefix) ? {
              [`${continuousAxis}2`]: {
                field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`
              }
            } : {},
            ...sharedEncoding,
            ...extraEncoding
          }
        });
      };
    }
    function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
      const { clip: clip2, color: color2, opacity: opacity2 } = markDef;
      const mark = markDef.type;
      if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
        return [
          {
            ...partBaseSpec,
            mark: {
              ...compositeMarkConfig[part],
              ...clip2 ? { clip: clip2 } : {},
              ...color2 ? { color: color2 } : {},
              ...opacity2 ? { opacity: opacity2 } : {},
              ...isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark },
              style: `${mark}-${String(part)}`,
              ...isBoolean$2(markDef[part]) ? {} : markDef[part]
            }
          }
        ];
      }
      return [];
    }
    function compositeMarkContinuousAxis(spec, orient2, compositeMark) {
      const { encoding } = spec;
      const continuousAxis = orient2 === "vertical" ? "y" : "x";
      const continuousAxisChannelDef = encoding[continuousAxis];
      const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];
      const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];
      const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];
      return {
        continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
        continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
        continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
        continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
        continuousAxis
      };
    }
    function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
      if (continuousAxisChannelDef == null ? void 0 : continuousAxisChannelDef.aggregate) {
        const { aggregate, ...continuousAxisWithoutAggregate } = continuousAxisChannelDef;
        if (aggregate !== compositeMark) {
          warn(errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
        }
        return continuousAxisWithoutAggregate;
      } else {
        return continuousAxisChannelDef;
      }
    }
    function compositeMarkOrient(spec, compositeMark) {
      const { mark, encoding } = spec;
      const { x: x2, y: y2 } = encoding;
      if (isMarkDef(mark) && mark.orient) {
        return mark.orient;
      }
      if (isContinuousFieldOrDatumDef(x2)) {
        if (isContinuousFieldOrDatumDef(y2)) {
          const xAggregate = isFieldDef(x2) && x2.aggregate;
          const yAggregate = isFieldDef(y2) && y2.aggregate;
          if (!xAggregate && yAggregate === compositeMark) {
            return "vertical";
          } else if (!yAggregate && xAggregate === compositeMark) {
            return "horizontal";
          } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
            throw new Error("Both x and y cannot have aggregate");
          } else {
            if (isFieldOrDatumDefForTimeFormat(y2) && !isFieldOrDatumDefForTimeFormat(x2)) {
              return "horizontal";
            }
            return "vertical";
          }
        }
        return "horizontal";
      } else if (isContinuousFieldOrDatumDef(y2)) {
        return "vertical";
      } else {
        throw new Error(`Need a valid continuous axis for ${compositeMark}s`);
      }
    }
    const BOXPLOT = "boxplot";
    const BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
    const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
    function getBoxPlotType(extent2) {
      if (isNumber$1(extent2)) {
        return "tukey";
      }
      return extent2;
    }
    function normalizeBoxPlot(spec, { config }) {
      spec = {
        ...spec,
        encoding: normalizeEncoding(spec.encoding, config)
      };
      const { mark, encoding: _encoding, params: params2, projection: _p, ...outerSpec } = spec;
      const markDef = isMarkDef(mark) ? mark : { type: mark };
      if (params2) {
        warn(selectionNotSupported("boxplot"));
      }
      const extent2 = markDef.extent ?? config.boxplot.extent;
      const sizeValue = getMarkPropOrConfig(
        "size",
        markDef,
        // TODO: https://github.com/vega/vega-lite/issues/6245
        config
      );
      const invalid = markDef.invalid;
      const boxPlotType = getBoxPlotType(extent2);
      const { bins: bins2, timeUnits: timeUnits2, transform: transform2, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent2, config);
      const { color: color2, size: size2, ...encodingWithoutSizeColorAndContinuousAxis } = encodingWithoutContinuousAxis;
      const makeBoxPlotPart = (sharedEncoding) => {
        return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
      };
      const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
      const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
      const makeBoxPlotMidTick = makeBoxPlotPart({ ...encodingWithoutSizeColorAndContinuousAxis, ...size2 ? { size: size2 } : {} });
      const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
        { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
        { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
        { fieldPrefix: "mid_box_", titlePrefix: "Median" },
        { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
        { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
      ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
      const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid, aria: false };
      const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : (
        // for tukey / k-IQR, just show upper/lower-whisker
        getCompositeMarkTooltip([
          { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
          { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
        ], continuousAxisChannelDef, encodingWithoutContinuousAxis)
      );
      const whiskerLayers = [
        ...makeBoxPlotExtent({
          partName: "rule",
          mark: { type: "rule", invalid, aria: false },
          positionPrefix: "lower_whisker",
          endPositionPrefix: "lower_box",
          extraEncoding: whiskerTooltipEncoding
        }),
        ...makeBoxPlotExtent({
          partName: "rule",
          mark: { type: "rule", invalid, aria: false },
          positionPrefix: "upper_box",
          endPositionPrefix: "upper_whisker",
          extraEncoding: whiskerTooltipEncoding
        }),
        ...makeBoxPlotExtent({
          partName: "ticks",
          mark: endTick,
          positionPrefix: "lower_whisker",
          extraEncoding: whiskerTooltipEncoding
        }),
        ...makeBoxPlotExtent({
          partName: "ticks",
          mark: endTick,
          positionPrefix: "upper_whisker",
          extraEncoding: whiskerTooltipEncoding
        })
      ];
      const boxLayers = [
        ...boxPlotType !== "tukey" ? whiskerLayers : [],
        ...makeBoxPlotBox({
          partName: "box",
          mark: {
            type: "bar",
            ...sizeValue ? { size: sizeValue } : {},
            orient: boxOrient,
            invalid,
            ariaRoleDescription: "box"
          },
          positionPrefix: "lower_box",
          endPositionPrefix: "upper_box",
          extraEncoding: fiveSummaryTooltipEncoding
        }),
        ...makeBoxPlotMidTick({
          partName: "median",
          mark: {
            type: "tick",
            invalid,
            ...isObject(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {},
            ...sizeValue ? { size: sizeValue } : {},
            orient: ticksOrient,
            aria: false
          },
          positionPrefix: "mid_box",
          extraEncoding: fiveSummaryTooltipEncoding
        })
      ];
      if (boxPlotType === "min-max") {
        return {
          ...outerSpec,
          transform: (outerSpec.transform ?? []).concat(transform2),
          layer: boxLayers
        };
      }
      const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
      const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
      const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
      const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent2} * ${iqrExpr}`;
      const upperWhiskerExpr = `${upperBoxExpr} + ${extent2} * ${iqrExpr}`;
      const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
      const joinaggregateTransform = {
        joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
        groupby
      };
      const filteredWhiskerSpec = {
        transform: [
          {
            filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
          },
          {
            aggregate: [
              {
                op: "min",
                field: continuousAxisChannelDef.field,
                as: `lower_whisker_${continuousAxisChannelDef.field}`
              },
              {
                op: "max",
                field: continuousAxisChannelDef.field,
                as: `upper_whisker_${continuousAxisChannelDef.field}`
              },
              // preserve lower_box / upper_box
              {
                op: "min",
                field: `lower_box_${continuousAxisChannelDef.field}`,
                as: `lower_box_${continuousAxisChannelDef.field}`
              },
              {
                op: "max",
                field: `upper_box_${continuousAxisChannelDef.field}`,
                as: `upper_box_${continuousAxisChannelDef.field}`
              },
              ...aggregate
            ],
            groupby
          }
        ],
        layer: whiskerLayers
      };
      const { tooltip: tooltip2, ...encodingWithoutSizeColorContinuousAxisAndTooltip } = encodingWithoutSizeColorAndContinuousAxis;
      const { scale: scale2, axis: axis2 } = continuousAxisChannelDef;
      const title2 = getTitle(continuousAxisChannelDef);
      const axisWithoutTitle = omit(axis2, ["title"]);
      const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, {
        transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
        mark: "point",
        encoding: {
          [continuousAxis]: {
            field: continuousAxisChannelDef.field,
            type: continuousAxisChannelDef.type,
            ...title2 !== void 0 ? { title: title2 } : {},
            ...scale2 !== void 0 ? { scale: scale2 } : {},
            // add axis without title since we already added the title above
            ...isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle }
          },
          ...encodingWithoutSizeColorContinuousAxisAndTooltip,
          ...color2 ? { color: color2 } : {},
          ...customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {}
        }
      })[0];
      let filteredLayersMixins;
      const filteredLayersMixinsTransforms = [...bins2, ...timeUnits2, joinaggregateTransform];
      if (outlierLayersMixins) {
        filteredLayersMixins = {
          transform: filteredLayersMixinsTransforms,
          layer: [outlierLayersMixins, filteredWhiskerSpec]
        };
      } else {
        filteredLayersMixins = filteredWhiskerSpec;
        filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);
      }
      return {
        ...outerSpec,
        layer: [
          filteredLayersMixins,
          {
            // boxplot
            transform: transform2,
            layer: boxLayers
          }
        ]
      };
    }
    function boxParamsQuartiles(continousAxisField) {
      return [
        {
          op: "q1",
          field: continousAxisField,
          as: `lower_box_${continousAxisField}`
        },
        {
          op: "q3",
          field: continousAxisField,
          as: `upper_box_${continousAxisField}`
        }
      ];
    }
    function boxParams(spec, extent2, config) {
      const orient2 = compositeMarkOrient(spec, BOXPLOT);
      const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, BOXPLOT);
      const continuousFieldName = continuousAxisChannelDef.field;
      const boxPlotType = getBoxPlotType(extent2);
      const boxplotSpecificAggregate = [
        ...boxParamsQuartiles(continuousFieldName),
        {
          op: "median",
          field: continuousFieldName,
          as: `mid_box_${continuousFieldName}`
        },
        {
          op: "min",
          field: continuousFieldName,
          as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
        },
        {
          op: "max",
          field: continuousFieldName,
          as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
        }
      ];
      const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
        // This is for the  original k-IQR, which we do not expose
        {
          calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
          as: `iqr_${continuousFieldName}`
        },
        {
          calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent2}, datum["max_${continuousFieldName}"])`,
          as: `upper_whisker_${continuousFieldName}`
        },
        {
          calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent2}, datum["min_${continuousFieldName}"])`,
          as: `lower_whisker_${continuousFieldName}`
        }
      ];
      const { [continuousAxis]: oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis } = spec.encoding;
      const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
      const { bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
      const ticksOrient = orient2 === "vertical" ? "horizontal" : "vertical";
      const boxOrient = orient2;
      const transform2 = [
        ...bins2,
        ...timeUnits2,
        {
          aggregate: [...aggregate, ...boxplotSpecificAggregate],
          groupby
        },
        ...postAggregateCalculates
      ];
      return {
        bins: bins2,
        timeUnits: timeUnits2,
        transform: transform2,
        groupby,
        aggregate,
        continuousAxisChannelDef,
        continuousAxis,
        encodingWithoutContinuousAxis,
        ticksOrient,
        boxOrient,
        customTooltipWithoutAggregatedField
      };
    }
    const ERRORBAR = "errorbar";
    const ERRORBAR_PARTS = ["ticks", "rule"];
    const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
    function normalizeErrorBar(spec, { config }) {
      spec = {
        ...spec,
        encoding: normalizeEncoding(spec.encoding, config)
      };
      const { transform: transform2, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
      delete encodingWithoutContinuousAxis["size"];
      const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
      const thickness = markDef.thickness;
      const size2 = markDef.size;
      const tick2 = {
        type: "tick",
        orient: ticksOrient,
        aria: false,
        ...thickness !== void 0 ? { thickness } : {},
        ...size2 !== void 0 ? { size: size2 } : {}
      };
      const layer = [
        ...makeErrorBarPart({
          partName: "ticks",
          mark: tick2,
          positionPrefix: "lower",
          extraEncoding: tooltipEncoding
        }),
        ...makeErrorBarPart({
          partName: "ticks",
          mark: tick2,
          positionPrefix: "upper",
          extraEncoding: tooltipEncoding
        }),
        ...makeErrorBarPart({
          partName: "rule",
          mark: {
            type: "rule",
            ariaRoleDescription: "errorbar",
            ...thickness !== void 0 ? { size: thickness } : {}
          },
          positionPrefix: "lower",
          endPositionPrefix: "upper",
          extraEncoding: tooltipEncoding
        })
      ];
      return {
        ...outerSpec,
        transform: transform2,
        ...layer.length > 1 ? { layer } : { ...layer[0] }
      };
    }
    function errorBarOrientAndInputType(spec, compositeMark) {
      const { encoding } = spec;
      if (errorBarIsInputTypeRaw(encoding)) {
        return {
          orient: compositeMarkOrient(spec, compositeMark),
          inputType: "raw"
        };
      }
      const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
      const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
      const x2 = encoding.x;
      const y2 = encoding.y;
      if (isTypeAggregatedUpperLower) {
        if (isTypeAggregatedError) {
          throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
        }
        const x22 = encoding.x2;
        const y22 = encoding.y2;
        if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
          throw new Error(`${compositeMark} cannot have both x2 and y2`);
        } else if (isFieldOrDatumDef(x22)) {
          if (isContinuousFieldOrDatumDef(x2)) {
            return { orient: "horizontal", inputType: "aggregated-upper-lower" };
          } else {
            throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
          }
        } else if (isFieldOrDatumDef(y22)) {
          if (isContinuousFieldOrDatumDef(y2)) {
            return { orient: "vertical", inputType: "aggregated-upper-lower" };
          } else {
            throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
          }
        }
        throw new Error("No ranged axis");
      } else {
        const xError = encoding.xError;
        const xError2 = encoding.xError2;
        const yError = encoding.yError;
        const yError2 = encoding.yError2;
        if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
          throw new Error(`${compositeMark} cannot have xError2 without xError`);
        }
        if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
          throw new Error(`${compositeMark} cannot have yError2 without yError`);
        }
        if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
          throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
        } else if (isFieldOrDatumDef(xError)) {
          if (isContinuousFieldOrDatumDef(x2)) {
            return { orient: "horizontal", inputType: "aggregated-error" };
          } else {
            throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
          }
        } else if (isFieldOrDatumDef(yError)) {
          if (isContinuousFieldOrDatumDef(y2)) {
            return { orient: "vertical", inputType: "aggregated-error" };
          } else {
            throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
          }
        }
        throw new Error("No ranged axis");
      }
    }
    function errorBarIsInputTypeRaw(encoding) {
      return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
    }
    function errorBarIsInputTypeAggregatedUpperLower(encoding) {
      return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
    }
    function errorBarIsInputTypeAggregatedError(encoding) {
      return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
    }
    function errorBarParams(spec, compositeMark, config) {
      const { mark, encoding, params: params2, projection: _p, ...outerSpec } = spec;
      const markDef = isMarkDef(mark) ? mark : { type: mark };
      if (params2) {
        warn(selectionNotSupported(compositeMark));
      }
      const { orient: orient2, inputType } = errorBarOrientAndInputType(spec, compositeMark);
      const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, compositeMark);
      const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
      const { [continuousAxis]: oldContinuousAxisChannelDef, [continuousAxis === "x" ? "x2" : "y2"]: oldContinuousAxisChannelDef2, [continuousAxis === "x" ? "xError" : "yError"]: oldContinuousAxisChannelDefError, [continuousAxis === "x" ? "xError2" : "yError2"]: oldContinuousAxisChannelDefError2, ...oldEncodingWithoutContinuousAxis } = encoding;
      const { bins: bins2, timeUnits: timeUnits2, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
      const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
      const groupby = inputType !== "raw" ? [] : oldGroupBy;
      const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
      return {
        transform: [
          ...outerSpec.transform ?? [],
          ...bins2,
          ...timeUnits2,
          ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
          ...postAggregateCalculates
        ],
        groupby,
        continuousAxisChannelDef,
        continuousAxis,
        encodingWithoutContinuousAxis,
        ticksOrient: orient2 === "vertical" ? "horizontal" : "vertical",
        markDef,
        outerSpec,
        tooltipEncoding
      };
    }
    function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
      let errorBarSpecificAggregate = [];
      let postAggregateCalculates = [];
      const continuousFieldName = continuousAxisChannelDef.field;
      let tooltipSummary;
      let tooltipTitleWithFieldName = false;
      if (inputType === "raw") {
        const center2 = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
        const extent2 = markDef.extent ? markDef.extent : center2 === "mean" ? "stderr" : "iqr";
        if (center2 === "median" !== (extent2 === "iqr")) {
          warn(errorBarCenterIsUsedWithWrongExtent(center2, extent2, compositeMark));
        }
        if (extent2 === "stderr" || extent2 === "stdev") {
          errorBarSpecificAggregate = [
            { op: extent2, field: continuousFieldName, as: `extent_${continuousFieldName}` },
            { op: center2, field: continuousFieldName, as: `center_${continuousFieldName}` }
          ];
          postAggregateCalculates = [
            {
              calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
              as: `upper_${continuousFieldName}`
            },
            {
              calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
              as: `lower_${continuousFieldName}`
            }
          ];
          tooltipSummary = [
            { fieldPrefix: "center_", titlePrefix: titleCase(center2) },
            { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center2, extent2, "+") },
            { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center2, extent2, "-") }
          ];
          tooltipTitleWithFieldName = true;
        } else {
          let centerOp;
          let lowerExtentOp;
          let upperExtentOp;
          if (extent2 === "ci") {
            centerOp = "mean";
            lowerExtentOp = "ci0";
            upperExtentOp = "ci1";
          } else {
            centerOp = "median";
            lowerExtentOp = "q1";
            upperExtentOp = "q3";
          }
          errorBarSpecificAggregate = [
            { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },
            { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },
            { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }
          ];
          tooltipSummary = [
            {
              fieldPrefix: "upper_",
              titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
                allowDisabling: false
              })
            },
            {
              fieldPrefix: "lower_",
              titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
                allowDisabling: false
              })
            },
            {
              fieldPrefix: "center_",
              titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
                allowDisabling: false
              })
            }
          ];
        }
      } else {
        if (markDef.center || markDef.extent) {
          warn(errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
        }
        if (inputType === "aggregated-upper-lower") {
          tooltipSummary = [];
          postAggregateCalculates = [
            { calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: `upper_${continuousFieldName}` },
            { calculate: `datum["${continuousFieldName}"]`, as: `lower_${continuousFieldName}` }
          ];
        } else if (inputType === "aggregated-error") {
          tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
          postAggregateCalculates = [
            {
              calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
              as: `upper_${continuousFieldName}`
            }
          ];
          if (continuousAxisChannelDefError2) {
            postAggregateCalculates.push({
              calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
              as: `lower_${continuousFieldName}`
            });
          } else {
            postAggregateCalculates.push({
              calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
              as: `lower_${continuousFieldName}`
            });
          }
        }
        for (const postAggregateCalculate of postAggregateCalculates) {
          tooltipSummary.push({
            fieldPrefix: postAggregateCalculate.as.substring(0, 6),
            titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
          });
        }
      }
      return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
    }
    function getTitlePrefix(center2, extent2, operation) {
      return `${titleCase(center2)} ${operation} ${extent2}`;
    }
    const ERRORBAND = "errorband";
    const ERRORBAND_PARTS = ["band", "borders"];
    const errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
    function normalizeErrorBand(spec, { config }) {
      spec = {
        ...spec,
        encoding: normalizeEncoding(spec.encoding, config)
      };
      const { transform: transform2, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
      const errorBandDef = markDef;
      const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
      const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
      let bandMark = { type: is2D ? "area" : "rect" };
      let bordersMark = { type: is2D ? "line" : "rule" };
      const interpolate2 = {
        ...errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {},
        ...errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {}
      };
      if (is2D) {
        bandMark = {
          ...bandMark,
          ...interpolate2,
          ariaRoleDescription: "errorband"
        };
        bordersMark = {
          ...bordersMark,
          ...interpolate2,
          aria: false
        };
      } else if (errorBandDef.interpolate) {
        warn(errorBand1DNotSupport("interpolate"));
      } else if (errorBandDef.tension) {
        warn(errorBand1DNotSupport("tension"));
      }
      return {
        ...outerSpec,
        transform: transform2,
        layer: [
          ...makeErrorBandPart({
            partName: "band",
            mark: bandMark,
            positionPrefix: "lower",
            endPositionPrefix: "upper",
            extraEncoding: tooltipEncoding
          }),
          ...makeErrorBandPart({
            partName: "borders",
            mark: bordersMark,
            positionPrefix: "lower",
            extraEncoding: tooltipEncoding
          }),
          ...makeErrorBandPart({
            partName: "borders",
            mark: bordersMark,
            positionPrefix: "upper",
            extraEncoding: tooltipEncoding
          })
        ]
      };
    }
    const compositeMarkRegistry = {};
    function add(mark, run2, parts) {
      const normalizer = new CompositeMarkNormalizer(mark, run2);
      compositeMarkRegistry[mark] = { normalizer, parts };
    }
    function getAllCompositeMarks() {
      return keys(compositeMarkRegistry);
    }
    add(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
    add(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
    add(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);
    const VL_ONLY_LEGEND_CONFIG = [
      "gradientHorizontalMaxLength",
      "gradientHorizontalMinLength",
      "gradientVerticalMaxLength",
      "gradientVerticalMinLength",
      "unselectedOpacity"
    ];
    const HEADER_TITLE_PROPERTIES_MAP = {
      titleAlign: "align",
      titleAnchor: "anchor",
      titleAngle: "angle",
      titleBaseline: "baseline",
      titleColor: "color",
      titleFont: "font",
      titleFontSize: "fontSize",
      titleFontStyle: "fontStyle",
      titleFontWeight: "fontWeight",
      titleLimit: "limit",
      titleLineHeight: "lineHeight",
      titleOrient: "orient",
      titlePadding: "offset"
    };
    const HEADER_LABEL_PROPERTIES_MAP = {
      labelAlign: "align",
      labelAnchor: "anchor",
      labelAngle: "angle",
      labelBaseline: "baseline",
      labelColor: "color",
      labelFont: "font",
      labelFontSize: "fontSize",
      labelFontStyle: "fontStyle",
      labelFontWeight: "fontWeight",
      labelLimit: "limit",
      labelLineHeight: "lineHeight",
      labelOrient: "orient",
      labelPadding: "offset"
    };
    const HEADER_TITLE_PROPERTIES = keys(HEADER_TITLE_PROPERTIES_MAP);
    const HEADER_LABEL_PROPERTIES = keys(HEADER_LABEL_PROPERTIES_MAP);
    const HEADER_CONFIGS_INDEX = {
      header: 1,
      headerRow: 1,
      headerColumn: 1,
      headerFacet: 1
    };
    const HEADER_CONFIGS = keys(HEADER_CONFIGS_INDEX);
    const LEGEND_SCALE_CHANNELS = [
      "size",
      "shape",
      "fill",
      "stroke",
      "strokeDash",
      "strokeWidth",
      "opacity"
    ];
    const defaultLegendConfig = {
      gradientHorizontalMaxLength: 200,
      gradientHorizontalMinLength: 100,
      gradientVerticalMaxLength: 200,
      gradientVerticalMinLength: 64,
      unselectedOpacity: 0.35
    };
    const COMMON_LEGEND_PROPERTY_INDEX = {
      aria: 1,
      clipHeight: 1,
      columnPadding: 1,
      columns: 1,
      cornerRadius: 1,
      description: 1,
      direction: 1,
      fillColor: 1,
      format: 1,
      formatType: 1,
      gradientLength: 1,
      gradientOpacity: 1,
      gradientStrokeColor: 1,
      gradientStrokeWidth: 1,
      gradientThickness: 1,
      gridAlign: 1,
      labelAlign: 1,
      labelBaseline: 1,
      labelColor: 1,
      labelFont: 1,
      labelFontSize: 1,
      labelFontStyle: 1,
      labelFontWeight: 1,
      labelLimit: 1,
      labelOffset: 1,
      labelOpacity: 1,
      labelOverlap: 1,
      labelPadding: 1,
      labelSeparation: 1,
      legendX: 1,
      legendY: 1,
      offset: 1,
      orient: 1,
      padding: 1,
      rowPadding: 1,
      strokeColor: 1,
      symbolDash: 1,
      symbolDashOffset: 1,
      symbolFillColor: 1,
      symbolLimit: 1,
      symbolOffset: 1,
      symbolOpacity: 1,
      symbolSize: 1,
      symbolStrokeColor: 1,
      symbolStrokeWidth: 1,
      symbolType: 1,
      tickCount: 1,
      tickMinStep: 1,
      title: 1,
      titleAlign: 1,
      titleAnchor: 1,
      titleBaseline: 1,
      titleColor: 1,
      titleFont: 1,
      titleFontSize: 1,
      titleFontStyle: 1,
      titleFontWeight: 1,
      titleLimit: 1,
      titleLineHeight: 1,
      titleOpacity: 1,
      titleOrient: 1,
      titlePadding: 1,
      type: 1,
      values: 1,
      zindex: 1
    };
    const SELECTION_ID = "_vgsid_";
    const defaultConfig$1 = {
      point: {
        on: "click",
        fields: [SELECTION_ID],
        toggle: "event.shiftKey",
        resolve: "global",
        clear: "dblclick"
      },
      interval: {
        on: "[pointerdown, window:pointerup] > window:pointermove!",
        encodings: ["x", "y"],
        translate: "[pointerdown, window:pointerup] > window:pointermove!",
        zoom: "wheel!",
        mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
        resolve: "global",
        clear: "dblclick"
      }
    };
    function isLegendBinding(bind2) {
      return bind2 === "legend" || !!(bind2 == null ? void 0 : bind2.legend);
    }
    function isLegendStreamBinding(bind2) {
      return isLegendBinding(bind2) && isObject(bind2);
    }
    function isSelectionParameter(param2) {
      return !!(param2 == null ? void 0 : param2["select"]);
    }
    function assembleParameterSignals(params2) {
      const signals = [];
      for (const param2 of params2 || []) {
        if (isSelectionParameter(param2))
          continue;
        const { expr: expr2, bind: bind2, ...rest } = param2;
        if (bind2 && expr2) {
          const signal = {
            ...rest,
            bind: bind2,
            init: expr2
          };
          signals.push(signal);
        } else {
          const signal = {
            ...rest,
            ...expr2 ? { update: expr2 } : {},
            ...bind2 ? { bind: bind2 } : {}
          };
          signals.push(signal);
        }
      }
      return signals;
    }
    function isAnyConcatSpec(spec) {
      return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
    }
    function isConcatSpec(spec) {
      return "concat" in spec;
    }
    function isVConcatSpec(spec) {
      return "vconcat" in spec;
    }
    function isHConcatSpec(spec) {
      return "hconcat" in spec;
    }
    function getStepFor({ step, offsetIsDiscrete }) {
      if (offsetIsDiscrete) {
        return step.for ?? "offset";
      } else {
        return "position";
      }
    }
    function isStep(size2) {
      return isObject(size2) && size2["step"] !== void 0;
    }
    function isFrameMixins(o) {
      return o["view"] || o["width"] || o["height"];
    }
    const DEFAULT_SPACING = 20;
    const COMPOSITION_LAYOUT_INDEX = {
      align: 1,
      bounds: 1,
      center: 1,
      columns: 1,
      spacing: 1
    };
    const COMPOSITION_LAYOUT_PROPERTIES = keys(COMPOSITION_LAYOUT_INDEX);
    function extractCompositionLayout(spec, specType, config) {
      const compositionConfig = config[specType];
      const layout = {};
      const { spacing: spacingConfig, columns } = compositionConfig;
      if (spacingConfig !== void 0) {
        layout.spacing = spacingConfig;
      }
      if (columns !== void 0) {
        if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
          layout.columns = columns;
        }
      }
      if (isVConcatSpec(spec)) {
        layout.columns = 1;
      }
      for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
        if (spec[prop] !== void 0) {
          if (prop === "spacing") {
            const spacing = spec[prop];
            layout[prop] = isNumber$1(spacing) ? spacing : {
              row: spacing.row ?? spacingConfig,
              column: spacing.column ?? spacingConfig
            };
          } else {
            layout[prop] = spec[prop];
          }
        }
      }
      return layout;
    }
    function getViewConfigContinuousSize(viewConfig, channel) {
      return viewConfig[channel] ?? viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
    }
    function getViewConfigDiscreteStep(viewConfig, channel) {
      const size2 = getViewConfigDiscreteSize(viewConfig, channel);
      return isStep(size2) ? size2.step : DEFAULT_STEP;
    }
    function getViewConfigDiscreteSize(viewConfig, channel) {
      const size2 = viewConfig[channel] ?? viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
      return getFirstDefined(size2, { step: viewConfig.step });
    }
    const DEFAULT_STEP = 20;
    const defaultViewConfig = {
      continuousWidth: 200,
      continuousHeight: 200,
      step: DEFAULT_STEP
    };
    const defaultConfig = {
      background: "white",
      padding: 5,
      timeFormat: "%b %d, %Y",
      countTitle: "Count of Records",
      view: defaultViewConfig,
      mark: defaultMarkConfig,
      arc: {},
      area: {},
      bar: defaultBarConfig,
      circle: {},
      geoshape: {},
      image: {},
      line: {},
      point: {},
      rect: defaultRectConfig,
      rule: { color: "black" },
      square: {},
      text: { color: "black" },
      tick: defaultTickConfig,
      trail: {},
      boxplot: {
        size: 14,
        extent: 1.5,
        box: {},
        median: { color: "white" },
        outliers: {},
        rule: {},
        ticks: null
      },
      errorbar: {
        center: "mean",
        rule: true,
        ticks: false
      },
      errorband: {
        band: {
          opacity: 0.3
        },
        borders: false
      },
      scale: defaultScaleConfig,
      projection: {},
      legend: defaultLegendConfig,
      header: { titlePadding: 10, labelPadding: 10 },
      headerColumn: {},
      headerRow: {},
      headerFacet: {},
      selection: defaultConfig$1,
      style: {},
      title: {},
      facet: { spacing: DEFAULT_SPACING },
      concat: { spacing: DEFAULT_SPACING },
      normalizedNumberFormat: ".0%"
    };
    const tab10 = [
      "#4c78a8",
      "#f58518",
      "#e45756",
      "#72b7b2",
      "#54a24b",
      "#eeca3b",
      "#b279a2",
      "#ff9da6",
      "#9d755d",
      "#bab0ac"
    ];
    const DEFAULT_FONT_SIZE = {
      text: 11,
      guideLabel: 10,
      guideTitle: 11,
      groupTitle: 13,
      groupSubtitle: 12
    };
    const DEFAULT_COLOR = {
      blue: tab10[0],
      orange: tab10[1],
      red: tab10[2],
      teal: tab10[3],
      green: tab10[4],
      yellow: tab10[5],
      purple: tab10[6],
      pink: tab10[7],
      brown: tab10[8],
      gray0: "#000",
      gray1: "#111",
      gray2: "#222",
      gray3: "#333",
      gray4: "#444",
      gray5: "#555",
      gray6: "#666",
      gray7: "#777",
      gray8: "#888",
      gray9: "#999",
      gray10: "#aaa",
      gray11: "#bbb",
      gray12: "#ccc",
      gray13: "#ddd",
      gray14: "#eee",
      gray15: "#fff"
    };
    function colorSignalConfig(color2 = {}) {
      return {
        signals: [
          {
            name: "color",
            value: isObject(color2) ? { ...DEFAULT_COLOR, ...color2 } : DEFAULT_COLOR
          }
        ],
        mark: { color: { signal: "color.blue" } },
        rule: { color: { signal: "color.gray0" } },
        text: {
          color: { signal: "color.gray0" }
        },
        style: {
          "guide-label": {
            fill: { signal: "color.gray0" }
          },
          "guide-title": {
            fill: { signal: "color.gray0" }
          },
          "group-title": {
            fill: { signal: "color.gray0" }
          },
          "group-subtitle": {
            fill: { signal: "color.gray0" }
          },
          cell: {
            stroke: { signal: "color.gray8" }
          }
        },
        axis: {
          domainColor: { signal: "color.gray13" },
          gridColor: { signal: "color.gray8" },
          tickColor: { signal: "color.gray13" }
        },
        range: {
          category: [
            { signal: "color.blue" },
            { signal: "color.orange" },
            { signal: "color.red" },
            { signal: "color.teal" },
            { signal: "color.green" },
            { signal: "color.yellow" },
            { signal: "color.purple" },
            { signal: "color.pink" },
            { signal: "color.brown" },
            { signal: "color.grey8" }
          ]
        }
      };
    }
    function fontSizeSignalConfig(fontSize2) {
      return {
        signals: [
          {
            name: "fontSize",
            value: isObject(fontSize2) ? { ...DEFAULT_FONT_SIZE, ...fontSize2 } : DEFAULT_FONT_SIZE
          }
        ],
        text: {
          fontSize: { signal: "fontSize.text" }
        },
        style: {
          "guide-label": {
            fontSize: { signal: "fontSize.guideLabel" }
          },
          "guide-title": {
            fontSize: { signal: "fontSize.guideTitle" }
          },
          "group-title": {
            fontSize: { signal: "fontSize.groupTitle" }
          },
          "group-subtitle": {
            fontSize: { signal: "fontSize.groupSubtitle" }
          }
        }
      };
    }
    function fontConfig(font2) {
      return {
        text: { font: font2 },
        style: {
          "guide-label": { font: font2 },
          "guide-title": { font: font2 },
          "group-title": { font: font2 },
          "group-subtitle": { font: font2 }
        }
      };
    }
    function getAxisConfigInternal(axisConfig2) {
      const props = keys(axisConfig2 || {});
      const axisConfigInternal = {};
      for (const prop of props) {
        const val = axisConfig2[prop];
        axisConfigInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
      }
      return axisConfigInternal;
    }
    function getStyleConfigInternal(styleConfig) {
      const props = keys(styleConfig);
      const styleConfigInternal = {};
      for (const prop of props) {
        styleConfigInternal[prop] = getAxisConfigInternal(styleConfig[prop]);
      }
      return styleConfigInternal;
    }
    const configPropsWithExpr = [
      ...MARK_CONFIGS,
      ...AXIS_CONFIGS,
      ...HEADER_CONFIGS,
      "background",
      "padding",
      "legend",
      "lineBreak",
      "scale",
      "style",
      "title",
      "view"
    ];
    function initConfig(specifiedConfig = {}) {
      const { color: color2, font: font2, fontSize: fontSize2, selection: selection2, ...restConfig } = specifiedConfig;
      const mergedConfig = mergeConfig({}, duplicate(defaultConfig), font2 ? fontConfig(font2) : {}, color2 ? colorSignalConfig(color2) : {}, fontSize2 ? fontSizeSignalConfig(fontSize2) : {}, restConfig || {});
      if (selection2) {
        writeConfig(mergedConfig, "selection", selection2, true);
      }
      const outputConfig = omit(mergedConfig, configPropsWithExpr);
      for (const prop of ["background", "lineBreak", "padding"]) {
        if (mergedConfig[prop]) {
          outputConfig[prop] = signalRefOrValue(mergedConfig[prop]);
        }
      }
      for (const markConfigType of MARK_CONFIGS) {
        if (mergedConfig[markConfigType]) {
          outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]);
        }
      }
      for (const axisConfigType of AXIS_CONFIGS) {
        if (mergedConfig[axisConfigType]) {
          outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]);
        }
      }
      for (const headerConfigType of HEADER_CONFIGS) {
        if (mergedConfig[headerConfigType]) {
          outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]);
        }
      }
      if (mergedConfig.legend) {
        outputConfig.legend = replaceExprRef(mergedConfig.legend);
      }
      if (mergedConfig.scale) {
        outputConfig.scale = replaceExprRef(mergedConfig.scale);
      }
      if (mergedConfig.style) {
        outputConfig.style = getStyleConfigInternal(mergedConfig.style);
      }
      if (mergedConfig.title) {
        outputConfig.title = replaceExprRef(mergedConfig.title);
      }
      if (mergedConfig.view) {
        outputConfig.view = replaceExprRef(mergedConfig.view);
      }
      return outputConfig;
    }
    const MARK_STYLES = /* @__PURE__ */ new Set(["view", ...PRIMITIVE_MARKS]);
    const VL_ONLY_CONFIG_PROPERTIES = [
      "color",
      "fontSize",
      "background",
      "padding",
      "facet",
      "concat",
      "numberFormat",
      "numberFormatType",
      "normalizedNumberFormat",
      "normalizedNumberFormatType",
      "timeFormat",
      "countTitle",
      "header",
      "axisQuantitative",
      "axisTemporal",
      "axisDiscrete",
      "axisPoint",
      "axisXBand",
      "axisXPoint",
      "axisXDiscrete",
      "axisXQuantitative",
      "axisXTemporal",
      "axisYBand",
      "axisYPoint",
      "axisYDiscrete",
      "axisYQuantitative",
      "axisYTemporal",
      "scale",
      "selection",
      "overlay"
      // FIXME: Redesign and unhide this
    ];
    const VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
      view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
      ...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX
    };
    function stripAndRedirectConfig(config) {
      config = duplicate(config);
      for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
        delete config[prop];
      }
      if (config.axis) {
        for (const prop in config.axis) {
          if (isConditionalAxisValue(config.axis[prop])) {
            delete config.axis[prop];
          }
        }
      }
      if (config.legend) {
        for (const prop of VL_ONLY_LEGEND_CONFIG) {
          delete config.legend[prop];
        }
      }
      if (config.mark) {
        for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
          delete config.mark[prop];
        }
        if (config.mark.tooltip && isObject(config.mark.tooltip)) {
          delete config.mark.tooltip;
        }
      }
      if (config.params) {
        config.signals = (config.signals || []).concat(assembleParameterSignals(config.params));
        delete config.params;
      }
      for (const markType2 of MARK_STYLES) {
        for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
          delete config[markType2][prop];
        }
        const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
        if (vlOnlyMarkSpecificConfigs) {
          for (const prop of vlOnlyMarkSpecificConfigs) {
            delete config[markType2][prop];
          }
        }
        redirectConfigToStyleConfig(config, markType2);
      }
      for (const m2 of getAllCompositeMarks()) {
        delete config[m2];
      }
      redirectTitleConfig(config);
      for (const prop in config) {
        if (isObject(config[prop]) && isEmpty(config[prop])) {
          delete config[prop];
        }
      }
      return isEmpty(config) ? void 0 : config;
    }
    function redirectTitleConfig(config) {
      const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
      if (!isEmpty(titleMarkConfig)) {
        config.style["group-title"] = {
          ...config.style["group-title"],
          ...titleMarkConfig
          // config.title has higher precedence than config.style.group-title in Vega
        };
      }
      if (!isEmpty(subtitleMarkConfig)) {
        config.style["group-subtitle"] = {
          ...config.style["group-subtitle"],
          ...subtitleMarkConfig
        };
      }
      if (!isEmpty(subtitle)) {
        config.title = subtitle;
      } else {
        delete config.title;
      }
    }
    function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
      const propConfig = compositeMarkPart ? config[prop][compositeMarkPart] : config[prop];
      if (prop === "view") {
        toProp = "cell";
      }
      const style2 = {
        ...propConfig,
        ...config.style[toProp ?? prop]
      };
      if (!isEmpty(style2)) {
        config.style[toProp ?? prop] = style2;
      }
      if (!compositeMarkPart) {
        delete config[prop];
      }
    }
    function isLayerSpec(spec) {
      return "layer" in spec;
    }
    function isRepeatSpec(spec) {
      return "repeat" in spec;
    }
    function isLayerRepeatSpec(spec) {
      return !isArray(spec.repeat) && spec.repeat["layer"];
    }
    class SpecMapper {
      map(spec, params2) {
        if (isFacetSpec(spec)) {
          return this.mapFacet(spec, params2);
        } else if (isRepeatSpec(spec)) {
          return this.mapRepeat(spec, params2);
        } else if (isHConcatSpec(spec)) {
          return this.mapHConcat(spec, params2);
        } else if (isVConcatSpec(spec)) {
          return this.mapVConcat(spec, params2);
        } else if (isConcatSpec(spec)) {
          return this.mapConcat(spec, params2);
        } else {
          return this.mapLayerOrUnit(spec, params2);
        }
      }
      mapLayerOrUnit(spec, params2) {
        if (isLayerSpec(spec)) {
          return this.mapLayer(spec, params2);
        } else if (isUnitSpec(spec)) {
          return this.mapUnit(spec, params2);
        }
        throw new Error(invalidSpec(spec));
      }
      mapLayer(spec, params2) {
        return {
          ...spec,
          layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2))
        };
      }
      mapHConcat(spec, params2) {
        return {
          ...spec,
          hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2))
        };
      }
      mapVConcat(spec, params2) {
        return {
          ...spec,
          vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2))
        };
      }
      mapConcat(spec, params2) {
        const { concat, ...rest } = spec;
        return {
          ...rest,
          concat: concat.map((subspec) => this.map(subspec, params2))
        };
      }
      mapFacet(spec, params2) {
        return {
          // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
          ...spec,
          // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
          spec: this.map(spec.spec, params2)
        };
      }
      mapRepeat(spec, params2) {
        return {
          ...spec,
          // as any is required here since TS cannot infer that the output type satisfies the input type
          spec: this.map(spec.spec, params2)
        };
      }
    }
    const STACK_OFFSET_INDEX = {
      zero: 1,
      center: 1,
      normalize: 1
    };
    function isStackOffset(s) {
      return s in STACK_OFFSET_INDEX;
    }
    const STACKABLE_MARKS = /* @__PURE__ */ new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);
    const STACK_BY_DEFAULT_MARKS = /* @__PURE__ */ new Set([BAR, AREA, ARC]);
    function isUnbinnedQuantitative(channelDef) {
      return isFieldDef(channelDef) && channelDefType(channelDef) === "quantitative" && !channelDef.bin;
    }
    function potentialStackedChannel(encoding, x2, { orient: orient2, type: mark }) {
      const y2 = x2 === "x" ? "y" : "radius";
      const isCartesianBarOrArea = x2 === "x" && ["bar", "area"].includes(mark);
      const xDef = encoding[x2];
      const yDef = encoding[y2];
      if (isFieldDef(xDef) && isFieldDef(yDef)) {
        if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {
          if (xDef.stack) {
            return x2;
          } else if (yDef.stack) {
            return y2;
          }
          const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
          const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
          if (xAggregate !== yAggregate) {
            return xAggregate ? x2 : y2;
          }
          if (isCartesianBarOrArea) {
            if (orient2 === "vertical") {
              return y2;
            } else if (orient2 === "horizontal") {
              return x2;
            }
          }
        } else if (isUnbinnedQuantitative(xDef)) {
          return x2;
        } else if (isUnbinnedQuantitative(yDef)) {
          return y2;
        }
      } else if (isUnbinnedQuantitative(xDef)) {
        if (isCartesianBarOrArea && orient2 === "vertical") {
          return void 0;
        }
        return x2;
      } else if (isUnbinnedQuantitative(yDef)) {
        if (isCartesianBarOrArea && orient2 === "horizontal") {
          return void 0;
        }
        return y2;
      }
      return void 0;
    }
    function getDimensionChannel(channel) {
      switch (channel) {
        case "x":
          return "y";
        case "y":
          return "x";
        case "theta":
          return "radius";
        case "radius":
          return "theta";
      }
    }
    function stack(m2, encoding) {
      var _a2, _b;
      const markDef = isMarkDef(m2) ? m2 : { type: m2 };
      const mark = markDef.type;
      if (!STACKABLE_MARKS.has(mark)) {
        return null;
      }
      const fieldChannel = potentialStackedChannel(encoding, "x", markDef) || potentialStackedChannel(encoding, "theta", markDef);
      if (!fieldChannel) {
        return null;
      }
      const stackedFieldDef = encoding[fieldChannel];
      const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
      const dimensionChannel = getDimensionChannel(fieldChannel);
      const groupbyChannels = [];
      const groupbyFields = /* @__PURE__ */ new Set();
      if (encoding[dimensionChannel]) {
        const dimensionDef = encoding[dimensionChannel];
        const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
        if (dimensionField && dimensionField !== stackedField) {
          groupbyChannels.push(dimensionChannel);
          groupbyFields.add(dimensionField);
        }
      }
      const dimensionOffsetChannel = dimensionChannel === "x" ? "xOffset" : "yOffset";
      const dimensionOffsetDef = encoding[dimensionOffsetChannel];
      const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : void 0;
      if (dimensionOffsetField && dimensionOffsetField !== stackedField) {
        groupbyChannels.push(dimensionOffsetChannel);
        groupbyFields.add(dimensionOffsetField);
      }
      const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
        if (channel !== "tooltip" && channelHasField(encoding, channel)) {
          const channelDef = encoding[channel];
          for (const cDef of array$2(channelDef)) {
            const fieldDef = getFieldDef(cDef);
            if (fieldDef.aggregate) {
              continue;
            }
            const f = vgField(fieldDef, {});
            if (
              // if fielddef is a repeat, just include it in the stack by
              !f || // otherwise, the field must be different from the groupBy fields.
              !groupbyFields.has(f)
            ) {
              sc.push({ channel, fieldDef });
            }
          }
        }
        return sc;
      }, []);
      let offset2;
      if (stackedFieldDef.stack !== void 0) {
        if (isBoolean$2(stackedFieldDef.stack)) {
          offset2 = stackedFieldDef.stack ? "zero" : null;
        } else {
          offset2 = stackedFieldDef.stack;
        }
      } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {
        offset2 = "zero";
      }
      if (!offset2 || !isStackOffset(offset2)) {
        return null;
      }
      if (isAggregate$1(encoding) && stackBy.length === 0) {
        return null;
      }
      if (((_a2 = stackedFieldDef == null ? void 0 : stackedFieldDef.scale) == null ? void 0 : _a2.type) && ((_b = stackedFieldDef == null ? void 0 : stackedFieldDef.scale) == null ? void 0 : _b.type) !== ScaleType.LINEAR) {
        if (stackedFieldDef == null ? void 0 : stackedFieldDef.stack) {
          warn(cannotStackNonLinearScale(stackedFieldDef.scale.type));
        }
        return null;
      }
      if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
        if (stackedFieldDef.stack !== void 0) {
          warn(cannotStackRangedMark(fieldChannel));
        }
        return null;
      }
      if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {
        warn(stackNonSummativeAggregate(stackedFieldDef.aggregate));
      }
      return {
        groupbyChannels,
        groupbyFields,
        fieldChannel,
        impute: stackedFieldDef.impute === null ? false : isPathMark(mark),
        stackBy,
        offset: offset2
      };
    }
    function initMarkdef(originalMarkDef, encoding, config) {
      const markDef = replaceExprRef(originalMarkDef);
      const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
      markDef.orient = orient(markDef.type, encoding, specifiedOrient);
      if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
        warn(orientOverridden(markDef.orient, specifiedOrient));
      }
      if (markDef.type === "bar" && markDef.orient) {
        const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
        if (cornerRadiusEnd !== void 0) {
          const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
          for (const newProp of newProps) {
            markDef[newProp] = cornerRadiusEnd;
          }
          if (markDef.cornerRadiusEnd !== void 0) {
            delete markDef.cornerRadiusEnd;
          }
        }
      }
      const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
      if (specifiedOpacity === void 0) {
        markDef.opacity = opacity(markDef.type, encoding);
      }
      const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
      if (specifiedCursor === void 0) {
        markDef.cursor = cursor(markDef, encoding, config);
      }
      return markDef;
    }
    function cursor(markDef, encoding, config) {
      if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
        return "pointer";
      }
      return markDef.cursor;
    }
    function opacity(mark, encoding) {
      if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {
        if (!isAggregate$1(encoding)) {
          return 0.7;
        }
      }
      return void 0;
    }
    function defaultFilled(markDef, config, { graticule: graticule2 }) {
      if (graticule2) {
        return false;
      }
      const filledConfig = getMarkConfig("filled", markDef, config);
      const mark = markDef.type;
      return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);
    }
    function orient(mark, encoding, specifiedOrient) {
      switch (mark) {
        case POINT:
        case CIRCLE:
        case SQUARE:
        case TEXT:
        case RECT:
        case IMAGE:
          return void 0;
      }
      const { x: x2, y: y2, x2: x22, y2: y22 } = encoding;
      switch (mark) {
        case BAR:
          if (isFieldDef(x2) && (isBinned(x2.bin) || isFieldDef(y2) && y2.aggregate && !x2.aggregate)) {
            return "vertical";
          }
          if (isFieldDef(y2) && (isBinned(y2.bin) || isFieldDef(x2) && x2.aggregate && !y2.aggregate)) {
            return "horizontal";
          }
          if (y22 || x22) {
            if (specifiedOrient) {
              return specifiedOrient;
            }
            if (!x22) {
              if (isFieldDef(x2) && x2.type === QUANTITATIVE && !isBinning(x2.bin) || isNumericDataDef(x2)) {
                if (isFieldDef(y2) && isBinned(y2.bin)) {
                  return "horizontal";
                }
              }
              return "vertical";
            }
            if (!y22) {
              if (isFieldDef(y2) && y2.type === QUANTITATIVE && !isBinning(y2.bin) || isNumericDataDef(y2)) {
                if (isFieldDef(x2) && isBinned(x2.bin)) {
                  return "vertical";
                }
              }
              return "horizontal";
            }
          }
        case RULE:
          if (x22 && !(isFieldDef(x2) && isBinned(x2.bin)) && y22 && !(isFieldDef(y2) && isBinned(y2.bin))) {
            return void 0;
          }
        case AREA:
          if (y22) {
            if (isFieldDef(y2) && isBinned(y2.bin)) {
              return "horizontal";
            } else {
              return "vertical";
            }
          } else if (x22) {
            if (isFieldDef(x2) && isBinned(x2.bin)) {
              return "vertical";
            } else {
              return "horizontal";
            }
          } else if (mark === RULE) {
            if (x2 && !y2) {
              return "vertical";
            } else if (y2 && !x2) {
              return "horizontal";
            }
          }
        case LINE:
        case TICK: {
          const xIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(x2);
          const yIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(y2);
          if (specifiedOrient) {
            return specifiedOrient;
          } else if (xIsMeasure && !yIsMeasure) {
            return mark !== "tick" ? "horizontal" : "vertical";
          } else if (!xIsMeasure && yIsMeasure) {
            return mark !== "tick" ? "vertical" : "horizontal";
          } else if (xIsMeasure && yIsMeasure) {
            return "vertical";
          } else {
            const xIsTemporal = isTypedFieldDef(x2) && x2.type === TEMPORAL;
            const yIsTemporal = isTypedFieldDef(y2) && y2.type === TEMPORAL;
            if (xIsTemporal && !yIsTemporal) {
              return "vertical";
            } else if (!xIsTemporal && yIsTemporal) {
              return "horizontal";
            }
          }
          return void 0;
        }
      }
      return "vertical";
    }
    function dropLineAndPoint(markDef) {
      const { point: _point, line: _line, ...mark } = markDef;
      return keys(mark).length > 1 ? mark : mark.type;
    }
    function dropLineAndPointFromConfig(config) {
      for (const mark of ["line", "area", "rule", "trail"]) {
        if (config[mark]) {
          config = {
            ...config,
            // TODO: remove as any
            [mark]: omit(config[mark], ["point", "line"])
          };
        }
      }
      return config;
    }
    function getPointOverlay(markDef, markConfig = {}, encoding) {
      if (markDef.point === "transparent") {
        return { opacity: 0 };
      } else if (markDef.point) {
        return isObject(markDef.point) ? markDef.point : {};
      } else if (markDef.point !== void 0) {
        return null;
      } else {
        if (markConfig.point || encoding.shape) {
          return isObject(markConfig.point) ? markConfig.point : {};
        }
        return void 0;
      }
    }
    function getLineOverlay(markDef, markConfig = {}) {
      if (markDef.line) {
        return markDef.line === true ? {} : markDef.line;
      } else if (markDef.line !== void 0) {
        return null;
      } else {
        if (markConfig.line) {
          return markConfig.line === true ? {} : markConfig.line;
        }
        return void 0;
      }
    }
    class PathOverlayNormalizer {
      constructor() {
        this.name = "path-overlay";
      }
      hasMatchingType(spec, config) {
        if (isUnitSpec(spec)) {
          const { mark, encoding } = spec;
          const markDef = isMarkDef(mark) ? mark : { type: mark };
          switch (markDef.type) {
            case "line":
            case "rule":
            case "trail":
              return !!getPointOverlay(markDef, config[markDef.type], encoding);
            case "area":
              return (
                // false / null are also included as we want to remove the properties
                !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])
              );
          }
        }
        return false;
      }
      run(spec, normParams, normalize2) {
        const { config } = normParams;
        const { params: params2, projection: projection2, mark, name: name2, encoding: e3, ...outerSpec } = spec;
        const encoding = normalizeEncoding(e3, config);
        const markDef = isMarkDef(mark) ? mark : { type: mark };
        const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
        const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
        const layer = [
          {
            name: name2,
            ...params2 ? { params: params2 } : {},
            mark: dropLineAndPoint({
              // TODO: extract this 0.7 to be shared with default opacity for point/tick/...
              ...markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? { opacity: 0.7 } : {},
              ...markDef
            }),
            // drop shape from encoding as this might be used to trigger point overlay
            encoding: omit(encoding, ["shape"])
          }
        ];
        const stackProps = stack(initMarkdef(markDef, encoding, config), encoding);
        let overlayEncoding = encoding;
        if (stackProps) {
          const { fieldChannel: stackFieldChannel, offset: offset2 } = stackProps;
          overlayEncoding = {
            ...encoding,
            [stackFieldChannel]: {
              ...encoding[stackFieldChannel],
              ...offset2 ? { stack: offset2 } : {}
            }
          };
        }
        overlayEncoding = omit(overlayEncoding, ["y2", "x2"]);
        if (lineOverlay) {
          layer.push({
            ...projection2 ? { projection: projection2 } : {},
            mark: {
              type: "line",
              ...pick(markDef, ["clip", "interpolate", "tension", "tooltip"]),
              ...lineOverlay
            },
            encoding: overlayEncoding
          });
        }
        if (pointOverlay) {
          layer.push({
            ...projection2 ? { projection: projection2 } : {},
            mark: {
              type: "point",
              opacity: 1,
              filled: true,
              ...pick(markDef, ["clip", "tooltip"]),
              ...pointOverlay
            },
            encoding: overlayEncoding
          });
        }
        return normalize2({
          ...outerSpec,
          layer
        }, {
          ...normParams,
          config: dropLineAndPointFromConfig(config)
        });
      }
    }
    function replaceRepeaterInFacet(facet, repeater) {
      if (!repeater) {
        return facet;
      }
      if (isFacetMapping(facet)) {
        return replaceRepeaterInMapping(facet, repeater);
      }
      return replaceRepeaterInFieldDef(facet, repeater);
    }
    function replaceRepeaterInEncoding(encoding, repeater) {
      if (!repeater) {
        return encoding;
      }
      return replaceRepeaterInMapping(encoding, repeater);
    }
    function replaceRepeatInProp(prop, o, repeater) {
      const val = o[prop];
      if (isRepeatRef(val)) {
        if (val.repeat in repeater) {
          return { ...o, [prop]: repeater[val.repeat] };
        } else {
          warn(noSuchRepeatedValue(val.repeat));
          return void 0;
        }
      }
      return o;
    }
    function replaceRepeaterInFieldDef(fieldDef, repeater) {
      fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
      if (fieldDef === void 0) {
        return void 0;
      } else if (fieldDef === null) {
        return null;
      }
      if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
        const sort2 = replaceRepeatInProp("field", fieldDef.sort, repeater);
        fieldDef = {
          ...fieldDef,
          ...sort2 ? { sort: sort2 } : {}
        };
      }
      return fieldDef;
    }
    function replaceRepeaterInFieldOrDatumDef(def2, repeater) {
      if (isFieldDef(def2)) {
        return replaceRepeaterInFieldDef(def2, repeater);
      } else {
        const datumDef = replaceRepeatInProp("datum", def2, repeater);
        if (datumDef !== def2 && !datumDef.type) {
          datumDef.type = "nominal";
        }
        return datumDef;
      }
    }
    function replaceRepeaterInChannelDef(channelDef, repeater) {
      if (isFieldOrDatumDef(channelDef)) {
        const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
        if (fd) {
          return fd;
        } else if (isConditionalDef(channelDef)) {
          return { condition: channelDef.condition };
        }
      } else {
        if (hasConditionalFieldOrDatumDef(channelDef)) {
          const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
          if (fd) {
            return {
              ...channelDef,
              condition: fd
            };
          } else {
            const { condition, ...channelDefWithoutCondition } = channelDef;
            return channelDefWithoutCondition;
          }
        }
        return channelDef;
      }
      return void 0;
    }
    function replaceRepeaterInMapping(mapping, repeater) {
      const out = {};
      for (const channel in mapping) {
        if (has$1(mapping, channel)) {
          const channelDef = mapping[channel];
          if (isArray(channelDef)) {
            out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
          } else {
            const cd = replaceRepeaterInChannelDef(channelDef, repeater);
            if (cd !== void 0) {
              out[channel] = cd;
            }
          }
        }
      }
      return out;
    }
    class RuleForRangedLineNormalizer {
      constructor() {
        this.name = "RuleForRangedLine";
      }
      hasMatchingType(spec) {
        if (isUnitSpec(spec)) {
          const { encoding, mark } = spec;
          if (mark === "line" || isMarkDef(mark) && mark.type === "line") {
            for (const channel of SECONDARY_RANGE_CHANNEL) {
              const mainChannel = getMainRangeChannel(channel);
              const mainChannelDef = encoding[mainChannel];
              if (encoding[channel]) {
                if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
      run(spec, params2, normalize2) {
        const { encoding, mark } = spec;
        warn(lineWithRange(!!encoding.x2, !!encoding.y2));
        return normalize2({
          ...spec,
          mark: isObject(mark) ? { ...mark, type: "rule" } : "rule"
        }, params2);
      }
    }
    class CoreNormalizer extends SpecMapper {
      constructor() {
        super(...arguments);
        this.nonFacetUnitNormalizers = [
          boxPlotNormalizer,
          errorBarNormalizer,
          errorBandNormalizer,
          new PathOverlayNormalizer(),
          new RuleForRangedLineNormalizer()
        ];
      }
      map(spec, params2) {
        if (isUnitSpec(spec)) {
          const hasRow = channelHasField(spec.encoding, ROW);
          const hasColumn = channelHasField(spec.encoding, COLUMN);
          const hasFacet = channelHasField(spec.encoding, FACET);
          if (hasRow || hasColumn || hasFacet) {
            return this.mapFacetedUnit(spec, params2);
          }
        }
        return super.map(spec, params2);
      }
      // This is for normalizing non-facet unit
      mapUnit(spec, params2) {
        const { parentEncoding, parentProjection } = params2;
        const encoding = replaceRepeaterInEncoding(spec.encoding, params2.repeater);
        const specWithReplacedEncoding = {
          ...spec,
          ...spec.name ? { name: [params2.repeaterPrefix, spec.name].filter((n) => n).join("_") } : {},
          ...encoding ? { encoding } : {}
        };
        if (parentEncoding || parentProjection) {
          return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
        }
        const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
        for (const unitNormalizer of this.nonFacetUnitNormalizers) {
          if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
            return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
          }
        }
        return specWithReplacedEncoding;
      }
      mapRepeat(spec, params2) {
        if (isLayerRepeatSpec(spec)) {
          return this.mapLayerRepeat(spec, params2);
        } else {
          return this.mapNonLayerRepeat(spec, params2);
        }
      }
      mapLayerRepeat(spec, params2) {
        const { repeat: repeat2, spec: childSpec, ...rest } = spec;
        const { row, column, layer } = repeat2;
        const { repeater = {}, repeaterPrefix = "" } = params2;
        if (row || column) {
          return this.mapRepeat({
            ...spec,
            repeat: {
              ...row ? { row } : {},
              ...column ? { column } : {}
            },
            spec: {
              repeat: { layer },
              spec: childSpec
            }
          }, params2);
        } else {
          return {
            ...rest,
            layer: layer.map((layerValue) => {
              const childRepeater = {
                ...repeater,
                layer: layerValue
              };
              const childName = `${(childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
              const child = this.mapLayerOrUnit(childSpec, { ...params2, repeater: childRepeater, repeaterPrefix: childName });
              child.name = childName;
              return child;
            })
          };
        }
      }
      mapNonLayerRepeat(spec, params2) {
        const { repeat: repeat2, spec: childSpec, data: data2, ...remainingProperties } = spec;
        if (!isArray(repeat2) && spec.columns) {
          spec = omit(spec, ["columns"]);
          warn(columnsNotSupportByRowCol("repeat"));
        }
        const concat = [];
        const { repeater = {}, repeaterPrefix = "" } = params2;
        const row = !isArray(repeat2) && repeat2.row || [repeater ? repeater.row : null];
        const column = !isArray(repeat2) && repeat2.column || [repeater ? repeater.column : null];
        const repeatValues = isArray(repeat2) && repeat2 || [repeater ? repeater.repeat : null];
        for (const repeatValue of repeatValues) {
          for (const rowValue of row) {
            for (const columnValue of column) {
              const childRepeater = {
                repeat: repeatValue,
                row: rowValue,
                column: columnValue,
                layer: repeater.layer
              };
              const childName = (childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix + "child__" + (isArray(repeat2) ? `${varName(repeatValue)}` : (repeat2.row ? `row_${varName(rowValue)}` : "") + (repeat2.column ? `column_${varName(columnValue)}` : ""));
              const child = this.map(childSpec, { ...params2, repeater: childRepeater, repeaterPrefix: childName });
              child.name = childName;
              concat.push(omit(child, ["data"]));
            }
          }
        }
        const columns = isArray(repeat2) ? spec.columns : repeat2.column ? repeat2.column.length : 1;
        return {
          data: childSpec.data ?? data2,
          align: "all",
          ...remainingProperties,
          columns,
          concat
        };
      }
      mapFacet(spec, params2) {
        const { facet } = spec;
        if (isFacetMapping(facet) && spec.columns) {
          spec = omit(spec, ["columns"]);
          warn(columnsNotSupportByRowCol("facet"));
        }
        return super.mapFacet(spec, params2);
      }
      mapUnitWithParentEncodingOrProjection(spec, params2) {
        const { encoding, projection: projection2 } = spec;
        const { parentEncoding, parentProjection, config } = params2;
        const mergedProjection = mergeProjection({ parentProjection, projection: projection2 });
        const mergedEncoding = mergeEncoding({
          parentEncoding,
          encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
        });
        return this.mapUnit({
          ...spec,
          ...mergedProjection ? { projection: mergedProjection } : {},
          ...mergedEncoding ? { encoding: mergedEncoding } : {}
        }, { config });
      }
      mapFacetedUnit(spec, normParams) {
        const { row, column, facet, ...encoding } = spec.encoding;
        const { mark, width: width2, projection: projection2, height: height2, view, params: params2, encoding: _, ...outerSpec } = spec;
        const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);
        const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);
        return this.mapFacet({
          ...outerSpec,
          ...layout,
          // row / column has higher precedence than facet
          facet: facetMapping,
          spec: {
            ...width2 ? { width: width2 } : {},
            ...height2 ? { height: height2 } : {},
            ...view ? { view } : {},
            ...projection2 ? { projection: projection2 } : {},
            mark,
            encoding: newEncoding,
            ...params2 ? { params: params2 } : {}
          }
        }, normParams);
      }
      getFacetMappingAndLayout(facets, params2) {
        const { row, column, facet } = facets;
        if (row || column) {
          if (facet) {
            warn(facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
          }
          const facetMapping = {};
          const layout = {};
          for (const channel of [ROW, COLUMN]) {
            const def2 = facets[channel];
            if (def2) {
              const { align: align2, center: center2, spacing, columns, ...defWithoutLayout } = def2;
              facetMapping[channel] = defWithoutLayout;
              for (const prop of ["align", "center", "spacing"]) {
                if (def2[prop] !== void 0) {
                  layout[prop] ?? (layout[prop] = {});
                  layout[prop][channel] = def2[prop];
                }
              }
            }
          }
          return { facetMapping, layout };
        } else {
          const { align: align2, center: center2, spacing, columns, ...facetMapping } = facet;
          return {
            facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
            layout: {
              ...align2 ? { align: align2 } : {},
              ...center2 ? { center: center2 } : {},
              ...spacing ? { spacing } : {},
              ...columns ? { columns } : {}
            }
          };
        }
      }
      mapLayer(spec, { parentEncoding, parentProjection, ...otherParams }) {
        const { encoding, projection: projection2, ...rest } = spec;
        const params2 = {
          ...otherParams,
          parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }),
          parentProjection: mergeProjection({ parentProjection, projection: projection2 })
        };
        return super.mapLayer({
          ...rest,
          ...spec.name ? { name: [params2.repeaterPrefix, spec.name].filter((n) => n).join("_") } : {}
        }, params2);
      }
    }
    function mergeEncoding({ parentEncoding, encoding = {}, layer }) {
      let merged = {};
      if (parentEncoding) {
        const channels = /* @__PURE__ */ new Set([...keys(parentEncoding), ...keys(encoding)]);
        for (const channel of channels) {
          const channelDef = encoding[channel];
          const parentChannelDef = parentEncoding[channel];
          if (isFieldOrDatumDef(channelDef)) {
            const mergedChannelDef = {
              ...parentChannelDef,
              ...channelDef
            };
            merged[channel] = mergedChannelDef;
          } else if (hasConditionalFieldOrDatumDef(channelDef)) {
            merged[channel] = {
              ...channelDef,
              condition: {
                ...parentChannelDef,
                ...channelDef.condition
              }
            };
          } else if (channelDef || channelDef === null) {
            merged[channel] = channelDef;
          } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {
            merged[channel] = parentChannelDef;
          }
        }
      } else {
        merged = encoding;
      }
      return !merged || isEmpty(merged) ? void 0 : merged;
    }
    function mergeProjection(opt) {
      const { parentProjection, projection: projection2 } = opt;
      if (parentProjection && projection2) {
        warn(projectionOverridden({ parentProjection, projection: projection2 }));
      }
      return projection2 ?? parentProjection;
    }
    function isFilter(t4) {
      return "filter" in t4;
    }
    function isImputeSequence(t4) {
      return (t4 == null ? void 0 : t4["stop"]) !== void 0;
    }
    function isLookup(t4) {
      return "lookup" in t4;
    }
    function isLookupData(from) {
      return "data" in from;
    }
    function isLookupSelection(from) {
      return "param" in from;
    }
    function isPivot(t4) {
      return "pivot" in t4;
    }
    function isDensity(t4) {
      return "density" in t4;
    }
    function isQuantile(t4) {
      return "quantile" in t4;
    }
    function isRegression(t4) {
      return "regression" in t4;
    }
    function isLoess(t4) {
      return "loess" in t4;
    }
    function isSample(t4) {
      return "sample" in t4;
    }
    function isWindow(t4) {
      return "window" in t4;
    }
    function isJoinAggregate(t4) {
      return "joinaggregate" in t4;
    }
    function isFlatten(t4) {
      return "flatten" in t4;
    }
    function isCalculate(t4) {
      return "calculate" in t4;
    }
    function isBin(t4) {
      return "bin" in t4;
    }
    function isImpute(t4) {
      return "impute" in t4;
    }
    function isTimeUnit(t4) {
      return "timeUnit" in t4;
    }
    function isAggregate(t4) {
      return "aggregate" in t4;
    }
    function isStack(t4) {
      return "stack" in t4;
    }
    function isFold(t4) {
      return "fold" in t4;
    }
    function isExtent(t4) {
      return "extent" in t4 && !("density" in t4);
    }
    function normalizeTransform(transform2) {
      return transform2.map((t4) => {
        if (isFilter(t4)) {
          return {
            filter: normalizeLogicalComposition(t4.filter, normalizePredicate$1)
          };
        }
        return t4;
      });
    }
    class SelectionCompatibilityNormalizer extends SpecMapper {
      map(spec, normParams) {
        normParams.emptySelections ?? (normParams.emptySelections = {});
        normParams.selectionPredicates ?? (normParams.selectionPredicates = {});
        spec = normalizeTransforms(spec, normParams);
        return super.map(spec, normParams);
      }
      mapLayerOrUnit(spec, normParams) {
        spec = normalizeTransforms(spec, normParams);
        if (spec.encoding) {
          const encoding = {};
          for (const [channel, enc] of entries$1(spec.encoding)) {
            encoding[channel] = normalizeChannelDef(enc, normParams);
          }
          spec = { ...spec, encoding };
        }
        return super.mapLayerOrUnit(spec, normParams);
      }
      mapUnit(spec, normParams) {
        const { selection: selection2, ...rest } = spec;
        if (selection2) {
          return {
            ...rest,
            params: entries$1(selection2).map(([name2, selDef]) => {
              const { init: value2, bind: bind2, empty: empty2, ...select2 } = selDef;
              if (select2.type === "single") {
                select2.type = "point";
                select2.toggle = false;
              } else if (select2.type === "multi") {
                select2.type = "point";
              }
              normParams.emptySelections[name2] = empty2 !== "none";
              for (const pred of vals(normParams.selectionPredicates[name2] ?? {})) {
                pred.empty = empty2 !== "none";
              }
              return { name: name2, value: value2, select: select2, bind: bind2 };
            })
          };
        }
        return spec;
      }
    }
    function normalizeTransforms(spec, normParams) {
      const { transform: tx2, ...rest } = spec;
      if (tx2) {
        const transform2 = tx2.map((t4) => {
          if (isFilter(t4)) {
            return { filter: normalizePredicate(t4, normParams) };
          } else if (isBin(t4) && isBinParams(t4.bin)) {
            return {
              ...t4,
              bin: normalizeBinExtent(t4.bin)
            };
          } else if (isLookup(t4)) {
            const { selection: param2, ...from } = t4.from;
            return param2 ? {
              ...t4,
              from: { param: param2, ...from }
            } : t4;
          }
          return t4;
        });
        return { ...rest, transform: transform2 };
      }
      return spec;
    }
    function normalizeChannelDef(obj, normParams) {
      var _a2, _b;
      const enc = duplicate(obj);
      if (isFieldDef(enc) && isBinParams(enc.bin)) {
        enc.bin = normalizeBinExtent(enc.bin);
      }
      if (isScaleFieldDef(enc) && ((_b = (_a2 = enc.scale) == null ? void 0 : _a2.domain) == null ? void 0 : _b.selection)) {
        const { selection: param2, ...domain2 } = enc.scale.domain;
        enc.scale.domain = { ...domain2, ...param2 ? { param: param2 } : {} };
      }
      if (isConditionalDef(enc)) {
        if (isArray(enc.condition)) {
          enc.condition = enc.condition.map((c2) => {
            const { selection: selection2, param: param2, test: test2, ...cond } = c2;
            return param2 ? c2 : { ...cond, test: normalizePredicate(c2, normParams) };
          });
        } else {
          const { selection: selection2, param: param2, test: test2, ...cond } = normalizeChannelDef(enc.condition, normParams);
          enc.condition = param2 ? enc.condition : {
            ...cond,
            test: normalizePredicate(enc.condition, normParams)
          };
        }
      }
      return enc;
    }
    function normalizeBinExtent(bin2) {
      const ext = bin2.extent;
      if (ext == null ? void 0 : ext.selection) {
        const { selection: param2, ...rest } = ext;
        return { ...bin2, extent: { ...rest, param: param2 } };
      }
      return bin2;
    }
    function normalizePredicate(op, normParams) {
      const normalizeSelectionComposition = (o) => {
        return normalizeLogicalComposition(o, (param2) => {
          var _a2;
          const empty2 = normParams.emptySelections[param2] ?? true;
          const pred = { param: param2, empty: empty2 };
          (_a2 = normParams.selectionPredicates)[param2] ?? (_a2[param2] = []);
          normParams.selectionPredicates[param2].push(pred);
          return pred;
        });
      };
      return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, (o) => o.selection ? normalizeSelectionComposition(o.selection) : o);
    }
    class TopLevelSelectionsNormalizer extends SpecMapper {
      map(spec, normParams) {
        const selections = normParams.selections ?? [];
        if (spec.params && !isUnitSpec(spec)) {
          const params2 = [];
          for (const param2 of spec.params) {
            if (isSelectionParameter(param2)) {
              selections.push(param2);
            } else {
              params2.push(param2);
            }
          }
          spec.params = params2;
        }
        normParams.selections = selections;
        return super.map(spec, normParams);
      }
      mapUnit(spec, normParams) {
        const selections = normParams.selections;
        if (!selections || !selections.length)
          return spec;
        const path2 = (normParams.path ?? []).concat(spec.name);
        const params2 = [];
        for (const selection2 of selections) {
          if (!selection2.views || !selection2.views.length) {
            params2.push(selection2);
          } else {
            for (const view of selection2.views) {
              if (isString(view) && (view === spec.name || path2.includes(view)) || isArray(view) && // logic for backwards compatibility with view paths before we had unique names
              // @ts-ignore
              view.map((v) => path2.indexOf(v)).every((v, i, arr) => v !== -1 && (i === 0 || v > arr[i - 1]))) {
                params2.push(selection2);
              }
            }
          }
        }
        if (params2.length)
          spec.params = params2;
        return spec;
      }
    }
    for (const method2 of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
      const proto = TopLevelSelectionsNormalizer.prototype[method2];
      TopLevelSelectionsNormalizer.prototype[method2] = function(spec, params2) {
        return proto.call(this, spec, addSpecNameToParams(spec, params2));
      };
    }
    function addSpecNameToParams(spec, params2) {
      return spec.name ? {
        ...params2,
        path: (params2.path ?? []).concat(spec.name)
      } : params2;
    }
    function normalize(spec, config) {
      if (config === void 0) {
        config = initConfig(spec.config);
      }
      const normalizedSpec = normalizeGenericSpec(spec, config);
      const { width: width2, height: height2 } = spec;
      const autosize = normalizeAutoSize(normalizedSpec, { width: width2, height: height2, autosize: spec.autosize }, config);
      return {
        ...normalizedSpec,
        ...autosize ? { autosize } : {}
      };
    }
    const coreNormalizer = new CoreNormalizer();
    const selectionCompatNormalizer = new SelectionCompatibilityNormalizer();
    const topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
    function normalizeGenericSpec(spec, config = {}) {
      const normParams = { config };
      return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
    }
    function _normalizeAutoSize(autosize) {
      return isString(autosize) ? { type: autosize } : autosize ?? {};
    }
    function normalizeAutoSize(spec, sizeInfo, config) {
      let { width: width2, height: height2 } = sizeInfo;
      const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
      const autosizeDefault = {};
      if (!isFitCompatible) {
        if (width2 == "container") {
          warn(containerSizeNonSingle("width"));
          width2 = void 0;
        }
        if (height2 == "container") {
          warn(containerSizeNonSingle("height"));
          height2 = void 0;
        }
      } else {
        if (width2 == "container" && height2 == "container") {
          autosizeDefault.type = "fit";
          autosizeDefault.contains = "padding";
        } else if (width2 == "container") {
          autosizeDefault.type = "fit-x";
          autosizeDefault.contains = "padding";
        } else if (height2 == "container") {
          autosizeDefault.type = "fit-y";
          autosizeDefault.contains = "padding";
        }
      }
      const autosize = {
        type: "pad",
        ...autosizeDefault,
        ...config ? _normalizeAutoSize(config.autosize) : {},
        ..._normalizeAutoSize(spec.autosize)
      };
      if (autosize.type === "fit" && !isFitCompatible) {
        warn(FIT_NON_SINGLE);
        autosize.type = "pad";
      }
      if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
        warn(containerSizeNotCompatibleWithAutosize("width"));
      }
      if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
        warn(containerSizeNotCompatibleWithAutosize("height"));
      }
      if (deepEqual(autosize, { type: "pad" })) {
        return void 0;
      }
      return autosize;
    }
    function isFitType(autoSizeType) {
      return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
    }
    function getFitType(sizeType) {
      return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
    }
    const TOP_LEVEL_PROPERTIES = [
      "background",
      "padding"
      // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
    ];
    function extractTopLevelProperties(t4, includeParams) {
      const o = {};
      for (const p of TOP_LEVEL_PROPERTIES) {
        if (t4 && t4[p] !== void 0) {
          o[p] = signalRefOrValue(t4[p]);
        }
      }
      if (includeParams) {
        o.params = t4.params;
      }
      return o;
    }
    class Split {
      constructor(explicit = {}, implicit2 = {}) {
        this.explicit = explicit;
        this.implicit = implicit2;
      }
      clone() {
        return new Split(duplicate(this.explicit), duplicate(this.implicit));
      }
      combine() {
        return {
          ...this.explicit,
          ...this.implicit
        };
      }
      get(key2) {
        return getFirstDefined(this.explicit[key2], this.implicit[key2]);
      }
      getWithExplicit(key2) {
        if (this.explicit[key2] !== void 0) {
          return { explicit: true, value: this.explicit[key2] };
        } else if (this.implicit[key2] !== void 0) {
          return { explicit: false, value: this.implicit[key2] };
        }
        return { explicit: false, value: void 0 };
      }
      setWithExplicit(key2, { value: value2, explicit }) {
        if (value2 !== void 0) {
          this.set(key2, value2, explicit);
        }
      }
      set(key2, value2, explicit) {
        delete this[explicit ? "implicit" : "explicit"][key2];
        this[explicit ? "explicit" : "implicit"][key2] = value2;
        return this;
      }
      copyKeyFromSplit(key2, { explicit, implicit: implicit2 }) {
        if (explicit[key2] !== void 0) {
          this.set(key2, explicit[key2], true);
        } else if (implicit2[key2] !== void 0) {
          this.set(key2, implicit2[key2], false);
        }
      }
      copyKeyFromObject(key2, s) {
        if (s[key2] !== void 0) {
          this.set(key2, s[key2], true);
        }
      }
      /**
       * Merge split object into this split object. Properties from the other split
       * overwrite properties from this split.
       */
      copyAll(other) {
        for (const key2 of keys(other.combine())) {
          const val = other.getWithExplicit(key2);
          this.setWithExplicit(key2, val);
        }
      }
    }
    function makeExplicit(value2) {
      return {
        explicit: true,
        value: value2
      };
    }
    function makeImplicit(value2) {
      return {
        explicit: false,
        value: value2
      };
    }
    function tieBreakByComparing(compare2) {
      return (v1, v2, property2, propertyOf) => {
        const diff = compare2(v1.value, v2.value);
        if (diff > 0) {
          return v1;
        } else if (diff < 0) {
          return v2;
        }
        return defaultTieBreaker(v1, v2, property2, propertyOf);
      };
    }
    function defaultTieBreaker(v1, v2, property2, propertyOf) {
      if (v1.explicit && v2.explicit) {
        warn(mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
      }
      return v1;
    }
    function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
      if (v1 === void 0 || v1.value === void 0) {
        return v2;
      }
      if (v1.explicit && !v2.explicit) {
        return v1;
      } else if (v2.explicit && !v1.explicit) {
        return v2;
      } else if (deepEqual(v1.value, v2.value)) {
        return v1;
      } else {
        return tieBreaker(v1, v2, property2, propertyOf);
      }
    }
    class AncestorParse extends Split {
      constructor(explicit = {}, implicit2 = {}, parseNothing = false) {
        super(explicit, implicit2);
        this.explicit = explicit;
        this.implicit = implicit2;
        this.parseNothing = parseNothing;
      }
      clone() {
        const clone = super.clone();
        clone.parseNothing = this.parseNothing;
        return clone;
      }
    }
    function isUrlData(data2) {
      return "url" in data2;
    }
    function isInlineData(data2) {
      return "values" in data2;
    }
    function isNamedData(data2) {
      return "name" in data2 && !isUrlData(data2) && !isInlineData(data2) && !isGenerator(data2);
    }
    function isGenerator(data2) {
      return data2 && (isSequenceGenerator(data2) || isSphereGenerator(data2) || isGraticuleGenerator(data2));
    }
    function isSequenceGenerator(data2) {
      return "sequence" in data2;
    }
    function isSphereGenerator(data2) {
      return "sphere" in data2;
    }
    function isGraticuleGenerator(data2) {
      return "graticule" in data2;
    }
    var DataSourceType;
    (function(DataSourceType2) {
      DataSourceType2[DataSourceType2["Raw"] = 0] = "Raw";
      DataSourceType2[DataSourceType2["Main"] = 1] = "Main";
      DataSourceType2[DataSourceType2["Row"] = 2] = "Row";
      DataSourceType2[DataSourceType2["Column"] = 3] = "Column";
      DataSourceType2[DataSourceType2["Lookup"] = 4] = "Lookup";
    })(DataSourceType || (DataSourceType = {}));
    function assembleProjection(proj) {
      const { signals, hasLegend, index: index2, ...rest } = proj;
      rest.field = replacePathInField(rest.field);
      return rest;
    }
    function assembleInit(init2, isExpr2 = true, wrap2 = identity$1) {
      if (isArray(init2)) {
        const assembled = init2.map((v) => assembleInit(v, isExpr2, wrap2));
        return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
      } else if (isDateTime(init2)) {
        if (isExpr2) {
          return wrap2(dateTimeToExpr(init2));
        } else {
          return wrap2(dateTimeToTimestamp(init2));
        }
      }
      return isExpr2 ? wrap2(stringify$1(init2)) : init2;
    }
    function assembleUnitSelectionSignals(model, signals) {
      for (const selCmpt of vals(model.component.selection ?? {})) {
        const name2 = selCmpt.name;
        let modifyExpr = `${name2}${TUPLE}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`}`;
        for (const c2 of selectionCompilers) {
          if (!c2.defined(selCmpt))
            continue;
          if (c2.signals)
            signals = c2.signals(model, selCmpt, signals);
          if (c2.modifyExpr)
            modifyExpr = c2.modifyExpr(model, selCmpt, modifyExpr);
        }
        signals.push({
          name: name2 + MODIFY,
          on: [
            {
              events: { signal: selCmpt.name + TUPLE },
              update: `modify(${$(selCmpt.name + STORE)}, ${modifyExpr})`
            }
          ]
        });
      }
      return cleanupEmptyOnArray(signals);
    }
    function assembleFacetSignals(model, signals) {
      if (model.component.selection && keys(model.component.selection).length) {
        const name2 = $(model.getName("cell"));
        signals.unshift({
          name: "facet",
          value: {},
          on: [
            {
              events: eventSelector("pointermove", "scope"),
              update: `isTuple(facet) ? facet : group(${name2}).datum`
            }
          ]
        });
      }
      return cleanupEmptyOnArray(signals);
    }
    function assembleTopLevelSignals(model, signals) {
      let hasSelections = false;
      for (const selCmpt of vals(model.component.selection ?? {})) {
        const name2 = selCmpt.name;
        const store2 = $(name2 + STORE);
        const hasSg = signals.filter((s) => s.name === name2);
        if (hasSg.length === 0) {
          const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
          const isPoint2 = selCmpt.type === "point" ? ", true, true)" : ")";
          signals.push({
            name: selCmpt.name,
            update: `${VL_SELECTION_RESOLVE}(${store2}, ${$(resolve2)}${isPoint2}`
          });
        }
        hasSelections = true;
        for (const c2 of selectionCompilers) {
          if (c2.defined(selCmpt) && c2.topLevelSignals) {
            signals = c2.topLevelSignals(model, selCmpt, signals);
          }
        }
      }
      if (hasSelections) {
        const hasUnit = signals.filter((s) => s.name === "unit");
        if (hasUnit.length === 0) {
          signals.unshift({
            name: "unit",
            value: {},
            on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
          });
        }
      }
      return cleanupEmptyOnArray(signals);
    }
    function assembleUnitSelectionData(model, data2) {
      const dataCopy = [...data2];
      const unit2 = unitName(model, { escape: false });
      for (const selCmpt of vals(model.component.selection ?? {})) {
        const store2 = { name: selCmpt.name + STORE };
        if (selCmpt.project.hasSelectionId) {
          store2.transform = [{ type: "collect", sort: { field: SELECTION_ID } }];
        }
        if (selCmpt.init) {
          const fields = selCmpt.project.items.map(assembleProjection);
          store2.values = selCmpt.project.hasSelectionId ? selCmpt.init.map((i) => ({ unit: unit2, [SELECTION_ID]: assembleInit(i, false)[0] })) : selCmpt.init.map((i) => ({ unit: unit2, fields, values: assembleInit(i, false) }));
        }
        const contains2 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
        if (!contains2.length) {
          dataCopy.push(store2);
        }
      }
      return dataCopy;
    }
    function assembleUnitSelectionMarks(model, marks) {
      for (const selCmpt of vals(model.component.selection ?? {})) {
        for (const c2 of selectionCompilers) {
          if (c2.defined(selCmpt) && c2.marks) {
            marks = c2.marks(model, selCmpt, marks);
          }
        }
      }
      return marks;
    }
    function assembleLayerSelectionMarks(model, marks) {
      for (const child of model.children) {
        if (isUnitModel(child)) {
          marks = assembleUnitSelectionMarks(child, marks);
        }
      }
      return marks;
    }
    function assembleSelectionScaleDomain(model, extent2, scaleCmpt, domain2) {
      const parsedExtent = parseSelectionExtent(model, extent2.param, extent2);
      return {
        signal: hasContinuousDomain(scaleCmpt.get("type")) && isArray(domain2) && domain2[0] > domain2[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent
      };
    }
    function cleanupEmptyOnArray(signals) {
      return signals.map((s) => {
        if (s.on && !s.on.length)
          delete s.on;
        return s;
      });
    }
    class DataFlowNode {
      constructor(parent, debugName) {
        this.debugName = debugName;
        this._children = [];
        this._parent = null;
        if (parent) {
          this.parent = parent;
        }
      }
      /**
       * Clone this node with a deep copy but don't clone links to children or parents.
       */
      clone() {
        throw new Error("Cannot clone node");
      }
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the node and also add this node to the parent's children.
       */
      set parent(parent) {
        this._parent = parent;
        if (parent) {
          parent.addChild(this);
        }
      }
      get children() {
        return this._children;
      }
      numChildren() {
        return this._children.length;
      }
      addChild(child, loc) {
        if (this._children.includes(child)) {
          warn(ADD_SAME_CHILD_TWICE);
          return;
        }
        if (loc !== void 0) {
          this._children.splice(loc, 0, child);
        } else {
          this._children.push(child);
        }
      }
      removeChild(oldChild) {
        const loc = this._children.indexOf(oldChild);
        this._children.splice(loc, 1);
        return loc;
      }
      /**
       * Remove node from the dataflow.
       */
      remove() {
        let loc = this._parent.removeChild(this);
        for (const child of this._children) {
          child._parent = this._parent;
          this._parent.addChild(child, loc++);
        }
      }
      /**
       * Insert another node as a parent of this node.
       */
      insertAsParentOf(other) {
        const parent = other.parent;
        parent.removeChild(this);
        this.parent = parent;
        other.parent = this;
      }
      swapWithParent() {
        const parent = this._parent;
        const newParent = parent.parent;
        for (const child of this._children) {
          child.parent = parent;
        }
        this._children = [];
        parent.removeChild(this);
        const loc = parent.parent.removeChild(parent);
        this._parent = newParent;
        newParent.addChild(this, loc);
        parent.parent = this;
      }
    }
    class OutputNode extends DataFlowNode {
      clone() {
        const cloneObj = new this.constructor();
        cloneObj.debugName = `clone_${this.debugName}`;
        cloneObj._source = this._source;
        cloneObj._name = `clone_${this._name}`;
        cloneObj.type = this.type;
        cloneObj.refCounts = this.refCounts;
        cloneObj.refCounts[cloneObj._name] = 0;
        return cloneObj;
      }
      /**
       * @param source The name of the source. Will change in assemble.
       * @param type The type of the output node.
       * @param refCounts A global ref counter map.
       */
      constructor(parent, source2, type2, refCounts) {
        super(parent, source2);
        this.type = type2;
        this.refCounts = refCounts;
        this._source = this._name = source2;
        if (this.refCounts && !(this._name in this.refCounts)) {
          this.refCounts[this._name] = 0;
        }
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        if (this._hash === void 0) {
          this._hash = `Output ${uniqueId()}`;
        }
        return this._hash;
      }
      /**
       * Request the datasource name and increase the ref counter.
       *
       * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
       * It is crucial to request the name from an output node to mark it as a required node.
       * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
       *
       * In the assemble phase, this will return the correct name.
       */
      getSource() {
        this.refCounts[this._name]++;
        return this._source;
      }
      isRequired() {
        return !!this.refCounts[this._name];
      }
      setSource(source2) {
        this._source = source2;
      }
    }
    function isTimeUnitTransformComponent(timeUnitComponent) {
      return timeUnitComponent.as !== void 0;
    }
    function offsetAs(field2) {
      return `${field2}_end`;
    }
    class TimeUnitNode extends DataFlowNode {
      clone() {
        return new TimeUnitNode(null, duplicate(this.timeUnits));
      }
      constructor(parent, timeUnits2) {
        super(parent);
        this.timeUnits = timeUnits2;
      }
      static makeFromEncoding(parent, model) {
        const formula2 = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {
          const { field: field2, timeUnit } = fieldDef;
          if (timeUnit) {
            let component;
            if (isBinnedTimeUnit(timeUnit)) {
              if (isUnitModel(model)) {
                const { mark, markDef, config } = model;
                const bandPosition = getBandPosition({ fieldDef, markDef, config });
                if (isRectBasedMark(mark) || !!bandPosition) {
                  component = {
                    timeUnit: normalizeTimeUnit(timeUnit),
                    field: field2
                  };
                }
              }
            } else {
              component = {
                as: vgField(fieldDef, { forAs: true }),
                field: field2,
                timeUnit
              };
            }
            if (isUnitModel(model)) {
              const { mark, markDef, config } = model;
              const bandPosition = getBandPosition({ fieldDef, markDef, config });
              if (isRectBasedMark(mark) && isXorY(channel) && bandPosition !== 0.5) {
                component.rectBandPosition = bandPosition;
              }
            }
            if (component) {
              timeUnitComponent[hash(component)] = component;
            }
          }
          return timeUnitComponent;
        }, {});
        if (isEmpty(formula2)) {
          return null;
        }
        return new TimeUnitNode(parent, formula2);
      }
      static makeFromTransform(parent, t4) {
        const { timeUnit, ...other } = { ...t4 };
        const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
        const component = {
          ...other,
          timeUnit: normalizedTimeUnit
        };
        return new TimeUnitNode(parent, {
          [hash(component)]: component
        });
      }
      /**
       * Merge together TimeUnitNodes assigning the children of `other` to `this`
       * and removing `other`.
       */
      merge(other) {
        this.timeUnits = { ...this.timeUnits };
        for (const key2 in other.timeUnits) {
          if (!this.timeUnits[key2]) {
            this.timeUnits[key2] = other.timeUnits[key2];
          }
        }
        for (const child of other.children) {
          other.removeChild(child);
          child.parent = this;
        }
        other.remove();
      }
      /**
       * Remove time units coming from the other node.
       */
      removeFormulas(fields) {
        const newFormula = {};
        for (const [key2, timeUnitComponent] of entries$1(this.timeUnits)) {
          const fieldAs = isTimeUnitTransformComponent(timeUnitComponent) ? timeUnitComponent.as : `${timeUnitComponent.field}_end`;
          if (!fields.has(fieldAs)) {
            newFormula[key2] = timeUnitComponent;
          }
        }
        this.timeUnits = newFormula;
      }
      producedFields() {
        return new Set(vals(this.timeUnits).map((f) => {
          return isTimeUnitTransformComponent(f) ? f.as : offsetAs(f.field);
        }));
      }
      dependentFields() {
        return new Set(vals(this.timeUnits).map((f) => f.field));
      }
      hash() {
        return `TimeUnit ${hash(this.timeUnits)}`;
      }
      assemble() {
        const transforms2 = [];
        for (const f of vals(this.timeUnits)) {
          const { rectBandPosition } = f;
          const normalizedTimeUnit = normalizeTimeUnit(f.timeUnit);
          if (isTimeUnitTransformComponent(f)) {
            const { field: field2, as } = f;
            const { unit: unit2, utc, ...params2 } = normalizedTimeUnit;
            const startEnd = [as, `${as}_end`];
            transforms2.push({
              field: replacePathInField(field2),
              type: "timeunit",
              ...unit2 ? { units: getTimeUnitParts(unit2) } : {},
              ...utc ? { timezone: "utc" } : {},
              ...params2,
              as: startEnd
            });
            transforms2.push(...offsetedRectFormulas(startEnd, rectBandPosition, normalizedTimeUnit));
          } else if (f) {
            const { field: escapedField } = f;
            const field2 = escapedField.replaceAll("\\.", ".");
            const expr2 = offsetExpr({ timeUnit: normalizedTimeUnit, field: field2 });
            const endAs = offsetAs(field2);
            transforms2.push({
              type: "formula",
              expr: expr2,
              as: endAs
            });
            transforms2.push(...offsetedRectFormulas([field2, endAs], rectBandPosition, normalizedTimeUnit));
          }
        }
        return transforms2;
      }
    }
    const OFFSETTED_RECT_START_SUFFIX = "offsetted_rect_start";
    const OFFSETTED_RECT_END_SUFFIX = "offsetted_rect_end";
    function offsetExpr({ timeUnit, field: field2, reverse: reverse2 }) {
      const { unit: unit2, utc } = timeUnit;
      const smallestUnit = getSmallestTimeUnitPart(unit2);
      const { part, step } = getDateTimePartAndStep(smallestUnit, timeUnit.step);
      const offsetFn = utc ? "utcOffset" : "timeOffset";
      const expr2 = `${offsetFn}('${part}', datum['${field2}'], ${reverse2 ? -step : step})`;
      return expr2;
    }
    function offsetedRectFormulas([startField, endField], rectBandPosition, timeUnit) {
      if (rectBandPosition !== void 0 && rectBandPosition !== 0.5) {
        const startExpr = `datum['${startField}']`;
        const endExpr = `datum['${endField}']`;
        return [
          {
            type: "formula",
            expr: interpolateExpr([
              offsetExpr({
                timeUnit,
                field: startField,
                reverse: true
              }),
              startExpr
            ], rectBandPosition + 0.5),
            as: `${startField}_${OFFSETTED_RECT_START_SUFFIX}`
          },
          {
            type: "formula",
            expr: interpolateExpr([startExpr, endExpr], rectBandPosition + 0.5),
            as: `${startField}_${OFFSETTED_RECT_END_SUFFIX}`
          }
        ];
      }
      return [];
    }
    function interpolateExpr([start2, end], fraction) {
      return `${1 - fraction} * ${start2} + ${fraction} * ${end}`;
    }
    const TUPLE_FIELDS = "_tuple_fields";
    class SelectionProjectionComponent {
      constructor(...items) {
        this.items = items;
        this.hasChannel = {};
        this.hasField = {};
        this.hasSelectionId = false;
      }
    }
    const project = {
      defined: () => {
        return true;
      },
      parse: (model, selCmpt, selDef) => {
        const name2 = selCmpt.name;
        const proj = selCmpt.project ?? (selCmpt.project = new SelectionProjectionComponent());
        const parsed = {};
        const timeUnits2 = {};
        const signals = /* @__PURE__ */ new Set();
        const signalName = (p, range2) => {
          const suffix = range2 === "visual" ? p.channel : p.field;
          let sg = varName(`${name2}_${suffix}`);
          for (let counter = 1; signals.has(sg); counter++) {
            sg = varName(`${name2}_${suffix}_${counter}`);
          }
          signals.add(sg);
          return { [range2]: sg };
        };
        const type2 = selCmpt.type;
        const cfg = model.config.selection[type2];
        const init2 = selDef.value !== void 0 ? array$2(selDef.value) : null;
        let { fields, encodings } = isObject(selDef.select) ? selDef.select : {};
        if (!fields && !encodings && init2) {
          for (const initVal of init2) {
            if (!isObject(initVal)) {
              continue;
            }
            for (const key2 of keys(initVal)) {
              if (isSingleDefUnitChannel(key2)) {
                (encodings || (encodings = [])).push(key2);
              } else {
                if (type2 === "interval") {
                  warn(INTERVAL_INITIALIZED_WITH_POS);
                  encodings = cfg.encodings;
                } else {
                  (fields ?? (fields = [])).push(key2);
                }
              }
            }
          }
        }
        if (!fields && !encodings) {
          encodings = cfg.encodings;
          if ("fields" in cfg) {
            fields = cfg.fields;
          }
        }
        for (const channel of encodings ?? []) {
          const fieldDef = model.fieldDef(channel);
          if (fieldDef) {
            let field2 = fieldDef.field;
            if (fieldDef.aggregate) {
              warn(cannotProjectAggregate(channel, fieldDef.aggregate));
              continue;
            } else if (!field2) {
              warn(cannotProjectOnChannelWithoutField(channel));
              continue;
            }
            if (fieldDef.timeUnit && !isBinnedTimeUnit(fieldDef.timeUnit)) {
              field2 = model.vgField(channel);
              const component = {
                timeUnit: fieldDef.timeUnit,
                as: field2,
                field: fieldDef.field
              };
              timeUnits2[hash(component)] = component;
            }
            if (!parsed[field2]) {
              const tplType = type2 === "interval" && isScaleChannel(channel) && hasContinuousDomain(model.getScaleComponent(channel).get("type")) ? "R" : fieldDef.bin ? "R-RE" : "E";
              const p = { field: field2, channel, type: tplType, index: proj.items.length };
              p.signals = { ...signalName(p, "data"), ...signalName(p, "visual") };
              proj.items.push(parsed[field2] = p);
              proj.hasField[field2] = parsed[field2];
              proj.hasSelectionId = proj.hasSelectionId || field2 === SELECTION_ID;
              if (isGeoPositionChannel(channel)) {
                p.geoChannel = channel;
                p.channel = getPositionChannelFromLatLong(channel);
                proj.hasChannel[p.channel] = parsed[field2];
              } else {
                proj.hasChannel[channel] = parsed[field2];
              }
            }
          } else {
            warn(cannotProjectOnChannelWithoutField(channel));
          }
        }
        for (const field2 of fields ?? []) {
          if (proj.hasField[field2])
            continue;
          const p = { type: "E", field: field2, index: proj.items.length };
          p.signals = { ...signalName(p, "data") };
          proj.items.push(p);
          proj.hasField[field2] = p;
          proj.hasSelectionId = proj.hasSelectionId || field2 === SELECTION_ID;
        }
        if (init2) {
          selCmpt.init = init2.map((v) => {
            return proj.items.map((p) => isObject(v) ? v[p.geoChannel || p.channel] !== void 0 ? v[p.geoChannel || p.channel] : v[p.field] : v);
          });
        }
        if (!isEmpty(timeUnits2)) {
          proj.timeUnit = new TimeUnitNode(null, timeUnits2);
        }
      },
      signals: (model, selCmpt, allSignals) => {
        const name2 = selCmpt.name + TUPLE_FIELDS;
        const hasSignal2 = allSignals.filter((s) => s.name === name2);
        return hasSignal2.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({
          name: name2,
          value: selCmpt.project.items.map(assembleProjection)
        });
      }
    };
    const scaleBindings = {
      defined: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
      },
      parse: (model, selCmpt) => {
        const bound2 = selCmpt.scales = [];
        for (const proj of selCmpt.project.items) {
          const channel = proj.channel;
          if (!isScaleChannel(channel)) {
            continue;
          }
          const scale2 = model.getScaleComponent(channel);
          const scaleType2 = scale2 ? scale2.get("type") : void 0;
          if (!scale2 || !hasContinuousDomain(scaleType2)) {
            warn(SCALE_BINDINGS_CONTINUOUS);
            continue;
          }
          scale2.set("selectionExtent", { param: selCmpt.name, field: proj.field }, true);
          bound2.push(proj);
        }
      },
      topLevelSignals: (model, selCmpt, signals) => {
        const bound2 = selCmpt.scales.filter((proj) => signals.filter((s) => s.name === proj.signals.data).length === 0);
        if (!model.parent || isTopLevelLayer(model) || bound2.length === 0) {
          return signals;
        }
        const namedSg = signals.filter((s) => s.name === selCmpt.name)[0];
        let update2 = namedSg.update;
        if (update2.indexOf(VL_SELECTION_RESOLVE) >= 0) {
          namedSg.update = `{${bound2.map((proj) => `${$(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
        } else {
          for (const proj of bound2) {
            const mapping = `${$(replacePathInField(proj.field))}: ${proj.signals.data}`;
            if (!update2.includes(mapping)) {
              update2 = `${update2.substring(0, update2.length - 1)}, ${mapping}}`;
            }
          }
          namedSg.update = update2;
        }
        return signals.concat(bound2.map((proj) => ({ name: proj.signals.data })));
      },
      signals: (model, selCmpt, signals) => {
        if (model.parent && !isTopLevelLayer(model)) {
          for (const proj of selCmpt.scales) {
            const signal = signals.filter((s) => s.name === proj.signals.data)[0];
            signal.push = "outer";
            delete signal.value;
            delete signal.update;
          }
        }
        return signals;
      }
    };
    function domain(model, channel) {
      const scale2 = $(model.scaleName(channel));
      return `domain(${scale2})`;
    }
    function isTopLevelLayer(model) {
      return model.parent && isLayerModel(model.parent) && !model.parent.parent;
    }
    const BRUSH = "_brush";
    const SCALE_TRIGGER = "_scale_trigger";
    const GEO_INIT_TICK = "geo_interval_init_tick";
    const INIT = "_init";
    const CENTER = "_center";
    const interval = {
      defined: (selCmpt) => selCmpt.type === "interval",
      parse: (model, selCmpt, selDef) => {
        var _a2;
        if (model.hasProjection) {
          const def2 = { ...isObject(selDef.select) ? selDef.select : {} };
          def2.fields = [SELECTION_ID];
          if (!def2.encodings) {
            def2.encodings = selDef.value ? keys(selDef.value) : [LONGITUDE, LATITUDE];
          }
          selDef.select = { type: "interval", ...def2 };
        }
        if (selCmpt.translate && !scaleBindings.defined(selCmpt)) {
          const filterExpr = `!event.item || event.item.mark.name !== ${$(selCmpt.name + BRUSH)}`;
          for (const evt of selCmpt.events) {
            if (!evt.between) {
              warn(`${evt} is not an ordered event stream for interval selections.`);
              continue;
            }
            const filters2 = array$2((_a2 = evt.between[0]).filter ?? (_a2.filter = []));
            if (filters2.indexOf(filterExpr) < 0) {
              filters2.push(filterExpr);
            }
          }
        }
      },
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const tupleSg = name2 + TUPLE;
        const channels = vals(selCmpt.project.hasChannel).filter((p) => p.channel === X || p.channel === Y);
        const init2 = selCmpt.init ? selCmpt.init[0] : null;
        signals.push(...channels.reduce((arr, proj) => arr.concat(channelSignals(model, selCmpt, proj, init2 && init2[proj.index])), []));
        if (!model.hasProjection) {
          if (!scaleBindings.defined(selCmpt)) {
            const triggerSg = name2 + SCALE_TRIGGER;
            const scaleTriggers = channels.map((proj) => {
              const channel = proj.channel;
              const { data: dname, visual: vname } = proj.signals;
              const scaleName = $(model.scaleName(channel));
              const scaleType2 = model.getScaleComponent(channel).get("type");
              const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
              return `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`;
            });
            if (scaleTriggers.length) {
              signals.push({
                name: triggerSg,
                value: {},
                on: [
                  {
                    events: channels.map((proj) => ({ scale: model.scaleName(proj.channel) })),
                    update: scaleTriggers.join(" && ") + ` ? ${triggerSg} : {}`
                  }
                ]
              });
            }
          }
          const dataSignals = channels.map((proj) => proj.signals.data);
          const update2 = `unit: ${unitName(model)}, fields: ${name2 + TUPLE_FIELDS}, values`;
          return signals.concat({
            name: tupleSg,
            ...init2 ? { init: `{${update2}: ${assembleInit(init2)}}` } : {},
            ...dataSignals.length ? {
              on: [
                {
                  events: [{ signal: dataSignals.join(" || ") }],
                  update: `${dataSignals.join(" && ")} ? {${update2}: [${dataSignals}]} : null`
                }
              ]
            } : {}
          });
        } else {
          const projection2 = $(model.projectionName());
          const centerSg = model.projectionName() + CENTER;
          const { x: x2, y: y2 } = selCmpt.project.hasChannel;
          const xvname = x2 && x2.signals.visual;
          const yvname = y2 && y2.signals.visual;
          const xinit = x2 ? init2 && init2[x2.index] : `${centerSg}[0]`;
          const yinit = y2 ? init2 && init2[y2.index] : `${centerSg}[1]`;
          const sizeSg = (layout) => model.getSizeSignalRef(layout).signal;
          const bbox = `[[${xvname ? xvname + "[0]" : "0"}, ${yvname ? yvname + "[0]" : "0"}],[${xvname ? xvname + "[1]" : sizeSg("width")}, ${yvname ? yvname + "[1]" : sizeSg("height")}]]`;
          if (init2) {
            signals.unshift({
              name: name2 + INIT,
              init: `[scale(${projection2}, [${x2 ? xinit[0] : xinit}, ${y2 ? yinit[0] : yinit}]), scale(${projection2}, [${x2 ? xinit[1] : xinit}, ${y2 ? yinit[1] : yinit}])]`
            });
            if (!x2 || !y2) {
              const hasCenterSg = signals.find((s) => s.name === centerSg);
              if (!hasCenterSg) {
                signals.unshift({
                  name: centerSg,
                  update: `invert(${projection2}, [${sizeSg("width")}/2, ${sizeSg("height")}/2])`
                });
              }
            }
          }
          const intersect2 = `intersect(${bbox}, {markname: ${$(model.getName("marks"))}}, unit.mark)`;
          const base2 = `{unit: ${unitName(model)}}`;
          const update2 = `vlSelectionTuples(${intersect2}, ${base2})`;
          const visualSignals = channels.map((proj) => proj.signals.visual);
          return signals.concat({
            name: tupleSg,
            on: [
              {
                events: [
                  ...visualSignals.length ? [{ signal: visualSignals.join(" || ") }] : [],
                  ...init2 ? [{ signal: GEO_INIT_TICK }] : []
                ],
                update: update2
              }
            ]
          });
        }
      },
      topLevelSignals: (model, selCmpt, signals) => {
        if (isUnitModel(model) && model.hasProjection && selCmpt.init) {
          const hasTick = signals.filter((s) => s.name === GEO_INIT_TICK);
          if (!hasTick.length) {
            signals.unshift({
              name: GEO_INIT_TICK,
              value: null,
              on: [
                {
                  events: "timer{1}",
                  update: `${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`
                }
              ]
            });
          }
        }
        return signals;
      },
      marks: (model, selCmpt, marks) => {
        const name2 = selCmpt.name;
        const { x: x2, y: y2 } = selCmpt.project.hasChannel;
        const xvname = x2 == null ? void 0 : x2.signals.visual;
        const yvname = y2 == null ? void 0 : y2.signals.visual;
        const store2 = `data(${$(selCmpt.name + STORE)})`;
        if (scaleBindings.defined(selCmpt) || !x2 && !y2) {
          return marks;
        }
        const update2 = {
          x: x2 !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
          y: y2 !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
          x2: x2 !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
          y2: y2 !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
        };
        if (selCmpt.resolve === "global") {
          for (const key2 of keys(update2)) {
            update2[key2] = [
              {
                test: `${store2}.length && ${store2}[0].unit === ${unitName(model)}`,
                ...update2[key2]
              },
              { value: 0 }
            ];
          }
        }
        const { fill: fill2, fillOpacity, cursor: cursor2, ...stroke2 } = selCmpt.mark;
        const vgStroke = keys(stroke2).reduce((def2, k) => {
          def2[k] = [
            {
              test: [x2 !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y2 !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t4) => t4).join(" && "),
              value: stroke2[k]
            },
            { value: null }
          ];
          return def2;
        }, {});
        return [
          {
            name: `${name2 + BRUSH}_bg`,
            type: "rect",
            clip: true,
            encode: {
              enter: {
                fill: { value: fill2 },
                fillOpacity: { value: fillOpacity }
              },
              update: update2
            }
          },
          ...marks,
          {
            name: name2 + BRUSH,
            type: "rect",
            clip: true,
            encode: {
              enter: {
                ...cursor2 ? { cursor: { value: cursor2 } } : {},
                fill: { value: "transparent" }
              },
              update: { ...update2, ...vgStroke }
            }
          }
        ];
      }
    };
    function channelSignals(model, selCmpt, proj, init2) {
      const scaledInterval = !model.hasProjection;
      const channel = proj.channel;
      const vname = proj.signals.visual;
      const scaleName = $(scaledInterval ? model.scaleName(channel) : model.projectionName());
      const scaled = (str) => `scale(${scaleName}, ${str})`;
      const size2 = model.getSizeSignalRef(channel === X ? "width" : "height").signal;
      const coord = `${channel}(unit)`;
      const von = selCmpt.events.reduce((def2, evt) => {
        return [
          ...def2,
          { events: evt.between[0], update: `[${coord}, ${coord}]` },
          { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size2})]` }
          // Brush End
        ];
      }, []);
      if (scaledInterval) {
        const dname = proj.signals.data;
        const hasScales = scaleBindings.defined(selCmpt);
        const scale2 = model.getScaleComponent(channel);
        const scaleType2 = scale2 ? scale2.get("type") : void 0;
        const vinit = init2 ? { init: assembleInit(init2, true, scaled) } : { value: [] };
        von.push({
          events: { signal: selCmpt.name + SCALE_TRIGGER },
          update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
        });
        return hasScales ? [{ name: dname, on: [] }] : [
          { name: vname, ...vinit, on: von },
          {
            name: dname,
            ...init2 ? { init: assembleInit(init2) } : {},
            on: [
              {
                events: { signal: vname },
                update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
              }
            ]
          }
        ];
      } else {
        const initIdx = channel === X ? 0 : 1;
        const initSg = selCmpt.name + INIT;
        const vinit = init2 ? { init: `[${initSg}[0][${initIdx}], ${initSg}[1][${initIdx}]]` } : { value: [] };
        return [{ name: vname, ...vinit, on: von }];
      }
    }
    const point$1 = {
      defined: (selCmpt) => selCmpt.type === "point",
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const fieldsSg = name2 + TUPLE_FIELDS;
        const project2 = selCmpt.project;
        const datum2 = "(item().isVoronoi ? datum.datum : datum)";
        const brushes = vals(model.component.selection ?? {}).reduce((acc, cmpt) => {
          return cmpt.type === "interval" ? acc.concat(cmpt.name + BRUSH) : acc;
        }, []).map((b2) => `indexof(item().mark.name, '${b2}') < 0`).join(" && ");
        const test2 = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ""}`;
        let update2 = `unit: ${unitName(model)}, `;
        if (selCmpt.project.hasSelectionId) {
          update2 += `${SELECTION_ID}: ${datum2}[${$(SELECTION_ID)}]`;
        } else {
          const values2 = project2.items.map((p) => {
            const fieldDef = model.fieldDef(p.channel);
            return (fieldDef == null ? void 0 : fieldDef.bin) ? `[${datum2}[${$(model.vgField(p.channel, {}))}], ${datum2}[${$(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum2}[${$(p.field)}]`;
          }).join(", ");
          update2 += `fields: ${fieldsSg}, values: [${values2}]`;
        }
        const events2 = selCmpt.events;
        return signals.concat([
          {
            name: name2 + TUPLE,
            on: events2 ? [
              {
                events: events2,
                update: `${test2} ? {${update2}} : null`,
                force: true
              }
            ] : []
          }
        ]);
      }
    };
    function wrapCondition(model, channelDef, vgChannel, refFn) {
      const condition = isConditionalDef(channelDef) && channelDef.condition;
      const valueRef = refFn(channelDef);
      if (condition) {
        const conditions = array$2(condition);
        const vgConditions = conditions.map((c2) => {
          const conditionValueRef = refFn(c2);
          if (isConditionalParameter(c2)) {
            const { param: param2, empty: empty2 } = c2;
            const test2 = parseSelectionPredicate(model, { param: param2, empty: empty2 });
            return { test: test2, ...conditionValueRef };
          } else {
            const test2 = expression(model, c2.test);
            return { test: test2, ...conditionValueRef };
          }
        });
        return {
          [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
        };
      } else {
        return valueRef !== void 0 ? { [vgChannel]: valueRef } : {};
      }
    }
    function text$1(model, channel = "text") {
      const channelDef = model.encoding[channel];
      return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
    }
    function textRef(channelDef, config, expr2 = "datum") {
      if (channelDef) {
        if (isValueDef(channelDef)) {
          return signalOrValueRef(channelDef.value);
        }
        if (isFieldOrDatumDef(channelDef)) {
          const { format: format2, formatType } = getFormatMixins(channelDef);
          return formatSignalRef({ fieldOrDatumDef: channelDef, format: format2, formatType, expr: expr2, config });
        }
      }
      return void 0;
    }
    function tooltip(model, opt = {}) {
      const { encoding, markDef, config, stack: stack2 } = model;
      const channelDef = encoding.tooltip;
      if (isArray(channelDef)) {
        return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack2, config, opt) };
      } else {
        const datum2 = opt.reactiveGeom ? "datum.datum" : "datum";
        return wrapCondition(model, channelDef, "tooltip", (cDef) => {
          const tooltipRefFromChannelDef = textRef(cDef, config, datum2);
          if (tooltipRefFromChannelDef) {
            return tooltipRefFromChannelDef;
          }
          if (cDef === null) {
            return void 0;
          }
          let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
          if (markTooltip === true) {
            markTooltip = { content: "encoding" };
          }
          if (isString(markTooltip)) {
            return { value: markTooltip };
          } else if (isObject(markTooltip)) {
            if (isSignalRef(markTooltip)) {
              return markTooltip;
            } else if (markTooltip.content === "encoding") {
              return tooltipRefForEncoding(encoding, stack2, config, opt);
            } else {
              return { signal: datum2 };
            }
          }
          return void 0;
        });
      }
    }
    function tooltipData(encoding, stack2, config, { reactiveGeom } = {}) {
      const formatConfig = { ...config, ...config.tooltipFormat };
      const toSkip = {};
      const expr2 = reactiveGeom ? "datum.datum" : "datum";
      const tuples = [];
      function add2(fDef, channel) {
        const mainChannel = getMainRangeChannel(channel);
        const fieldDef = isTypedFieldDef(fDef) ? fDef : {
          ...fDef,
          type: encoding[mainChannel].type
          // for secondary field def, copy type from main channel
        };
        const title2 = fieldDef.title || defaultTitle(fieldDef, formatConfig);
        const key2 = array$2(title2).join(", ").replaceAll(/"/g, '\\"');
        let value2;
        if (isXorY(channel)) {
          const channel2 = channel === "x" ? "x2" : "y2";
          const fieldDef2 = getFieldDef(encoding[channel2]);
          if (isBinned(fieldDef.bin) && fieldDef2) {
            const startField = vgField(fieldDef, { expr: expr2 });
            const endField = vgField(fieldDef2, { expr: expr2 });
            const { format: format2, formatType } = getFormatMixins(fieldDef);
            value2 = binFormatExpression(startField, endField, format2, formatType, formatConfig);
            toSkip[channel2] = true;
          }
        }
        if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack2 && stack2.fieldChannel === channel && stack2.offset === "normalize") {
          const { format: format2, formatType } = getFormatMixins(fieldDef);
          value2 = formatSignalRef({
            fieldOrDatumDef: fieldDef,
            format: format2,
            formatType,
            expr: expr2,
            config: formatConfig,
            normalizeStack: true
          }).signal;
        }
        value2 ?? (value2 = textRef(fieldDef, formatConfig, expr2).signal);
        tuples.push({ channel, key: key2, value: value2 });
      }
      forEach(encoding, (channelDef, channel) => {
        if (isFieldDef(channelDef)) {
          add2(channelDef, channel);
        } else if (hasConditionalFieldDef(channelDef)) {
          add2(channelDef.condition, channel);
        }
      });
      const out = {};
      for (const { channel, key: key2, value: value2 } of tuples) {
        if (!toSkip[channel] && !out[key2]) {
          out[key2] = value2;
        }
      }
      return out;
    }
    function tooltipRefForEncoding(encoding, stack2, config, { reactiveGeom } = {}) {
      const data2 = tooltipData(encoding, stack2, config, { reactiveGeom });
      const keyValues = entries$1(data2).map(([key2, value2]) => `"${key2}": ${value2}`);
      return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
    }
    function aria(model) {
      const { markDef, config } = model;
      const enableAria = getMarkPropOrConfig("aria", markDef, config);
      if (enableAria === false) {
        return {};
      }
      return {
        ...enableAria ? { aria: enableAria } : {},
        ...ariaRoleDescription(model),
        ...description$1(model)
      };
    }
    function ariaRoleDescription(model) {
      const { mark, markDef, config } = model;
      if (config.aria === false) {
        return {};
      }
      const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
      if (ariaRoleDesc != null) {
        return { ariaRoleDescription: { value: ariaRoleDesc } };
      }
      return mark in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark } };
    }
    function description$1(model) {
      const { encoding, markDef, config, stack: stack2 } = model;
      const channelDef = encoding.description;
      if (channelDef) {
        return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
      }
      const descriptionValue = getMarkPropOrConfig("description", markDef, config);
      if (descriptionValue != null) {
        return {
          description: signalOrValueRef(descriptionValue)
        };
      }
      if (config.aria === false) {
        return {};
      }
      const data2 = tooltipData(encoding, stack2, config);
      if (isEmpty(data2)) {
        return void 0;
      }
      return {
        description: {
          signal: entries$1(data2).map(([key2, value2], index2) => `"${index2 > 0 ? "; " : ""}${key2}: " + (${value2})`).join(" + ")
        }
      };
    }
    function nonPosition(channel, model, opt = {}) {
      const { markDef, encoding, config } = model;
      const { vgChannel } = opt;
      let { defaultRef, defaultValue } = opt;
      if (defaultRef === void 0) {
        defaultValue ?? (defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true }));
        if (defaultValue !== void 0) {
          defaultRef = signalOrValueRef(defaultValue);
        }
      }
      const channelDef = encoding[channel];
      return wrapCondition(model, channelDef, vgChannel ?? channel, (cDef) => {
        return midPoint({
          channel,
          channelDef: cDef,
          markDef,
          config,
          scaleName: model.scaleName(channel),
          scale: model.getScaleComponent(channel),
          stack: null,
          defaultRef
        });
      });
    }
    function color(model, opt = { filled: void 0 }) {
      const { markDef, encoding, config } = model;
      const { type: markType2 } = markDef;
      const filled = opt.filled ?? getMarkPropOrConfig("filled", markDef, config);
      const transparentIfNeeded = contains(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
      const defaultFill = getMarkPropOrConfig(filled === true ? "color" : void 0, markDef, config, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
      config.mark[filled === true && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
      // with transparent fills https://github.com/vega/vega-lite/issues/1316
      transparentIfNeeded;
      const defaultStroke = getMarkPropOrConfig(filled === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
      config.mark[filled === false && "color"];
      const colorVgChannel = filled ? "fill" : "stroke";
      const fillStrokeMarkDefAndConfig = {
        ...defaultFill ? { fill: signalOrValueRef(defaultFill) } : {},
        ...defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {}
      };
      if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {
        warn(droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
      }
      return {
        ...fillStrokeMarkDefAndConfig,
        ...nonPosition("color", model, {
          vgChannel: colorVgChannel,
          defaultValue: filled ? defaultFill : defaultStroke
        }),
        ...nonPosition("fill", model, {
          // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
          defaultValue: encoding.fill ? defaultFill : void 0
        }),
        ...nonPosition("stroke", model, {
          // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
          defaultValue: encoding.stroke ? defaultStroke : void 0
        })
      };
    }
    function zindex(model) {
      const { encoding, mark } = model;
      const order = encoding.order;
      if (!isPathMark(mark) && isValueDef(order)) {
        return wrapCondition(model, order, "zindex", (cd) => signalOrValueRef(cd.value));
      }
      return {};
    }
    function positionOffset({ channel: baseChannel, markDef, encoding = {}, model, bandPosition }) {
      const channel = `${baseChannel}Offset`;
      const defaultValue = markDef[channel];
      const channelDef = encoding[channel];
      if ((channel === "xOffset" || channel === "yOffset") && channelDef) {
        const ref2 = midPoint({
          channel,
          channelDef,
          markDef,
          config: model == null ? void 0 : model.config,
          scaleName: model.scaleName(channel),
          scale: model.getScaleComponent(channel),
          stack: null,
          defaultRef: signalOrValueRef(defaultValue),
          bandPosition
        });
        return { offsetType: "encoding", offset: ref2 };
      }
      const markDefOffsetValue = markDef[channel];
      if (markDefOffsetValue) {
        return { offsetType: "visual", offset: markDefOffsetValue };
      }
      return {};
    }
    function pointPosition(channel, model, { defaultPos, vgChannel }) {
      const { encoding, markDef, config, stack: stack2 } = model;
      const channelDef = encoding[channel];
      const channel2Def = encoding[getSecondaryRangeChannel(channel)];
      const scaleName = model.scaleName(channel);
      const scale2 = model.getScaleComponent(channel);
      const { offset: offset2, offsetType } = positionOffset({
        channel,
        markDef,
        encoding,
        model,
        bandPosition: 0.5
      });
      const defaultRef = pointPositionDefaultRef({
        model,
        defaultPos,
        channel,
        scaleName,
        scale: scale2
      });
      const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? (
        // use geopoint output if there are lat/long and there is no point position overriding lat/long.
        { field: model.getName(channel) }
      ) : positionRef({
        channel,
        channelDef,
        channel2Def,
        markDef,
        config,
        scaleName,
        scale: scale2,
        stack: stack2,
        offset: offset2,
        defaultRef,
        bandPosition: offsetType === "encoding" ? 0 : void 0
      });
      return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
    }
    function positionRef(params2) {
      const { channel, channelDef, scaleName, stack: stack2, offset: offset2, markDef } = params2;
      if (isFieldOrDatumDef(channelDef) && stack2 && channel === stack2.fieldChannel) {
        if (isFieldDef(channelDef)) {
          let bandPosition = channelDef.bandPosition;
          if (bandPosition === void 0 && markDef.type === "text" && (channel === "radius" || channel === "theta")) {
            bandPosition = 0.5;
          }
          if (bandPosition !== void 0) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              startSuffix: "start",
              bandPosition,
              offset: offset2
            });
          }
        }
        return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset: offset2 });
      }
      return midPointRefWithPositionInvalidTest(params2);
    }
    function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale: scale2 }) {
      const { markDef, config } = model;
      return () => {
        const mainChannel = getMainRangeChannel(channel);
        const vgChannel = getVgPositionChannel(channel);
        const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
        if (definedValueOrConfig !== void 0) {
          return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
        }
        switch (defaultPos) {
          case "zeroOrMin":
          case "zeroOrMax":
            if (scaleName) {
              const scaleType2 = scale2.get("type");
              if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2))
                ;
              else {
                if (scale2.domainDefinitelyIncludesZero()) {
                  return {
                    scale: scaleName,
                    value: 0
                  };
                }
              }
            }
            if (defaultPos === "zeroOrMin") {
              return mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
            } else {
              switch (mainChannel) {
                case "radius":
                  return {
                    signal: `min(${model.width.signal},${model.height.signal})/2`
                  };
                case "theta":
                  return { signal: "2*PI" };
                case "x":
                  return { field: { group: "width" } };
                case "y":
                  return { value: 0 };
              }
            }
            break;
          case "mid": {
            const sizeRef = model[getSizeChannel(channel)];
            return { ...sizeRef, mult: 0.5 };
          }
        }
        return void 0;
      };
    }
    const ALIGNED_X_CHANNEL = {
      left: "x",
      center: "xc",
      right: "x2"
    };
    const BASELINED_Y_CHANNEL = {
      top: "y",
      middle: "yc",
      bottom: "y2"
    };
    function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
      if (channel === "radius" || channel === "theta") {
        return getVgPositionChannel(channel);
      }
      const alignChannel = channel === "x" ? "align" : "baseline";
      const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
      let alignExcludingSignal;
      if (isSignalRef(align2)) {
        warn(rangeMarkAlignmentCannotBeExpression(alignChannel));
        alignExcludingSignal = void 0;
      } else {
        alignExcludingSignal = align2;
      }
      if (channel === "x") {
        return ALIGNED_X_CHANNEL[alignExcludingSignal || (defaultAlign === "top" ? "left" : "center")];
      } else {
        return BASELINED_Y_CHANNEL[alignExcludingSignal || defaultAlign];
      }
    }
    function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range2 }) {
      if (range2) {
        return rangePosition(channel, model, { defaultPos, defaultPos2 });
      }
      return pointPosition(channel, model, { defaultPos });
    }
    function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
      const { markDef, config } = model;
      const channel2 = getSecondaryRangeChannel(channel);
      const sizeChannel = getSizeChannel(channel);
      const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
      const vgChannel = pos2Mixins[sizeChannel] ? (
        // If there is width/height, we need to position the marks based on the alignment.
        vgAlignedPositionChannel(channel, markDef, config)
      ) : (
        // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
        getVgPositionChannel(channel)
      );
      return {
        ...pointPosition(channel, model, { defaultPos, vgChannel }),
        ...pos2Mixins
      };
    }
    function pointPosition2OrSize(model, defaultPos, channel) {
      const { encoding, mark, markDef, stack: stack2, config } = model;
      const baseChannel = getMainRangeChannel(channel);
      const sizeChannel = getSizeChannel(channel);
      const vgChannel = getVgPositionChannel(channel);
      const channelDef = encoding[baseChannel];
      const scaleName = model.scaleName(baseChannel);
      const scale2 = model.getScaleComponent(baseChannel);
      const { offset: offset2 } = channel in encoding || channel in markDef ? positionOffset({ channel, markDef, encoding, model }) : positionOffset({ channel: baseChannel, markDef, encoding, model });
      if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
        const vgSizeChannel = getSizeChannel(channel);
        const size2 = model.markDef[vgSizeChannel];
        if (size2 != null) {
          return {
            [vgSizeChannel]: { value: size2 }
          };
        } else {
          return {
            [vgChannel]: { field: model.getName(channel) }
          };
        }
      }
      const valueRef = position2Ref({
        channel,
        channelDef,
        channel2Def: encoding[channel],
        markDef,
        config,
        scaleName,
        scale: scale2,
        stack: stack2,
        offset: offset2,
        defaultRef: void 0
      });
      if (valueRef !== void 0) {
        return { [vgChannel]: valueRef };
      }
      return position2orSize(channel, markDef) || position2orSize(channel, {
        [channel]: getMarkStyleConfig(channel, markDef, config.style),
        [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
      }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {
        [vgChannel]: pointPositionDefaultRef({
          model,
          defaultPos,
          channel,
          scaleName,
          scale: scale2
        })()
      };
    }
    function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale2, stack: stack2, offset: offset2, defaultRef }) {
      if (isFieldOrDatumDef(channelDef) && stack2 && // If fieldChannel is X and channel is X2 (or Y and Y2)
      channel.charAt(0) === stack2.fieldChannel.charAt(0)) {
        return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset: offset2 });
      }
      return midPointRefWithPositionInvalidTest({
        channel,
        channelDef: channel2Def,
        scaleName,
        scale: scale2,
        stack: stack2,
        markDef,
        config,
        offset: offset2,
        defaultRef
      });
    }
    function position2orSize(channel, markDef) {
      const sizeChannel = getSizeChannel(channel);
      const vgChannel = getVgPositionChannel(channel);
      if (markDef[vgChannel] !== void 0) {
        return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
      } else if (markDef[channel] !== void 0) {
        return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
      } else if (markDef[sizeChannel]) {
        const dimensionSize = markDef[sizeChannel];
        if (isRelativeBandSize(dimensionSize)) {
          warn(relativeBandSizeNotSupported(sizeChannel));
        } else {
          return { [sizeChannel]: widthHeightValueOrSignalRef(channel, dimensionSize) };
        }
      }
      return void 0;
    }
    function rectPosition(model, channel) {
      const { config, encoding, markDef } = model;
      const mark = markDef.type;
      const channel2 = getSecondaryRangeChannel(channel);
      const sizeChannel = getSizeChannel(channel);
      const channelDef = encoding[channel];
      const channelDef2 = encoding[channel2];
      const scale2 = model.getScaleComponent(channel);
      const scaleType2 = scale2 ? scale2.get("type") : void 0;
      const orient2 = markDef.orient;
      const hasSizeDef = encoding[sizeChannel] ?? encoding.size ?? getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
      const offsetScaleChannel = getOffsetChannel(channel);
      const isBarBand = mark === "bar" && (channel === "x" ? orient2 === "vertical" : orient2 === "horizontal");
      if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !encoding[offsetScaleChannel] && !hasDiscreteDomain(scaleType2)) {
        return rectBinPosition({
          fieldDef: channelDef,
          fieldDef2: channelDef2,
          channel,
          model
        });
      } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
        return positionAndSize(channelDef, channel, model);
      } else {
        return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
      }
    }
    function defaultSizeRef(sizeChannel, scaleName, scale2, config, bandSize, hasFieldDef, mark) {
      if (isRelativeBandSize(bandSize)) {
        if (scale2) {
          const scaleType2 = scale2.get("type");
          if (scaleType2 === "band") {
            let bandWidth = `bandwidth('${scaleName}')`;
            if (bandSize.band !== 1) {
              bandWidth = `${bandSize.band} * ${bandWidth}`;
            }
            const minBandSize = getMarkConfig("minBandSize", { type: mark }, config);
            return { signal: minBandSize ? `max(${signalOrStringValue(minBandSize)}, ${bandWidth})` : bandWidth };
          } else if (bandSize.band !== 1) {
            warn(cannotUseRelativeBandSizeWithNonBandScale(scaleType2));
            bandSize = void 0;
          }
        } else {
          return {
            mult: bandSize.band,
            field: { group: sizeChannel }
          };
        }
      } else if (isSignalRef(bandSize)) {
        return bandSize;
      } else if (bandSize) {
        return { value: bandSize };
      }
      if (scale2) {
        const scaleRange = scale2.get("range");
        if (isVgRangeStep(scaleRange) && isNumber$1(scaleRange.step)) {
          return { value: scaleRange.step - 2 };
        }
      }
      if (!hasFieldDef) {
        const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner } = config.scale;
        const padding2 = getFirstDefined(bandPaddingInner, mark === "bar" ? barBandPaddingInner : rectBandPaddingInner);
        if (isSignalRef(padding2)) {
          return { signal: `(1 - (${padding2.signal})) * ${sizeChannel}` };
        } else if (isNumber$1(padding2)) {
          return { signal: `${1 - padding2} * ${sizeChannel}` };
        }
      }
      const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);
      return { value: defaultStep - 2 };
    }
    function positionAndSize(fieldDef, channel, model) {
      var _a2, _b;
      const { markDef, encoding, config, stack: stack2 } = model;
      const orient2 = markDef.orient;
      const scaleName = model.scaleName(channel);
      const scale2 = model.getScaleComponent(channel);
      const vgSizeChannel = getSizeChannel(channel);
      const channel2 = getSecondaryRangeChannel(channel);
      const offsetScaleChannel = getOffsetChannel(channel);
      const offsetScaleName = model.scaleName(offsetScaleChannel);
      const offsetScale = model.getScaleComponent(getOffsetScaleChannel(channel));
      const useVlSizeChannel = orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x";
      let sizeMixins;
      if (encoding.size || markDef.size) {
        if (useVlSizeChannel) {
          sizeMixins = nonPosition("size", model, {
            vgChannel: vgSizeChannel,
            defaultRef: signalOrValueRef(markDef.size)
          });
        } else {
          warn(cannotApplySizeToNonOrientedMark(markDef.type));
        }
      }
      const hasSizeFromMarkOrEncoding = !!sizeMixins;
      const bandSize = getBandSize({
        channel,
        fieldDef,
        markDef,
        config,
        scaleType: (_a2 = scale2 || offsetScale) == null ? void 0 : _a2.get("type"),
        useVlSizeChannel
      });
      sizeMixins = sizeMixins || {
        [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, offsetScale || scale2, config, bandSize, !!fieldDef, markDef.type)
      };
      const defaultBandAlign = ((_b = scale2 || offsetScale) == null ? void 0 : _b.get("type")) === "band" && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? "top" : "middle";
      const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);
      const center2 = vgChannel === "xc" || vgChannel === "yc";
      const { offset: offset2, offsetType } = positionOffset({ channel, markDef, encoding, model, bandPosition: center2 ? 0.5 : 0 });
      const posRef = midPointRefWithPositionInvalidTest({
        channel,
        channelDef: fieldDef,
        markDef,
        config,
        scaleName,
        scale: scale2,
        stack: stack2,
        offset: offset2,
        defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale: scale2 }),
        bandPosition: center2 ? offsetType === "encoding" ? 0 : 0.5 : isSignalRef(bandSize) ? { signal: `(1-${bandSize})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0
      });
      if (vgSizeChannel) {
        return { [vgChannel]: posRef, ...sizeMixins };
      } else {
        const vgChannel2 = getVgPositionChannel(channel2);
        const sizeRef = sizeMixins[vgSizeChannel];
        const sizeOffset = offset2 ? { ...sizeRef, offset: offset2 } : sizeRef;
        return {
          [vgChannel]: posRef,
          // posRef might be an array that wraps position invalid test
          [vgChannel2]: isArray(posRef) ? [posRef[0], { ...posRef[1], offset: sizeOffset }] : {
            ...posRef,
            offset: sizeOffset
          }
        };
      }
    }
    function getBinSpacing(channel, spacing, reverse2, axisTranslate, offset2, minBandSize, bandSizeExpr) {
      if (isPolarPositionChannel(channel)) {
        return 0;
      }
      const isEnd = channel === "x" || channel === "y2";
      const spacingOffset = isEnd ? -spacing / 2 : spacing / 2;
      if (isSignalRef(reverse2) || isSignalRef(offset2) || isSignalRef(axisTranslate) || minBandSize) {
        const reverseExpr = signalOrStringValue(reverse2);
        const offsetExpr2 = signalOrStringValue(offset2);
        const axisTranslateExpr = signalOrStringValue(axisTranslate);
        const minBandSizeExpr = signalOrStringValue(minBandSize);
        const sign2 = isEnd ? "" : "-";
        const spacingAndSizeOffset = minBandSize ? `(${bandSizeExpr} < ${minBandSizeExpr} ? ${sign2}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacingOffset})` : spacingOffset;
        const t4 = axisTranslateExpr ? `${axisTranslateExpr} + ` : "";
        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : "";
        const o = offsetExpr2 ? `(${offsetExpr2} + ${spacingAndSizeOffset})` : spacingAndSizeOffset;
        return {
          signal: t4 + r + o
        };
      } else {
        offset2 = offset2 || 0;
        return axisTranslate + (reverse2 ? -offset2 - spacingOffset : +offset2 + spacingOffset);
      }
    }
    function rectBinPosition({ fieldDef, fieldDef2, channel, model }) {
      var _a2;
      const { config, markDef, encoding } = model;
      const scale2 = model.getScaleComponent(channel);
      const scaleName = model.scaleName(channel);
      const scaleType2 = scale2 ? scale2.get("type") : void 0;
      const reverse2 = scale2.get("reverse");
      const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scaleType2 });
      const axis2 = (_a2 = model.component.axes[channel]) == null ? void 0 : _a2[0];
      const axisTranslate = (axis2 == null ? void 0 : axis2.get("translate")) ?? 0.5;
      const spacing = isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) ?? 0 : 0;
      const channel2 = getSecondaryRangeChannel(channel);
      const vgChannel = getVgPositionChannel(channel);
      const vgChannel2 = getVgPositionChannel(channel2);
      const minBandSize = getMarkConfig("minBandSize", markDef, config);
      const { offset: offset2 } = positionOffset({ channel, markDef, encoding, model, bandPosition: 0 });
      const { offset: offset22 } = positionOffset({ channel: channel2, markDef, encoding, model, bandPosition: 0 });
      const bandSizeExpr = binSizeExpr({ fieldDef, scaleName });
      const binSpacingOffset = getBinSpacing(channel, spacing, reverse2, axisTranslate, offset2, minBandSize, bandSizeExpr);
      const binSpacingOffset2 = getBinSpacing(channel2, spacing, reverse2, axisTranslate, offset22 ?? offset2, minBandSize, bandSizeExpr);
      const bandPositionForBandSize = isSignalRef(bandSize) ? { signal: `(1-${bandSize.signal})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;
      const bandPosition = getBandPosition({ fieldDef, fieldDef2, markDef, config });
      if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
        const useRectOffsetField = fieldDef.timeUnit && bandPosition !== 0.5;
        return {
          [vgChannel2]: rectBinRef({
            fieldDef,
            scaleName,
            bandPosition: bandPositionForBandSize,
            offset: binSpacingOffset2,
            useRectOffsetField
          }),
          [vgChannel]: rectBinRef({
            fieldDef,
            scaleName,
            bandPosition: isSignalRef(bandPositionForBandSize) ? { signal: `1-${bandPositionForBandSize.signal}` } : 1 - bandPositionForBandSize,
            offset: binSpacingOffset,
            useRectOffsetField
          })
        };
      } else if (isBinned(fieldDef.bin)) {
        const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: binSpacingOffset2 });
        if (isFieldDef(fieldDef2)) {
          return {
            [vgChannel2]: startRef,
            [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: binSpacingOffset })
          };
        } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
          return {
            [vgChannel2]: startRef,
            [vgChannel]: {
              signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
              offset: binSpacingOffset
            }
          };
        }
      }
      warn(channelRequiredForBinned(channel2));
      return void 0;
    }
    function rectBinRef({ fieldDef, scaleName, bandPosition, offset: offset2, useRectOffsetField }) {
      return interpolatedSignalRef({
        scaleName,
        fieldOrDatumDef: fieldDef,
        bandPosition,
        offset: offset2,
        ...useRectOffsetField ? {
          startSuffix: OFFSETTED_RECT_START_SUFFIX,
          endSuffix: OFFSETTED_RECT_END_SUFFIX
        } : {}
      });
    }
    const ALWAYS_IGNORE = /* @__PURE__ */ new Set(["aria", "width", "height"]);
    function baseEncodeEntry(model, ignore) {
      const { fill: fill2 = void 0, stroke: stroke2 = void 0 } = ignore.color === "include" ? color(model) : {};
      return {
        ...markDefProperties(model.markDef, ignore),
        ...wrapAllFieldsInvalid(model, "fill", fill2),
        ...wrapAllFieldsInvalid(model, "stroke", stroke2),
        ...nonPosition("opacity", model),
        ...nonPosition("fillOpacity", model),
        ...nonPosition("strokeOpacity", model),
        ...nonPosition("strokeWidth", model),
        ...nonPosition("strokeDash", model),
        ...zindex(model),
        ...tooltip(model),
        ...text$1(model, "href"),
        ...aria(model)
      };
    }
    function wrapAllFieldsInvalid(model, channel, valueRef) {
      const { config, mark, markDef } = model;
      const invalid = getMarkPropOrConfig("invalid", markDef, config);
      if (invalid === "hide" && valueRef && !isPathMark(mark)) {
        const test2 = allFieldsInvalidPredicate$1(model, { invalid: true, channels: SCALE_CHANNELS });
        if (test2) {
          return {
            [channel]: [
              // prepend the invalid case
              // TODO: support custom value
              { test: test2, value: null },
              ...array$2(valueRef)
            ]
          };
        }
      }
      return valueRef ? { [channel]: valueRef } : {};
    }
    function markDefProperties(mark, ignore) {
      return VG_MARK_CONFIGS.reduce((m2, prop) => {
        if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== void 0 && ignore[prop] !== "ignore") {
          m2[prop] = signalOrValueRef(mark[prop]);
        }
        return m2;
      }, {});
    }
    function allFieldsInvalidPredicate$1(model, { invalid = false, channels }) {
      const filterIndex = channels.reduce((aggregator, channel) => {
        const scaleComponent = model.getScaleComponent(channel);
        if (scaleComponent) {
          const scaleType2 = scaleComponent.get("type");
          const field2 = model.vgField(channel, { expr: "datum" });
          if (field2 && hasContinuousDomain(scaleType2)) {
            aggregator[field2] = true;
          }
        }
        return aggregator;
      }, {});
      const fields = keys(filterIndex);
      if (fields.length > 0) {
        const op = invalid ? "||" : "&&";
        return fields.map((field2) => fieldInvalidPredicate(field2, invalid)).join(` ${op} `);
      }
      return void 0;
    }
    function defined(model) {
      const { config, markDef } = model;
      const invalid = getMarkPropOrConfig("invalid", markDef, config);
      if (invalid) {
        const signal = allFieldsInvalidPredicate(model, { channels: POSITION_SCALE_CHANNELS });
        if (signal) {
          return { defined: { signal } };
        }
      }
      return {};
    }
    function allFieldsInvalidPredicate(model, { invalid = false, channels }) {
      const filterIndex = channels.reduce((aggregator, channel) => {
        var _a2;
        const scaleComponent = model.getScaleComponent(channel);
        if (scaleComponent) {
          const scaleType2 = scaleComponent.get("type");
          const field2 = model.vgField(channel, { expr: "datum", binSuffix: ((_a2 = model.stack) == null ? void 0 : _a2.impute) ? "mid" : void 0 });
          if (field2 && hasContinuousDomain(scaleType2)) {
            aggregator[field2] = true;
          }
        }
        return aggregator;
      }, {});
      const fields = keys(filterIndex);
      if (fields.length > 0) {
        const op = invalid ? "||" : "&&";
        return fields.map((field2) => fieldInvalidPredicate(field2, invalid)).join(` ${op} `);
      }
      return void 0;
    }
    function valueIfDefined(prop, value2) {
      if (value2 !== void 0) {
        return { [prop]: signalOrValueRef(value2) };
      }
      return void 0;
    }
    const VORONOI = "voronoi";
    const nearest = {
      defined: (selCmpt) => {
        return selCmpt.type === "point" && selCmpt.nearest;
      },
      parse: (model, selCmpt) => {
        if (selCmpt.events) {
          for (const s of selCmpt.events) {
            s.markname = model.getName(VORONOI);
          }
        }
      },
      marks: (model, selCmpt, marks) => {
        const { x: x2, y: y2 } = selCmpt.project.hasChannel;
        const markType2 = model.mark;
        if (isPathMark(markType2)) {
          warn(nearestNotSupportForContinuous(markType2));
          return marks;
        }
        const cellDef = {
          name: model.getName(VORONOI),
          type: "path",
          interactive: true,
          from: { data: model.getName("marks") },
          encode: {
            update: {
              fill: { value: "transparent" },
              strokeWidth: { value: 0.35 },
              stroke: { value: "transparent" },
              isVoronoi: { value: true },
              ...tooltip(model, { reactiveGeom: true })
            }
          },
          transform: [
            {
              type: "voronoi",
              x: { expr: x2 || !y2 ? "datum.datum.x || 0" : "0" },
              y: { expr: y2 || !x2 ? "datum.datum.y || 0" : "0" },
              size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
            }
          ]
        };
        let index2 = 0;
        let exists = false;
        marks.forEach((mark, i) => {
          const name2 = mark.name ?? "";
          if (name2 === model.component.mark[0].name) {
            index2 = i;
          } else if (name2.indexOf(VORONOI) >= 0) {
            exists = true;
          }
        });
        if (!exists) {
          marks.splice(index2 + 1, 0, cellDef);
        }
        return marks;
      }
    };
    const inputBindings = {
      defined: (selCmpt) => {
        return selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
      },
      parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),
      topLevelSignals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const proj = selCmpt.project;
        const bind2 = selCmpt.bind;
        const init2 = selCmpt.init && selCmpt.init[0];
        const datum2 = nearest.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
        proj.items.forEach((p, i) => {
          const sgname = varName(`${name2}_${p.field}`);
          const hasSignal2 = signals.filter((s) => s.name === sgname);
          if (!hasSignal2.length) {
            signals.unshift({
              name: sgname,
              ...init2 ? { init: assembleInit(init2[i]) } : { value: null },
              on: selCmpt.events ? [
                {
                  events: selCmpt.events,
                  update: `datum && item().mark.marktype !== 'group' ? ${datum2}[${$(p.field)}] : null`
                }
              ] : [],
              bind: bind2[p.field] ?? bind2[p.channel] ?? bind2
            });
          }
        });
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const proj = selCmpt.project;
        const signal = signals.filter((s) => s.name === name2 + TUPLE)[0];
        const fields = name2 + TUPLE_FIELDS;
        const values2 = proj.items.map((p) => varName(`${name2}_${p.field}`));
        const valid = values2.map((v) => `${v} !== null`).join(" && ");
        if (values2.length) {
          signal.update = `${valid} ? {fields: ${fields}, values: [${values2.join(", ")}]} : null`;
        }
        delete signal.value;
        delete signal.on;
        return signals;
      }
    };
    const TOGGLE = "_toggle";
    const toggle = {
      defined: (selCmpt) => {
        return selCmpt.type === "point" && !!selCmpt.toggle;
      },
      signals: (model, selCmpt, signals) => {
        return signals.concat({
          name: selCmpt.name + TOGGLE,
          value: false,
          on: [{ events: selCmpt.events, update: selCmpt.toggle }]
        });
      },
      modifyExpr: (model, selCmpt) => {
        const tpl = selCmpt.name + TUPLE;
        const signal = selCmpt.name + TOGGLE;
        return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
      }
    };
    const clear = {
      defined: (selCmpt) => {
        return selCmpt.clear !== void 0 && selCmpt.clear !== false;
      },
      parse: (model, selCmpt) => {
        if (selCmpt.clear) {
          selCmpt.clear = isString(selCmpt.clear) ? eventSelector(selCmpt.clear, "view") : selCmpt.clear;
        }
      },
      topLevelSignals: (model, selCmpt, signals) => {
        if (inputBindings.defined(selCmpt)) {
          for (const proj of selCmpt.project.items) {
            const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
            if (idx !== -1) {
              signals[idx].on.push({ events: selCmpt.clear, update: "null" });
            }
          }
        }
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        function addClear(idx, update2) {
          if (idx !== -1 && signals[idx].on) {
            signals[idx].on.push({ events: selCmpt.clear, update: update2 });
          }
        }
        if (selCmpt.type === "interval") {
          for (const proj of selCmpt.project.items) {
            const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
            addClear(vIdx, "[0, 0]");
            if (vIdx === -1) {
              const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
              addClear(dIdx, "null");
            }
          }
        } else {
          let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
          addClear(tIdx, "null");
          if (toggle.defined(selCmpt)) {
            tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
            addClear(tIdx, "false");
          }
        }
        return signals;
      }
    };
    const legendBindings = {
      defined: (selCmpt) => {
        const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
        const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
        if (spec && !projLen) {
          warn(LEGEND_BINDINGS_MUST_HAVE_PROJECTION);
        }
        return spec && projLen;
      },
      parse: (model, selCmpt, selDef) => {
        const selDef_ = duplicate(selDef);
        selDef_.select = isString(selDef_.select) ? { type: selDef_.select, toggle: selCmpt.toggle } : { ...selDef_.select, toggle: selCmpt.toggle };
        disableDirectManipulation(selCmpt, selDef_);
        if (isObject(selDef.select) && (selDef.select.on || selDef.select.clear)) {
          const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
          for (const evt2 of selCmpt.events) {
            evt2.filter = array$2(evt2.filter ?? []);
            if (!evt2.filter.includes(legendFilter)) {
              evt2.filter.push(legendFilter);
            }
          }
        }
        const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
        const stream2 = isString(evt) ? eventSelector(evt, "view") : array$2(evt);
        selCmpt.bind = { legend: { merge: stream2 } };
      },
      topLevelSignals: (model, selCmpt, signals) => {
        const selName = selCmpt.name;
        const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
        const markName = (name2) => (s) => {
          const ds = duplicate(s);
          ds.markname = name2;
          return ds;
        };
        for (const proj of selCmpt.project.items) {
          if (!proj.hasLegend)
            continue;
          const prefix = `${varName(proj.field)}_legend`;
          const sgName = `${selName}_${prefix}`;
          const hasSignal2 = signals.filter((s) => s.name === sgName);
          if (hasSignal2.length === 0) {
            const events2 = stream2.merge.map(markName(`${prefix}_symbols`)).concat(stream2.merge.map(markName(`${prefix}_labels`))).concat(stream2.merge.map(markName(`${prefix}_entries`)));
            signals.unshift({
              name: sgName,
              ...!selCmpt.init ? { value: null } : {},
              on: [
                // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
                {
                  events: events2,
                  update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
                  force: true
                },
                { events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
              ]
            });
          }
        }
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const proj = selCmpt.project;
        const tuple = signals.find((s) => s.name === name2 + TUPLE);
        const fields = name2 + TUPLE_FIELDS;
        const values2 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name2}_${varName(p.field)}_legend`));
        const valid = values2.map((v) => `${v} !== null`).join(" && ");
        const update2 = `${valid} ? {fields: ${fields}, values: [${values2.join(", ")}]} : null`;
        if (selCmpt.events && values2.length > 0) {
          tuple.on.push({
            events: values2.map((signal) => ({ signal })),
            update: update2
          });
        } else if (values2.length > 0) {
          tuple.update = update2;
          delete tuple.value;
          delete tuple.on;
        }
        const toggle2 = signals.find((s) => s.name === name2 + TOGGLE);
        const events2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
        if (toggle2) {
          if (!selCmpt.events)
            toggle2.on[0].events = events2;
          else
            toggle2.on.push({ ...toggle2.on[0], events: events2 });
        }
        return signals;
      }
    };
    function parseInteractiveLegend(model, channel, legendCmpt) {
      var _a2;
      const field2 = (_a2 = model.fieldDef(channel)) == null ? void 0 : _a2.field;
      for (const selCmpt of vals(model.component.selection ?? {})) {
        const proj = selCmpt.project.hasField[field2] ?? selCmpt.project.hasChannel[channel];
        if (proj && legendBindings.defined(selCmpt)) {
          const legendSelections = legendCmpt.get("selections") ?? [];
          legendSelections.push(selCmpt.name);
          legendCmpt.set("selections", legendSelections, false);
          proj.hasLegend = true;
        }
      }
    }
    const ANCHOR$1 = "_translate_anchor";
    const DELTA$1 = "_translate_delta";
    const translate = {
      defined: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.translate;
      },
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const boundScales = scaleBindings.defined(selCmpt);
        const anchor2 = name2 + ANCHOR$1;
        const { x: x2, y: y2 } = selCmpt.project.hasChannel;
        let events2 = eventSelector(selCmpt.translate, "scope");
        if (!boundScales) {
          events2 = events2.map((e3) => (e3.between[0].markname = name2 + BRUSH, e3));
        }
        signals.push({
          name: anchor2,
          value: {},
          on: [
            {
              events: events2.map((e3) => e3.between[0]),
              update: "{x: x(unit), y: y(unit)" + (x2 !== void 0 ? `, extent_x: ${boundScales ? domain(model, X) : `slice(${x2.signals.visual})`}` : "") + (y2 !== void 0 ? `, extent_y: ${boundScales ? domain(model, Y) : `slice(${y2.signals.visual})`}` : "") + "}"
            }
          ]
        }, {
          name: name2 + DELTA$1,
          value: {},
          on: [
            {
              events: events2,
              update: `{x: ${anchor2}.x - x(unit), y: ${anchor2}.y - y(unit)}`
            }
          ]
        });
        if (x2 !== void 0) {
          onDelta$1(model, selCmpt, x2, "width", signals);
        }
        if (y2 !== void 0) {
          onDelta$1(model, selCmpt, y2, "height", signals);
        }
        return signals;
      }
    };
    function onDelta$1(model, selCmpt, proj, size2, signals) {
      const name2 = selCmpt.name;
      const anchor2 = name2 + ANCHOR$1;
      const delta = name2 + DELTA$1;
      const channel = proj.channel;
      const boundScales = scaleBindings.defined(selCmpt);
      const signal = signals.filter((s) => s.name === proj.signals[boundScales ? "data" : "visual"])[0];
      const sizeSg = model.getSizeSignalRef(size2).signal;
      const scaleCmpt = model.getScaleComponent(channel);
      const scaleType2 = scaleCmpt && scaleCmpt.get("type");
      const reversed = scaleCmpt && scaleCmpt.get("reverse");
      const sign2 = !boundScales ? "" : channel === X ? reversed ? "" : "-" : reversed ? "-" : "";
      const extent2 = `${anchor2}.extent_${channel}`;
      const offset2 = `${sign2}${delta}.${channel} / ${boundScales ? `${sizeSg}` : `span(${extent2})`}`;
      const panFn = !boundScales || !scaleCmpt ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "symlog" ? "panSymlog" : scaleType2 === "pow" ? "panPow" : "panLinear";
      const arg = !boundScales ? "" : scaleType2 === "pow" ? `, ${scaleCmpt.get("exponent") ?? 1}` : scaleType2 === "symlog" ? `, ${scaleCmpt.get("constant") ?? 1}` : "";
      const update2 = `${panFn}(${extent2}, ${offset2}${arg})`;
      signal.on.push({
        events: { signal: delta },
        update: boundScales ? update2 : `clampRange(${update2}, 0, ${sizeSg})`
      });
    }
    const ANCHOR = "_zoom_anchor";
    const DELTA = "_zoom_delta";
    const zoom = {
      defined: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.zoom;
      },
      signals: (model, selCmpt, signals) => {
        const name2 = selCmpt.name;
        const boundScales = scaleBindings.defined(selCmpt);
        const delta = name2 + DELTA;
        const { x: x2, y: y2 } = selCmpt.project.hasChannel;
        const sx = $(model.scaleName(X));
        const sy = $(model.scaleName(Y));
        let events2 = eventSelector(selCmpt.zoom, "scope");
        if (!boundScales) {
          events2 = events2.map((e3) => (e3.markname = name2 + BRUSH, e3));
        }
        signals.push({
          name: name2 + ANCHOR,
          on: [
            {
              events: events2,
              update: !boundScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => expr2).join(", ") + "}"
            }
          ]
        }, {
          name: delta,
          on: [
            {
              events: events2,
              force: true,
              update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
            }
          ]
        });
        if (x2 !== void 0) {
          onDelta(model, selCmpt, x2, "width", signals);
        }
        if (y2 !== void 0) {
          onDelta(model, selCmpt, y2, "height", signals);
        }
        return signals;
      }
    };
    function onDelta(model, selCmpt, proj, size2, signals) {
      const name2 = selCmpt.name;
      const channel = proj.channel;
      const boundScales = scaleBindings.defined(selCmpt);
      const signal = signals.filter((s) => s.name === proj.signals[boundScales ? "data" : "visual"])[0];
      const sizeSg = model.getSizeSignalRef(size2).signal;
      const scaleCmpt = model.getScaleComponent(channel);
      const scaleType2 = scaleCmpt && scaleCmpt.get("type");
      const base2 = boundScales ? domain(model, channel) : signal.name;
      const delta = name2 + DELTA;
      const anchor2 = `${name2}${ANCHOR}.${channel}`;
      const zoomFn = !boundScales || !scaleCmpt ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "symlog" ? "zoomSymlog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
      const arg = !boundScales ? "" : scaleType2 === "pow" ? `, ${scaleCmpt.get("exponent") ?? 1}` : scaleType2 === "symlog" ? `, ${scaleCmpt.get("constant") ?? 1}` : "";
      const update2 = `${zoomFn}(${base2}, ${anchor2}, ${delta}${arg})`;
      signal.on.push({
        events: { signal: delta },
        update: boundScales ? update2 : `clampRange(${update2}, 0, ${sizeSg})`
      });
    }
    const STORE = "_store";
    const TUPLE = "_tuple";
    const MODIFY = "_modify";
    const VL_SELECTION_RESOLVE = "vlSelectionResolve";
    const selectionCompilers = [
      point$1,
      interval,
      project,
      toggle,
      // Bindings may disable direct manipulation.
      inputBindings,
      scaleBindings,
      legendBindings,
      clear,
      translate,
      zoom,
      nearest
    ];
    function getFacetModel(model) {
      let parent = model.parent;
      while (parent) {
        if (isFacetModel(parent))
          break;
        parent = parent.parent;
      }
      return parent;
    }
    function unitName(model, { escape: escape2 } = { escape: true }) {
      let name2 = escape2 ? $(model.name) : model.name;
      const facetModel = getFacetModel(model);
      if (facetModel) {
        const { facet } = facetModel;
        for (const channel of FACET_CHANNELS) {
          if (facet[channel]) {
            name2 += ` + '__facet_${channel}_' + (facet[${$(facetModel.vgField(channel))}])`;
          }
        }
      }
      return name2;
    }
    function requiresSelectionId(model) {
      return vals(model.component.selection ?? {}).reduce((identifier, selCmpt) => {
        return identifier || selCmpt.project.hasSelectionId;
      }, false);
    }
    function disableDirectManipulation(selCmpt, selDef) {
      if (isString(selDef.select) || !selDef.select.on)
        delete selCmpt.events;
      if (isString(selDef.select) || !selDef.select.clear)
        delete selCmpt.clear;
      if (isString(selDef.select) || !selDef.select.toggle)
        delete selCmpt.toggle;
    }
    function getName(node) {
      const name2 = [];
      if (node.type === "Identifier") {
        return [node.name];
      }
      if (node.type === "Literal") {
        return [node.value];
      }
      if (node.type === "MemberExpression") {
        name2.push(...getName(node.object));
        name2.push(...getName(node.property));
      }
      return name2;
    }
    function startsWithDatum(node) {
      if (node.object.type === "MemberExpression") {
        return startsWithDatum(node.object);
      }
      return node.object.name === "datum";
    }
    function getDependentFields(expression2) {
      const ast = parser$1(expression2);
      const dependents = /* @__PURE__ */ new Set();
      ast.visit((node) => {
        if (node.type === "MemberExpression" && startsWithDatum(node)) {
          dependents.add(getName(node).slice(1).join("."));
        }
      });
      return dependents;
    }
    class FilterNode extends DataFlowNode {
      clone() {
        return new FilterNode(null, this.model, duplicate(this.filter));
      }
      constructor(parent, model, filter2) {
        super(parent);
        this.model = model;
        this.filter = filter2;
        this.expr = expression(this.model, this.filter, this);
        this._dependentFields = getDependentFields(this.expr);
      }
      dependentFields() {
        return this._dependentFields;
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      assemble() {
        return {
          type: "filter",
          expr: this.expr
        };
      }
      hash() {
        return `Filter ${this.expr}`;
      }
    }
    function parseUnitSelection(model, selDefs) {
      const selCmpts = {};
      const selectionConfig = model.config.selection;
      if (!selDefs || !selDefs.length)
        return selCmpts;
      for (const def2 of selDefs) {
        const name2 = varName(def2.name);
        const selDef = def2.select;
        const type2 = isString(selDef) ? selDef : selDef.type;
        const defaults2 = isObject(selDef) ? duplicate(selDef) : { type: type2 };
        const cfg = selectionConfig[type2];
        for (const key2 in cfg) {
          if (key2 === "fields" || key2 === "encodings") {
            continue;
          }
          if (key2 === "mark") {
            defaults2[key2] = { ...cfg[key2], ...defaults2[key2] };
          }
          if (defaults2[key2] === void 0 || defaults2[key2] === true) {
            defaults2[key2] = duplicate(cfg[key2] ?? defaults2[key2]);
          }
        }
        const selCmpt = selCmpts[name2] = {
          ...defaults2,
          name: name2,
          type: type2,
          init: def2.value,
          bind: def2.bind,
          events: isString(defaults2.on) ? eventSelector(defaults2.on, "scope") : array$2(duplicate(defaults2.on))
        };
        const def_ = duplicate(def2);
        for (const c2 of selectionCompilers) {
          if (c2.defined(selCmpt) && c2.parse) {
            c2.parse(model, selCmpt, def_);
          }
        }
      }
      return selCmpts;
    }
    function parseSelectionPredicate(model, pred, dfnode, datum2 = "datum") {
      const name2 = isString(pred) ? pred : pred.param;
      const vname = varName(name2);
      const store2 = $(vname + STORE);
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(vname, name2);
      } catch (e3) {
        return `!!${vname}`;
      }
      if (selCmpt.project.timeUnit) {
        const child = dfnode ?? model.component.data.raw;
        const tunode = selCmpt.project.timeUnit.clone();
        if (child.parent) {
          tunode.insertAsParentOf(child);
        } else {
          child.parent = tunode;
        }
      }
      const fn = selCmpt.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(";
      const resolve2 = selCmpt.resolve === "global" ? ")" : `, ${$(selCmpt.resolve)})`;
      const test2 = `${fn}${store2}, ${datum2}${resolve2}`;
      const length2 = `length(data(${store2}))`;
      return pred.empty === false ? `${length2} && ${test2}` : `!${length2} || ${test2}`;
    }
    function parseSelectionExtent(model, name2, extent2) {
      const vname = varName(name2);
      const encoding = extent2["encoding"];
      let field2 = extent2["field"];
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(vname, name2);
      } catch (e3) {
        return vname;
      }
      if (!encoding && !field2) {
        field2 = selCmpt.project.items[0].field;
        if (selCmpt.project.items.length > 1) {
          warn(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(field2)}.`);
        }
      } else if (encoding && !field2) {
        const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
        if (!encodings.length || encodings.length > 1) {
          field2 = selCmpt.project.items[0].field;
          warn((!encodings.length ? "No " : "Multiple ") + `matching ${$(encoding)} encoding found for selection ${$(extent2.param)}. Using "field": ${$(field2)}.`);
        } else {
          field2 = encodings[0].field;
        }
      }
      return `${selCmpt.name}[${$(replacePathInField(field2))}]`;
    }
    function materializeSelections(model, main2) {
      for (const [selection2, selCmpt] of entries$1(model.component.selection ?? {})) {
        const lookupName = model.getName(`lookup_${selection2}`);
        model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main2, model, { param: selection2 }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
      }
    }
    function expression(model, filterOp, node) {
      return logicalExpr(filterOp, (predicate) => {
        if (isString(predicate)) {
          return predicate;
        } else if (isSelectionPredicate(predicate)) {
          return parseSelectionPredicate(model, predicate, node);
        } else {
          return fieldFilterExpression(predicate);
        }
      });
    }
    function assembleTitle(title2, config) {
      if (!title2) {
        return void 0;
      }
      if (isArray(title2) && !isText(title2)) {
        return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
      }
      return title2;
    }
    function setAxisEncode(axis2, part, vgProp, vgRef) {
      var _a2, _b;
      axis2.encode ?? (axis2.encode = {});
      (_a2 = axis2.encode)[part] ?? (_a2[part] = {});
      (_b = axis2.encode[part]).update ?? (_b.update = {});
      axis2.encode[part].update[vgProp] = vgRef;
    }
    function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
      var _a2, _b;
      const { disable, orient: orient2, scale: scale2, labelExpr, title: title2, zindex: zindex2, ...axis2 } = axisCmpt.combine();
      if (disable) {
        return void 0;
      }
      for (const prop in axis2) {
        const propType = AXIS_PROPERTY_TYPE[prop];
        const propValue = axis2[prop];
        if (propType && propType !== kind && propType !== "both") {
          delete axis2[prop];
        } else if (isConditionalAxisValue(propValue)) {
          const { condition, ...valueOrSignalRef } = propValue;
          const conditions = array$2(condition);
          const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
          if (propIndex) {
            const { vgProp, part } = propIndex;
            const vgRef = [
              ...conditions.map((c2) => {
                const { test: test2, ...valueOrSignalCRef } = c2;
                return {
                  test: expression(null, test2),
                  ...valueOrSignalCRef
                };
              }),
              valueOrSignalRef
            ];
            setAxisEncode(axis2, part, vgProp, vgRef);
            delete axis2[prop];
          } else if (propIndex === null) {
            const signalRef = {
              signal: conditions.map((c2) => {
                const { test: test2, ...valueOrSignalCRef } = c2;
                return `${expression(null, test2)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;
              }).join("") + exprFromValueRefOrSignalRef(valueOrSignalRef)
            };
            axis2[prop] = signalRef;
          }
        } else if (isSignalRef(propValue)) {
          const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
          if (propIndex) {
            const { vgProp, part } = propIndex;
            setAxisEncode(axis2, part, vgProp, propValue);
            delete axis2[prop];
          }
        }
        if (contains(["labelAlign", "labelBaseline"], prop) && axis2[prop] === null) {
          delete axis2[prop];
        }
      }
      if (kind === "grid") {
        if (!axis2.grid) {
          return void 0;
        }
        if (axis2.encode) {
          const { grid } = axis2.encode;
          axis2.encode = {
            ...grid ? { grid } : {}
          };
          if (isEmpty(axis2.encode)) {
            delete axis2.encode;
          }
        }
        return {
          scale: scale2,
          orient: orient2,
          ...axis2,
          domain: false,
          labels: false,
          aria: false,
          // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
          // would not affect gridAxis
          maxExtent: 0,
          minExtent: 0,
          ticks: false,
          zindex: getFirstDefined(zindex2, 0)
          // put grid behind marks by default
        };
      } else {
        if (!opt.header && axisCmpt.mainExtracted) {
          return void 0;
        }
        if (labelExpr !== void 0) {
          let expr2 = labelExpr;
          if (((_b = (_a2 = axis2.encode) == null ? void 0 : _a2.labels) == null ? void 0 : _b.update) && isSignalRef(axis2.encode.labels.update.text)) {
            expr2 = replaceAll(labelExpr, "datum.label", axis2.encode.labels.update.text.signal);
          }
          setAxisEncode(axis2, "labels", "text", { signal: expr2 });
        }
        if (axis2.labelAlign === null) {
          delete axis2.labelAlign;
        }
        if (axis2.encode) {
          for (const part of AXIS_PARTS) {
            if (!axisCmpt.hasAxisPart(part)) {
              delete axis2.encode[part];
            }
          }
          if (isEmpty(axis2.encode)) {
            delete axis2.encode;
          }
        }
        const titleString = assembleTitle(title2, config);
        return {
          scale: scale2,
          orient: orient2,
          grid: false,
          ...titleString ? { title: titleString } : {},
          ...axis2,
          ...config.aria === false ? { aria: false } : {},
          zindex: getFirstDefined(zindex2, 0)
          // put axis line above marks by default
        };
      }
    }
    function assembleAxisSignals(model) {
      const { axes } = model.component;
      const signals = [];
      for (const channel of POSITION_SCALE_CHANNELS) {
        if (axes[channel]) {
          for (const axis2 of axes[channel]) {
            if (!axis2.get("disable") && !axis2.get("gridScale")) {
              const sizeType = channel === "x" ? "height" : "width";
              const update2 = model.getSizeSignalRef(sizeType).signal;
              if (sizeType !== update2) {
                signals.push({
                  name: sizeType,
                  update: update2
                });
              }
            }
          }
        }
      }
      return signals;
    }
    function assembleAxes(axisComponents, config) {
      const { x: x2 = [], y: y2 = [] } = axisComponents;
      return [
        ...x2.map((a2) => assembleAxis(a2, "grid", config)),
        ...y2.map((a2) => assembleAxis(a2, "grid", config)),
        ...x2.map((a2) => assembleAxis(a2, "main", config)),
        ...y2.map((a2) => assembleAxis(a2, "main", config))
      ].filter((a2) => a2);
    }
    function getAxisConfigFromConfigTypes(configTypes, config, channel, orient2) {
      return Object.assign.apply(null, [
        {},
        ...configTypes.map((configType) => {
          if (configType === "axisOrient") {
            const orient1 = channel === "x" ? "bottom" : "left";
            const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
            const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
            const props = /* @__PURE__ */ new Set([...keys(orientConfig1), ...keys(orientConfig2)]);
            const conditionalOrientAxisConfig = {};
            for (const prop of props.values()) {
              conditionalOrientAxisConfig[prop] = {
                // orient is surely signal in this case
                signal: `${orient2["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
              };
            }
            return conditionalOrientAxisConfig;
          }
          return config[configType];
        })
      ]);
    }
    function getAxisConfigs(channel, scaleType2, orient2, config) {
      const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
      const axisChannel = channel === "x" ? "axisX" : "axisY";
      const axisOrient = isSignalRef(orient2) ? "axisOrient" : `axis${titleCase(orient2)}`;
      const vlOnlyConfigTypes = [
        // technically Vega does have axisBand, but if we make another separation here,
        // it will further introduce complexity in the code
        ...typeBasedConfigTypes,
        ...typeBasedConfigTypes.map((c2) => axisChannel + c2.substr(4))
      ];
      const vgConfigTypes = ["axis", axisOrient, axisChannel];
      return {
        vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient2),
        vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient2),
        axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
      };
    }
    function getAxisConfigStyle(axisConfigTypes, config) {
      var _a2;
      const toMerge = [{}];
      for (const configType of axisConfigTypes) {
        let style2 = (_a2 = config[configType]) == null ? void 0 : _a2.style;
        if (style2) {
          style2 = array$2(style2);
          for (const s of style2) {
            toMerge.push(config.style[s]);
          }
        }
      }
      return Object.assign.apply(null, toMerge);
    }
    function getAxisConfig(property2, styleConfigIndex, style2, axisConfigs = {}) {
      var _a2;
      const styleConfig = getStyleConfig(property2, style2, styleConfigIndex);
      if (styleConfig !== void 0) {
        return {
          configFrom: "style",
          configValue: styleConfig
        };
      }
      for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
        if (((_a2 = axisConfigs[configFrom]) == null ? void 0 : _a2[property2]) !== void 0) {
          return { configFrom, configValue: axisConfigs[configFrom][property2] };
        }
      }
      return {};
    }
    const axisRules = {
      scale: ({ model, channel }) => model.scaleName(channel),
      format: ({ format: format2 }) => format2,
      formatType: ({ formatType }) => formatType,
      grid: ({ fieldOrDatumDef, axis: axis2, scaleType: scaleType2 }) => axis2.grid ?? defaultGrid(scaleType2, fieldOrDatumDef),
      gridScale: ({ model, channel }) => gridScale(model, channel),
      labelAlign: ({ axis: axis2, labelAngle, orient: orient2, channel }) => axis2.labelAlign || defaultLabelAlign(labelAngle, orient2, channel),
      labelAngle: ({ labelAngle }) => labelAngle,
      labelBaseline: ({ axis: axis2, labelAngle, orient: orient2, channel }) => axis2.labelBaseline || defaultLabelBaseline(labelAngle, orient2, channel),
      labelFlush: ({ axis: axis2, fieldOrDatumDef, channel }) => axis2.labelFlush ?? defaultLabelFlush(fieldOrDatumDef.type, channel),
      labelOverlap: ({ axis: axis2, fieldOrDatumDef, scaleType: scaleType2 }) => axis2.labelOverlap ?? defaultLabelOverlap$1(fieldOrDatumDef.type, scaleType2, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0),
      // we already calculate orient in parse
      orient: ({ orient: orient2 }) => orient2,
      tickCount: ({ channel, model, axis: axis2, fieldOrDatumDef, scaleType: scaleType2 }) => {
        const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
        const size2 = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
        return axis2.tickCount ?? defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size: size2, values: axis2.values });
      },
      tickMinStep: defaultTickMinStep,
      title: ({ axis: axis2, model, channel }) => {
        if (axis2.title !== void 0) {
          return axis2.title;
        }
        const fieldDefTitle = getFieldDefTitle(model, channel);
        if (fieldDefTitle !== void 0) {
          return fieldDefTitle;
        }
        const fieldDef = model.typedFieldDef(channel);
        const channel2 = channel === "x" ? "x2" : "y2";
        const fieldDef2 = model.fieldDef(channel2);
        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
      },
      values: ({ axis: axis2, fieldOrDatumDef }) => values$1(axis2, fieldOrDatumDef),
      zindex: ({ axis: axis2, fieldOrDatumDef, mark }) => axis2.zindex ?? defaultZindex(mark, fieldOrDatumDef)
    };
    function defaultGrid(scaleType2, fieldDef) {
      return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef == null ? void 0 : fieldDef.bin) && !isBinned(fieldDef == null ? void 0 : fieldDef.bin);
    }
    function gridScale(model, channel) {
      const gridChannel = channel === "x" ? "y" : "x";
      if (model.getScaleComponent(gridChannel)) {
        return model.scaleName(gridChannel);
      }
      return void 0;
    }
    function getLabelAngle(fieldOrDatumDef, axis2, channel, styleConfig, axisConfigs) {
      const labelAngle = axis2 == null ? void 0 : axis2.labelAngle;
      if (labelAngle !== void 0) {
        return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
      } else {
        const { configValue: angle2 } = getAxisConfig("labelAngle", styleConfig, axis2 == null ? void 0 : axis2.style, axisConfigs);
        if (angle2 !== void 0) {
          return normalizeAngle(angle2);
        } else {
          if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {
            return 270;
          }
          return void 0;
        }
      }
    }
    function normalizeAngleExpr(angle2) {
      return `(((${angle2.signal} % 360) + 360) % 360)`;
    }
    function defaultLabelBaseline(angle2, orient2, channel, alwaysIncludeMiddle) {
      if (angle2 !== void 0) {
        if (channel === "x") {
          if (isSignalRef(angle2)) {
            const a2 = normalizeAngleExpr(angle2);
            const orientIsTop = isSignalRef(orient2) ? `(${orient2.signal} === "top")` : orient2 === "top";
            return {
              signal: `(45 < ${a2} && ${a2} < 135) || (225 < ${a2} && ${a2} < 315) ? "middle" :(${a2} <= 45 || 315 <= ${a2}) === ${orientIsTop} ? "bottom" : "top"`
            };
          }
          if (45 < angle2 && angle2 < 135 || 225 < angle2 && angle2 < 315) {
            return "middle";
          }
          if (isSignalRef(orient2)) {
            const op = angle2 <= 45 || 315 <= angle2 ? "===" : "!==";
            return { signal: `${orient2.signal} ${op} "top" ? "bottom" : "top"` };
          }
          return (angle2 <= 45 || 315 <= angle2) === (orient2 === "top") ? "bottom" : "top";
        } else {
          if (isSignalRef(angle2)) {
            const a2 = normalizeAngleExpr(angle2);
            const orientIsLeft = isSignalRef(orient2) ? `(${orient2.signal} === "left")` : orient2 === "left";
            const middle = alwaysIncludeMiddle ? '"middle"' : "null";
            return {
              signal: `${a2} <= 45 || 315 <= ${a2} || (135 <= ${a2} && ${a2} <= 225) ? ${middle} : (45 <= ${a2} && ${a2} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
            };
          }
          if (angle2 <= 45 || 315 <= angle2 || 135 <= angle2 && angle2 <= 225) {
            return alwaysIncludeMiddle ? "middle" : null;
          }
          if (isSignalRef(orient2)) {
            const op = 45 <= angle2 && angle2 <= 135 ? "===" : "!==";
            return { signal: `${orient2.signal} ${op} "left" ? "top" : "bottom"` };
          }
          return (45 <= angle2 && angle2 <= 135) === (orient2 === "left") ? "top" : "bottom";
        }
      }
      return void 0;
    }
    function defaultLabelAlign(angle2, orient2, channel) {
      if (angle2 === void 0) {
        return void 0;
      }
      const isX2 = channel === "x";
      const startAngle = isX2 ? 0 : 90;
      const mainOrient = isX2 ? "bottom" : "left";
      if (isSignalRef(angle2)) {
        const a2 = normalizeAngleExpr(angle2);
        const orientIsMain = isSignalRef(orient2) ? `(${orient2.signal} === "${mainOrient}")` : orient2 === mainOrient;
        return {
          signal: `(${startAngle ? `(${a2} + 90)` : a2} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a2} && ${a2} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
        };
      }
      if ((angle2 + startAngle) % 180 === 0) {
        return isX2 ? null : "center";
      }
      if (isSignalRef(orient2)) {
        const op = startAngle < angle2 && angle2 < 180 + startAngle ? "===" : "!==";
        const orientIsMain = `${orient2.signal} ${op} "${mainOrient}"`;
        return {
          signal: `${orientIsMain} ? "left" : "right"`
        };
      }
      if ((startAngle < angle2 && angle2 < 180 + startAngle) === (orient2 === mainOrient)) {
        return "left";
      }
      return "right";
    }
    function defaultLabelFlush(type2, channel) {
      if (channel === "x" && contains(["quantitative", "temporal"], type2)) {
        return true;
      }
      return void 0;
    }
    function defaultLabelOverlap$1(type2, scaleType2, hasTimeUnit, sort2) {
      if (hasTimeUnit && !isObject(sort2) || type2 !== "nominal" && type2 !== "ordinal") {
        if (scaleType2 === "log" || scaleType2 === "symlog") {
          return "greedy";
        }
        return true;
      }
      return void 0;
    }
    function defaultOrient(channel) {
      return channel === "x" ? "bottom" : "left";
    }
    function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size: size2, values: vals2 }) {
      var _a2;
      if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
        if (isFieldDef(fieldOrDatumDef)) {
          if (isBinning(fieldOrDatumDef.bin)) {
            return { signal: `ceil(${size2.signal}/10)` };
          }
          if (fieldOrDatumDef.timeUnit && contains(["month", "hours", "day", "quarter"], (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit)) {
            return void 0;
          }
        }
        return { signal: `ceil(${size2.signal}/40)` };
      }
      return void 0;
    }
    function defaultTickMinStep({ format: format2, fieldOrDatumDef }) {
      if (format2 === "d") {
        return 1;
      }
      if (isFieldDef(fieldOrDatumDef)) {
        const { timeUnit } = fieldOrDatumDef;
        if (timeUnit) {
          const signal = durationExpr(timeUnit);
          if (signal) {
            return { signal };
          }
        }
      }
      return void 0;
    }
    function getFieldDefTitle(model, channel) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef = model.fieldDef(channel);
      const fieldDef2 = model.fieldDef(channel2);
      const title1 = fieldDef ? fieldDef.title : void 0;
      const title2 = fieldDef2 ? fieldDef2.title : void 0;
      if (title1 && title2) {
        return mergeTitle(title1, title2);
      } else if (title1) {
        return title1;
      } else if (title2) {
        return title2;
      } else if (title1 !== void 0) {
        return title1;
      } else if (title2 !== void 0) {
        return title2;
      }
      return void 0;
    }
    function values$1(axis2, fieldOrDatumDef) {
      const vals2 = axis2.values;
      if (isArray(vals2)) {
        return valueArray(fieldOrDatumDef, vals2);
      } else if (isSignalRef(vals2)) {
        return vals2;
      }
      return void 0;
    }
    function defaultZindex(mark, fieldDef) {
      if (mark === "rect" && isDiscrete(fieldDef)) {
        return 1;
      }
      return 0;
    }
    class CalculateNode extends DataFlowNode {
      clone() {
        return new CalculateNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this._dependentFields = getDependentFields(this.transform.calculate);
      }
      static parseAllForSortIndex(parent, model) {
        model.forEachFieldDef((fieldDef, channel) => {
          if (!isScaleFieldDef(fieldDef)) {
            return;
          }
          if (isSortArray(fieldDef.sort)) {
            const { field: field2, timeUnit } = fieldDef;
            const sort2 = fieldDef.sort;
            const calculate = sort2.map((sortValue, i) => {
              return `${fieldFilterExpression({ field: field2, timeUnit, equal: sortValue })} ? ${i} : `;
            }).join("") + sort2.length;
            parent = new CalculateNode(parent, {
              calculate,
              as: sortArrayIndexField(fieldDef, channel, { forAs: true })
            });
          }
        });
        return parent;
      }
      producedFields() {
        return /* @__PURE__ */ new Set([this.transform.as]);
      }
      dependentFields() {
        return this._dependentFields;
      }
      assemble() {
        return {
          type: "formula",
          expr: this.transform.calculate,
          as: this.transform.as
        };
      }
      hash() {
        return `Calculate ${hash(this.transform)}`;
      }
    }
    function sortArrayIndexField(fieldDef, channel, opt) {
      return vgField(fieldDef, { prefix: channel, suffix: "sort_index", ...opt ?? {} });
    }
    function getHeaderChannel(channel, orient2) {
      if (contains(["top", "bottom"], orient2)) {
        return "column";
      } else if (contains(["left", "right"], orient2)) {
        return "row";
      }
      return channel === "row" ? "row" : "column";
    }
    function getHeaderProperty(prop, header, config, channel) {
      const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
      return getFirstDefined((header || {})[prop], headerSpecificConfig[prop], config.header[prop]);
    }
    function getHeaderProperties(properties, header, config, channel) {
      const props = {};
      for (const prop of properties) {
        const value2 = getHeaderProperty(prop, header || {}, config, channel);
        if (value2 !== void 0) {
          props[prop] = value2;
        }
      }
      return props;
    }
    const HEADER_CHANNELS = ["row", "column"];
    const HEADER_TYPES = ["header", "footer"];
    function assembleTitleGroup(model, channel) {
      const title2 = model.component.layoutHeaders[channel].title;
      const config = model.config ? model.config : void 0;
      const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
      const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const titleAngle = normalizeAngle(ta);
      return {
        name: `${channel}-title`,
        type: "group",
        role: `${headerChannel}-title`,
        title: {
          text: title2,
          ...channel === "row" ? { orient: "left" } : {},
          style: "guide-title",
          ...defaultHeaderGuideBaseline(titleAngle, headerChannel),
          ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor),
          ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)
        }
      };
    }
    function defaultHeaderGuideAlign(headerChannel, angle2, anchor2 = "middle") {
      switch (anchor2) {
        case "start":
          return { align: "left" };
        case "end":
          return { align: "right" };
      }
      const align2 = defaultLabelAlign(angle2, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
      return align2 ? { align: align2 } : {};
    }
    function defaultHeaderGuideBaseline(angle2, channel) {
      const baseline2 = defaultLabelBaseline(angle2, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
      return baseline2 ? { baseline: baseline2 } : {};
    }
    function assembleHeaderGroups(model, channel) {
      const layoutHeader = model.component.layoutHeaders[channel];
      const groups = [];
      for (const headerType of HEADER_TYPES) {
        if (layoutHeader[headerType]) {
          for (const headerComponent of layoutHeader[headerType]) {
            const group2 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
            if (group2 != null) {
              groups.push(group2);
            }
          }
        }
      }
      return groups;
    }
    function getSort$1(facetFieldDef, channel) {
      const { sort: sort2 } = facetFieldDef;
      if (isSortField(sort2)) {
        return {
          field: vgField(sort2, { expr: "datum" }),
          order: sort2.order ?? "ascending"
        };
      } else if (isArray(sort2)) {
        return {
          field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
          order: "ascending"
        };
      } else {
        return {
          field: vgField(facetFieldDef, { expr: "datum" }),
          order: sort2 ?? "ascending"
        };
      }
    }
    function assembleLabelTitle(facetFieldDef, channel, config) {
      const { format: format2, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef.header, config, channel);
      const titleTextExpr = formatSignalRef({
        fieldOrDatumDef: facetFieldDef,
        format: format2,
        formatType,
        expr: "parent",
        config
      }).signal;
      const headerChannel = getHeaderChannel(channel, labelOrient);
      return {
        text: {
          signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
        },
        ...channel === "row" ? { orient: "left" } : {},
        style: "guide-label",
        frame: "group",
        ...defaultHeaderGuideBaseline(labelAngle, headerChannel),
        ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor),
        ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)
      };
    }
    function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
      if (headerComponent) {
        let title2 = null;
        const { facetFieldDef } = layoutHeader;
        const config = model.config ? model.config : void 0;
        if (facetFieldDef && headerComponent.labels) {
          const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef.header, config, channel);
          if (channel === "row" && !contains(["top", "bottom"], labelOrient) || channel === "column" && !contains(["left", "right"], labelOrient)) {
            title2 = assembleLabelTitle(facetFieldDef, channel, config);
          }
        }
        const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
        const axes = headerComponent.axes;
        const hasAxes = (axes == null ? void 0 : axes.length) > 0;
        if (title2 || hasAxes) {
          const sizeChannel = channel === "row" ? "height" : "width";
          return {
            name: model.getName(`${channel}_${headerType}`),
            type: "group",
            role: `${channel}-${headerType}`,
            ...layoutHeader.facetFieldDef ? {
              from: { data: model.getName(`${channel}_domain`) },
              sort: getSort$1(facetFieldDef, channel)
            } : {},
            ...hasAxes && isFacetWithoutRowCol ? {
              from: { data: model.getName(`facet_domain_${channel}`) }
            } : {},
            ...title2 ? { title: title2 } : {},
            ...headerComponent.sizeSignal ? {
              encode: {
                update: {
                  [sizeChannel]: headerComponent.sizeSignal
                }
              }
            } : {},
            ...hasAxes ? { axes } : {}
          };
        }
      }
      return null;
    }
    const LAYOUT_TITLE_BAND = {
      column: {
        start: 0,
        end: 1
      },
      row: {
        start: 1,
        end: 0
      }
    };
    function getLayoutTitleBand(titleAnchor, headerChannel) {
      return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
    }
    function assembleLayoutTitleBand(headerComponentIndex, config) {
      const titleBand = {};
      for (const channel of FACET_CHANNELS) {
        const headerComponent = headerComponentIndex[channel];
        if (headerComponent == null ? void 0 : headerComponent.facetFieldDef) {
          const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
          const headerChannel = getHeaderChannel(channel, titleOrient);
          const band2 = getLayoutTitleBand(titleAnchor, headerChannel);
          if (band2 !== void 0) {
            titleBand[headerChannel] = band2;
          }
        }
      }
      return isEmpty(titleBand) ? void 0 : titleBand;
    }
    function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
      const props = {};
      for (const prop of properties) {
        if (!propertiesMap[prop]) {
          continue;
        }
        const value2 = getHeaderProperty(prop, facetFieldDef == null ? void 0 : facetFieldDef.header, config, channel);
        if (value2 !== void 0) {
          props[propertiesMap[prop]] = value2;
        }
      }
      return props;
    }
    function assembleLayoutSignals(model) {
      return [
        ...sizeSignals(model, "width"),
        ...sizeSignals(model, "height"),
        ...sizeSignals(model, "childWidth"),
        ...sizeSignals(model, "childHeight")
      ];
    }
    function sizeSignals(model, sizeType) {
      const channel = sizeType === "width" ? "x" : "y";
      const size2 = model.component.layoutSize.get(sizeType);
      if (!size2 || size2 === "merged") {
        return [];
      }
      const name2 = model.getSizeSignalRef(sizeType).signal;
      if (size2 === "step") {
        const scaleComponent = model.getScaleComponent(channel);
        if (scaleComponent) {
          const type2 = scaleComponent.get("type");
          const range2 = scaleComponent.get("range");
          if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
            const scaleName = model.scaleName(channel);
            if (isFacetModel(model.parent)) {
              const parentResolve = model.parent.component.resolve;
              if (parentResolve.scale[channel] === "independent") {
                return [stepSignal(scaleName, range2)];
              }
            }
            return [
              stepSignal(scaleName, range2),
              {
                name: name2,
                update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
              }
            ];
          }
        }
        throw new Error("layout size is step although width/height is not step.");
      } else if (size2 == "container") {
        const isWidth = name2.endsWith("width");
        const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
        const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
        const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
        return [{ name: name2, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
      } else {
        return [
          {
            name: name2,
            value: size2
          }
        ];
      }
    }
    function stepSignal(scaleName, range2) {
      const name2 = `${scaleName}_step`;
      if (isSignalRef(range2.step)) {
        return { name: name2, update: range2.step.signal };
      } else {
        return { name: name2, value: range2.step };
      }
    }
    function sizeExpr(scaleName, scaleComponent, cardinality) {
      const type2 = scaleComponent.get("type");
      const padding2 = scaleComponent.get("padding");
      const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding2);
      let paddingInner2 = scaleComponent.get("paddingInner");
      paddingInner2 = type2 === "band" ? (
        // only band has real paddingInner
        paddingInner2 !== void 0 ? paddingInner2 : padding2
      ) : (
        // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
        1
      );
      return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner2)}, ${signalOrStringValue(paddingOuter2)}) * ${scaleName}_step`;
    }
    function getSizeTypeFromLayoutSizeType(layoutSizeType) {
      return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
    }
    function guideEncodeEntry(encoding, model) {
      return keys(encoding).reduce((encode2, channel) => {
        const valueDef = encoding[channel];
        return {
          ...encode2,
          ...wrapCondition(model, valueDef, channel, (def2) => signalOrValueRef(def2.value))
        };
      }, {});
    }
    function defaultScaleResolve(channel, model) {
      if (isFacetModel(model)) {
        return channel === "theta" ? "independent" : "shared";
      } else if (isLayerModel(model)) {
        return "shared";
      } else if (isConcatModel(model)) {
        return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
      }
      throw new Error("invalid model type for resolve");
    }
    function parseGuideResolve(resolve2, channel) {
      const channelScaleResolve = resolve2.scale[channel];
      const guide = isXorY(channel) ? "axis" : "legend";
      if (channelScaleResolve === "independent") {
        if (resolve2[guide][channel] === "shared") {
          warn(independentScaleMeansIndependentGuide(channel));
        }
        return "independent";
      }
      return resolve2[guide][channel] || "shared";
    }
    const LEGEND_COMPONENT_PROPERTY_INDEX = {
      ...COMMON_LEGEND_PROPERTY_INDEX,
      disable: 1,
      labelExpr: 1,
      selections: 1,
      // channel scales
      opacity: 1,
      shape: 1,
      stroke: 1,
      fill: 1,
      size: 1,
      strokeWidth: 1,
      strokeDash: 1,
      // encode
      encode: 1
    };
    const LEGEND_COMPONENT_PROPERTIES = keys(LEGEND_COMPONENT_PROPERTY_INDEX);
    class LegendComponent extends Split {
    }
    const legendEncodeRules = {
      symbols,
      gradient,
      labels: labels$1,
      entries
    };
    function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 }) {
      if (legendType2 !== "symbol") {
        return void 0;
      }
      const { markDef, encoding, config, mark } = model;
      const filled = markDef.filled && mark !== "trail";
      let out = {
        ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),
        ...color(model, { filled })
      };
      const symbolOpacity = legendCmpt.get("symbolOpacity") ?? config.legend.symbolOpacity;
      const symbolFillColor = legendCmpt.get("symbolFillColor") ?? config.legend.symbolFillColor;
      const symbolStrokeColor = legendCmpt.get("symbolStrokeColor") ?? config.legend.symbolStrokeColor;
      const opacity2 = symbolOpacity === void 0 ? getMaxValue(encoding.opacity) ?? markDef.opacity : void 0;
      if (out.fill) {
        if (channel === "fill" || filled && channel === COLOR) {
          delete out.fill;
        } else {
          if (out.fill["field"]) {
            if (symbolFillColor) {
              delete out.fill;
            } else {
              out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? "black");
              out.fillOpacity = signalOrValueRef(opacity2 ?? 1);
            }
          } else if (isArray(out.fill)) {
            const fill2 = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);
            if (fill2) {
              out.fill = signalOrValueRef(fill2);
            }
          }
        }
      }
      if (out.stroke) {
        if (channel === "stroke" || !filled && channel === COLOR) {
          delete out.stroke;
        } else {
          if (out.stroke["field"] || symbolStrokeColor) {
            delete out.stroke;
          } else if (isArray(out.stroke)) {
            const stroke2 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : void 0);
            if (stroke2) {
              out.stroke = { value: stroke2 };
            }
          }
        }
      }
      if (channel !== OPACITY) {
        const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
        if (condition) {
          out.opacity = [
            { test: condition, ...signalOrValueRef(opacity2 ?? 1) },
            signalOrValueRef(config.legend.unselectedOpacity)
          ];
        } else if (opacity2) {
          out.opacity = signalOrValueRef(opacity2);
        }
      }
      out = { ...out, ...symbolsSpec };
      return isEmpty(out) ? void 0 : out;
    }
    function gradient(gradientSpec, { model, legendType: legendType2, legendCmpt }) {
      if (legendType2 !== "gradient") {
        return void 0;
      }
      const { config, markDef, encoding } = model;
      let out = {};
      const gradientOpacity = legendCmpt.get("gradientOpacity") ?? config.legend.gradientOpacity;
      const opacity2 = gradientOpacity === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
      if (opacity2) {
        out.opacity = signalOrValueRef(opacity2);
      }
      out = { ...out, ...gradientSpec };
      return isEmpty(out) ? void 0 : out;
    }
    function labels$1(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
      const legend = model.legend(channel) || {};
      const config = model.config;
      const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
      const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
      const { format: format2, formatType } = legend;
      let text2 = void 0;
      if (isCustomFormatType(formatType)) {
        text2 = formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: format2,
          formatType,
          config
        });
      } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (fieldOrDatumDef.type === "quantitative" && config.numberFormatType) {
          text2 = formatCustomType({
            fieldOrDatumDef,
            field: "datum.value",
            format: config.numberFormat,
            formatType: config.numberFormatType,
            config
          });
        } else if (fieldOrDatumDef.type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
          text2 = formatCustomType({
            fieldOrDatumDef,
            field: "datum.value",
            format: config.timeFormat,
            formatType: config.timeFormatType,
            config
          });
        }
      }
      const labelsSpec = {
        ...opacity2 ? { opacity: opacity2 } : {},
        ...text2 ? { text: text2 } : {},
        ...specifiedlabelsSpec
      };
      return isEmpty(labelsSpec) ? void 0 : labelsSpec;
    }
    function entries(entriesSpec, { legendCmpt }) {
      const selections = legendCmpt.get("selections");
      return (selections == null ? void 0 : selections.length) ? { ...entriesSpec, fill: { value: "transparent" } } : entriesSpec;
    }
    function getMaxValue(channelDef) {
      return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
    }
    function getFirstConditionValue(channelDef) {
      return getConditionValue(channelDef, (v, conditionalDef) => {
        return getFirstDefined(v, conditionalDef.value);
      });
    }
    function getConditionValue(channelDef, reducer) {
      if (hasConditionalValueDef(channelDef)) {
        return array$2(channelDef.condition).reduce(reducer, channelDef.value);
      } else if (isValueDef(channelDef)) {
        return channelDef.value;
      }
      return void 0;
    }
    function selectedCondition(model, legendCmpt, fieldDef) {
      const selections = legendCmpt.get("selections");
      if (!(selections == null ? void 0 : selections.length))
        return void 0;
      const field2 = $(fieldDef.field);
      return selections.map((name2) => {
        const store2 = $(varName(name2) + STORE);
        return `(!length(data(${store2})) || (${name2}[${field2}] && indexof(${name2}[${field2}], datum.value) >= 0))`;
      }).join(" || ");
    }
    const legendRules = {
      direction: ({ direction }) => direction,
      format: ({ fieldOrDatumDef, legend, config }) => {
        const { format: format2, formatType } = legend;
        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format2, formatType, config, false);
      },
      formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
        const { formatType } = legend;
        return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
      },
      gradientLength: (params2) => {
        const { legend, legendConfig } = params2;
        return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params2);
      },
      labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType2),
      symbolType: ({ legend, markDef, channel, encoding }) => legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),
      title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
      type: ({ legendType: legendType2, scaleType: scaleType2, channel }) => {
        if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
          if (legendType2 === "gradient") {
            return void 0;
          }
        } else if (legendType2 === "symbol") {
          return void 0;
        }
        return legendType2;
      },
      values: ({ fieldOrDatumDef, legend }) => values(legend, fieldOrDatumDef)
    };
    function values(legend, fieldOrDatumDef) {
      const vals2 = legend.values;
      if (isArray(vals2)) {
        return valueArray(fieldOrDatumDef, vals2);
      } else if (isSignalRef(vals2)) {
        return vals2;
      }
      return void 0;
    }
    function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {
      if (channel !== "shape") {
        const shape2 = getFirstConditionValue(shapeChannelDef) ?? markShape;
        if (shape2) {
          return shape2;
        }
      }
      switch (mark) {
        case "bar":
        case "rect":
        case "image":
        case "square":
          return "square";
        case "line":
        case "trail":
        case "rule":
          return "stroke";
        case "arc":
        case "point":
        case "circle":
        case "tick":
        case "geoshape":
        case "area":
        case "text":
          return "circle";
      }
    }
    function getLegendType(params2) {
      const { legend } = params2;
      return getFirstDefined(legend.type, defaultType$1(params2));
    }
    function defaultType$1({ channel, timeUnit, scaleType: scaleType2 }) {
      if (isColorChannel(channel)) {
        if (contains(["quarter", "month", "day"], timeUnit)) {
          return "symbol";
        }
        if (isContinuousToContinuous(scaleType2)) {
          return "gradient";
        }
      }
      return "symbol";
    }
    function getDirection({ legendConfig, legendType: legendType2, orient: orient2, legend }) {
      return legend.direction ?? legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"] ?? defaultDirection(orient2, legendType2);
    }
    function defaultDirection(orient2, legendType2) {
      switch (orient2) {
        case "top":
        case "bottom":
          return "horizontal";
        case "left":
        case "right":
        case "none":
        case void 0:
          return void 0;
        default:
          return legendType2 === "gradient" ? "horizontal" : void 0;
      }
    }
    function defaultGradientLength({ legendConfig, model, direction, orient: orient2, scaleType: scaleType2 }) {
      const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
      if (isContinuousToContinuous(scaleType2)) {
        if (direction === "horizontal") {
          if (orient2 === "top" || orient2 === "bottom") {
            return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
          } else {
            return gradientHorizontalMinLength;
          }
        } else {
          return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
        }
      }
      return void 0;
    }
    function gradientLengthSignal(model, sizeType, min2, max2) {
      const sizeSignal = model.getSizeSignalRef(sizeType).signal;
      return { signal: `clamp(${sizeSignal}, ${min2}, ${max2})` };
    }
    function defaultLabelOverlap(scaleType2) {
      if (contains(["quantile", "threshold", "log", "symlog"], scaleType2)) {
        return "greedy";
      }
      return void 0;
    }
    function parseLegend(model) {
      const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
      model.component.legends = legendComponent;
      return legendComponent;
    }
    function parseUnitLegend(model) {
      const { encoding } = model;
      const legendComponent = {};
      for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
        const def2 = getFieldOrDatumDef(encoding[channel]);
        if (!def2 || !model.getScaleComponent(channel)) {
          continue;
        }
        if (channel === SHAPE && isFieldDef(def2) && def2.type === GEOJSON) {
          continue;
        }
        legendComponent[channel] = parseLegendForChannel(model, channel);
      }
      return legendComponent;
    }
    function getLegendDefWithScale(model, channel) {
      const scale2 = model.scaleName(channel);
      if (model.mark === "trail") {
        if (channel === "color") {
          return { stroke: scale2 };
        } else if (channel === "size") {
          return { strokeWidth: scale2 };
        }
      }
      if (channel === "color") {
        return model.markDef.filled ? { fill: scale2 } : { stroke: scale2 };
      }
      return { [channel]: scale2 };
    }
    function isExplicit$1(value2, property2, legend, fieldDef) {
      switch (property2) {
        case "disable":
          return legend !== void 0;
        case "values":
          return !!(legend == null ? void 0 : legend.values);
        case "title":
          if (property2 === "title" && value2 === (fieldDef == null ? void 0 : fieldDef.title)) {
            return true;
          }
      }
      return value2 === (legend || {})[property2];
    }
    function parseLegendForChannel(model, channel) {
      var _a2;
      let legend = model.legend(channel);
      const { markDef, encoding, config } = model;
      const legendConfig = config.legend;
      const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
      parseInteractiveLegend(model, channel, legendCmpt);
      const disable = legend !== void 0 ? !legend : legendConfig.disable;
      legendCmpt.set("disable", disable, legend !== void 0);
      if (disable) {
        return legendCmpt;
      }
      legend = legend || {};
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit : void 0;
      const orient2 = legend.orient || config.legend.orient || "right";
      const legendType2 = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
      const direction = getDirection({ legend, legendType: legendType2, orient: orient2, legendConfig });
      const ruleParams = {
        legend,
        channel,
        model,
        markDef,
        encoding,
        fieldOrDatumDef,
        legendConfig,
        config,
        scaleType: scaleType2,
        orient: orient2,
        legendType: legendType2,
        direction
      };
      for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
        if (legendType2 === "gradient" && property2.startsWith("symbol") || legendType2 === "symbol" && property2.startsWith("gradient")) {
          continue;
        }
        const value2 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
        if (value2 !== void 0) {
          const explicit = isExplicit$1(value2, property2, legend, model.fieldDef(channel));
          if (explicit || config.legend[property2] === void 0) {
            legendCmpt.set(property2, value2, explicit);
          }
        }
      }
      const legendEncoding = (legend == null ? void 0 : legend.encoding) ?? {};
      const selections = legendCmpt.get("selections");
      const legendEncode = {};
      const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 };
      for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
        const legendEncodingPart = guideEncodeEntry(legendEncoding[part] ?? {}, model);
        const value2 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
        if (value2 !== void 0 && !isEmpty(value2)) {
          legendEncode[part] = {
            ...(selections == null ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {},
            ...(selections == null ? void 0 : selections.length) ? { interactive: !!selections } : {},
            update: value2
          };
        }
      }
      if (!isEmpty(legendEncode)) {
        legendCmpt.set("encode", legendEncode, !!(legend == null ? void 0 : legend.encoding));
      }
      return legendCmpt;
    }
    function parseNonUnitLegend(model) {
      const { legends, resolve: resolve2 } = model.component;
      for (const child of model.children) {
        parseLegend(child);
        for (const channel of keys(child.component.legends)) {
          resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
          if (resolve2.legend[channel] === "shared") {
            legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
            if (!legends[channel]) {
              resolve2.legend[channel] = "independent";
              delete legends[channel];
            }
          }
        }
      }
      for (const channel of keys(legends)) {
        for (const child of model.children) {
          if (!child.component.legends[channel]) {
            continue;
          }
          if (resolve2.legend[channel] === "shared") {
            delete child.component.legends[channel];
          }
        }
      }
      return legends;
    }
    function mergeLegendComponent(mergedLegend, childLegend) {
      var _a2, _b, _c2, _d2;
      if (!mergedLegend) {
        return childLegend.clone();
      }
      const mergedOrient = mergedLegend.getWithExplicit("orient");
      const childOrient = childLegend.getWithExplicit("orient");
      if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
        return void 0;
      }
      let typeMerged = false;
      for (const prop of LEGEND_COMPONENT_PROPERTIES) {
        const mergedValueWithExplicit = mergeValuesWithExplicit(
          mergedLegend.getWithExplicit(prop),
          childLegend.getWithExplicit(prop),
          prop,
          "legend",
          // Tie breaker function
          (v1, v2) => {
            switch (prop) {
              case "symbolType":
                return mergeSymbolType(v1, v2);
              case "title":
                return mergeTitleComponent(v1, v2);
              case "type":
                typeMerged = true;
                return makeImplicit("symbol");
            }
            return defaultTieBreaker(v1, v2, prop, "legend");
          }
        );
        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
      }
      if (typeMerged) {
        if ((_b = (_a2 = mergedLegend.implicit) == null ? void 0 : _a2.encode) == null ? void 0 : _b.gradient) {
          deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
        }
        if ((_d2 = (_c2 = mergedLegend.explicit) == null ? void 0 : _c2.encode) == null ? void 0 : _d2.gradient) {
          deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
        }
      }
      return mergedLegend;
    }
    function mergeSymbolType(st1, st2) {
      if (st2.value === "circle") {
        return st2;
      }
      return st1;
    }
    function setLegendEncode(legend, part, vgProp, vgRef) {
      var _a2, _b;
      legend.encode ?? (legend.encode = {});
      (_a2 = legend.encode)[part] ?? (_a2[part] = {});
      (_b = legend.encode[part]).update ?? (_b.update = {});
      legend.encode[part].update[vgProp] = vgRef;
    }
    function assembleLegends(model) {
      const legendComponentIndex = model.component.legends;
      const legendByDomain = {};
      for (const channel of keys(legendComponentIndex)) {
        const scaleComponent = model.getScaleComponent(channel);
        const domainHash = stringify$1(scaleComponent.get("domains"));
        if (legendByDomain[domainHash]) {
          for (const mergedLegendComponent of legendByDomain[domainHash]) {
            const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
            if (!merged) {
              legendByDomain[domainHash].push(legendComponentIndex[channel]);
            }
          }
        } else {
          legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
        }
      }
      const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
      return legends;
    }
    function assembleLegend(legendCmpt, config) {
      var _a2, _b, _c2;
      const { disable, labelExpr, selections, ...legend } = legendCmpt.combine();
      if (disable) {
        return void 0;
      }
      if (config.aria === false && legend.aria == void 0) {
        legend.aria = false;
      }
      if ((_a2 = legend.encode) == null ? void 0 : _a2.symbols) {
        const out = legend.encode.symbols.update;
        if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
          out.stroke = { value: "transparent" };
        }
        for (const property2 of LEGEND_SCALE_CHANNELS) {
          if (legend[property2]) {
            delete out[property2];
          }
        }
      }
      if (!legend.title) {
        delete legend.title;
      }
      if (labelExpr !== void 0) {
        let expr2 = labelExpr;
        if (((_c2 = (_b = legend.encode) == null ? void 0 : _b.labels) == null ? void 0 : _c2.update) && isSignalRef(legend.encode.labels.update.text)) {
          expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
        }
        setLegendEncode(legend, "labels", "text", { signal: expr2 });
      }
      return legend;
    }
    function assembleProjections(model) {
      if (isLayerModel(model) || isConcatModel(model)) {
        return assembleProjectionsForModelAndChildren(model);
      } else {
        return assembleProjectionForModel(model);
      }
    }
    function assembleProjectionsForModelAndChildren(model) {
      return model.children.reduce((projections2, child) => {
        return projections2.concat(child.assembleProjections());
      }, assembleProjectionForModel(model));
    }
    function assembleProjectionForModel(model) {
      const component = model.component.projection;
      if (!component || component.merged) {
        return [];
      }
      const projection2 = component.combine();
      const { name: name2 } = projection2;
      if (!component.data) {
        return [
          {
            name: name2,
            // translate to center by default
            ...{ translate: { signal: "[width / 2, height / 2]" } },
            // parameters, overwrite default translate if specified
            ...projection2
          }
        ];
      } else {
        const size2 = {
          signal: `[${component.size.map((ref2) => ref2.signal).join(", ")}]`
        };
        const fits = component.data.reduce((sources, data2) => {
          const source2 = isSignalRef(data2) ? data2.signal : `data('${model.lookupDataSource(data2)}')`;
          if (!contains(sources, source2)) {
            sources.push(source2);
          }
          return sources;
        }, []);
        if (fits.length <= 0) {
          throw new Error("Projection's fit didn't find any data sources");
        }
        return [
          {
            name: name2,
            size: size2,
            fit: {
              signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
            },
            ...projection2
          }
        ];
      }
    }
    const PROJECTION_PROPERTIES = [
      "type",
      "clipAngle",
      "clipExtent",
      "center",
      "rotate",
      "precision",
      "reflectX",
      "reflectY",
      "coefficient",
      "distance",
      "fraction",
      "lobes",
      "parallel",
      "radius",
      "ratio",
      "spacing",
      "tilt"
    ];
    class ProjectionComponent extends Split {
      constructor(name2, specifiedProjection, size2, data2) {
        super(
          { ...specifiedProjection },
          // all explicit properties of projection
          { name: name2 }
          // name as initial implicit property
        );
        this.specifiedProjection = specifiedProjection;
        this.size = size2;
        this.data = data2;
        this.merged = false;
      }
      /**
       * Whether the projection parameters should fit provided data.
       */
      get isFit() {
        return !!this.data;
      }
    }
    function parseProjection(model) {
      model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
    }
    function parseUnitProjection(model) {
      if (model.hasProjection) {
        const proj = replaceExprRef(model.specifiedProjection);
        const fit2 = !(proj && (proj.scale != null || proj.translate != null));
        const size2 = fit2 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
        const data2 = fit2 ? gatherFitData(model) : void 0;
        const projComp = new ProjectionComponent(model.projectionName(true), {
          ...replaceExprRef(model.config.projection) ?? {},
          ...proj ?? {}
        }, size2, data2);
        if (!projComp.get("type")) {
          projComp.set("type", "equalEarth", false);
        }
        return projComp;
      }
      return void 0;
    }
    function gatherFitData(model) {
      const data2 = [];
      const { encoding } = model;
      for (const posssiblePair of [
        [LONGITUDE, LATITUDE],
        [LONGITUDE2, LATITUDE2]
      ]) {
        if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
          data2.push({
            signal: model.getName(`geojson_${data2.length}`)
          });
        }
      }
      if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
        data2.push({
          signal: model.getName(`geojson_${data2.length}`)
        });
      }
      if (data2.length === 0) {
        data2.push(model.requestDataName(DataSourceType.Main));
      }
      return data2;
    }
    function mergeIfNoConflict(first, second2) {
      const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {
        if (!has$1(first.explicit, prop) && !has$1(second2.explicit, prop)) {
          return true;
        }
        if (has$1(first.explicit, prop) && has$1(second2.explicit, prop) && // some properties might be signals or objects and require hashing for comparison
        deepEqual(first.get(prop), second2.get(prop))) {
          return true;
        }
        return false;
      });
      const size2 = deepEqual(first.size, second2.size);
      if (size2) {
        if (allPropertiesShared) {
          return first;
        } else if (deepEqual(first.explicit, {})) {
          return second2;
        } else if (deepEqual(second2.explicit, {})) {
          return first;
        }
      }
      return null;
    }
    function parseNonUnitProjections(model) {
      if (model.children.length === 0) {
        return void 0;
      }
      let nonUnitProjection;
      for (const child of model.children) {
        parseProjection(child);
      }
      const mergable = every(model.children, (child) => {
        const projection2 = child.component.projection;
        if (!projection2) {
          return true;
        } else if (!nonUnitProjection) {
          nonUnitProjection = projection2;
          return true;
        } else {
          const merge2 = mergeIfNoConflict(nonUnitProjection, projection2);
          if (merge2) {
            nonUnitProjection = merge2;
          }
          return !!merge2;
        }
      });
      if (nonUnitProjection && mergable) {
        const name2 = model.projectionName(true);
        const modelProjection = new ProjectionComponent(name2, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
        for (const child of model.children) {
          const projection2 = child.component.projection;
          if (projection2) {
            if (projection2.isFit) {
              modelProjection.data.push(...child.component.projection.data);
            }
            child.renameProjection(projection2.get("name"), name2);
            projection2.merged = true;
          }
        }
        return modelProjection;
      }
      return void 0;
    }
    function rangeFormula(model, fieldDef, channel, config) {
      if (binRequiresRange(fieldDef, channel)) {
        const guide = isUnitModel(model) ? model.axis(channel) ?? model.legend(channel) ?? {} : {};
        const startField = vgField(fieldDef, { expr: "datum" });
        const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
        return {
          formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
          formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
        };
      }
      return {};
    }
    function binKey(bin2, field2) {
      return `${binToString(bin2)}_${field2}`;
    }
    function getSignalsFromModel(model, key2) {
      return {
        signal: model.getName(`${key2}_bins`),
        extentSignal: model.getName(`${key2}_extent`)
      };
    }
    function getBinSignalName(model, field2, bin2) {
      const normalizedBin = normalizeBin(bin2, void 0) ?? {};
      const key2 = binKey(normalizedBin, field2);
      return model.getName(`${key2}_bins`);
    }
    function isBinTransform(t4) {
      return "as" in t4;
    }
    function createBinComponent(t4, bin2, model) {
      let as;
      let span2;
      if (isBinTransform(t4)) {
        as = isString(t4.as) ? [t4.as, `${t4.as}_end`] : [t4.as[0], t4.as[1]];
      } else {
        as = [vgField(t4, { forAs: true }), vgField(t4, { binSuffix: "end", forAs: true })];
      }
      const normalizedBin = { ...normalizeBin(bin2, void 0) };
      const key2 = binKey(normalizedBin, t4.field);
      const { signal, extentSignal } = getSignalsFromModel(model, key2);
      if (isParameterExtent(normalizedBin.extent)) {
        const ext = normalizedBin.extent;
        span2 = parseSelectionExtent(model, ext.param, ext);
        delete normalizedBin.extent;
      }
      const binComponent = {
        bin: normalizedBin,
        field: t4.field,
        as: [as],
        ...signal ? { signal } : {},
        ...extentSignal ? { extentSignal } : {},
        ...span2 ? { span: span2 } : {}
      };
      return { key: key2, binComponent };
    }
    class BinNode extends DataFlowNode {
      clone() {
        return new BinNode(null, duplicate(this.bins));
      }
      constructor(parent, bins2) {
        super(parent);
        this.bins = bins2;
      }
      static makeFromEncoding(parent, model) {
        const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
          if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
            const { key: key2, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
            binComponentIndex[key2] = {
              ...binComponent,
              ...binComponentIndex[key2],
              ...rangeFormula(model, fieldDef, channel, model.config)
            };
          }
          return binComponentIndex;
        }, {});
        if (isEmpty(bins2)) {
          return null;
        }
        return new BinNode(parent, bins2);
      }
      /**
       * Creates a bin node from BinTransform.
       * The optional parameter should provide
       */
      static makeFromTransform(parent, t4, model) {
        const { key: key2, binComponent } = createBinComponent(t4, t4.bin, model);
        return new BinNode(parent, {
          [key2]: binComponent
        });
      }
      /**
       * Merge bin nodes. This method either integrates the bin config from the other node
       * or if this node already has a bin config, renames the corresponding signal in the model.
       */
      merge(other, renameSignal) {
        for (const key2 of keys(other.bins)) {
          if (key2 in this.bins) {
            renameSignal(other.bins[key2].signal, this.bins[key2].signal);
            this.bins[key2].as = unique([...this.bins[key2].as, ...other.bins[key2].as], hash);
          } else {
            this.bins[key2] = other.bins[key2];
          }
        }
        for (const child of other.children) {
          other.removeChild(child);
          child.parent = this;
        }
        other.remove();
      }
      producedFields() {
        return new Set(vals(this.bins).map((c2) => c2.as).flat(2));
      }
      dependentFields() {
        return new Set(vals(this.bins).map((c2) => c2.field));
      }
      hash() {
        return `Bin ${hash(this.bins)}`;
      }
      assemble() {
        return vals(this.bins).flatMap((bin2) => {
          const transform2 = [];
          const [binAs, ...remainingAs] = bin2.as;
          const { extent: extent2, ...params2 } = bin2.bin;
          const binTrans = {
            type: "bin",
            field: replacePathInField(bin2.field),
            as: binAs,
            signal: bin2.signal,
            ...!isParameterExtent(extent2) ? { extent: extent2 } : { extent: null },
            ...bin2.span ? { span: { signal: `span(${bin2.span})` } } : {},
            ...params2
          };
          if (!extent2 && bin2.extentSignal) {
            transform2.push({
              type: "extent",
              field: replacePathInField(bin2.field),
              signal: bin2.extentSignal
            });
            binTrans.extent = { signal: bin2.extentSignal };
          }
          transform2.push(binTrans);
          for (const as of remainingAs) {
            for (let i = 0; i < 2; i++) {
              transform2.push({
                type: "formula",
                expr: vgField({ field: binAs[i] }, { expr: "datum" }),
                as: as[i]
              });
            }
          }
          if (bin2.formula) {
            transform2.push({
              type: "formula",
              expr: bin2.formula,
              as: bin2.formulaAs
            });
          }
          return transform2;
        });
      }
    }
    function addDimension(dims, channel, fieldDef, model) {
      var _a2;
      const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
      if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {
        dims.add(vgField(fieldDef, {}));
        dims.add(vgField(fieldDef, { suffix: "end" }));
        const { mark, markDef, config } = model;
        const bandPosition = getBandPosition({ fieldDef, markDef, config });
        if (isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel)) {
          dims.add(vgField(fieldDef, { suffix: OFFSETTED_RECT_START_SUFFIX }));
          dims.add(vgField(fieldDef, { suffix: OFFSETTED_RECT_END_SUFFIX }));
        }
        if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
          dims.add(vgField(fieldDef, { binSuffix: "range" }));
        }
      } else if (isGeoPositionChannel(channel)) {
        const posChannel = getPositionChannelFromLatLong(channel);
        dims.add(model.getName(posChannel));
      } else {
        dims.add(vgField(fieldDef));
      }
      if (isScaleFieldDef(fieldDef) && isFieldRange((_a2 = fieldDef.scale) == null ? void 0 : _a2.range)) {
        dims.add(fieldDef.scale.range.field);
      }
      return dims;
    }
    function mergeMeasures(parentMeasures, childMeasures) {
      for (const field2 of keys(childMeasures)) {
        const ops2 = childMeasures[field2];
        for (const op of keys(ops2)) {
          if (field2 in parentMeasures) {
            parentMeasures[field2][op] = /* @__PURE__ */ new Set([...parentMeasures[field2][op] ?? [], ...ops2[op]]);
          } else {
            parentMeasures[field2] = { [op]: ops2[op] };
          }
        }
      }
    }
    class AggregateNode extends DataFlowNode {
      clone() {
        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
      }
      /**
       * @param dimensions string set for dimensions
       * @param measures dictionary mapping field name => dict of aggregation functions and names to use
       */
      constructor(parent, dimensions, measures) {
        super(parent);
        this.dimensions = dimensions;
        this.measures = measures;
      }
      get groupBy() {
        return this.dimensions;
      }
      static makeFromEncoding(parent, model) {
        let isAggregate2 = false;
        model.forEachFieldDef((fd) => {
          if (fd.aggregate) {
            isAggregate2 = true;
          }
        });
        const meas = {};
        const dims = /* @__PURE__ */ new Set();
        if (!isAggregate2) {
          return null;
        }
        model.forEachFieldDef((fieldDef, channel) => {
          const { aggregate, field: field2 } = fieldDef;
          if (aggregate) {
            if (aggregate === "count") {
              meas["*"] ?? (meas["*"] = {});
              meas["*"]["count"] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
            } else {
              if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
                const op = isArgminDef(aggregate) ? "argmin" : "argmax";
                const argField = aggregate[op];
                meas[argField] ?? (meas[argField] = {});
                meas[argField][op] = /* @__PURE__ */ new Set([vgField({ op, field: argField }, { forAs: true })]);
              } else {
                meas[field2] ?? (meas[field2] = {});
                meas[field2][aggregate] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
              }
              if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
                meas[field2] ?? (meas[field2] = {});
                meas[field2]["min"] = /* @__PURE__ */ new Set([vgField({ field: field2, aggregate: "min" }, { forAs: true })]);
                meas[field2]["max"] = /* @__PURE__ */ new Set([vgField({ field: field2, aggregate: "max" }, { forAs: true })]);
              }
            }
          } else {
            addDimension(dims, channel, fieldDef, model);
          }
        });
        if (dims.size + keys(meas).length === 0) {
          return null;
        }
        return new AggregateNode(parent, dims, meas);
      }
      static makeFromTransform(parent, t4) {
        const dims = /* @__PURE__ */ new Set();
        const meas = {};
        for (const s of t4.aggregate) {
          const { op, field: field2, as } = s;
          if (op) {
            if (op === "count") {
              meas["*"] ?? (meas["*"] = {});
              meas["*"]["count"] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
            } else {
              meas[field2] ?? (meas[field2] = {});
              meas[field2][op] = /* @__PURE__ */ new Set([as ? as : vgField(s, { forAs: true })]);
            }
          }
        }
        for (const s of t4.groupby ?? []) {
          dims.add(s);
        }
        if (dims.size + keys(meas).length === 0) {
          return null;
        }
        return new AggregateNode(parent, dims, meas);
      }
      merge(other) {
        if (setEqual(this.dimensions, other.dimensions)) {
          mergeMeasures(this.measures, other.measures);
          return true;
        }
        debug$2("different dimensions, cannot merge");
        return false;
      }
      addDimensions(fields) {
        fields.forEach(this.dimensions.add, this.dimensions);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([...this.dimensions, ...keys(this.measures)]);
      }
      producedFields() {
        const out = /* @__PURE__ */ new Set();
        for (const field2 of keys(this.measures)) {
          for (const op of keys(this.measures[field2])) {
            const m2 = this.measures[field2][op];
            if (m2.size === 0) {
              out.add(`${op}_${field2}`);
            } else {
              m2.forEach(out.add, out);
            }
          }
        }
        return out;
      }
      hash() {
        return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
      }
      assemble() {
        const ops2 = [];
        const fields = [];
        const as = [];
        for (const field2 of keys(this.measures)) {
          for (const op of keys(this.measures[field2])) {
            for (const alias of this.measures[field2][op]) {
              as.push(alias);
              ops2.push(op);
              fields.push(field2 === "*" ? null : replacePathInField(field2));
            }
          }
        }
        const result = {
          type: "aggregate",
          groupby: [...this.dimensions].map(replacePathInField),
          ops: ops2,
          fields,
          as
        };
        return result;
      }
    }
    class FacetNode extends DataFlowNode {
      /**
       * @param model The facet model.
       * @param name The name that this facet source will have.
       * @param data The source data for this facet data.
       */
      constructor(parent, model, name2, data2) {
        super(parent);
        this.model = model;
        this.name = name2;
        this.data = data2;
        for (const channel of FACET_CHANNELS) {
          const fieldDef = model.facet[channel];
          if (fieldDef) {
            const { bin: bin2, sort: sort2 } = fieldDef;
            this[channel] = {
              name: model.getName(`${channel}_domain`),
              fields: [vgField(fieldDef), ...isBinning(bin2) ? [vgField(fieldDef, { binSuffix: "end" })] : []],
              ...isSortField(sort2) ? { sortField: sort2 } : isArray(sort2) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {}
            };
          }
        }
        this.childModel = model.child;
      }
      hash() {
        let out = `Facet`;
        for (const channel of FACET_CHANNELS) {
          if (this[channel]) {
            out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
          }
        }
        return out;
      }
      get fields() {
        var _a2;
        const f = [];
        for (const channel of FACET_CHANNELS) {
          if ((_a2 = this[channel]) == null ? void 0 : _a2.fields) {
            f.push(...this[channel].fields);
          }
        }
        return f;
      }
      dependentFields() {
        const depFields = new Set(this.fields);
        for (const channel of FACET_CHANNELS) {
          if (this[channel]) {
            if (this[channel].sortField) {
              depFields.add(this[channel].sortField.field);
            }
            if (this[channel].sortIndexField) {
              depFields.add(this[channel].sortIndexField);
            }
          }
        }
        return depFields;
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      /**
       * The name to reference this source is its name.
       */
      getSource() {
        return this.name;
      }
      getChildIndependentFieldsWithStep() {
        const childIndependentFieldsWithStep = {};
        for (const channel of POSITION_SCALE_CHANNELS) {
          const childScaleComponent = this.childModel.component.scales[channel];
          if (childScaleComponent && !childScaleComponent.merged) {
            const type2 = childScaleComponent.get("type");
            const range2 = childScaleComponent.get("range");
            if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
              const domain2 = assembleDomain(this.childModel, channel);
              const field2 = getFieldFromDomain(domain2);
              if (field2) {
                childIndependentFieldsWithStep[channel] = field2;
              } else {
                warn(unknownField(channel));
              }
            }
          }
        }
        return childIndependentFieldsWithStep;
      }
      assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
        const childChannel = { row: "y", column: "x", facet: void 0 }[channel];
        const fields = [];
        const ops2 = [];
        const as = [];
        if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
          if (crossedDataName) {
            fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
            ops2.push("max");
          } else {
            fields.push(childIndependentFieldsWithStep[childChannel]);
            ops2.push("distinct");
          }
          as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        }
        const { sortField, sortIndexField } = this[channel];
        if (sortField) {
          const { op = DEFAULT_SORT_OP, field: field2 } = sortField;
          fields.push(field2);
          ops2.push(op);
          as.push(vgField(sortField, { forAs: true }));
        } else if (sortIndexField) {
          fields.push(sortIndexField);
          ops2.push("max");
          as.push(sortIndexField);
        }
        return {
          name: this[channel].name,
          // Use data from the crossed one if it exist
          source: crossedDataName ?? this.data,
          transform: [
            {
              type: "aggregate",
              groupby: this[channel].fields,
              ...fields.length ? {
                fields,
                ops: ops2,
                as
              } : {}
            }
          ]
        };
      }
      assembleFacetHeaderData(childIndependentFieldsWithStep) {
        var _a2;
        const { columns } = this.model.layout;
        const { layoutHeaders: layoutHeaders2 } = this.model.component;
        const data2 = [];
        const hasSharedAxis = {};
        for (const headerChannel of HEADER_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            const headers = (layoutHeaders2[headerChannel] && layoutHeaders2[headerChannel][headerType]) ?? [];
            for (const header of headers) {
              if (((_a2 = header.axes) == null ? void 0 : _a2.length) > 0) {
                hasSharedAxis[headerChannel] = true;
                break;
              }
            }
          }
          if (hasSharedAxis[headerChannel]) {
            const cardinality = `length(data("${this.facet.name}"))`;
            const stop2 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
            data2.push({
              name: `${this.facet.name}_${headerChannel}`,
              transform: [
                {
                  type: "sequence",
                  start: 0,
                  stop: stop2
                }
              ]
            });
          }
        }
        const { row, column } = hasSharedAxis;
        if (row || column) {
          data2.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
        }
        return data2;
      }
      assemble() {
        const data2 = [];
        let crossedDataName = null;
        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
        const { column, row, facet } = this;
        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
          crossedDataName = `cross_${this.column.name}_${this.row.name}`;
          const fields = [].concat(childIndependentFieldsWithStep.x ?? [], childIndependentFieldsWithStep.y ?? []);
          const ops2 = fields.map(() => "distinct");
          data2.push({
            name: crossedDataName,
            source: this.data,
            transform: [
              {
                type: "aggregate",
                groupby: this.fields,
                fields,
                ops: ops2
              }
            ]
          });
        }
        for (const channel of [COLUMN, ROW]) {
          if (this[channel]) {
            data2.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
          }
        }
        if (facet) {
          const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
          if (facetData) {
            data2.push(...facetData);
          }
        }
        return data2;
      }
    }
    function unquote(pattern) {
      if (pattern.startsWith("'") && pattern.endsWith("'") || pattern.startsWith('"') && pattern.endsWith('"')) {
        return pattern.slice(1, -1);
      }
      return pattern;
    }
    function parseExpression(field2, parse2) {
      const f = accessPathWithDatum(field2);
      if (parse2 === "number") {
        return `toNumber(${f})`;
      } else if (parse2 === "boolean") {
        return `toBoolean(${f})`;
      } else if (parse2 === "string") {
        return `toString(${f})`;
      } else if (parse2 === "date") {
        return `toDate(${f})`;
      } else if (parse2 === "flatten") {
        return f;
      } else if (parse2.startsWith("date:")) {
        const specifier = unquote(parse2.slice(5, parse2.length));
        return `timeParse(${f},'${specifier}')`;
      } else if (parse2.startsWith("utc:")) {
        const specifier = unquote(parse2.slice(4, parse2.length));
        return `utcParse(${f},'${specifier}')`;
      } else {
        warn(unrecognizedParse(parse2));
        return null;
      }
    }
    function getImplicitFromFilterTransform(transform2) {
      const implicit2 = {};
      forEachLeaf(transform2.filter, (filter2) => {
        if (isFieldPredicate(filter2)) {
          let val = null;
          if (isFieldEqualPredicate(filter2)) {
            val = signalRefOrValue(filter2.equal);
          } else if (isFieldLTEPredicate(filter2)) {
            val = signalRefOrValue(filter2.lte);
          } else if (isFieldLTPredicate(filter2)) {
            val = signalRefOrValue(filter2.lt);
          } else if (isFieldGTPredicate(filter2)) {
            val = signalRefOrValue(filter2.gt);
          } else if (isFieldGTEPredicate(filter2)) {
            val = signalRefOrValue(filter2.gte);
          } else if (isFieldRangePredicate(filter2)) {
            val = filter2.range[0];
          } else if (isFieldOneOfPredicate(filter2)) {
            val = (filter2.oneOf ?? filter2["in"])[0];
          }
          if (val) {
            if (isDateTime(val)) {
              implicit2[filter2.field] = "date";
            } else if (isNumber$1(val)) {
              implicit2[filter2.field] = "number";
            } else if (isString(val)) {
              implicit2[filter2.field] = "string";
            }
          }
          if (filter2.timeUnit) {
            implicit2[filter2.field] = "date";
          }
        }
      });
      return implicit2;
    }
    function getImplicitFromEncoding(model) {
      const implicit2 = {};
      function add2(fieldDef) {
        if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
          implicit2[fieldDef.field] = "date";
        } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
          implicit2[fieldDef.field] = "number";
        } else if (accessPathDepth(fieldDef.field) > 1) {
          if (!(fieldDef.field in implicit2)) {
            implicit2[fieldDef.field] = "flatten";
          }
        } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
          if (!(fieldDef.sort.field in implicit2)) {
            implicit2[fieldDef.sort.field] = "flatten";
          }
        }
      }
      if (isUnitModel(model) || isFacetModel(model)) {
        model.forEachFieldDef((fieldDef, channel) => {
          if (isTypedFieldDef(fieldDef)) {
            add2(fieldDef);
          } else {
            const mainChannel = getMainRangeChannel(channel);
            const mainFieldDef = model.fieldDef(mainChannel);
            add2({
              ...fieldDef,
              type: mainFieldDef.type
            });
          }
        });
      }
      if (isUnitModel(model)) {
        const { mark, markDef, encoding } = model;
        if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
        !model.encoding.order) {
          const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
          const dimensionChannelDef = encoding[dimensionChannel];
          if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit2)) {
            implicit2[dimensionChannelDef.field] = "number";
          }
        }
      }
      return implicit2;
    }
    function getImplicitFromSelection(model) {
      const implicit2 = {};
      if (isUnitModel(model) && model.component.selection) {
        for (const name2 of keys(model.component.selection)) {
          const selCmpt = model.component.selection[name2];
          for (const proj of selCmpt.project.items) {
            if (!proj.channel && accessPathDepth(proj.field) > 1) {
              implicit2[proj.field] = "flatten";
            }
          }
        }
      }
      return implicit2;
    }
    class ParseNode extends DataFlowNode {
      clone() {
        return new ParseNode(null, duplicate(this._parse));
      }
      constructor(parent, parse2) {
        super(parent);
        this._parse = parse2;
      }
      hash() {
        return `Parse ${hash(this._parse)}`;
      }
      /**
       * Creates a parse node from a data.format.parse and updates ancestorParse.
       */
      static makeExplicit(parent, model, ancestorParse) {
        var _a2;
        let explicit = {};
        const data2 = model.data;
        if (!isGenerator(data2) && ((_a2 = data2 == null ? void 0 : data2.format) == null ? void 0 : _a2.parse)) {
          explicit = data2.format.parse;
        }
        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
      }
      /**
       * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
       */
      static makeWithAncestors(parent, explicit, implicit2, ancestorParse) {
        for (const field2 of keys(implicit2)) {
          const parsedAs = ancestorParse.getWithExplicit(field2);
          if (parsedAs.value !== void 0) {
            if (parsedAs.explicit || parsedAs.value === implicit2[field2] || parsedAs.value === "derived" || implicit2[field2] === "flatten") {
              delete implicit2[field2];
            } else {
              warn(differentParse(field2, implicit2[field2], parsedAs.value));
            }
          }
        }
        for (const field2 of keys(explicit)) {
          const parsedAs = ancestorParse.get(field2);
          if (parsedAs !== void 0) {
            if (parsedAs === explicit[field2]) {
              delete explicit[field2];
            } else {
              warn(differentParse(field2, explicit[field2], parsedAs));
            }
          }
        }
        const parse2 = new Split(explicit, implicit2);
        ancestorParse.copyAll(parse2);
        const p = {};
        for (const key2 of keys(parse2.combine())) {
          const val = parse2.get(key2);
          if (val !== null) {
            p[key2] = val;
          }
        }
        if (keys(p).length === 0 || ancestorParse.parseNothing) {
          return null;
        }
        return new ParseNode(parent, p);
      }
      get parse() {
        return this._parse;
      }
      merge(other) {
        this._parse = { ...this._parse, ...other.parse };
        other.remove();
      }
      /**
       * Assemble an object for Vega's format.parse property.
       */
      assembleFormatParse() {
        const formatParse = {};
        for (const field2 of keys(this._parse)) {
          const p = this._parse[field2];
          if (accessPathDepth(field2) === 1) {
            formatParse[field2] = p;
          }
        }
        return formatParse;
      }
      // format parse depends and produces all fields in its parse
      producedFields() {
        return new Set(keys(this._parse));
      }
      dependentFields() {
        return new Set(keys(this._parse));
      }
      assembleTransforms(onlyNested = false) {
        return keys(this._parse).filter((field2) => onlyNested ? accessPathDepth(field2) > 1 : true).map((field2) => {
          const expr2 = parseExpression(field2, this._parse[field2]);
          if (!expr2) {
            return null;
          }
          const formula2 = {
            type: "formula",
            expr: expr2,
            as: removePathFromField(field2)
            // Vega output is always flattened
          };
          return formula2;
        }).filter((t4) => t4 !== null);
      }
    }
    class IdentifierNode extends DataFlowNode {
      clone() {
        return new IdentifierNode(null);
      }
      constructor(parent) {
        super(parent);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set([SELECTION_ID]);
      }
      hash() {
        return "Identifier";
      }
      assemble() {
        return { type: "identifier", as: SELECTION_ID };
      }
    }
    class GraticuleNode extends DataFlowNode {
      clone() {
        return new GraticuleNode(null, this.params);
      }
      constructor(parent, params2) {
        super(parent);
        this.params = params2;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return void 0;
      }
      hash() {
        return `Graticule ${hash(this.params)}`;
      }
      assemble() {
        return {
          type: "graticule",
          ...this.params === true ? {} : this.params
        };
      }
    }
    class SequenceNode extends DataFlowNode {
      clone() {
        return new SequenceNode(null, this.params);
      }
      constructor(parent, params2) {
        super(parent);
        this.params = params2;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
      }
      hash() {
        return `Hash ${hash(this.params)}`;
      }
      assemble() {
        return {
          type: "sequence",
          ...this.params
        };
      }
    }
    class SourceNode extends DataFlowNode {
      constructor(data2) {
        super(null);
        data2 ?? (data2 = { name: "source" });
        let format2;
        if (!isGenerator(data2)) {
          format2 = data2.format ? { ...omit(data2.format, ["parse"]) } : {};
        }
        if (isInlineData(data2)) {
          this._data = { values: data2.values };
        } else if (isUrlData(data2)) {
          this._data = { url: data2.url };
          if (!format2.type) {
            let defaultExtension = /(?:\.([^.]+))?$/.exec(data2.url)[1];
            if (!contains(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
              defaultExtension = "json";
            }
            format2.type = defaultExtension;
          }
        } else if (isSphereGenerator(data2)) {
          this._data = { values: [{ type: "Sphere" }] };
        } else if (isNamedData(data2) || isGenerator(data2)) {
          this._data = {};
        }
        this._generator = isGenerator(data2);
        if (data2.name) {
          this._name = data2.name;
        }
        if (format2 && !isEmpty(format2)) {
          this._data.format = format2;
        }
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return void 0;
      }
      get data() {
        return this._data;
      }
      hasName() {
        return !!this._name;
      }
      get isGenerator() {
        return this._generator;
      }
      get dataName() {
        return this._name;
      }
      set dataName(name2) {
        this._name = name2;
      }
      set parent(parent) {
        throw new Error("Source nodes have to be roots.");
      }
      remove() {
        throw new Error("Source nodes are roots and cannot be removed.");
      }
      hash() {
        throw new Error("Cannot hash sources");
      }
      assemble() {
        return {
          name: this._name,
          ...this._data,
          transform: []
        };
      }
    }
    var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    var __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Optimizer_modified;
    function isDataSourceNode(node) {
      return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
    }
    class Optimizer {
      constructor() {
        _Optimizer_modified.set(this, void 0);
        __classPrivateFieldSet(this, _Optimizer_modified, false, "f");
      }
      // Once true, #modified is never set to false
      setModified() {
        __classPrivateFieldSet(this, _Optimizer_modified, true, "f");
      }
      get modifiedFlag() {
        return __classPrivateFieldGet(this, _Optimizer_modified, "f");
      }
    }
    _Optimizer_modified = /* @__PURE__ */ new WeakMap();
    class BottomUpOptimizer extends Optimizer {
      /**
       * Compute a map of node depths that we can use to determine a topological sort order.
       */
      getNodeDepths(node, depth, depths) {
        depths.set(node, depth);
        for (const child of node.children) {
          this.getNodeDepths(child, depth + 1, depths);
        }
        return depths;
      }
      /**
       * Run the optimizer on all nodes starting from the leaves.
       */
      optimize(node) {
        const depths = this.getNodeDepths(node, 0, /* @__PURE__ */ new Map());
        const topologicalSort = [...depths.entries()].sort((a2, b2) => b2[1] - a2[1]);
        for (const tuple of topologicalSort) {
          this.run(tuple[0]);
        }
        return this.modifiedFlag;
      }
    }
    class TopDownOptimizer extends Optimizer {
      /**
       * Run the optimizer depth first on all nodes starting from the roots.
       */
      optimize(node) {
        this.run(node);
        for (const child of node.children) {
          this.optimize(child);
        }
        return this.modifiedFlag;
      }
    }
    class MergeIdenticalNodes extends TopDownOptimizer {
      mergeNodes(parent, nodes) {
        const mergedNode = nodes.shift();
        for (const node of nodes) {
          parent.removeChild(node);
          node.parent = mergedNode;
          node.remove();
        }
      }
      run(node) {
        const hashes = node.children.map((x2) => x2.hash());
        const buckets = {};
        for (let i = 0; i < hashes.length; i++) {
          if (buckets[hashes[i]] === void 0) {
            buckets[hashes[i]] = [node.children[i]];
          } else {
            buckets[hashes[i]].push(node.children[i]);
          }
        }
        for (const k of keys(buckets)) {
          if (buckets[k].length > 1) {
            this.setModified();
            this.mergeNodes(node, buckets[k]);
          }
        }
      }
    }
    class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer {
      constructor(model) {
        super();
        this.requiresSelectionId = model && requiresSelectionId(model);
      }
      run(node) {
        if (node instanceof IdentifierNode) {
          if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
            this.setModified();
            node.remove();
          }
        }
      }
    }
    class RemoveDuplicateTimeUnits extends Optimizer {
      optimize(node) {
        this.run(node, /* @__PURE__ */ new Set());
        return this.modifiedFlag;
      }
      run(node, timeUnitFields) {
        let producedFields = /* @__PURE__ */ new Set();
        if (node instanceof TimeUnitNode) {
          producedFields = node.producedFields();
          if (hasIntersection(producedFields, timeUnitFields)) {
            this.setModified();
            node.removeFormulas(timeUnitFields);
            if (node.producedFields.length === 0) {
              node.remove();
            }
          }
        }
        for (const child of node.children) {
          this.run(child, /* @__PURE__ */ new Set([...timeUnitFields, ...producedFields]));
        }
      }
    }
    class RemoveUnnecessaryOutputNodes extends TopDownOptimizer {
      constructor() {
        super();
      }
      run(node) {
        if (node instanceof OutputNode && !node.isRequired()) {
          this.setModified();
          node.remove();
        }
      }
    }
    class MoveParseUp extends BottomUpOptimizer {
      run(node) {
        if (isDataSourceNode(node)) {
          return;
        }
        if (node.numChildren() > 1) {
          return;
        }
        for (const child of node.children) {
          if (child instanceof ParseNode) {
            if (node instanceof ParseNode) {
              this.setModified();
              node.merge(child);
            } else {
              if (fieldIntersection(node.producedFields(), child.dependentFields())) {
                continue;
              }
              this.setModified();
              child.swapWithParent();
            }
          }
        }
        return;
      }
    }
    class MergeParse extends BottomUpOptimizer {
      run(node) {
        const originalChildren = [...node.children];
        const parseChildren = node.children.filter((child) => child instanceof ParseNode);
        if (node.numChildren() > 1 && parseChildren.length >= 1) {
          const commonParse = {};
          const conflictingParse = /* @__PURE__ */ new Set();
          for (const parseNode of parseChildren) {
            const parse2 = parseNode.parse;
            for (const k of keys(parse2)) {
              if (!(k in commonParse)) {
                commonParse[k] = parse2[k];
              } else if (commonParse[k] !== parse2[k]) {
                conflictingParse.add(k);
              }
            }
          }
          for (const field2 of conflictingParse) {
            delete commonParse[field2];
          }
          if (!isEmpty(commonParse)) {
            this.setModified();
            const mergedParseNode = new ParseNode(node, commonParse);
            for (const childNode of originalChildren) {
              if (childNode instanceof ParseNode) {
                for (const key2 of keys(commonParse)) {
                  delete childNode.parse[key2];
                }
              }
              node.removeChild(childNode);
              childNode.parent = mergedParseNode;
              if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {
                childNode.remove();
              }
            }
          }
        }
      }
    }
    class RemoveUnusedSubtrees extends BottomUpOptimizer {
      run(node) {
        if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode)
          ;
        else if (node instanceof SourceNode)
          ;
        else {
          this.setModified();
          node.remove();
        }
      }
    }
    class MergeTimeUnits extends BottomUpOptimizer {
      run(node) {
        const timeUnitChildren = node.children.filter((x2) => x2 instanceof TimeUnitNode);
        const combination = timeUnitChildren.pop();
        for (const timeUnit of timeUnitChildren) {
          this.setModified();
          combination.merge(timeUnit);
        }
      }
    }
    class MergeAggregates extends BottomUpOptimizer {
      run(node) {
        const aggChildren = node.children.filter((child) => child instanceof AggregateNode);
        const groupedAggregates = {};
        for (const agg of aggChildren) {
          const groupBys = hash(agg.groupBy);
          if (!(groupBys in groupedAggregates)) {
            groupedAggregates[groupBys] = [];
          }
          groupedAggregates[groupBys].push(agg);
        }
        for (const group2 of keys(groupedAggregates)) {
          const mergeableAggs = groupedAggregates[group2];
          if (mergeableAggs.length > 1) {
            const mergedAggs = mergeableAggs.pop();
            for (const agg of mergeableAggs) {
              if (mergedAggs.merge(agg)) {
                node.removeChild(agg);
                agg.parent = mergedAggs;
                agg.remove();
                this.setModified();
              }
            }
          }
        }
      }
    }
    class MergeBins extends BottomUpOptimizer {
      constructor(model) {
        super();
        this.model = model;
      }
      run(node) {
        const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);
        const promotableBins = [];
        const remainingBins = [];
        for (const child of node.children) {
          if (child instanceof BinNode) {
            if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {
              promotableBins.push(child);
            } else {
              remainingBins.push(child);
            }
          }
        }
        if (promotableBins.length > 0) {
          const promotedBin = promotableBins.pop();
          for (const bin2 of promotableBins) {
            promotedBin.merge(bin2, this.model.renameSignal.bind(this.model));
          }
          this.setModified();
          if (node instanceof BinNode) {
            node.merge(promotedBin, this.model.renameSignal.bind(this.model));
          } else {
            promotedBin.swapWithParent();
          }
        }
        if (remainingBins.length > 1) {
          const remainingBin = remainingBins.pop();
          for (const bin2 of remainingBins) {
            remainingBin.merge(bin2, this.model.renameSignal.bind(this.model));
          }
          this.setModified();
        }
      }
    }
    class MergeOutputs extends BottomUpOptimizer {
      run(node) {
        const children2 = [...node.children];
        const hasOutputChild = some(children2, (child) => child instanceof OutputNode);
        if (!hasOutputChild || node.numChildren() <= 1) {
          return;
        }
        const otherChildren = [];
        let mainOutput;
        for (const child of children2) {
          if (child instanceof OutputNode) {
            let lastOutput = child;
            while (lastOutput.numChildren() === 1) {
              const [theChild] = lastOutput.children;
              if (theChild instanceof OutputNode) {
                lastOutput = theChild;
              } else {
                break;
              }
            }
            otherChildren.push(...lastOutput.children);
            if (mainOutput) {
              node.removeChild(child);
              child.parent = mainOutput.parent;
              mainOutput.parent.removeChild(mainOutput);
              mainOutput.parent = lastOutput;
              this.setModified();
            } else {
              mainOutput = lastOutput;
            }
          } else {
            otherChildren.push(child);
          }
        }
        if (otherChildren.length) {
          this.setModified();
          for (const child of otherChildren) {
            child.parent.removeChild(child);
            child.parent = mainOutput;
          }
        }
      }
    }
    class JoinAggregateTransformNode extends DataFlowNode {
      clone() {
        return new JoinAggregateTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
      }
      dependentFields() {
        const out = /* @__PURE__ */ new Set();
        if (this.transform.groupby) {
          this.transform.groupby.forEach(out.add, out);
        }
        this.transform.joinaggregate.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.joinaggregate.map(this.getDefaultName));
      }
      getDefaultName(joinAggregateFieldDef) {
        return joinAggregateFieldDef.as ?? vgField(joinAggregateFieldDef);
      }
      hash() {
        return `JoinAggregateTransform ${hash(this.transform)}`;
      }
      assemble() {
        const fields = [];
        const ops2 = [];
        const as = [];
        for (const joinaggregate of this.transform.joinaggregate) {
          ops2.push(joinaggregate.op);
          as.push(this.getDefaultName(joinaggregate));
          fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
        }
        const groupby = this.transform.groupby;
        return {
          type: "joinaggregate",
          as,
          ops: ops2,
          fields,
          ...groupby !== void 0 ? { groupby } : {}
        };
      }
    }
    function getStackByFields(model) {
      return model.stack.stackBy.reduce((fields, by) => {
        const fieldDef = by.fieldDef;
        const _field = vgField(fieldDef);
        if (_field) {
          fields.push(_field);
        }
        return fields;
      }, []);
    }
    function isValidAsArray(as) {
      return isArray(as) && as.every((s) => isString(s)) && as.length > 1;
    }
    class StackNode extends DataFlowNode {
      clone() {
        return new StackNode(null, duplicate(this._stack));
      }
      constructor(parent, stack2) {
        super(parent);
        this._stack = stack2;
      }
      static makeFromTransform(parent, stackTransform) {
        const { stack: stack2, groupby, as, offset: offset2 = "zero" } = stackTransform;
        const sortFields = [];
        const sortOrder = [];
        if (stackTransform.sort !== void 0) {
          for (const sortField of stackTransform.sort) {
            sortFields.push(sortField.field);
            sortOrder.push(getFirstDefined(sortField.order, "ascending"));
          }
        }
        const sort2 = {
          field: sortFields,
          order: sortOrder
        };
        let normalizedAs;
        if (isValidAsArray(as)) {
          normalizedAs = as;
        } else if (isString(as)) {
          normalizedAs = [as, `${as}_end`];
        } else {
          normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
        }
        return new StackNode(parent, {
          dimensionFieldDefs: [],
          stackField: stack2,
          groupby,
          offset: offset2,
          sort: sort2,
          facetby: [],
          as: normalizedAs
        });
      }
      static makeFromEncoding(parent, model) {
        const stackProperties = model.stack;
        const { encoding } = model;
        if (!stackProperties) {
          return null;
        }
        const { groupbyChannels, fieldChannel, offset: offset2, impute } = stackProperties;
        const dimensionFieldDefs = groupbyChannels.map((groupbyChannel) => {
          const cDef = encoding[groupbyChannel];
          return getFieldDef(cDef);
        }).filter((def2) => !!def2);
        const stackby = getStackByFields(model);
        const orderDef = model.encoding.order;
        let sort2;
        if (isArray(orderDef) || isFieldDef(orderDef)) {
          sort2 = sortParams(orderDef);
        } else {
          const sortOrder = isOrderOnlyDef(orderDef) ? orderDef.sort : fieldChannel === "y" ? "descending" : "ascending";
          sort2 = stackby.reduce((s, field2) => {
            s.field.push(field2);
            s.order.push(sortOrder);
            return s;
          }, { field: [], order: [] });
        }
        return new StackNode(parent, {
          dimensionFieldDefs,
          stackField: model.vgField(fieldChannel),
          facetby: [],
          stackby,
          sort: sort2,
          offset: offset2,
          impute,
          as: [
            model.vgField(fieldChannel, { suffix: "start", forAs: true }),
            model.vgField(fieldChannel, { suffix: "end", forAs: true })
          ]
        });
      }
      get stack() {
        return this._stack;
      }
      addDimensions(fields) {
        this._stack.facetby.push(...fields);
      }
      dependentFields() {
        const out = /* @__PURE__ */ new Set();
        out.add(this._stack.stackField);
        this.getGroupbyFields().forEach(out.add, out);
        this._stack.facetby.forEach(out.add, out);
        this._stack.sort.field.forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this._stack.as);
      }
      hash() {
        return `Stack ${hash(this._stack)}`;
      }
      getGroupbyFields() {
        const { dimensionFieldDefs, impute, groupby } = this._stack;
        if (dimensionFieldDefs.length > 0) {
          return dimensionFieldDefs.map((dimensionFieldDef) => {
            if (dimensionFieldDef.bin) {
              if (impute) {
                return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
              }
              return [
                // For binned group by field without impute, we need both bin (start) and bin_end
                vgField(dimensionFieldDef, {}),
                vgField(dimensionFieldDef, { binSuffix: "end" })
              ];
            }
            return [vgField(dimensionFieldDef)];
          }).flat();
        }
        return groupby ?? [];
      }
      assemble() {
        const transform2 = [];
        const { facetby, dimensionFieldDefs, stackField: field2, stackby, sort: sort2, offset: offset2, impute, as } = this._stack;
        if (impute) {
          for (const dimensionFieldDef of dimensionFieldDefs) {
            const { bandPosition = 0.5, bin: bin2 } = dimensionFieldDef;
            if (bin2) {
              const binStart = vgField(dimensionFieldDef, { expr: "datum" });
              const binEnd = vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" });
              transform2.push({
                type: "formula",
                expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,
                as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
              });
            }
            transform2.push({
              type: "impute",
              field: field2,
              groupby: [...stackby, ...facetby],
              key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
              method: "value",
              value: 0
            });
          }
        }
        transform2.push({
          type: "stack",
          groupby: [...this.getGroupbyFields(), ...facetby],
          field: field2,
          sort: sort2,
          as,
          offset: offset2
        });
        return transform2;
      }
    }
    class WindowTransformNode extends DataFlowNode {
      clone() {
        return new WindowTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
      }
      dependentFields() {
        const out = /* @__PURE__ */ new Set();
        (this.transform.groupby ?? []).forEach(out.add, out);
        (this.transform.sort ?? []).forEach((m2) => out.add(m2.field));
        this.transform.window.map((w2) => w2.field).filter((f) => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.window.map(this.getDefaultName));
      }
      getDefaultName(windowFieldDef) {
        return windowFieldDef.as ?? vgField(windowFieldDef);
      }
      hash() {
        return `WindowTransform ${hash(this.transform)}`;
      }
      assemble() {
        const fields = [];
        const ops2 = [];
        const as = [];
        const params2 = [];
        for (const window2 of this.transform.window) {
          ops2.push(window2.op);
          as.push(this.getDefaultName(window2));
          params2.push(window2.param === void 0 ? null : window2.param);
          fields.push(window2.field === void 0 ? null : window2.field);
        }
        const frame2 = this.transform.frame;
        const groupby = this.transform.groupby;
        if (frame2 && frame2[0] === null && frame2[1] === null && ops2.every((o) => isAggregateOp(o))) {
          return {
            type: "joinaggregate",
            as,
            ops: ops2,
            fields,
            ...groupby !== void 0 ? { groupby } : {}
          };
        }
        const sortFields = [];
        const sortOrder = [];
        if (this.transform.sort !== void 0) {
          for (const sortField of this.transform.sort) {
            sortFields.push(sortField.field);
            sortOrder.push(sortField.order ?? "ascending");
          }
        }
        const sort2 = {
          field: sortFields,
          order: sortOrder
        };
        const ignorePeers = this.transform.ignorePeers;
        return {
          type: "window",
          params: params2,
          as,
          ops: ops2,
          fields,
          sort: sort2,
          ...ignorePeers !== void 0 ? { ignorePeers } : {},
          ...groupby !== void 0 ? { groupby } : {},
          ...frame2 !== void 0 ? { frame: frame2 } : {}
        };
      }
    }
    function cloneSubtree(facet) {
      function clone(node) {
        if (!(node instanceof FacetNode)) {
          const copy2 = node.clone();
          if (copy2 instanceof OutputNode) {
            const newName = FACET_SCALE_PREFIX + copy2.getSource();
            copy2.setSource(newName);
            facet.model.component.data.outputNodes[newName] = copy2;
          } else if (copy2 instanceof AggregateNode || copy2 instanceof StackNode || copy2 instanceof WindowTransformNode || copy2 instanceof JoinAggregateTransformNode) {
            copy2.addDimensions(facet.fields);
          }
          for (const n of node.children.flatMap(clone)) {
            n.parent = copy2;
          }
          return [copy2];
        }
        return node.children.flatMap(clone);
      }
      return clone;
    }
    function moveFacetDown(node) {
      if (node instanceof FacetNode) {
        if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
          const child = node.children[0];
          if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
            child.addDimensions(node.fields);
          }
          child.swapWithParent();
          moveFacetDown(node);
        } else {
          const facetMain = node.model.component.data.main;
          moveMainDownToFacet(facetMain);
          const cloner = cloneSubtree(node);
          const copy2 = node.children.map(cloner).flat();
          for (const c2 of copy2) {
            c2.parent = facetMain;
          }
        }
      } else {
        node.children.map(moveFacetDown);
      }
    }
    function moveMainDownToFacet(node) {
      if (node instanceof OutputNode && node.type === DataSourceType.Main) {
        if (node.numChildren() === 1) {
          const child = node.children[0];
          if (!(child instanceof FacetNode)) {
            child.swapWithParent();
            moveMainDownToFacet(node);
          }
        }
      }
    }
    const FACET_SCALE_PREFIX = "scale_";
    const MAX_OPTIMIZATION_RUNS = 5;
    function checkLinks(nodes) {
      for (const node of nodes) {
        for (const child of node.children) {
          if (child.parent !== node) {
            return false;
          }
        }
        if (!checkLinks(node.children)) {
          return false;
        }
      }
      return true;
    }
    function runOptimizer(optimizer, nodes) {
      let modified2 = false;
      for (const node of nodes) {
        modified2 = optimizer.optimize(node) || modified2;
      }
      return modified2;
    }
    function optimizationDataflowHelper(dataComponent, model, firstPass) {
      let roots = dataComponent.sources;
      let modified2 = false;
      modified2 = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified2;
      modified2 = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified2;
      roots = roots.filter((r) => r.numChildren() > 0);
      modified2 = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified2;
      roots = roots.filter((r) => r.numChildren() > 0);
      if (!firstPass) {
        modified2 = runOptimizer(new MoveParseUp(), roots) || modified2;
        modified2 = runOptimizer(new MergeBins(model), roots) || modified2;
        modified2 = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified2;
        modified2 = runOptimizer(new MergeParse(), roots) || modified2;
        modified2 = runOptimizer(new MergeAggregates(), roots) || modified2;
        modified2 = runOptimizer(new MergeTimeUnits(), roots) || modified2;
        modified2 = runOptimizer(new MergeIdenticalNodes(), roots) || modified2;
        modified2 = runOptimizer(new MergeOutputs(), roots) || modified2;
      }
      dataComponent.sources = roots;
      return modified2;
    }
    function optimizeDataflow(data2, model) {
      checkLinks(data2.sources);
      let firstPassCounter = 0;
      let secondPassCounter = 0;
      for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
        if (!optimizationDataflowHelper(data2, model, true)) {
          break;
        }
        firstPassCounter++;
      }
      data2.sources.map(moveFacetDown);
      for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
        if (!optimizationDataflowHelper(data2, model, false)) {
          break;
        }
        secondPassCounter++;
      }
      checkLinks(data2.sources);
      if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
        warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
      }
    }
    class SignalRefWrapper {
      constructor(exprGenerator) {
        Object.defineProperty(this, "signal", {
          enumerable: true,
          get: exprGenerator
        });
      }
      static fromName(rename, signalName) {
        return new SignalRefWrapper(() => rename(signalName));
      }
    }
    function parseScaleDomain(model) {
      if (isUnitModel(model)) {
        parseUnitScaleDomain(model);
      } else {
        parseNonUnitScaleDomain(model);
      }
    }
    function parseUnitScaleDomain(model) {
      const localScaleComponents = model.component.scales;
      for (const channel of keys(localScaleComponents)) {
        const domains = parseDomainForChannel(model, channel);
        const localScaleCmpt = localScaleComponents[channel];
        localScaleCmpt.setWithExplicit("domains", domains);
        parseSelectionDomain(model, channel);
        if (model.component.data.isFaceted) {
          let facetParent = model;
          while (!isFacetModel(facetParent) && facetParent.parent) {
            facetParent = facetParent.parent;
          }
          const resolve2 = facetParent.component.resolve.scale[channel];
          if (resolve2 === "shared") {
            for (const domain2 of domains.value) {
              if (isDataRefDomain(domain2)) {
                domain2.data = FACET_SCALE_PREFIX + domain2.data.replace(FACET_SCALE_PREFIX, "");
              }
            }
          }
        }
      }
    }
    function parseNonUnitScaleDomain(model) {
      for (const child of model.children) {
        parseScaleDomain(child);
      }
      const localScaleComponents = model.component.scales;
      for (const channel of keys(localScaleComponents)) {
        let domains;
        let selectionExtent = null;
        for (const child of model.children) {
          const childComponent = child.component.scales[channel];
          if (childComponent) {
            if (domains === void 0) {
              domains = childComponent.getWithExplicit("domains");
            } else {
              domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
            }
            const se = childComponent.get("selectionExtent");
            if (selectionExtent && se && selectionExtent.param !== se.param) {
              warn(NEEDS_SAME_SELECTION);
            }
            selectionExtent = se;
          }
        }
        localScaleComponents[channel].setWithExplicit("domains", domains);
        if (selectionExtent) {
          localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
        }
      }
    }
    function normalizeUnaggregatedDomain(domain2, fieldDef, scaleType2, scaleConfig) {
      if (domain2 === "unaggregated") {
        const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
        if (!valid) {
          warn(reason);
          return void 0;
        }
      } else if (domain2 === void 0 && scaleConfig.useUnaggregatedDomain) {
        const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType2);
        if (valid) {
          return "unaggregated";
        }
      }
      return domain2;
    }
    function parseDomainForChannel(model, channel) {
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const { encoding } = model;
      const domain2 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
      if (domain2 !== model.scaleDomain(channel)) {
        model.specifiedScales[channel] = {
          ...model.specifiedScales[channel],
          domain: domain2
        };
      }
      if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
        if (getFieldOrDatumDef(encoding.x)) {
          return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "x"), parseSingleChannelDomain(scaleType2, domain2, model, "x2"), "domain", "scale", domainsTieBreaker);
        } else {
          return parseSingleChannelDomain(scaleType2, domain2, model, "x2");
        }
      } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
        if (getFieldOrDatumDef(encoding.y)) {
          return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain2, model, "y"), parseSingleChannelDomain(scaleType2, domain2, model, "y2"), "domain", "scale", domainsTieBreaker);
        } else {
          return parseSingleChannelDomain(scaleType2, domain2, model, "y2");
        }
      }
      return parseSingleChannelDomain(scaleType2, domain2, model, channel);
    }
    function mapDomainToDataSignal(domain2, type2, timeUnit) {
      return domain2.map((v) => {
        const data2 = valueExpr(v, { timeUnit, type: type2 });
        return { signal: `{data: ${data2}}` };
      });
    }
    function convertDomainIfItIsDateTime(domain2, type2, timeUnit) {
      var _a2;
      const normalizedTimeUnit = (_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit;
      if (type2 === "temporal" || normalizedTimeUnit) {
        return mapDomainToDataSignal(domain2, type2, normalizedTimeUnit);
      }
      return [domain2];
    }
    function parseSingleChannelDomain(scaleType2, domain2, model, channel) {
      const { encoding, markDef, mark, config, stack: stack2 } = model;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      const { type: type2 } = fieldOrDatumDef;
      const timeUnit = fieldOrDatumDef["timeUnit"];
      if (isDomainUnionWith(domain2)) {
        const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
        const unionWith = convertDomainIfItIsDateTime(domain2.unionWith, type2, timeUnit);
        return makeExplicit([...unionWith, ...defaultDomain.value]);
      } else if (isSignalRef(domain2)) {
        return makeExplicit([domain2]);
      } else if (domain2 && domain2 !== "unaggregated" && !isParameterDomain(domain2)) {
        return makeExplicit(convertDomainIfItIsDateTime(domain2, type2, timeUnit));
      }
      if (stack2 && channel === stack2.fieldChannel) {
        if (stack2.offset === "normalize") {
          return makeImplicit([[0, 1]]);
        }
        const data2 = model.requestDataName(DataSourceType.Main);
        return makeImplicit([
          {
            data: data2,
            field: model.vgField(channel, { suffix: "start" })
          },
          {
            data: data2,
            field: model.vgField(channel, { suffix: "end" })
          }
        ]);
      }
      const sort2 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
      if (isDatumDef(fieldOrDatumDef)) {
        const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type2, timeUnit);
        return makeImplicit(d);
      }
      const fieldDef = fieldOrDatumDef;
      if (domain2 === "unaggregated") {
        const data2 = model.requestDataName(DataSourceType.Main);
        const { field: field2 } = fieldOrDatumDef;
        return makeImplicit([
          {
            data: data2,
            field: vgField({ field: field2, aggregate: "min" })
          },
          {
            data: data2,
            field: vgField({ field: field2, aggregate: "max" })
          }
        ]);
      } else if (isBinning(fieldDef.bin)) {
        if (hasDiscreteDomain(scaleType2)) {
          if (scaleType2 === "bin-ordinal") {
            return makeImplicit([]);
          }
          return makeImplicit([
            {
              // If sort by aggregation of a specified sort field, we need to use RAW table,
              // so we can aggregate values for the scale independently from the main aggregation.
              data: isBoolean(sort2) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
              // Use range if we added it and the scale does not support computing a range as a signal.
              field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
              // we have to use a sort object if sort = true to make the sort correct by bin start
              sort: sort2 === true || !isObject(sort2) ? {
                field: model.vgField(channel, {}),
                op: "min"
                // min or max doesn't matter since we sort by the start of the bin range
              } : sort2
            }
          ]);
        } else {
          const { bin: bin2 } = fieldDef;
          if (isBinning(bin2)) {
            const binSignal = getBinSignalName(model, fieldDef.field, bin2);
            return makeImplicit([
              new SignalRefWrapper(() => {
                const signal = model.getSignalName(binSignal);
                return `[${signal}.start, ${signal}.stop]`;
              })
            ]);
          } else {
            return makeImplicit([
              {
                data: model.requestDataName(DataSourceType.Main),
                field: model.vgField(channel, {})
              }
            ]);
          }
        }
      } else if (fieldDef.timeUnit && contains(["time", "utc"], scaleType2)) {
        const fieldDef2 = encoding[getSecondaryRangeChannel(channel)];
        if (hasBandEnd(fieldDef, fieldDef2, markDef, config)) {
          const data2 = model.requestDataName(DataSourceType.Main);
          const bandPosition = getBandPosition({ fieldDef, fieldDef2, markDef, config });
          const isRectWithOffset = isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel);
          return makeImplicit([
            {
              data: data2,
              field: model.vgField(channel, isRectWithOffset ? { suffix: OFFSETTED_RECT_START_SUFFIX } : {})
            },
            {
              data: data2,
              field: model.vgField(channel, { suffix: isRectWithOffset ? OFFSETTED_RECT_END_SUFFIX : "end" })
            }
          ]);
        }
      }
      if (sort2) {
        return makeImplicit([
          {
            // If sort by aggregation of a specified sort field, we need to use RAW table,
            // so we can aggregate values for the scale independently from the main aggregation.
            data: isBoolean(sort2) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),
            field: model.vgField(channel),
            sort: sort2
          }
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(DataSourceType.Main),
            field: model.vgField(channel)
          }
        ]);
      }
    }
    function normalizeSortField(sort2, isStackedMeasure) {
      const { op, field: field2, order } = sort2;
      return {
        // Apply default op
        op: op ?? (isStackedMeasure ? "sum" : DEFAULT_SORT_OP),
        // flatten nested fields
        ...field2 ? { field: replacePathInField(field2) } : {},
        ...order ? { order } : {}
      };
    }
    function parseSelectionDomain(model, channel) {
      var _a2;
      const scale2 = model.component.scales[channel];
      const spec = model.specifiedScales[channel].domain;
      const bin2 = (_a2 = model.fieldDef(channel)) == null ? void 0 : _a2.bin;
      const domain2 = isParameterDomain(spec) && spec;
      const extent2 = isBinParams(bin2) && isParameterExtent(bin2.extent) && bin2.extent;
      if (domain2 || extent2) {
        scale2.set("selectionExtent", domain2 ?? extent2, true);
      }
    }
    function domainSort(model, channel, scaleType2) {
      if (!hasDiscreteDomain(scaleType2)) {
        return void 0;
      }
      const fieldDef = model.fieldDef(channel);
      const sort2 = fieldDef.sort;
      if (isSortArray(sort2)) {
        return {
          op: "min",
          field: sortArrayIndexField(fieldDef, channel),
          order: "ascending"
        };
      }
      const { stack: stack2 } = model;
      const stackDimensions = stack2 ? /* @__PURE__ */ new Set([...stack2.groupbyFields, ...stack2.stackBy.map((s) => s.fieldDef.field)]) : void 0;
      if (isSortField(sort2)) {
        const isStackedMeasure = stack2 && !stackDimensions.has(sort2.field);
        return normalizeSortField(sort2, isStackedMeasure);
      } else if (isSortByEncoding(sort2)) {
        const { encoding, order } = sort2;
        const fieldDefToSortBy = model.fieldDef(encoding);
        const { aggregate, field: field2 } = fieldDefToSortBy;
        const isStackedMeasure = stack2 && !stackDimensions.has(field2);
        if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
          return normalizeSortField({
            field: vgField(fieldDefToSortBy),
            order
          }, isStackedMeasure);
        } else if (isAggregateOp(aggregate) || !aggregate) {
          return normalizeSortField({
            op: aggregate,
            field: field2,
            order
          }, isStackedMeasure);
        }
      } else if (sort2 === "descending") {
        return {
          op: "min",
          field: model.vgField(channel),
          order: "descending"
        };
      } else if (contains([
        "ascending",
        void 0
        /* default =ascending*/
      ], sort2)) {
        return true;
      }
      return void 0;
    }
    function canUseUnaggregatedDomain(fieldDef, scaleType2) {
      const { aggregate, type: type2 } = fieldDef;
      if (!aggregate) {
        return {
          valid: false,
          reason: unaggregateDomainHasNoEffectForRawField(fieldDef)
        };
      }
      if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {
        return {
          valid: false,
          reason: unaggregateDomainWithNonSharedDomainOp(aggregate)
        };
      }
      if (type2 === "quantitative") {
        if (scaleType2 === "log") {
          return {
            valid: false,
            reason: unaggregatedDomainWithLogScale(fieldDef)
          };
        }
      }
      return { valid: true };
    }
    function domainsTieBreaker(v1, v2, property2, propertyOf) {
      if (v1.explicit && v2.explicit) {
        warn(mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
      }
      return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
    }
    function mergeDomains(domains) {
      const uniqueDomains = unique(domains.map((domain2) => {
        if (isDataRefDomain(domain2)) {
          const { sort: _s, ...domainWithoutSort } = domain2;
          return domainWithoutSort;
        }
        return domain2;
      }), hash);
      const sorts = unique(domains.map((d) => {
        if (isDataRefDomain(d)) {
          const s = d.sort;
          if (s !== void 0 && !isBoolean(s)) {
            if ("op" in s && s.op === "count") {
              delete s.field;
            }
            if (s.order === "ascending") {
              delete s.order;
            }
          }
          return s;
        }
        return void 0;
      }).filter((s) => s !== void 0), hash);
      if (uniqueDomains.length === 0) {
        return void 0;
      } else if (uniqueDomains.length === 1) {
        const domain2 = domains[0];
        if (isDataRefDomain(domain2) && sorts.length > 0) {
          let sort3 = sorts[0];
          if (sorts.length > 1) {
            warn(MORE_THAN_ONE_SORT);
            const filteredSorts = sorts.filter((s) => isObject(s) && "op" in s && s.op !== "min");
            if (sorts.every((s) => isObject(s) && "op" in s) && filteredSorts.length === 1) {
              sort3 = filteredSorts[0];
            } else {
              sort3 = true;
            }
          } else {
            if (isObject(sort3) && "field" in sort3) {
              const sortField = sort3.field;
              if (domain2.field === sortField) {
                sort3 = sort3.order ? { order: sort3.order } : true;
              }
            }
          }
          return {
            ...domain2,
            sort: sort3
          };
        }
        return domain2;
      }
      const unionDomainSorts = unique(sorts.map((s) => {
        if (isBoolean(s) || !("op" in s) || isString(s.op) && s.op in MULTIDOMAIN_SORT_OP_INDEX) {
          return s;
        }
        warn(domainSortDropped(s));
        return true;
      }), hash);
      let sort2;
      if (unionDomainSorts.length === 1) {
        sort2 = unionDomainSorts[0];
      } else if (unionDomainSorts.length > 1) {
        warn(MORE_THAN_ONE_SORT);
        sort2 = true;
      }
      const allData = unique(domains.map((d) => {
        if (isDataRefDomain(d)) {
          return d.data;
        }
        return null;
      }), (x2) => x2);
      if (allData.length === 1 && allData[0] !== null) {
        const domain2 = {
          data: allData[0],
          fields: uniqueDomains.map((d) => d.field),
          ...sort2 ? { sort: sort2 } : {}
        };
        return domain2;
      }
      return { fields: uniqueDomains, ...sort2 ? { sort: sort2 } : {} };
    }
    function getFieldFromDomain(domain2) {
      if (isDataRefDomain(domain2) && isString(domain2.field)) {
        return domain2.field;
      } else if (isDataRefUnionedDomain(domain2)) {
        let field2;
        for (const nonUnionDomain of domain2.fields) {
          if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {
            if (!field2) {
              field2 = nonUnionDomain.field;
            } else if (field2 !== nonUnionDomain.field) {
              warn(FACETED_INDEPENDENT_DIFFERENT_SOURCES);
              return field2;
            }
          }
        }
        warn(FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
        return field2;
      } else if (isFieldRefUnionDomain(domain2)) {
        warn(FACETED_INDEPENDENT_SAME_SOURCE);
        const field2 = domain2.fields[0];
        return isString(field2) ? field2 : void 0;
      }
      return void 0;
    }
    function assembleDomain(model, channel) {
      const scaleComponent = model.component.scales[channel];
      const domains = scaleComponent.get("domains").map((domain2) => {
        if (isDataRefDomain(domain2)) {
          domain2.data = model.lookupDataSource(domain2.data);
        }
        return domain2;
      });
      return mergeDomains(domains);
    }
    function assembleScales(model) {
      if (isLayerModel(model) || isConcatModel(model)) {
        return model.children.reduce((scales2, child) => {
          return scales2.concat(assembleScales(child));
        }, assembleScalesForModel(model));
      } else {
        return assembleScalesForModel(model);
      }
    }
    function assembleScalesForModel(model) {
      return keys(model.component.scales).reduce((scales2, channel) => {
        const scaleComponent = model.component.scales[channel];
        if (scaleComponent.merged) {
          return scales2;
        }
        const scale2 = scaleComponent.combine();
        const { name: name2, type: type2, selectionExtent, domains: _d2, range: _r2, reverse: reverse2, ...otherScaleProps } = scale2;
        const range2 = assembleScaleRange(scale2.range, name2, channel, model);
        const domain2 = assembleDomain(model, channel);
        const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain2) : null;
        scales2.push({
          name: name2,
          type: type2,
          ...domain2 ? { domain: domain2 } : {},
          ...domainRaw ? { domainRaw } : {},
          range: range2,
          ...reverse2 !== void 0 ? { reverse: reverse2 } : {},
          ...otherScaleProps
        });
        return scales2;
      }, []);
    }
    function assembleScaleRange(scaleRange, scaleName, channel, model) {
      if (isXorY(channel)) {
        if (isVgRangeStep(scaleRange)) {
          return {
            step: { signal: `${scaleName}_step` }
          };
        }
      } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {
        return {
          ...scaleRange,
          data: model.lookupDataSource(scaleRange.data)
        };
      }
      return scaleRange;
    }
    class ScaleComponent extends Split {
      constructor(name2, typeWithExplicit) {
        super(
          {},
          // no initial explicit property
          { name: name2 }
          // name as initial implicit property
        );
        this.merged = false;
        this.setWithExplicit("type", typeWithExplicit);
      }
      /**
       * Whether the scale definitely includes zero in the domain
       */
      domainDefinitelyIncludesZero() {
        if (this.get("zero") !== false) {
          return true;
        }
        return some(this.get("domains"), (d) => isArray(d) && d.length === 2 && isNumber$1(d[0]) && d[0] <= 0 && isNumber$1(d[1]) && d[1] >= 0);
      }
    }
    const RANGE_PROPERTIES = ["range", "scheme"];
    function parseUnitScaleRange(model) {
      const localScaleComponents = model.component.scales;
      for (const channel of SCALE_CHANNELS) {
        const localScaleCmpt = localScaleComponents[channel];
        if (!localScaleCmpt) {
          continue;
        }
        const rangeWithExplicit = parseRangeForChannel(channel, model);
        localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
      }
    }
    function getBinStepSignal(model, channel) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef == null ? void 0 : fieldDef.bin) {
        const { bin: bin2, field: field2 } = fieldDef;
        const sizeType = getSizeChannel(channel);
        const sizeSignal = model.getName(sizeType);
        if (isObject(bin2) && bin2.binned && bin2.step !== void 0) {
          return new SignalRefWrapper(() => {
            const scaleName = model.scaleName(channel);
            const binCount = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin2.step}`;
            return `${model.getSignalName(sizeSignal)} / (${binCount})`;
          });
        } else if (isBinning(bin2)) {
          const binSignal = getBinSignalName(model, field2, bin2);
          return new SignalRefWrapper(() => {
            const updatedName = model.getSignalName(binSignal);
            const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
            return `${model.getSignalName(sizeSignal)} / (${binCount})`;
          });
        }
      }
      return void 0;
    }
    function parseRangeForChannel(channel, model) {
      const specifiedScale = model.specifiedScales[channel];
      const { size: size2 } = model;
      const mergedScaleCmpt = model.getScaleComponent(channel);
      const scaleType2 = mergedScaleCmpt.get("type");
      for (const property2 of RANGE_PROPERTIES) {
        if (specifiedScale[property2] !== void 0) {
          const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
          const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
          if (!supportedByScaleType) {
            warn(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
          } else if (channelIncompatability) {
            warn(channelIncompatability);
          } else {
            switch (property2) {
              case "range": {
                const range2 = specifiedScale.range;
                if (isArray(range2)) {
                  if (isXorY(channel)) {
                    return makeExplicit(range2.map((v) => {
                      if (v === "width" || v === "height") {
                        const sizeSignal = model.getName(v);
                        const getSignalName = model.getSignalName.bind(model);
                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                      }
                      return v;
                    }));
                  }
                } else if (isObject(range2)) {
                  return makeExplicit({
                    data: model.requestDataName(DataSourceType.Main),
                    field: range2.field,
                    sort: { op: "min", field: model.vgField(channel) }
                  });
                }
                return makeExplicit(range2);
              }
              case "scheme":
                return makeExplicit(parseScheme(specifiedScale[property2]));
            }
          }
        }
      }
      const sizeChannel = channel === X || channel === "xOffset" ? "width" : "height";
      const sizeValue = size2[sizeChannel];
      if (isStep(sizeValue)) {
        if (isXorY(channel)) {
          if (hasDiscreteDomain(scaleType2)) {
            const step = getPositionStep(sizeValue, model, channel);
            if (step) {
              return makeExplicit({ step });
            }
          } else {
            warn(stepDropped(sizeChannel));
          }
        } else if (isXorYOffset(channel)) {
          const positionChannel = channel === XOFFSET ? "x" : "y";
          const positionScaleCmpt = model.getScaleComponent(positionChannel);
          const positionScaleType = positionScaleCmpt.get("type");
          if (positionScaleType === "band") {
            const step = getOffsetStep(sizeValue, scaleType2);
            if (step) {
              return makeExplicit(step);
            }
          }
        }
      }
      const { rangeMin: rangeMin2, rangeMax: rangeMax2 } = specifiedScale;
      const d = defaultRange(channel, model);
      if ((rangeMin2 !== void 0 || rangeMax2 !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
      scaleTypeSupportProperty(scaleType2, "rangeMin") && isArray(d) && d.length === 2) {
        return makeExplicit([rangeMin2 ?? d[0], rangeMax2 ?? d[1]]);
      }
      return makeImplicit(d);
    }
    function parseScheme(scheme2) {
      if (isExtendedScheme(scheme2)) {
        return {
          scheme: scheme2.name,
          ...omit(scheme2, ["name"])
        };
      }
      return { scheme: scheme2 };
    }
    function fullWidthOrHeightRange(channel, model, scaleType2, { center: center2 } = {}) {
      const sizeType = getSizeChannel(channel);
      const sizeSignal = model.getName(sizeType);
      const getSignalName = model.getSignalName.bind(model);
      if (channel === Y && hasContinuousDomain(scaleType2)) {
        return center2 ? [
          SignalRefWrapper.fromName((name2) => `${getSignalName(name2)}/2`, sizeSignal),
          SignalRefWrapper.fromName((name2) => `-${getSignalName(name2)}/2`, sizeSignal)
        ] : [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return center2 ? [
          SignalRefWrapper.fromName((name2) => `-${getSignalName(name2)}/2`, sizeSignal),
          SignalRefWrapper.fromName((name2) => `${getSignalName(name2)}/2`, sizeSignal)
        ] : [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    function defaultRange(channel, model) {
      const { size: size2, config, mark, encoding } = model;
      const { type: type2 } = getFieldOrDatumDef(encoding[channel]);
      const mergedScaleCmpt = model.getScaleComponent(channel);
      const scaleType2 = mergedScaleCmpt.get("type");
      const { domain: domain2, domainMid } = model.specifiedScales[channel];
      switch (channel) {
        case X:
        case Y: {
          if (contains(["point", "band"], scaleType2)) {
            const positionSize = getDiscretePositionSize(channel, size2, config.view);
            if (isStep(positionSize)) {
              const step = getPositionStep(positionSize, model, channel);
              return { step };
            }
          }
          return fullWidthOrHeightRange(channel, model, scaleType2);
        }
        case XOFFSET:
        case YOFFSET:
          return getOffsetRange(channel, model, scaleType2);
        case SIZE: {
          const zero2 = model.component.scales[channel].get("zero");
          const rangeMin2 = sizeRangeMin(mark, zero2, config);
          const rangeMax2 = sizeRangeMax(mark, size2, model, config);
          if (isContinuousToDiscrete(scaleType2)) {
            return interpolateRange(rangeMin2, rangeMax2, defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel));
          } else {
            return [rangeMin2, rangeMax2];
          }
        }
        case THETA:
          return [0, Math.PI * 2];
        case ANGLE:
          return [0, 360];
        case RADIUS: {
          return [
            0,
            new SignalRefWrapper(() => {
              const w2 = model.getSignalName("width");
              const h2 = model.getSignalName("height");
              return `min(${w2},${h2})/2`;
            })
          ];
        }
        case STROKEWIDTH:
          return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
        case STROKEDASH:
          return [
            // TODO: add this to Vega's config.range?
            [1, 0],
            [4, 2],
            [2, 1],
            [1, 1],
            [1, 2, 4, 2]
          ];
        case SHAPE:
          return "symbol";
        case COLOR:
        case FILL:
        case STROKE:
          if (scaleType2 === "ordinal") {
            return type2 === "nominal" ? "category" : "ordinal";
          } else {
            if (domainMid !== void 0) {
              return "diverging";
            } else {
              return mark === "rect" || mark === "geoshape" ? "heatmap" : "ramp";
            }
          }
        case OPACITY:
        case FILLOPACITY:
        case STROKEOPACITY:
          return [config.scale.minOpacity, config.scale.maxOpacity];
      }
    }
    function getPositionStep(step, model, channel) {
      const { encoding } = model;
      const mergedScaleCmpt = model.getScaleComponent(channel);
      const offsetChannel = getOffsetScaleChannel(channel);
      const offsetDef = encoding[offsetChannel];
      const stepFor = getStepFor({ step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete$1(offsetDef.type) });
      if (stepFor === "offset" && channelHasFieldOrDatum(encoding, offsetChannel)) {
        const offsetScaleCmpt = model.getScaleComponent(offsetChannel);
        const offsetScaleName = model.scaleName(offsetChannel);
        let stepCount = `domain('${offsetScaleName}').length`;
        if (offsetScaleCmpt.get("type") === "band") {
          const offsetPaddingInner = offsetScaleCmpt.get("paddingInner") ?? offsetScaleCmpt.get("padding") ?? 0;
          const offsetPaddingOuter = offsetScaleCmpt.get("paddingOuter") ?? offsetScaleCmpt.get("padding") ?? 0;
          stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;
        }
        const paddingInner2 = mergedScaleCmpt.get("paddingInner") ?? mergedScaleCmpt.get("padding");
        return {
          signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner2)})`
        };
      } else {
        return step.step;
      }
    }
    function getOffsetStep(step, offsetScaleType) {
      const stepFor = getStepFor({ step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType) });
      if (stepFor === "offset") {
        return { step: step.step };
      }
      return void 0;
    }
    function getOffsetRange(channel, model, offsetScaleType) {
      const positionChannel = channel === XOFFSET ? "x" : "y";
      const positionScaleCmpt = model.getScaleComponent(positionChannel);
      if (!positionScaleCmpt) {
        return fullWidthOrHeightRange(positionChannel, model, offsetScaleType, { center: true });
      }
      const positionScaleType = positionScaleCmpt.get("type");
      const positionScaleName = model.scaleName(positionChannel);
      const { markDef, config } = model;
      if (positionScaleType === "band") {
        const size2 = getDiscretePositionSize(positionChannel, model.size, model.config.view);
        if (isStep(size2)) {
          const step = getOffsetStep(size2, offsetScaleType);
          if (step) {
            return step;
          }
        }
        return [0, { signal: `bandwidth('${positionScaleName}')` }];
      } else {
        const positionDef = model.encoding[positionChannel];
        if (isFieldDef(positionDef) && positionDef.timeUnit) {
          const duration = durationExpr(positionDef.timeUnit, (expr2) => `scale('${positionScaleName}', ${expr2})`);
          const padding2 = model.config.scale.bandWithNestedOffsetPaddingInner;
          const bandPositionOffset = getBandPosition({
            fieldDef: positionDef,
            markDef,
            config
          }) - 0.5;
          const bandPositionOffsetExpr = bandPositionOffset !== 0 ? ` + ${bandPositionOffset}` : "";
          if (padding2) {
            const startRatio = isSignalRef(padding2) ? `${padding2.signal}/2` + bandPositionOffsetExpr : `${padding2 / 2 + bandPositionOffset}`;
            const endRatio = isSignalRef(padding2) ? `(1 - ${padding2.signal}/2)` + bandPositionOffsetExpr : `${1 - padding2 / 2 + bandPositionOffset}`;
            return [{ signal: `${startRatio} * (${duration})` }, { signal: `${endRatio} * (${duration})` }];
          }
          return [0, { signal: duration }];
        }
        return never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);
      }
    }
    function getDiscretePositionSize(channel, size2, viewConfig) {
      const sizeChannel = channel === X ? "width" : "height";
      const sizeValue = size2[sizeChannel];
      if (sizeValue) {
        return sizeValue;
      }
      return getViewConfigDiscreteSize(viewConfig, sizeChannel);
    }
    function defaultContinuousToDiscreteCount(scaleType2, config, domain2, channel) {
      switch (scaleType2) {
        case "quantile":
          return config.scale.quantileCount;
        case "quantize":
          return config.scale.quantizeCount;
        case "threshold":
          if (domain2 !== void 0 && isArray(domain2)) {
            return domain2.length + 1;
          } else {
            warn(domainRequiredForThresholdScale(channel));
            return 3;
          }
      }
    }
    function interpolateRange(rangeMin2, rangeMax2, cardinality) {
      const f = () => {
        const rMax = signalOrStringValue(rangeMax2);
        const rMin = signalOrStringValue(rangeMin2);
        const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
        return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
      };
      if (isSignalRef(rangeMax2)) {
        return new SignalRefWrapper(f);
      } else {
        return { signal: f() };
      }
    }
    function sizeRangeMin(mark, zero2, config) {
      if (zero2) {
        if (isSignalRef(zero2)) {
          return { signal: `${zero2.signal} ? 0 : ${sizeRangeMin(mark, false, config)}` };
        } else {
          return 0;
        }
      }
      switch (mark) {
        case "bar":
        case "tick":
          return config.scale.minBandSize;
        case "line":
        case "trail":
        case "rule":
          return config.scale.minStrokeWidth;
        case "text":
          return config.scale.minFontSize;
        case "point":
        case "square":
        case "circle":
          return config.scale.minSize;
      }
      throw new Error(incompatibleChannel("size", mark));
    }
    const MAX_SIZE_RANGE_STEP_RATIO = 0.95;
    function sizeRangeMax(mark, size2, model, config) {
      const xyStepSignals = {
        x: getBinStepSignal(model, "x"),
        y: getBinStepSignal(model, "y")
      };
      switch (mark) {
        case "bar":
        case "tick": {
          if (config.scale.maxBandSize !== void 0) {
            return config.scale.maxBandSize;
          }
          const min2 = minXYStep(size2, xyStepSignals, config.view);
          if (isNumber$1(min2)) {
            return min2 - 1;
          } else {
            return new SignalRefWrapper(() => `${min2.signal} - 1`);
          }
        }
        case "line":
        case "trail":
        case "rule":
          return config.scale.maxStrokeWidth;
        case "text":
          return config.scale.maxFontSize;
        case "point":
        case "square":
        case "circle": {
          if (config.scale.maxSize) {
            return config.scale.maxSize;
          }
          const pointStep = minXYStep(size2, xyStepSignals, config.view);
          if (isNumber$1(pointStep)) {
            return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
          } else {
            return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
          }
        }
      }
      throw new Error(incompatibleChannel("size", mark));
    }
    function minXYStep(size2, xyStepSignals, viewConfig) {
      const widthStep = isStep(size2.width) ? size2.width.step : getViewConfigDiscreteStep(viewConfig, "width");
      const heightStep = isStep(size2.height) ? size2.height.step : getViewConfigDiscreteStep(viewConfig, "height");
      if (xyStepSignals.x || xyStepSignals.y) {
        return new SignalRefWrapper(() => {
          const exprs = [
            xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
            xyStepSignals.y ? xyStepSignals.y.signal : heightStep
          ];
          return `min(${exprs.join(", ")})`;
        });
      }
      return Math.min(widthStep, heightStep);
    }
    function parseScaleProperty(model, property2) {
      if (isUnitModel(model)) {
        parseUnitScaleProperty(model, property2);
      } else {
        parseNonUnitScaleProperty(model, property2);
      }
    }
    function parseUnitScaleProperty(model, property2) {
      const localScaleComponents = model.component.scales;
      const { config, encoding, markDef, specifiedScales } = model;
      for (const channel of keys(localScaleComponents)) {
        const specifiedScale = specifiedScales[channel];
        const localScaleCmpt = localScaleComponents[channel];
        const mergedScaleCmpt = model.getScaleComponent(channel);
        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
        const specifiedValue = specifiedScale[property2];
        const scaleType2 = mergedScaleCmpt.get("type");
        const scalePadding = mergedScaleCmpt.get("padding");
        const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
        const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
        const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
        if (specifiedValue !== void 0) {
          if (!supportedByScaleType) {
            warn(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
          } else if (channelIncompatability) {
            warn(channelIncompatability);
          }
        }
        if (supportedByScaleType && channelIncompatability === void 0) {
          if (specifiedValue !== void 0) {
            const timeUnit = fieldOrDatumDef["timeUnit"];
            const type2 = fieldOrDatumDef.type;
            switch (property2) {
              case "domainMax":
              case "domainMin":
                if (isDateTime(specifiedScale[property2]) || type2 === "temporal" || timeUnit) {
                  localScaleCmpt.set(property2, { signal: valueExpr(specifiedScale[property2], { type: type2, timeUnit }) }, true);
                } else {
                  localScaleCmpt.set(property2, specifiedScale[property2], true);
                }
                break;
              default:
                localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
            }
          } else {
            const value2 = property2 in scaleRules ? scaleRules[property2]({
              model,
              channel,
              fieldOrDatumDef,
              scaleType: scaleType2,
              scalePadding,
              scalePaddingInner,
              domain: specifiedScale.domain,
              domainMin: specifiedScale.domainMin,
              domainMax: specifiedScale.domainMax,
              markDef,
              config,
              hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),
              hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]
            }) : config.scale[property2];
            if (value2 !== void 0) {
              localScaleCmpt.set(property2, value2, false);
            }
          }
        }
      }
    }
    const scaleRules = {
      bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
      interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),
      nice: ({ scaleType: scaleType2, channel, domain: domain2, domainMin, domainMax, fieldOrDatumDef }) => nice(scaleType2, channel, domain2, domainMin, domainMax, fieldOrDatumDef),
      padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
      paddingInner: ({ scalePadding, channel, markDef, scaleType: scaleType2, config, hasNestedOffsetScale }) => paddingInner(scalePadding, channel, markDef.type, scaleType2, config.scale, hasNestedOffsetScale),
      paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, scalePaddingInner, config, hasNestedOffsetScale }) => paddingOuter(scalePadding, channel, scaleType2, scalePaddingInner, config.scale, hasNestedOffsetScale),
      reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
        const sort2 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
        return reverse(scaleType2, sort2, channel, config.scale);
      },
      zero: ({ channel, fieldOrDatumDef, domain: domain2, markDef, scaleType: scaleType2, config, hasSecondaryRangeChannel }) => zero(channel, fieldOrDatumDef, domain2, markDef, scaleType2, config.scale, hasSecondaryRangeChannel)
    };
    function parseScaleRange(model) {
      if (isUnitModel(model)) {
        parseUnitScaleRange(model);
      } else {
        parseNonUnitScaleProperty(model, "range");
      }
    }
    function parseNonUnitScaleProperty(model, property2) {
      const localScaleComponents = model.component.scales;
      for (const child of model.children) {
        if (property2 === "range") {
          parseScaleRange(child);
        } else {
          parseScaleProperty(child, property2);
        }
      }
      for (const channel of keys(localScaleComponents)) {
        let valueWithExplicit;
        for (const child of model.children) {
          const childComponent = child.component.scales[channel];
          if (childComponent) {
            const childValueWithExplicit = childComponent.getWithExplicit(property2);
            valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
              switch (property2) {
                case "range":
                  if (v1.step && v2.step) {
                    return v1.step - v2.step;
                  }
                  return 0;
              }
              return 0;
            }));
          }
        }
        localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
      }
    }
    function bins(model, fieldDef) {
      const bin2 = fieldDef.bin;
      if (isBinning(bin2)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin2);
        return new SignalRefWrapper(() => {
          return model.getSignalName(binSignal);
        });
      } else if (isBinned(bin2) && isBinParams(bin2) && bin2.step !== void 0) {
        return {
          step: bin2.step
        };
      }
      return void 0;
    }
    function interpolate(channel, type2) {
      if (contains([COLOR, FILL, STROKE], channel) && type2 !== "nominal") {
        return "hcl";
      }
      return void 0;
    }
    function nice(scaleType2, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {
      var _a2;
      if (((_a2 = getFieldDef(fieldOrDatumDef)) == null ? void 0 : _a2.bin) || isArray(specifiedDomain) || domainMax != null || domainMin != null || contains([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
        return void 0;
      }
      return isXorY(channel) ? true : void 0;
    }
    function padding(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
      if (isXorY(channel)) {
        if (isContinuousToContinuous(scaleType2)) {
          if (scaleConfig.continuousPadding !== void 0) {
            return scaleConfig.continuousPadding;
          }
          const { type: type2, orient: orient2 } = markDef;
          if (type2 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
            if (orient2 === "vertical" && channel === "x" || orient2 === "horizontal" && channel === "y") {
              return barConfig.continuousBandSize;
            }
          }
        }
        if (scaleType2 === ScaleType.POINT) {
          return scaleConfig.pointPadding;
        }
      }
      return void 0;
    }
    function paddingInner(paddingValue, channel, mark, scaleType2, scaleConfig, hasNestedOffsetScale = false) {
      if (paddingValue !== void 0) {
        return void 0;
      }
      if (isXorY(channel)) {
        const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, bandWithNestedOffsetPaddingInner } = scaleConfig;
        if (hasNestedOffsetScale) {
          return bandWithNestedOffsetPaddingInner;
        }
        return getFirstDefined(bandPaddingInner, mark === "bar" ? barBandPaddingInner : rectBandPaddingInner);
      } else if (isXorYOffset(channel)) {
        if (scaleType2 === ScaleType.BAND) {
          return scaleConfig.offsetBandPaddingInner;
        }
      }
      return void 0;
    }
    function paddingOuter(paddingValue, channel, scaleType2, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {
      if (paddingValue !== void 0) {
        return void 0;
      }
      if (isXorY(channel)) {
        const { bandPaddingOuter, bandWithNestedOffsetPaddingOuter } = scaleConfig;
        if (hasNestedOffsetScale) {
          return bandWithNestedOffsetPaddingOuter;
        }
        if (scaleType2 === ScaleType.BAND) {
          return getFirstDefined(
            bandPaddingOuter,
            /* By default, paddingOuter is paddingInner / 2. The reason is that
              size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
              and we want the width/height to be integer by default.
              Note that step (by default) and cardinality are integers.) */
            isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2
          );
        }
      } else if (isXorYOffset(channel)) {
        if (scaleType2 === ScaleType.POINT) {
          return 0.5;
        } else if (scaleType2 === ScaleType.BAND) {
          return scaleConfig.offsetBandPaddingOuter;
        }
      }
      return void 0;
    }
    function reverse(scaleType2, sort2, channel, scaleConfig) {
      if (channel === "x" && scaleConfig.xReverse !== void 0) {
        if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
          if (isSignalRef(scaleConfig.xReverse)) {
            return { signal: `!${scaleConfig.xReverse.signal}` };
          } else {
            return !scaleConfig.xReverse;
          }
        }
        return scaleConfig.xReverse;
      }
      if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
        return true;
      }
      return void 0;
    }
    function zero(channel, fieldDef, specifiedDomain, markDef, scaleType2, scaleConfig, hasSecondaryRangeChannel) {
      const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
      if (hasCustomDomain) {
        if (hasContinuousDomain(scaleType2)) {
          if (isArray(specifiedDomain)) {
            const first = specifiedDomain[0];
            const last2 = specifiedDomain[specifiedDomain.length - 1];
            if (isNumber$1(first) && first <= 0 && isNumber$1(last2) && last2 >= 0) {
              return true;
            }
          }
          return false;
        }
      }
      if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
        return true;
      }
      if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
        const { orient: orient2, type: type2 } = markDef;
        if (contains(["bar", "area", "line", "trail"], type2)) {
          if (orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x") {
            return false;
          }
        }
        if (contains(["bar", "area"], type2) && !hasSecondaryRangeChannel) {
          return true;
        }
        return scaleConfig == null ? void 0 : scaleConfig.zero;
      }
      return false;
    }
    function scaleType(specifiedScale, channel, fieldDef, mark, hasNestedOffsetScale = false) {
      const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);
      const { type: type2 } = specifiedScale;
      if (!isScaleChannel(channel)) {
        return null;
      }
      if (type2 !== void 0) {
        if (!channelSupportScaleType(channel, type2)) {
          warn(scaleTypeNotWorkWithChannel(channel, type2, defaultScaleType));
          return defaultScaleType;
        }
        if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type2, fieldDef.type)) {
          warn(scaleTypeNotWorkWithFieldDef(type2, defaultScaleType));
          return defaultScaleType;
        }
        return type2;
      }
      return defaultScaleType;
    }
    function defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {
      var _a2;
      switch (fieldDef.type) {
        case "nominal":
        case "ordinal": {
          if (isColorChannel(channel) || rangeType(channel) === "discrete") {
            if (channel === "shape" && fieldDef.type === "ordinal") {
              warn(discreteChannelCannotEncode(channel, "ordinal"));
            }
            return "ordinal";
          }
          if (isXorY(channel) || isXorYOffset(channel)) {
            if (contains(["rect", "bar", "image", "rule"], mark.type)) {
              return "band";
            }
            if (hasNestedOffsetScale) {
              return "band";
            }
          } else if (mark.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
            return "band";
          }
          const dimensionSize = mark[getSizeChannel(channel)];
          if (isRelativeBandSize(dimensionSize)) {
            return "band";
          }
          if (isPositionFieldOrDatumDef(fieldDef) && ((_a2 = fieldDef.axis) == null ? void 0 : _a2.tickBand)) {
            return "band";
          }
          return "point";
        }
        case "temporal":
          if (isColorChannel(channel)) {
            return "time";
          } else if (rangeType(channel) === "discrete") {
            warn(discreteChannelCannotEncode(channel, "temporal"));
            return "ordinal";
          } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
            return "utc";
          }
          return "time";
        case "quantitative":
          if (isColorChannel(channel)) {
            if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
              return "bin-ordinal";
            }
            return "linear";
          } else if (rangeType(channel) === "discrete") {
            warn(discreteChannelCannotEncode(channel, "quantitative"));
            return "ordinal";
          }
          return "linear";
        case "geojson":
          return void 0;
      }
      throw new Error(invalidFieldType(fieldDef.type));
    }
    function parseScales(model, { ignoreRange } = {}) {
      parseScaleCore(model);
      parseScaleDomain(model);
      for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
        parseScaleProperty(model, prop);
      }
      if (!ignoreRange) {
        parseScaleRange(model);
      }
    }
    function parseScaleCore(model) {
      if (isUnitModel(model)) {
        model.component.scales = parseUnitScaleCore(model);
      } else {
        model.component.scales = parseNonUnitScaleCore(model);
      }
    }
    function parseUnitScaleCore(model) {
      const { encoding, mark, markDef } = model;
      const scaleComponents = {};
      for (const channel of SCALE_CHANNELS) {
        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
        if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
          continue;
        }
        let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
        if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
          specifiedScale ?? (specifiedScale = {});
          const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);
          const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);
          scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {
            value: sType,
            explicit: specifiedScale.type === sType
          });
        }
      }
      return scaleComponents;
    }
    const scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
    function parseNonUnitScaleCore(model) {
      var _a2;
      const scaleComponents = model.component.scales = {};
      const scaleTypeWithExplicitIndex = {};
      const resolve2 = model.component.resolve;
      for (const child of model.children) {
        parseScaleCore(child);
        for (const channel of keys(child.component.scales)) {
          (_a2 = resolve2.scale)[channel] ?? (_a2[channel] = defaultScaleResolve(channel, model));
          if (resolve2.scale[channel] === "shared") {
            const explicitScaleType = scaleTypeWithExplicitIndex[channel];
            const childScaleType = child.component.scales[channel].getWithExplicit("type");
            if (explicitScaleType) {
              if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
                scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
              } else {
                resolve2.scale[channel] = "independent";
                delete scaleTypeWithExplicitIndex[channel];
              }
            } else {
              scaleTypeWithExplicitIndex[channel] = childScaleType;
            }
          }
        }
      }
      for (const channel of keys(scaleTypeWithExplicitIndex)) {
        const name2 = model.scaleName(channel, true);
        const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
        scaleComponents[channel] = new ScaleComponent(name2, typeWithExplicit);
        for (const child of model.children) {
          const childScale = child.component.scales[channel];
          if (childScale) {
            child.renameScale(childScale.get("name"), name2);
            childScale.merged = true;
          }
        }
      }
      return scaleComponents;
    }
    class NameMap {
      constructor() {
        this.nameMap = {};
      }
      rename(oldName, newName) {
        this.nameMap[oldName] = newName;
      }
      has(name2) {
        return this.nameMap[name2] !== void 0;
      }
      get(name2) {
        while (this.nameMap[name2] && name2 !== this.nameMap[name2]) {
          name2 = this.nameMap[name2];
        }
        return name2;
      }
    }
    function isUnitModel(model) {
      return (model == null ? void 0 : model.type) === "unit";
    }
    function isFacetModel(model) {
      return (model == null ? void 0 : model.type) === "facet";
    }
    function isConcatModel(model) {
      return (model == null ? void 0 : model.type) === "concat";
    }
    function isLayerModel(model) {
      return (model == null ? void 0 : model.type) === "layer";
    }
    class Model {
      constructor(spec, type2, parent, parentGivenName, config, resolve2, view) {
        this.type = type2;
        this.parent = parent;
        this.config = config;
        this.correctDataNames = (mark) => {
          var _a2, _b, _c2;
          if ((_a2 = mark.from) == null ? void 0 : _a2.data) {
            mark.from.data = this.lookupDataSource(mark.from.data);
          }
          if ((_c2 = (_b = mark.from) == null ? void 0 : _b.facet) == null ? void 0 : _c2.data) {
            mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);
          }
          return mark;
        };
        this.parent = parent;
        this.config = config;
        this.view = replaceExprRef(view);
        this.name = spec.name ?? parentGivenName;
        this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : void 0;
        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
        this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
        this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
        this.data = spec.data;
        this.description = spec.description;
        this.transforms = normalizeTransform(spec.transform ?? []);
        this.layout = type2 === "layer" || type2 === "unit" ? {} : extractCompositionLayout(spec, type2, config);
        this.component = {
          data: {
            sources: parent ? parent.component.data.sources : [],
            outputNodes: parent ? parent.component.data.outputNodes : {},
            outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
            // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
            isFaceted: isFacetSpec(spec) || (parent == null ? void 0 : parent.component.data.isFaceted) && spec.data === void 0
          },
          layoutSize: new Split(),
          layoutHeaders: { row: {}, column: {}, facet: {} },
          mark: null,
          resolve: {
            scale: {},
            axis: {},
            legend: {},
            ...resolve2 ? duplicate(resolve2) : {}
          },
          selection: null,
          scales: null,
          projection: null,
          axes: {},
          legends: {}
        };
      }
      get width() {
        return this.getSizeSignalRef("width");
      }
      get height() {
        return this.getSizeSignalRef("height");
      }
      parse() {
        this.parseScale();
        this.parseLayoutSize();
        this.renameTopLevelLayoutSizeSignal();
        this.parseSelections();
        this.parseProjection();
        this.parseData();
        this.parseAxesAndHeaders();
        this.parseLegends();
        this.parseMarkGroup();
      }
      parseScale() {
        parseScales(this);
      }
      parseProjection() {
        parseProjection(this);
      }
      /**
       * Rename top-level spec's size to be just width / height, ignoring model name.
       * This essentially merges the top-level spec's width/height signals with the width/height signals
       * to help us reduce redundant signals declaration.
       */
      renameTopLevelLayoutSizeSignal() {
        if (this.getName("width") !== "width") {
          this.renameSignal(this.getName("width"), "width");
        }
        if (this.getName("height") !== "height") {
          this.renameSignal(this.getName("height"), "height");
        }
      }
      parseLegends() {
        parseLegend(this);
      }
      assembleEncodeFromView(view) {
        const { style: _, ...baseView } = view;
        const e3 = {};
        for (const property2 of keys(baseView)) {
          const value2 = baseView[property2];
          if (value2 !== void 0) {
            e3[property2] = signalOrValueRef(value2);
          }
        }
        return e3;
      }
      assembleGroupEncodeEntry(isTopLevel) {
        let encodeEntry2 = {};
        if (this.view) {
          encodeEntry2 = this.assembleEncodeFromView(this.view);
        }
        if (!isTopLevel) {
          if (this.description) {
            encodeEntry2["description"] = signalOrValueRef(this.description);
          }
          if (this.type === "unit" || this.type === "layer") {
            return {
              width: this.getSizeSignalRef("width"),
              height: this.getSizeSignalRef("height"),
              ...encodeEntry2 ?? {}
            };
          }
        }
        return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
      }
      assembleLayout() {
        if (!this.layout) {
          return void 0;
        }
        const { spacing, ...layout } = this.layout;
        const { component, config } = this;
        const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
        return {
          padding: spacing,
          ...this.assembleDefaultLayout(),
          ...layout,
          ...titleBand ? { titleBand } : {}
        };
      }
      assembleDefaultLayout() {
        return {};
      }
      assembleHeaderMarks() {
        const { layoutHeaders: layoutHeaders2 } = this.component;
        let headerMarks = [];
        for (const channel of FACET_CHANNELS) {
          if (layoutHeaders2[channel].title) {
            headerMarks.push(assembleTitleGroup(this, channel));
          }
        }
        for (const channel of HEADER_CHANNELS) {
          headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
        }
        return headerMarks;
      }
      assembleAxes() {
        return assembleAxes(this.component.axes, this.config);
      }
      assembleLegends() {
        return assembleLegends(this);
      }
      assembleProjections() {
        return assembleProjections(this);
      }
      assembleTitle() {
        const { encoding, ...titleNoEncoding } = this.title ?? {};
        const title2 = {
          ...extractTitleConfig(this.config.title).nonMarkTitleProperties,
          ...titleNoEncoding,
          ...encoding ? { encode: { update: encoding } } : {}
        };
        if (title2.text) {
          if (contains(["unit", "layer"], this.type)) {
            if (contains(["middle", void 0], title2.anchor)) {
              title2.frame ?? (title2.frame = "group");
            }
          } else {
            title2.anchor ?? (title2.anchor = "start");
          }
          return isEmpty(title2) ? void 0 : title2;
        }
        return void 0;
      }
      /**
       * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
       */
      assembleGroup(signals = []) {
        const group2 = {};
        signals = signals.concat(this.assembleSignals());
        if (signals.length > 0) {
          group2.signals = signals;
        }
        const layout = this.assembleLayout();
        if (layout) {
          group2.layout = layout;
        }
        group2.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
        const scales2 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
        if (scales2.length > 0) {
          group2.scales = scales2;
        }
        const axes = this.assembleAxes();
        if (axes.length > 0) {
          group2.axes = axes;
        }
        const legends = this.assembleLegends();
        if (legends.length > 0) {
          group2.legends = legends;
        }
        return group2;
      }
      getName(text2) {
        return varName((this.name ? `${this.name}_` : "") + text2);
      }
      getDataName(type2) {
        return this.getName(DataSourceType[type2].toLowerCase());
      }
      /**
       * Request a data source name for the given data source type and mark that data source as required.
       * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
       * You can lookup the correct dataset name in assemble with `lookupDataSource`.
       */
      requestDataName(name2) {
        const fullName = this.getDataName(name2);
        const refCounts = this.component.data.outputNodeRefCounts;
        refCounts[fullName] = (refCounts[fullName] || 0) + 1;
        return fullName;
      }
      getSizeSignalRef(layoutSizeType) {
        if (isFacetModel(this.parent)) {
          const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
          const channel = getPositionScaleChannel(sizeType);
          const scaleComponent = this.component.scales[channel];
          if (scaleComponent && !scaleComponent.merged) {
            const type2 = scaleComponent.get("type");
            const range2 = scaleComponent.get("range");
            if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
              const scaleName = scaleComponent.get("name");
              const domain2 = assembleDomain(this, channel);
              const field2 = getFieldFromDomain(domain2);
              if (field2) {
                const fieldRef2 = vgField({ aggregate: "distinct", field: field2 }, { expr: "datum" });
                return {
                  signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
                };
              } else {
                warn(unknownField(channel));
                return null;
              }
            }
          }
        }
        return {
          signal: this.signalNameMap.get(this.getName(layoutSizeType))
        };
      }
      /**
       * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
       */
      lookupDataSource(name2) {
        const node = this.component.data.outputNodes[name2];
        if (!node) {
          return name2;
        }
        return node.getSource();
      }
      getSignalName(oldSignalName) {
        return this.signalNameMap.get(oldSignalName);
      }
      renameSignal(oldName, newName) {
        this.signalNameMap.rename(oldName, newName);
      }
      renameScale(oldName, newName) {
        this.scaleNameMap.rename(oldName, newName);
      }
      renameProjection(oldName, newName) {
        this.projectionNameMap.rename(oldName, newName);
      }
      /**
       * @return scale name for a given channel after the scale has been parsed and named.
       */
      scaleName(originalScaleName, parse2) {
        if (parse2) {
          return this.getName(originalScaleName);
        }
        if (
          // If there is a scale for the channel, there should be a local scale component for it
          isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || // in the scale name map (the scale get merged by its parent)
          this.scaleNameMap.has(this.getName(originalScaleName))
        ) {
          return this.scaleNameMap.get(this.getName(originalScaleName));
        }
        return void 0;
      }
      /**
       * @return projection name after the projection has been parsed and named.
       */
      projectionName(parse2) {
        if (parse2) {
          return this.getName("projection");
        }
        if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
          return this.projectionNameMap.get(this.getName("projection"));
        }
        return void 0;
      }
      /**
       * Traverse a model's hierarchy to get the scale component for a particular channel.
       */
      getScaleComponent(channel) {
        if (!this.component.scales) {
          throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
        }
        const localScaleComponent = this.component.scales[channel];
        if (localScaleComponent && !localScaleComponent.merged) {
          return localScaleComponent;
        }
        return this.parent ? this.parent.getScaleComponent(channel) : void 0;
      }
      /**
       * Traverse a model's hierarchy to get a particular selection component.
       */
      getSelectionComponent(variableName, origName) {
        let sel = this.component.selection[variableName];
        if (!sel && this.parent) {
          sel = this.parent.getSelectionComponent(variableName, origName);
        }
        if (!sel) {
          throw new Error(selectionNotFound(origName));
        }
        return sel;
      }
      /**
       * Returns true if the model has a signalRef for an axis orient.
       */
      hasAxisOrientSignalRef() {
        var _a2, _b;
        return ((_a2 = this.component.axes.x) == null ? void 0 : _a2.some((a2) => a2.hasOrientSignalRef())) || ((_b = this.component.axes.y) == null ? void 0 : _b.some((a2) => a2.hasOrientSignalRef()));
      }
    }
    class ModelWithField extends Model {
      /** Get "field" reference for Vega */
      vgField(channel, opt = {}) {
        const fieldDef = this.fieldDef(channel);
        if (!fieldDef) {
          return void 0;
        }
        return vgField(fieldDef, opt);
      }
      reduceFieldDef(f, init2) {
        return reduce(this.getMapping(), (acc, cd, c2) => {
          const fieldDef = getFieldDef(cd);
          if (fieldDef) {
            return f(acc, fieldDef, c2);
          }
          return acc;
        }, init2);
      }
      forEachFieldDef(f, t4) {
        forEach(this.getMapping(), (cd, c2) => {
          const fieldDef = getFieldDef(cd);
          if (fieldDef) {
            f(fieldDef, c2);
          }
        }, t4);
      }
    }
    class DensityTransformNode extends DataFlowNode {
      clone() {
        return new DensityTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const specifiedAs = this.transform.as ?? [void 0, void 0];
        this.transform.as = [specifiedAs[0] ?? "value", specifiedAs[1] ?? "density"];
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `DensityTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { density, ...rest } = this.transform;
        const result = {
          type: "kde",
          field: density,
          ...rest
        };
        if (this.transform.groupby) {
          result.resolve = "shared";
        }
        return result;
      }
    }
    class ExtentTransformNode extends DataFlowNode {
      clone() {
        return new ExtentTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.extent]);
      }
      producedFields() {
        return /* @__PURE__ */ new Set([]);
      }
      hash() {
        return `ExtentTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { extent: extent2, param: param2 } = this.transform;
        const result = {
          type: "extent",
          field: extent2,
          signal: param2
        };
        return result;
      }
    }
    class FilterInvalidNode extends DataFlowNode {
      clone() {
        return new FilterInvalidNode(null, { ...this.filter });
      }
      constructor(parent, filter2) {
        super(parent);
        this.filter = filter2;
      }
      static make(parent, model) {
        const { config, mark, markDef } = model;
        const invalid = getMarkPropOrConfig("invalid", markDef, config);
        if (invalid !== "filter") {
          return null;
        }
        const filter2 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
          const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
          if (scaleComponent) {
            const scaleType2 = scaleComponent.get("type");
            if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark)) {
              aggregator[fieldDef.field] = fieldDef;
            }
          }
          return aggregator;
        }, {});
        if (!keys(filter2).length) {
          return null;
        }
        return new FilterInvalidNode(parent, filter2);
      }
      dependentFields() {
        return new Set(keys(this.filter));
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `FilterInvalid ${hash(this.filter)}`;
      }
      /**
       * Create the VgTransforms for each of the filtered fields.
       */
      assemble() {
        const filters2 = keys(this.filter).reduce((vegaFilters, field2) => {
          const fieldDef = this.filter[field2];
          const ref2 = vgField(fieldDef, { expr: "datum" });
          if (fieldDef !== null) {
            if (fieldDef.type === "temporal") {
              vegaFilters.push(`(isDate(${ref2}) || (isValid(${ref2}) && isFinite(+${ref2})))`);
            } else if (fieldDef.type === "quantitative") {
              vegaFilters.push(`isValid(${ref2})`);
              vegaFilters.push(`isFinite(+${ref2})`);
            } else
              ;
          }
          return vegaFilters;
        }, []);
        return filters2.length > 0 ? {
          type: "filter",
          expr: filters2.join(" && ")
        } : null;
      }
    }
    class FlattenTransformNode extends DataFlowNode {
      clone() {
        return new FlattenTransformNode(this.parent, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const { flatten: flatten2, as = [] } = this.transform;
        this.transform.as = flatten2.map((f, i) => as[i] ?? f);
      }
      dependentFields() {
        return new Set(this.transform.flatten);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FlattenTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { flatten: fields, as } = this.transform;
        const result = {
          type: "flatten",
          fields,
          as
        };
        return result;
      }
    }
    class FoldTransformNode extends DataFlowNode {
      clone() {
        return new FoldTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const specifiedAs = this.transform.as ?? [void 0, void 0];
        this.transform.as = [specifiedAs[0] ?? "key", specifiedAs[1] ?? "value"];
      }
      dependentFields() {
        return new Set(this.transform.fold);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FoldTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { fold, as } = this.transform;
        const result = {
          type: "fold",
          fields: fold,
          as
        };
        return result;
      }
    }
    class GeoJSONNode extends DataFlowNode {
      clone() {
        return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
      }
      static parseAll(parent, model) {
        if (model.component.projection && !model.component.projection.isFit) {
          return parent;
        }
        let geoJsonCounter = 0;
        for (const coordinates of [
          [LONGITUDE, LATITUDE],
          [LONGITUDE2, LATITUDE2]
        ]) {
          const pair = coordinates.map((channel) => {
            const def2 = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
          });
          if (pair[0] || pair[1]) {
            parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
          }
        }
        if (model.channelHasField(SHAPE)) {
          const fieldDef = model.typedFieldDef(SHAPE);
          if (fieldDef.type === GEOJSON) {
            parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
          }
        }
        return parent;
      }
      constructor(parent, fields, geojson, signal) {
        super(parent);
        this.fields = fields;
        this.geojson = geojson;
        this.signal = signal;
      }
      dependentFields() {
        const fields = (this.fields ?? []).filter(isString);
        return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...fields]);
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
      }
      assemble() {
        return [
          ...this.geojson ? [
            {
              type: "filter",
              expr: `isValid(datum["${this.geojson}"])`
            }
          ] : [],
          {
            type: "geojson",
            ...this.fields ? { fields: this.fields } : {},
            ...this.geojson ? { geojson: this.geojson } : {},
            signal: this.signal
          }
        ];
      }
    }
    class GeoPointNode extends DataFlowNode {
      clone() {
        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
      }
      constructor(parent, projection2, fields, as) {
        super(parent);
        this.projection = projection2;
        this.fields = fields;
        this.as = as;
      }
      static parseAll(parent, model) {
        if (!model.projectionName()) {
          return parent;
        }
        for (const coordinates of [
          [LONGITUDE, LATITUDE],
          [LONGITUDE2, LATITUDE2]
        ]) {
          const pair = coordinates.map((channel) => {
            const def2 = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? { expr: `${def2.datum}` } : isValueDef(def2) ? { expr: `${def2["value"]}` } : void 0;
          });
          const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
          if (pair[0] || pair[1]) {
            parent = new GeoPointNode(parent, model.projectionName(), pair, [
              model.getName(`x${suffix}`),
              model.getName(`y${suffix}`)
            ]);
          }
        }
        return parent;
      }
      dependentFields() {
        return new Set(this.fields.filter(isString));
      }
      producedFields() {
        return new Set(this.as);
      }
      hash() {
        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
      }
      assemble() {
        return {
          type: "geopoint",
          projection: this.projection,
          fields: this.fields,
          as: this.as
        };
      }
    }
    class ImputeNode extends DataFlowNode {
      clone() {
        return new ImputeNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
      }
      producedFields() {
        return /* @__PURE__ */ new Set([this.transform.impute]);
      }
      processSequence(keyvals) {
        const { start: start2 = 0, stop: stop2, step } = keyvals;
        const result = [start2, stop2, ...step ? [step] : []].join(",");
        return { signal: `sequence(${result})` };
      }
      static makeFromTransform(parent, imputeTransform) {
        return new ImputeNode(parent, imputeTransform);
      }
      static makeFromEncoding(parent, model) {
        const encoding = model.encoding;
        const xDef = encoding.x;
        const yDef = encoding.y;
        if (isFieldDef(xDef) && isFieldDef(yDef)) {
          const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
          if (imputedChannel === void 0) {
            return void 0;
          }
          const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
          const { method: method2, value: value2, frame: frame2, keyvals } = imputedChannel.impute;
          const groupbyFields = pathGroupingFields(model.mark, encoding);
          return new ImputeNode(parent, {
            impute: imputedChannel.field,
            key: keyChannel.field,
            ...method2 ? { method: method2 } : {},
            ...value2 !== void 0 ? { value: value2 } : {},
            ...frame2 ? { frame: frame2 } : {},
            ...keyvals !== void 0 ? { keyvals } : {},
            ...groupbyFields.length ? { groupby: groupbyFields } : {}
          });
        }
        return null;
      }
      hash() {
        return `Impute ${hash(this.transform)}`;
      }
      assemble() {
        const { impute, key: key2, keyvals, method: method2, groupby, value: value2, frame: frame2 = [null, null] } = this.transform;
        const imputeTransform = {
          type: "impute",
          field: impute,
          key: key2,
          ...keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {},
          method: "value",
          ...groupby ? { groupby } : {},
          value: !method2 || method2 === "value" ? value2 : null
        };
        if (method2 && method2 !== "value") {
          const deriveNewField = {
            type: "window",
            as: [`imputed_${impute}_value`],
            ops: [method2],
            fields: [impute],
            frame: frame2,
            ignorePeers: false,
            ...groupby ? { groupby } : {}
          };
          const replaceOriginal = {
            type: "formula",
            expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
            as: impute
          };
          return [imputeTransform, deriveNewField, replaceOriginal];
        } else {
          return [imputeTransform];
        }
      }
    }
    class LoessTransformNode extends DataFlowNode {
      clone() {
        return new LoessTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const specifiedAs = this.transform.as ?? [void 0, void 0];
        this.transform.as = [specifiedAs[0] ?? transform2.on, specifiedAs[1] ?? transform2.loess];
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `LoessTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { loess: loess2, on: on2, ...rest } = this.transform;
        const result = {
          type: "loess",
          x: on2,
          y: loess2,
          ...rest
        };
        return result;
      }
    }
    class LookupNode extends DataFlowNode {
      clone() {
        return new LookupNode(null, duplicate(this.transform), this.secondary);
      }
      constructor(parent, transform2, secondary) {
        super(parent);
        this.transform = transform2;
        this.secondary = secondary;
      }
      static make(parent, model, transform2, counter) {
        const sources = model.component.data.sources;
        const { from } = transform2;
        let fromOutputNode = null;
        if (isLookupData(from)) {
          let fromSource = findSource(from.data, sources);
          if (!fromSource) {
            fromSource = new SourceNode(from.data);
            sources.push(fromSource);
          }
          const fromOutputName = model.getName(`lookup_${counter}`);
          fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
          model.component.data.outputNodes[fromOutputName] = fromOutputNode;
        } else if (isLookupSelection(from)) {
          const selName = from.param;
          transform2 = { as: selName, ...transform2 };
          let selCmpt;
          try {
            selCmpt = model.getSelectionComponent(varName(selName), selName);
          } catch (e3) {
            throw new Error(cannotLookupVariableParameter(selName));
          }
          fromOutputNode = selCmpt.materialized;
          if (!fromOutputNode) {
            throw new Error(noSameUnitLookup(selName));
          }
        }
        return new LookupNode(parent, transform2, fromOutputNode.getSource());
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.lookup]);
      }
      producedFields() {
        return new Set(this.transform.as ? array$2(this.transform.as) : this.transform.from.fields);
      }
      hash() {
        return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
      }
      assemble() {
        let foreign;
        if (this.transform.from.fields) {
          foreign = {
            values: this.transform.from.fields,
            ...this.transform.as ? { as: array$2(this.transform.as) } : {}
          };
        } else {
          let asName = this.transform.as;
          if (!isString(asName)) {
            warn(NO_FIELDS_NEEDS_AS);
            asName = "_lookup";
          }
          foreign = {
            as: [asName]
          };
        }
        return {
          type: "lookup",
          from: this.secondary,
          key: this.transform.from.key,
          fields: [this.transform.lookup],
          ...foreign,
          ...this.transform.default ? { default: this.transform.default } : {}
        };
      }
    }
    class QuantileTransformNode extends DataFlowNode {
      clone() {
        return new QuantileTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const specifiedAs = this.transform.as ?? [void 0, void 0];
        this.transform.as = [specifiedAs[0] ?? "prob", specifiedAs[1] ?? "value"];
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `QuantileTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { quantile: quantile2, ...rest } = this.transform;
        const result = {
          type: "quantile",
          field: quantile2,
          ...rest
        };
        return result;
      }
    }
    class RegressionTransformNode extends DataFlowNode {
      clone() {
        return new RegressionTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
        this.transform = duplicate(transform2);
        const specifiedAs = this.transform.as ?? [void 0, void 0];
        this.transform.as = [specifiedAs[0] ?? transform2.on, specifiedAs[1] ?? transform2.regression];
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `RegressionTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { regression, on: on2, ...rest } = this.transform;
        const result = {
          type: "regression",
          x: on2,
          y: regression,
          ...rest
        };
        return result;
      }
    }
    class PivotTransformNode extends DataFlowNode {
      clone() {
        return new PivotTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
      }
      addDimensions(fields) {
        this.transform.groupby = unique((this.transform.groupby ?? []).concat(fields), (d) => d);
      }
      producedFields() {
        return void 0;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
      }
      hash() {
        return `PivotTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { pivot, value: value2, groupby, limit, op } = this.transform;
        return {
          type: "pivot",
          field: pivot,
          value: value2,
          ...limit !== void 0 ? { limit } : {},
          ...op !== void 0 ? { op } : {},
          ...groupby !== void 0 ? { groupby } : {}
        };
      }
    }
    class SampleTransformNode extends DataFlowNode {
      clone() {
        return new SampleTransformNode(null, duplicate(this.transform));
      }
      constructor(parent, transform2) {
        super(parent);
        this.transform = transform2;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `SampleTransform ${hash(this.transform)}`;
      }
      assemble() {
        return {
          type: "sample",
          size: this.transform.sample
        };
      }
    }
    function makeWalkTree(data2) {
      let datasetIndex = 0;
      function walkTree(node, dataSource) {
        if (node instanceof SourceNode) {
          if (!node.isGenerator && !isUrlData(node.data)) {
            data2.push(dataSource);
            const newData = {
              name: null,
              source: dataSource.name,
              transform: []
            };
            dataSource = newData;
          }
        }
        if (node instanceof ParseNode) {
          if (node.parent instanceof SourceNode && !dataSource.source) {
            dataSource.format = {
              ...dataSource.format ?? {},
              parse: node.assembleFormatParse()
            };
            dataSource.transform.push(...node.assembleTransforms(true));
          } else {
            dataSource.transform.push(...node.assembleTransforms());
          }
        }
        if (node instanceof FacetNode) {
          if (!dataSource.name) {
            dataSource.name = `data_${datasetIndex++}`;
          }
          if (!dataSource.source || dataSource.transform.length > 0) {
            data2.push(dataSource);
            node.data = dataSource.name;
          } else {
            node.data = dataSource.source;
          }
          data2.push(...node.assemble());
          return;
        }
        if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode || node instanceof ExtentTransformNode) {
          dataSource.transform.push(node.assemble());
        }
        if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {
          dataSource.transform.push(...node.assemble());
        }
        if (node instanceof OutputNode) {
          if (dataSource.source && dataSource.transform.length === 0) {
            node.setSource(dataSource.source);
          } else if (node.parent instanceof OutputNode) {
            node.setSource(dataSource.name);
          } else {
            if (!dataSource.name) {
              dataSource.name = `data_${datasetIndex++}`;
            }
            node.setSource(dataSource.name);
            if (node.numChildren() === 1) {
              data2.push(dataSource);
              const newData = {
                name: null,
                source: dataSource.name,
                transform: []
              };
              dataSource = newData;
            }
          }
        }
        switch (node.numChildren()) {
          case 0:
            if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
              data2.push(dataSource);
            }
            break;
          case 1:
            walkTree(node.children[0], dataSource);
            break;
          default: {
            if (!dataSource.name) {
              dataSource.name = `data_${datasetIndex++}`;
            }
            let source2 = dataSource.name;
            if (!dataSource.source || dataSource.transform.length > 0) {
              data2.push(dataSource);
            } else {
              source2 = dataSource.source;
            }
            for (const child of node.children) {
              const newData = {
                name: null,
                source: source2,
                transform: []
              };
              walkTree(child, newData);
            }
            break;
          }
        }
      }
      return walkTree;
    }
    function assembleFacetData(root2) {
      const data2 = [];
      const walkTree = makeWalkTree(data2);
      for (const child of root2.children) {
        walkTree(child, {
          source: root2.name,
          name: null,
          transform: []
        });
      }
      return data2;
    }
    function assembleRootData(dataComponent, datasets) {
      const data2 = [];
      const walkTree = makeWalkTree(data2);
      let sourceIndex = 0;
      for (const root2 of dataComponent.sources) {
        if (!root2.hasName()) {
          root2.dataName = `source_${sourceIndex++}`;
        }
        const newData = root2.assemble();
        walkTree(root2, newData);
      }
      for (const d of data2) {
        if (d.transform.length === 0) {
          delete d.transform;
        }
      }
      let whereTo = 0;
      for (const [i, d] of data2.entries()) {
        if ((d.transform ?? []).length === 0 && !d.source) {
          data2.splice(whereTo++, 0, data2.splice(i, 1)[0]);
        }
      }
      for (const d of data2) {
        for (const t4 of d.transform ?? []) {
          if (t4.type === "lookup") {
            t4.from = dataComponent.outputNodes[t4.from].getSource();
          }
        }
      }
      for (const d of data2) {
        if (d.name in datasets) {
          d.values = datasets[d.name];
        }
      }
      return data2;
    }
    function getHeaderType(orient2) {
      if (orient2 === "top" || orient2 === "left" || isSignalRef(orient2)) {
        return "header";
      }
      return "footer";
    }
    function parseFacetHeaders(model) {
      for (const channel of FACET_CHANNELS) {
        parseFacetHeader(model, channel);
      }
      mergeChildAxis(model, "x");
      mergeChildAxis(model, "y");
    }
    function parseFacetHeader(model, channel) {
      var _a2;
      const { facet, config, child, component } = model;
      if (model.channelHasField(channel)) {
        const fieldDef = facet[channel];
        const titleConfig = getHeaderProperty("title", null, config, channel);
        let title$12 = title(fieldDef, config, {
          allowDisabling: true,
          includeDefault: titleConfig === void 0 || !!titleConfig
        });
        if (child.component.layoutHeaders[channel].title) {
          title$12 = isArray(title$12) ? title$12.join(", ") : title$12;
          title$12 += ` / ${child.component.layoutHeaders[channel].title}`;
          child.component.layoutHeaders[channel].title = null;
        }
        const labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
        const labels2 = fieldDef.header !== null ? getFirstDefined((_a2 = fieldDef.header) == null ? void 0 : _a2.labels, config.header.labels, true) : false;
        const headerType = contains(["bottom", "right"], labelOrient) ? "footer" : "header";
        component.layoutHeaders[channel] = {
          title: fieldDef.header !== null ? title$12 : null,
          facetFieldDef: fieldDef,
          [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels2)]
        };
      }
    }
    function makeHeaderComponent(model, channel, labels2) {
      const sizeType = channel === "row" ? "height" : "width";
      return {
        labels: labels2,
        sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
        axes: []
      };
    }
    function mergeChildAxis(model, channel) {
      const { child } = model;
      if (child.component.axes[channel]) {
        const { layoutHeaders: layoutHeaders2, resolve: resolve2 } = model.component;
        resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
        if (resolve2.axis[channel] === "shared") {
          const headerChannel = channel === "x" ? "column" : "row";
          const layoutHeader = layoutHeaders2[headerChannel];
          for (const axisComponent of child.component.axes[channel]) {
            const headerType = getHeaderType(axisComponent.get("orient"));
            layoutHeader[headerType] ?? (layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]);
            const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
            if (mainAxis) {
              layoutHeader[headerType][0].axes.push(mainAxis);
            }
            axisComponent.mainExtracted = true;
          }
        }
      }
    }
    function parseLayerLayoutSize(model) {
      parseChildrenLayoutSize(model);
      parseNonUnitLayoutSizeForChannel(model, "width");
      parseNonUnitLayoutSizeForChannel(model, "height");
    }
    function parseConcatLayoutSize(model) {
      parseChildrenLayoutSize(model);
      const widthType = model.layout.columns === 1 ? "width" : "childWidth";
      const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
      parseNonUnitLayoutSizeForChannel(model, widthType);
      parseNonUnitLayoutSizeForChannel(model, heightType);
    }
    function parseChildrenLayoutSize(model) {
      for (const child of model.children) {
        child.parseLayoutSize();
      }
    }
    function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const resolve2 = model.component.resolve;
      const layoutSizeCmpt = model.component.layoutSize;
      let mergedSize;
      for (const child of model.children) {
        const childSize = child.component.layoutSize.getWithExplicit(sizeType);
        const scaleResolve = resolve2.scale[channel] ?? defaultScaleResolve(channel, model);
        if (scaleResolve === "independent" && childSize.value === "step") {
          mergedSize = void 0;
          break;
        }
        if (mergedSize) {
          if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
            mergedSize = void 0;
            break;
          }
          mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
        } else {
          mergedSize = childSize;
        }
      }
      if (mergedSize) {
        for (const child of model.children) {
          model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
          child.component.layoutSize.set(sizeType, "merged", false);
        }
        layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
      } else {
        layoutSizeCmpt.setWithExplicit(layoutSizeType, {
          explicit: false,
          value: void 0
        });
      }
    }
    function parseUnitLayoutSize(model) {
      const { size: size2, component } = model;
      for (const channel of POSITION_SCALE_CHANNELS) {
        const sizeType = getSizeChannel(channel);
        if (size2[sizeType]) {
          const specifiedSize = size2[sizeType];
          component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
        } else {
          const defaultSize2 = defaultUnitSize(model, sizeType);
          component.layoutSize.set(sizeType, defaultSize2, false);
        }
      }
    }
    function defaultUnitSize(model, sizeType) {
      const channel = sizeType === "width" ? "x" : "y";
      const config = model.config;
      const scaleComponent = model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        const range2 = scaleComponent.get("range");
        if (hasDiscreteDomain(scaleType2)) {
          const size2 = getViewConfigDiscreteSize(config.view, sizeType);
          if (isVgRangeStep(range2) || isStep(size2)) {
            return "step";
          } else {
            return size2;
          }
        } else {
          return getViewConfigContinuousSize(config.view, sizeType);
        }
      } else if (model.hasProjection || model.mark === "arc") {
        return getViewConfigContinuousSize(config.view, sizeType);
      } else {
        const size2 = getViewConfigDiscreteSize(config.view, sizeType);
        return isStep(size2) ? size2.step : size2;
      }
    }
    function facetSortFieldName(fieldDef, sort2, opt) {
      return vgField(sort2, { suffix: `by_${vgField(fieldDef)}`, ...opt ?? {} });
    }
    class FacetModel extends ModelWithField {
      constructor(spec, parent, parentGivenName, config) {
        super(spec, "facet", parent, parentGivenName, config, spec.resolve);
        this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
        this.children = [this.child];
        this.facet = this.initFacet(spec.facet);
      }
      initFacet(facet) {
        if (!isFacetMapping(facet)) {
          return { facet: this.initFacetFieldDef(facet, "facet") };
        }
        const channels = keys(facet);
        const normalizedFacet = {};
        for (const channel of channels) {
          if (![ROW, COLUMN].includes(channel)) {
            warn(incompatibleChannel(channel, "facet"));
            break;
          }
          const fieldDef = facet[channel];
          if (fieldDef.field === void 0) {
            warn(emptyFieldDef(fieldDef, channel));
            break;
          }
          normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);
        }
        return normalizedFacet;
      }
      initFacetFieldDef(fieldDef, channel) {
        const facetFieldDef = initFieldDef(fieldDef, channel);
        if (facetFieldDef.header) {
          facetFieldDef.header = replaceExprRef(facetFieldDef.header);
        } else if (facetFieldDef.header === null) {
          facetFieldDef.header = null;
        }
        return facetFieldDef;
      }
      channelHasField(channel) {
        return !!this.facet[channel];
      }
      fieldDef(channel) {
        return this.facet[channel];
      }
      parseData() {
        this.component.data = parseData(this);
        this.child.parseData();
      }
      parseLayoutSize() {
        parseChildrenLayoutSize(this);
      }
      parseSelections() {
        this.child.parseSelections();
        this.component.selection = this.child.component.selection;
      }
      parseMarkGroup() {
        this.child.parseMarkGroup();
      }
      parseAxesAndHeaders() {
        this.child.parseAxesAndHeaders();
        parseFacetHeaders(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.child.assembleSelectionTopLevelSignals(signals);
      }
      assembleSignals() {
        this.child.assembleSignals();
        return [];
      }
      assembleSelectionData(data2) {
        return this.child.assembleSelectionData(data2);
      }
      getHeaderLayoutMixins() {
        const layoutMixins = {};
        for (const channel of FACET_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            const layoutHeaderComponent = this.component.layoutHeaders[channel];
            const headerComponent = layoutHeaderComponent[headerType];
            const { facetFieldDef } = layoutHeaderComponent;
            if (facetFieldDef) {
              const titleOrient = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel);
              if (["right", "bottom"].includes(titleOrient)) {
                const headerChannel = getHeaderChannel(channel, titleOrient);
                layoutMixins.titleAnchor ?? (layoutMixins.titleAnchor = {});
                layoutMixins.titleAnchor[headerChannel] = "end";
              }
            }
            if (headerComponent == null ? void 0 : headerComponent[0]) {
              const sizeType = channel === "row" ? "height" : "width";
              const bandType = headerType === "header" ? "headerBand" : "footerBand";
              if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
                layoutMixins[bandType] ?? (layoutMixins[bandType] = {});
                layoutMixins[bandType][channel] = 0.5;
              }
              if (layoutHeaderComponent.title) {
                layoutMixins.offset ?? (layoutMixins.offset = {});
                layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
              }
            }
          }
        }
        return layoutMixins;
      }
      assembleDefaultLayout() {
        const { column, row } = this.facet;
        const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
        let align2 = "all";
        if (!row && this.component.resolve.scale.x === "independent") {
          align2 = "none";
        } else if (!column && this.component.resolve.scale.y === "independent") {
          align2 = "none";
        }
        return {
          ...this.getHeaderLayoutMixins(),
          ...columns ? { columns } : {},
          bounds: "full",
          align: align2
        };
      }
      assembleLayoutSignals() {
        return this.child.assembleLayoutSignals();
      }
      columnDistinctSignal() {
        if (this.parent && this.parent instanceof FacetModel) {
          return void 0;
        } else {
          const facetLayoutDataName = this.getName("column_domain");
          return { signal: `length(data('${facetLayoutDataName}'))` };
        }
      }
      assembleGroupStyle() {
        return void 0;
      }
      assembleGroup(signals) {
        if (this.parent && this.parent instanceof FacetModel) {
          return {
            ...this.channelHasField("column") ? {
              encode: {
                update: {
                  // TODO(https://github.com/vega/vega-lite/issues/2759):
                  // Correct the signal for facet of concat of facet_column
                  columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
                }
              }
            } : {},
            ...super.assembleGroup(signals)
          };
        }
        return super.assembleGroup(signals);
      }
      /**
       * Aggregate cardinality for calculating size
       */
      getCardinalityAggregateForChild() {
        const fields = [];
        const ops2 = [];
        const as = [];
        if (this.child instanceof FacetModel) {
          if (this.child.channelHasField("column")) {
            const field2 = vgField(this.child.facet.column);
            fields.push(field2);
            ops2.push("distinct");
            as.push(`distinct_${field2}`);
          }
        } else {
          for (const channel of POSITION_SCALE_CHANNELS) {
            const childScaleComponent = this.child.component.scales[channel];
            if (childScaleComponent && !childScaleComponent.merged) {
              const type2 = childScaleComponent.get("type");
              const range2 = childScaleComponent.get("range");
              if (hasDiscreteDomain(type2) && isVgRangeStep(range2)) {
                const domain2 = assembleDomain(this.child, channel);
                const field2 = getFieldFromDomain(domain2);
                if (field2) {
                  fields.push(field2);
                  ops2.push("distinct");
                  as.push(`distinct_${field2}`);
                } else {
                  warn(unknownField(channel));
                }
              }
            }
          }
        }
        return { fields, ops: ops2, as };
      }
      assembleFacet() {
        const { name: name2, data: data2 } = this.component.data.facetRoot;
        const { row, column } = this.facet;
        const { fields, ops: ops2, as } = this.getCardinalityAggregateForChild();
        const groupby = [];
        for (const channel of FACET_CHANNELS) {
          const fieldDef = this.facet[channel];
          if (fieldDef) {
            groupby.push(vgField(fieldDef));
            const { bin: bin2, sort: sort2 } = fieldDef;
            if (isBinning(bin2)) {
              groupby.push(vgField(fieldDef, { binSuffix: "end" }));
            }
            if (isSortField(sort2)) {
              const { field: field2, op = DEFAULT_SORT_OP } = sort2;
              const outputName = facetSortFieldName(fieldDef, sort2);
              if (row && column) {
                fields.push(outputName);
                ops2.push("max");
                as.push(outputName);
              } else {
                fields.push(field2);
                ops2.push(op);
                as.push(outputName);
              }
            } else if (isArray(sort2)) {
              const outputName = sortArrayIndexField(fieldDef, channel);
              fields.push(outputName);
              ops2.push("max");
              as.push(outputName);
            }
          }
        }
        const cross2 = !!row && !!column;
        return {
          name: name2,
          data: data2,
          groupby,
          ...cross2 || fields.length > 0 ? {
            aggregate: {
              ...cross2 ? { cross: cross2 } : {},
              ...fields.length ? { fields, ops: ops2, as } : {}
            }
          } : {}
        };
      }
      facetSortFields(channel) {
        const { facet } = this;
        const fieldDef = facet[channel];
        if (fieldDef) {
          if (isSortField(fieldDef.sort)) {
            return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
          } else if (isArray(fieldDef.sort)) {
            return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
          }
          return [vgField(fieldDef, { expr: "datum" })];
        }
        return [];
      }
      facetSortOrder(channel) {
        const { facet } = this;
        const fieldDef = facet[channel];
        if (fieldDef) {
          const { sort: sort2 } = fieldDef;
          const order = (isSortField(sort2) ? sort2.order : !isArray(sort2) && sort2) || "ascending";
          return [order];
        }
        return [];
      }
      assembleLabelTitle() {
        var _a2;
        const { facet, config } = this;
        if (facet.facet) {
          return assembleLabelTitle(facet.facet, "facet", config);
        }
        const ORTHOGONAL_ORIENT = {
          row: ["top", "bottom"],
          column: ["left", "right"]
        };
        for (const channel of HEADER_CHANNELS) {
          if (facet[channel]) {
            const labelOrient = getHeaderProperty("labelOrient", (_a2 = facet[channel]) == null ? void 0 : _a2.header, config, channel);
            if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
              return assembleLabelTitle(facet[channel], channel, config);
            }
          }
        }
        return void 0;
      }
      assembleMarks() {
        const { child } = this;
        const facetRoot = this.component.data.facetRoot;
        const data2 = assembleFacetData(facetRoot);
        const encodeEntry2 = child.assembleGroupEncodeEntry(false);
        const title2 = this.assembleLabelTitle() || child.assembleTitle();
        const style2 = child.assembleGroupStyle();
        const markGroup = {
          name: this.getName("cell"),
          type: "group",
          ...title2 ? { title: title2 } : {},
          ...style2 ? { style: style2 } : {},
          from: {
            facet: this.assembleFacet()
          },
          // TODO: move this to after data
          sort: {
            field: FACET_CHANNELS.map((c2) => this.facetSortFields(c2)).flat(),
            order: FACET_CHANNELS.map((c2) => this.facetSortOrder(c2)).flat()
          },
          ...data2.length > 0 ? { data: data2 } : {},
          ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
          ...child.assembleGroup(assembleFacetSignals(this, []))
        };
        return [markGroup];
      }
      getMapping() {
        return this.facet;
      }
    }
    function makeJoinAggregateFromFacet(parent, facet) {
      const { row, column } = facet;
      if (row && column) {
        let newParent = null;
        for (const fieldDef of [row, column]) {
          if (isSortField(fieldDef.sort)) {
            const { field: field2, op = DEFAULT_SORT_OP } = fieldDef.sort;
            parent = newParent = new JoinAggregateTransformNode(parent, {
              joinaggregate: [
                {
                  op,
                  field: field2,
                  as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
                }
              ],
              groupby: [vgField(fieldDef)]
            });
          }
        }
        return newParent;
      }
      return null;
    }
    function findSource(data2, sources) {
      var _a2, _b, _c2, _d2;
      for (const other of sources) {
        const otherData = other.data;
        if (data2.name && other.hasName() && data2.name !== other.dataName) {
          continue;
        }
        const formatMesh = (_a2 = data2["format"]) == null ? void 0 : _a2.mesh;
        const otherFeature = (_b = otherData.format) == null ? void 0 : _b.feature;
        if (formatMesh && otherFeature) {
          continue;
        }
        const formatFeature = (_c2 = data2["format"]) == null ? void 0 : _c2.feature;
        if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {
          continue;
        }
        const otherMesh = (_d2 = otherData.format) == null ? void 0 : _d2.mesh;
        if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {
          continue;
        }
        if (isInlineData(data2) && isInlineData(otherData)) {
          if (deepEqual(data2.values, otherData.values)) {
            return other;
          }
        } else if (isUrlData(data2) && isUrlData(otherData)) {
          if (data2.url === otherData.url) {
            return other;
          }
        } else if (isNamedData(data2)) {
          if (data2.name === other.dataName) {
            return other;
          }
        }
      }
      return null;
    }
    function parseRoot(model, sources) {
      if (model.data || !model.parent) {
        if (model.data === null) {
          const source2 = new SourceNode({ values: [] });
          sources.push(source2);
          return source2;
        }
        const existingSource = findSource(model.data, sources);
        if (existingSource) {
          if (!isGenerator(model.data)) {
            existingSource.data.format = mergeDeep$1({}, model.data.format, existingSource.data.format);
          }
          if (!existingSource.hasName() && model.data.name) {
            existingSource.dataName = model.data.name;
          }
          return existingSource;
        } else {
          const source2 = new SourceNode(model.data);
          sources.push(source2);
          return source2;
        }
      } else {
        return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
      }
    }
    function parseTransformArray(head, model, ancestorParse) {
      let lookupCounter = 0;
      for (const t4 of model.transforms) {
        let derivedType = void 0;
        let transformNode;
        if (isCalculate(t4)) {
          transformNode = head = new CalculateNode(head, t4);
          derivedType = "derived";
        } else if (isFilter(t4)) {
          const implicit2 = getImplicitFromFilterTransform(t4);
          transformNode = head = ParseNode.makeWithAncestors(head, {}, implicit2, ancestorParse) ?? head;
          head = new FilterNode(head, model, t4.filter);
        } else if (isBin(t4)) {
          transformNode = head = BinNode.makeFromTransform(head, t4, model);
          derivedType = "number";
        } else if (isTimeUnit(t4)) {
          derivedType = "date";
          const parsedAs = ancestorParse.getWithExplicit(t4.field);
          if (parsedAs.value === void 0) {
            head = new ParseNode(head, { [t4.field]: derivedType });
            ancestorParse.set(t4.field, derivedType, false);
          }
          transformNode = head = TimeUnitNode.makeFromTransform(head, t4);
        } else if (isAggregate(t4)) {
          transformNode = head = AggregateNode.makeFromTransform(head, t4);
          derivedType = "number";
          if (requiresSelectionId(model)) {
            head = new IdentifierNode(head);
          }
        } else if (isLookup(t4)) {
          transformNode = head = LookupNode.make(head, model, t4, lookupCounter++);
          derivedType = "derived";
        } else if (isWindow(t4)) {
          transformNode = head = new WindowTransformNode(head, t4);
          derivedType = "number";
        } else if (isJoinAggregate(t4)) {
          transformNode = head = new JoinAggregateTransformNode(head, t4);
          derivedType = "number";
        } else if (isStack(t4)) {
          transformNode = head = StackNode.makeFromTransform(head, t4);
          derivedType = "derived";
        } else if (isFold(t4)) {
          transformNode = head = new FoldTransformNode(head, t4);
          derivedType = "derived";
        } else if (isExtent(t4)) {
          transformNode = head = new ExtentTransformNode(head, t4);
          derivedType = "derived";
        } else if (isFlatten(t4)) {
          transformNode = head = new FlattenTransformNode(head, t4);
          derivedType = "derived";
        } else if (isPivot(t4)) {
          transformNode = head = new PivotTransformNode(head, t4);
          derivedType = "derived";
        } else if (isSample(t4)) {
          head = new SampleTransformNode(head, t4);
        } else if (isImpute(t4)) {
          transformNode = head = ImputeNode.makeFromTransform(head, t4);
          derivedType = "derived";
        } else if (isDensity(t4)) {
          transformNode = head = new DensityTransformNode(head, t4);
          derivedType = "derived";
        } else if (isQuantile(t4)) {
          transformNode = head = new QuantileTransformNode(head, t4);
          derivedType = "derived";
        } else if (isRegression(t4)) {
          transformNode = head = new RegressionTransformNode(head, t4);
          derivedType = "derived";
        } else if (isLoess(t4)) {
          transformNode = head = new LoessTransformNode(head, t4);
          derivedType = "derived";
        } else {
          warn(invalidTransformIgnored(t4));
          continue;
        }
        if (transformNode && derivedType !== void 0) {
          for (const field2 of transformNode.producedFields() ?? []) {
            ancestorParse.set(field2, derivedType, false);
          }
        }
      }
      return head;
    }
    function parseData(model) {
      var _a2;
      let head = parseRoot(model, model.component.data.sources);
      const { outputNodes, outputNodeRefCounts } = model.component.data;
      const data2 = model.data;
      const newData = data2 && (isGenerator(data2) || isUrlData(data2) || isInlineData(data2));
      const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
      if (isGenerator(data2)) {
        if (isSequenceGenerator(data2)) {
          head = new SequenceNode(head, data2.sequence);
        } else if (isGraticuleGenerator(data2)) {
          head = new GraticuleNode(head, data2.graticule);
        }
        ancestorParse.parseNothing = true;
      } else if (((_a2 = data2 == null ? void 0 : data2.format) == null ? void 0 : _a2.parse) === null) {
        ancestorParse.parseNothing = true;
      }
      head = ParseNode.makeExplicit(head, model, ancestorParse) ?? head;
      head = new IdentifierNode(head);
      const parentIsLayer = model.parent && isLayerModel(model.parent);
      if (isUnitModel(model) || isFacetModel(model)) {
        if (parentIsLayer) {
          head = BinNode.makeFromEncoding(head, model) ?? head;
        }
      }
      if (model.transforms.length > 0) {
        head = parseTransformArray(head, model, ancestorParse);
      }
      const implicitSelection = getImplicitFromSelection(model);
      const implicitEncoding = getImplicitFromEncoding(model);
      head = ParseNode.makeWithAncestors(head, {}, { ...implicitSelection, ...implicitEncoding }, ancestorParse) ?? head;
      if (isUnitModel(model)) {
        head = GeoJSONNode.parseAll(head, model);
        head = GeoPointNode.parseAll(head, model);
      }
      if (isUnitModel(model) || isFacetModel(model)) {
        if (!parentIsLayer) {
          head = BinNode.makeFromEncoding(head, model) ?? head;
        }
        head = TimeUnitNode.makeFromEncoding(head, model) ?? head;
        head = CalculateNode.parseAllForSortIndex(head, model);
      }
      const rawName = model.getDataName(DataSourceType.Raw);
      const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);
      outputNodes[rawName] = raw;
      head = raw;
      if (isUnitModel(model)) {
        const agg = AggregateNode.makeFromEncoding(head, model);
        if (agg) {
          head = agg;
          if (requiresSelectionId(model)) {
            head = new IdentifierNode(head);
          }
        }
        head = ImputeNode.makeFromEncoding(head, model) ?? head;
        head = StackNode.makeFromEncoding(head, model) ?? head;
      }
      if (isUnitModel(model)) {
        head = FilterInvalidNode.make(head, model) ?? head;
      }
      const mainName = model.getDataName(DataSourceType.Main);
      const main2 = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);
      outputNodes[mainName] = main2;
      head = main2;
      if (isUnitModel(model)) {
        materializeSelections(model, main2);
      }
      let facetRoot = null;
      if (isFacetModel(model)) {
        const facetName = model.getName("facet");
        head = makeJoinAggregateFromFacet(head, model.facet) ?? head;
        facetRoot = new FacetNode(head, model, facetName, main2.getSource());
        outputNodes[facetName] = facetRoot;
      }
      return {
        ...model.component.data,
        outputNodes,
        outputNodeRefCounts,
        raw,
        main: main2,
        facetRoot,
        ancestorParse
      };
    }
    class ConcatModel extends Model {
      constructor(spec, parent, parentGivenName, config) {
        var _a2, _b, _c2, _d2;
        super(spec, "concat", parent, parentGivenName, config, spec.resolve);
        if (((_b = (_a2 = spec.resolve) == null ? void 0 : _a2.axis) == null ? void 0 : _b.x) === "shared" || ((_d2 = (_c2 = spec.resolve) == null ? void 0 : _c2.axis) == null ? void 0 : _d2.y) === "shared") {
          warn(CONCAT_CANNOT_SHARE_AXIS);
        }
        this.children = this.getChildren(spec).map((child, i) => {
          return buildModel(child, this, this.getName(`concat_${i}`), void 0, config);
        });
      }
      parseData() {
        this.component.data = parseData(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key2 of keys(child.component.selection)) {
            this.component.selection[key2] = child.component.selection[key2];
          }
        }
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        for (const child of this.children) {
          child.parseAxesAndHeaders();
        }
      }
      getChildren(spec) {
        if (isVConcatSpec(spec)) {
          return spec.vconcat;
        } else if (isHConcatSpec(spec)) {
          return spec.hconcat;
        }
        return spec.concat;
      }
      parseLayoutSize() {
        parseConcatLayoutSize(this);
      }
      parseAxisGroup() {
        return null;
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      assembleSignals() {
        this.children.forEach((child) => child.assembleSignals());
        return [];
      }
      assembleLayoutSignals() {
        const layoutSignals = assembleLayoutSignals(this);
        for (const child of this.children) {
          layoutSignals.push(...child.assembleLayoutSignals());
        }
        return layoutSignals;
      }
      assembleSelectionData(data2) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data2);
      }
      assembleMarks() {
        return this.children.map((child) => {
          const title2 = child.assembleTitle();
          const style2 = child.assembleGroupStyle();
          const encodeEntry2 = child.assembleGroupEncodeEntry(false);
          return {
            type: "group",
            name: child.getName("group"),
            ...title2 ? { title: title2 } : {},
            ...style2 ? { style: style2 } : {},
            ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
            ...child.assembleGroup()
          };
        });
      }
      assembleGroupStyle() {
        return void 0;
      }
      assembleDefaultLayout() {
        const columns = this.layout.columns;
        return {
          ...columns != null ? { columns } : {},
          bounds: "full",
          // Use align each so it can work with multiple plots with different size
          align: "each"
        };
      }
    }
    function isFalseOrNull(v) {
      return v === false || v === null;
    }
    const AXIS_COMPONENT_PROPERTIES_INDEX = {
      disable: 1,
      gridScale: 1,
      scale: 1,
      ...COMMON_AXIS_PROPERTIES_INDEX,
      labelExpr: 1,
      encode: 1
    };
    const AXIS_COMPONENT_PROPERTIES = keys(AXIS_COMPONENT_PROPERTIES_INDEX);
    class AxisComponent extends Split {
      constructor(explicit = {}, implicit2 = {}, mainExtracted = false) {
        super();
        this.explicit = explicit;
        this.implicit = implicit2;
        this.mainExtracted = mainExtracted;
      }
      clone() {
        return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
      }
      hasAxisPart(part) {
        if (part === "axis") {
          return true;
        }
        if (part === "grid" || part === "title") {
          return !!this.get(part);
        }
        return !isFalseOrNull(this.get(part));
      }
      hasOrientSignalRef() {
        return isSignalRef(this.explicit.orient);
      }
    }
    function labels(model, channel, specifiedLabelsSpec) {
      const { encoding, config } = model;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) ?? getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
      const axis2 = model.axis(channel) || {};
      const { format: format2, formatType } = axis2;
      if (isCustomFormatType(formatType)) {
        return {
          text: formatCustomType({
            fieldOrDatumDef,
            field: "datum.value",
            format: format2,
            formatType,
            config
          }),
          ...specifiedLabelsSpec
        };
      } else if (format2 === void 0 && formatType === void 0 && config.customFormatTypes) {
        if (channelDefType(fieldOrDatumDef) === "quantitative") {
          if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormatType) {
            return {
              text: formatCustomType({
                fieldOrDatumDef,
                field: "datum.value",
                format: config.normalizedNumberFormat,
                formatType: config.normalizedNumberFormatType,
                config
              }),
              ...specifiedLabelsSpec
            };
          } else if (config.numberFormatType) {
            return {
              text: formatCustomType({
                fieldOrDatumDef,
                field: "datum.value",
                format: config.numberFormat,
                formatType: config.numberFormatType,
                config
              }),
              ...specifiedLabelsSpec
            };
          }
        }
        if (channelDefType(fieldOrDatumDef) === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && !fieldOrDatumDef.timeUnit) {
          return {
            text: formatCustomType({
              fieldOrDatumDef,
              field: "datum.value",
              format: config.timeFormat,
              formatType: config.timeFormatType,
              config
            }),
            ...specifiedLabelsSpec
          };
        }
      }
      return specifiedLabelsSpec;
    }
    function parseUnitAxes(model) {
      return POSITION_SCALE_CHANNELS.reduce((axis2, channel) => {
        if (model.component.scales[channel]) {
          axis2[channel] = [parseAxis(channel, model)];
        }
        return axis2;
      }, {});
    }
    const OPPOSITE_ORIENT = {
      bottom: "top",
      top: "bottom",
      left: "right",
      right: "left"
    };
    function parseLayerAxes(model) {
      const { axes, resolve: resolve2 } = model.component;
      const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
      for (const child of model.children) {
        child.parseAxesAndHeaders();
        for (const channel of keys(child.component.axes)) {
          resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
          if (resolve2.axis[channel] === "shared") {
            axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
            if (!axes[channel]) {
              resolve2.axis[channel] = "independent";
              delete axes[channel];
            }
          }
        }
      }
      for (const channel of POSITION_SCALE_CHANNELS) {
        for (const child of model.children) {
          if (!child.component.axes[channel]) {
            continue;
          }
          if (resolve2.axis[channel] === "independent") {
            axes[channel] = (axes[channel] ?? []).concat(child.component.axes[channel]);
            for (const axisComponent of child.component.axes[channel]) {
              const { value: orient2, explicit } = axisComponent.getWithExplicit("orient");
              if (isSignalRef(orient2)) {
                continue;
              }
              if (axisCount[orient2] > 0 && !explicit) {
                const oppositeOrient = OPPOSITE_ORIENT[orient2];
                if (axisCount[orient2] > axisCount[oppositeOrient]) {
                  axisComponent.set("orient", oppositeOrient, false);
                }
              }
              axisCount[orient2]++;
            }
          }
          delete child.component.axes[channel];
        }
        if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
          for (const [index2, axisCmpt] of (axes[channel] || []).entries()) {
            if (index2 > 0 && !!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
              axisCmpt.implicit.grid = false;
            }
          }
        }
      }
    }
    function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
      if (mergedAxisCmpts) {
        if (mergedAxisCmpts.length !== childAxisCmpts.length) {
          return void 0;
        }
        const length2 = mergedAxisCmpts.length;
        for (let i = 0; i < length2; i++) {
          const merged = mergedAxisCmpts[i];
          const child = childAxisCmpts[i];
          if (!!merged !== !!child) {
            return void 0;
          } else if (merged && child) {
            const mergedOrient = merged.getWithExplicit("orient");
            const childOrient = child.getWithExplicit("orient");
            if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
              return void 0;
            } else {
              mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
            }
          }
        }
      } else {
        return childAxisCmpts.map((axisComponent) => axisComponent.clone());
      }
      return mergedAxisCmpts;
    }
    function mergeAxisComponent(merged, child) {
      for (const prop of AXIS_COMPONENT_PROPERTIES) {
        const mergedValueWithExplicit = mergeValuesWithExplicit(
          merged.getWithExplicit(prop),
          child.getWithExplicit(prop),
          prop,
          "axis",
          // Tie breaker function
          (v1, v2) => {
            switch (prop) {
              case "title":
                return mergeTitleComponent(v1, v2);
              case "gridScale":
                return {
                  explicit: v1.explicit,
                  value: getFirstDefined(v1.value, v2.value)
                };
            }
            return defaultTieBreaker(v1, v2, prop, "axis");
          }
        );
        merged.setWithExplicit(prop, mergedValueWithExplicit);
      }
      return merged;
    }
    function isExplicit(value2, property2, axis2, model, channel) {
      if (property2 === "disable") {
        return axis2 !== void 0;
      }
      axis2 = axis2 || {};
      switch (property2) {
        case "titleAngle":
        case "labelAngle":
          return value2 === (isSignalRef(axis2.labelAngle) ? axis2.labelAngle : normalizeAngle(axis2.labelAngle));
        case "values":
          return !!axis2.values;
        case "encode":
          return !!axis2.encoding || !!axis2.labelAngle;
        case "title":
          if (value2 === getFieldDefTitle(model, channel)) {
            return true;
          }
      }
      return value2 === axis2[property2];
    }
    const propsToAlwaysIncludeConfig = /* @__PURE__ */ new Set([
      "grid",
      "translate",
      // the rest are not axis configs in Vega, but are in VL, so we need to set too.
      "format",
      "formatType",
      "orient",
      "labelExpr",
      "tickCount",
      "position",
      "tickMinStep"
    ]);
    function parseAxis(channel, model) {
      var _a2, _b;
      let axis2 = model.axis(channel);
      const axisComponent = new AxisComponent();
      const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
      const { mark, config } = model;
      const orient2 = (axis2 == null ? void 0 : axis2.orient) || ((_a2 = config[channel === "x" ? "axisX" : "axisY"]) == null ? void 0 : _a2.orient) || ((_b = config.axis) == null ? void 0 : _b.orient) || defaultOrient(channel);
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const axisConfigs = getAxisConfigs(channel, scaleType2, orient2, model.config);
      const disable = axis2 !== void 0 ? !axis2 : getAxisConfig("disable", config.style, axis2 == null ? void 0 : axis2.style, axisConfigs).configValue;
      axisComponent.set("disable", disable, axis2 !== void 0);
      if (disable) {
        return axisComponent;
      }
      axis2 = axis2 || {};
      const labelAngle = getLabelAngle(fieldOrDatumDef, axis2, channel, config.style, axisConfigs);
      const formatType = guideFormatType(axis2.formatType, fieldOrDatumDef, scaleType2);
      const format2 = guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, axis2.format, axis2.formatType, config, true);
      const ruleParams = {
        fieldOrDatumDef,
        axis: axis2,
        channel,
        model,
        scaleType: scaleType2,
        orient: orient2,
        labelAngle,
        format: format2,
        formatType,
        mark,
        config
      };
      for (const property2 of AXIS_COMPONENT_PROPERTIES) {
        const value2 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis2[property2] : void 0;
        const hasValue = value2 !== void 0;
        const explicit = isExplicit(value2, property2, axis2, model, channel);
        if (hasValue && explicit) {
          axisComponent.set(property2, value2, explicit);
        } else {
          const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, config.style, axis2.style, axisConfigs) : {};
          const hasConfigValue = configValue !== void 0;
          if (hasValue && !hasConfigValue) {
            axisComponent.set(property2, value2, explicit);
          } else if (
            // Cases need implicit values
            // 1. Axis config that aren't available in Vega
            !(configFrom === "vgAxisConfig") || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
            propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || // 3. Conditional axis values and signals
            isConditionalAxisValue(configValue) || isSignalRef(configValue)
          ) {
            axisComponent.set(property2, configValue, false);
          }
        }
      }
      const axisEncoding = axis2.encoding ?? {};
      const axisEncode = AXIS_PARTS.reduce((e3, part) => {
        if (!axisComponent.hasAxisPart(part)) {
          return e3;
        }
        const axisEncodingPart = guideEncodeEntry(axisEncoding[part] ?? {}, model);
        const value2 = part === "labels" ? labels(model, channel, axisEncodingPart) : axisEncodingPart;
        if (value2 !== void 0 && !isEmpty(value2)) {
          e3[part] = { update: value2 };
        }
        return e3;
      }, {});
      if (!isEmpty(axisEncode)) {
        axisComponent.set("encode", axisEncode, !!axis2.encoding || axis2.labelAngle !== void 0);
      }
      return axisComponent;
    }
    function initLayoutSize({ encoding, size: size2 }) {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const sizeType = getSizeChannel(channel);
        if (isStep(size2[sizeType])) {
          if (isContinuousFieldOrDatumDef(encoding[channel])) {
            delete size2[sizeType];
            warn(stepDropped(sizeType));
          }
        }
      }
      return size2;
    }
    const arc = {
      vgMark: "arc",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            size: "ignore",
            orient: "ignore",
            theta: "ignore"
          }),
          ...pointPosition("x", model, { defaultPos: "mid" }),
          ...pointPosition("y", model, { defaultPos: "mid" }),
          // arcs are rectangles in polar coordinates
          ...rectPosition(model, "radius"),
          ...rectPosition(model, "theta")
        };
      }
    };
    const area = {
      vgMark: "area",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            orient: "include",
            size: "ignore",
            theta: "ignore"
          }),
          ...pointOrRangePosition("x", model, {
            defaultPos: "zeroOrMin",
            defaultPos2: "zeroOrMin",
            range: model.markDef.orient === "horizontal"
          }),
          ...pointOrRangePosition("y", model, {
            defaultPos: "zeroOrMin",
            defaultPos2: "zeroOrMin",
            range: model.markDef.orient === "vertical"
          }),
          ...defined(model)
        };
      }
    };
    const bar = {
      vgMark: "rect",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            orient: "ignore",
            size: "ignore",
            theta: "ignore"
          }),
          ...rectPosition(model, "x"),
          ...rectPosition(model, "y")
        };
      }
    };
    const geoshape = {
      vgMark: "shape",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            size: "ignore",
            orient: "ignore",
            theta: "ignore"
          })
        };
      },
      postEncodingTransform: (model) => {
        const { encoding } = model;
        const shapeDef = encoding.shape;
        const transform2 = {
          type: "geoshape",
          projection: model.projectionName(),
          // as: 'shape',
          ...shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {}
        };
        return [transform2];
      }
    };
    const image = {
      vgMark: "image",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "ignore",
            orient: "ignore",
            size: "ignore",
            theta: "ignore"
          }),
          ...rectPosition(model, "x"),
          ...rectPosition(model, "y"),
          ...text$1(model, "url")
        };
      }
    };
    const line = {
      vgMark: "line",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            size: "ignore",
            orient: "ignore",
            theta: "ignore"
          }),
          ...pointPosition("x", model, { defaultPos: "mid" }),
          ...pointPosition("y", model, { defaultPos: "mid" }),
          ...nonPosition("size", model, {
            vgChannel: "strokeWidth"
            // VL's line size is strokeWidth
          }),
          ...defined(model)
        };
      }
    };
    const trail = {
      vgMark: "trail",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            size: "include",
            orient: "ignore",
            theta: "ignore"
          }),
          ...pointPosition("x", model, { defaultPos: "mid" }),
          ...pointPosition("y", model, { defaultPos: "mid" }),
          ...nonPosition("size", model),
          ...defined(model)
        };
      }
    };
    function encodeEntry(model, fixedShape) {
      const { config } = model;
      return {
        ...baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          size: "include",
          orient: "ignore",
          theta: "ignore"
        }),
        ...pointPosition("x", model, { defaultPos: "mid" }),
        ...pointPosition("y", model, { defaultPos: "mid" }),
        ...nonPosition("size", model),
        ...nonPosition("angle", model),
        ...shapeMixins(model, config, fixedShape)
      };
    }
    function shapeMixins(model, config, fixedShape) {
      if (fixedShape) {
        return { shape: { value: fixedShape } };
      }
      return nonPosition("shape", model);
    }
    const point = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model);
      }
    };
    const circle = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model, "circle");
      }
    };
    const square = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model, "square");
      }
    };
    const rect = {
      vgMark: "rect",
      encodeEntry: (model) => {
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            orient: "ignore",
            size: "ignore",
            theta: "ignore"
          }),
          ...rectPosition(model, "x"),
          ...rectPosition(model, "y")
        };
      }
    };
    const rule = {
      vgMark: "rule",
      encodeEntry: (model) => {
        const { markDef } = model;
        const orient2 = markDef.orient;
        if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
          return {};
        }
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            orient: "ignore",
            size: "ignore",
            theta: "ignore"
          }),
          ...pointOrRangePosition("x", model, {
            defaultPos: orient2 === "horizontal" ? "zeroOrMax" : "mid",
            defaultPos2: "zeroOrMin",
            range: orient2 !== "vertical"
            // include x2 for horizontal or line segment rule
          }),
          ...pointOrRangePosition("y", model, {
            defaultPos: orient2 === "vertical" ? "zeroOrMax" : "mid",
            defaultPos2: "zeroOrMin",
            range: orient2 !== "horizontal"
            // include y2 for vertical or line segment rule
          }),
          ...nonPosition("size", model, {
            vgChannel: "strokeWidth"
            // VL's rule size is strokeWidth
          })
        };
      }
    };
    const text = {
      vgMark: "text",
      encodeEntry: (model) => {
        const { config, encoding } = model;
        return {
          ...baseEncodeEntry(model, {
            align: "include",
            baseline: "include",
            color: "include",
            size: "ignore",
            orient: "ignore",
            theta: "include"
          }),
          ...pointPosition("x", model, { defaultPos: "mid" }),
          ...pointPosition("y", model, { defaultPos: "mid" }),
          ...text$1(model),
          ...nonPosition("size", model, {
            vgChannel: "fontSize"
            // VL's text size is fontSize
          }),
          ...nonPosition("angle", model),
          ...valueIfDefined("align", align(model.markDef, encoding, config)),
          ...valueIfDefined("baseline", baseline(model.markDef, encoding, config)),
          ...pointPosition("radius", model, { defaultPos: null }),
          ...pointPosition("theta", model, { defaultPos: null })
        };
      }
    };
    function align(markDef, encoding, config) {
      const a2 = getMarkPropOrConfig("align", markDef, config);
      if (a2 === void 0) {
        return "center";
      }
      return void 0;
    }
    function baseline(markDef, encoding, config) {
      const b2 = getMarkPropOrConfig("baseline", markDef, config);
      if (b2 === void 0) {
        return "middle";
      }
      return void 0;
    }
    const tick = {
      vgMark: "rect",
      encodeEntry: (model) => {
        const { config, markDef } = model;
        const orient2 = markDef.orient;
        const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
        const vgThicknessChannel = orient2 === "horizontal" ? "height" : "width";
        return {
          ...baseEncodeEntry(model, {
            align: "ignore",
            baseline: "ignore",
            color: "include",
            orient: "ignore",
            size: "ignore",
            theta: "ignore"
          }),
          ...pointPosition("x", model, { defaultPos: "mid", vgChannel: "xc" }),
          ...pointPosition("y", model, { defaultPos: "mid", vgChannel: "yc" }),
          // size / thickness => width / height
          ...nonPosition("size", model, {
            defaultValue: defaultSize(model),
            vgChannel: vgSizeChannel
          }),
          [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config))
        };
      }
    };
    function defaultSize(model) {
      const { config, markDef } = model;
      const { orient: orient2 } = markDef;
      const vgSizeChannel = orient2 === "horizontal" ? "width" : "height";
      const scale2 = model.getScaleComponent(orient2 === "horizontal" ? "x" : "y");
      const markPropOrConfig = getMarkPropOrConfig("size", markDef, config, { vgChannel: vgSizeChannel }) ?? config.tick.bandSize;
      if (markPropOrConfig !== void 0) {
        return markPropOrConfig;
      } else {
        const scaleRange = scale2 ? scale2.get("range") : void 0;
        if (scaleRange && isVgRangeStep(scaleRange) && isNumber$1(scaleRange.step)) {
          return scaleRange.step * 3 / 4;
        }
        const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
        return defaultViewStep * 3 / 4;
      }
    }
    const markCompiler = {
      arc,
      area,
      bar,
      circle,
      geoshape,
      image,
      line,
      point,
      rect,
      rule,
      square,
      text,
      tick,
      trail
    };
    function parseMarkGroups(model) {
      if (contains([LINE, AREA, TRAIL], model.mark)) {
        const details2 = pathGroupingFields(model.mark, model.encoding);
        if (details2.length > 0) {
          return getPathGroups(model, details2);
        }
      } else if (model.mark === BAR) {
        const hasCornerRadius2 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
        if (model.stack && !model.fieldDef("size") && hasCornerRadius2) {
          return getGroupsForStackedBarWithCornerRadius(model);
        }
      }
      return getMarkGroup(model);
    }
    const FACETED_PATH_PREFIX = "faceted_path_";
    function getPathGroups(model, details2) {
      return [
        {
          name: model.getName("pathgroup"),
          type: "group",
          from: {
            facet: {
              name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),
              data: model.requestDataName(DataSourceType.Main),
              groupby: details2
            }
          },
          encode: {
            update: {
              width: { field: { group: "width" } },
              height: { field: { group: "height" } }
            }
          },
          // With subfacet for line/area group, need to use faceted data from above.
          marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })
        }
      ];
    }
    const STACK_GROUP_PREFIX = "stack_group_";
    function getGroupsForStackedBarWithCornerRadius(model) {
      var _a2;
      const [mark] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });
      const fieldScale = model.scaleName(model.stack.fieldChannel);
      const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
      const stackFieldGroup = (func2, expr2) => {
        const vgFieldMinMax = [
          stackField({ prefix: "min", suffix: "start", expr: expr2 }),
          stackField({ prefix: "max", suffix: "start", expr: expr2 }),
          stackField({ prefix: "min", suffix: "end", expr: expr2 }),
          stackField({ prefix: "max", suffix: "end", expr: expr2 })
        ];
        return `${func2}(${vgFieldMinMax.map((field2) => `scale('${fieldScale}',${field2})`).join(",")})`;
      };
      let groupUpdate;
      let innerGroupUpdate;
      if (model.stack.fieldChannel === "x") {
        groupUpdate = {
          ...pick(mark.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS]),
          x: { signal: stackFieldGroup("min", "datum") },
          x2: { signal: stackFieldGroup("max", "datum") },
          clip: { value: true }
        };
        innerGroupUpdate = {
          x: { field: { group: "x" }, mult: -1 },
          height: { field: { group: "height" } }
        };
        mark.encode.update = {
          ...omit(mark.encode.update, ["y", "yc", "y2"]),
          height: { field: { group: "height" } }
        };
      } else {
        groupUpdate = {
          ...pick(mark.encode.update, ["x", "xc", "x2", "width"]),
          y: { signal: stackFieldGroup("min", "datum") },
          y2: { signal: stackFieldGroup("max", "datum") },
          clip: { value: true }
        };
        innerGroupUpdate = {
          y: { field: { group: "y" }, mult: -1 },
          width: { field: { group: "width" } }
        };
        mark.encode.update = {
          ...omit(mark.encode.update, ["x", "xc", "x2"]),
          width: { field: { group: "width" } }
        };
      }
      for (const key2 of VG_CORNERRADIUS_CHANNELS) {
        const configValue = getMarkConfig(key2, model.markDef, model.config);
        if (mark.encode.update[key2]) {
          groupUpdate[key2] = mark.encode.update[key2];
          delete mark.encode.update[key2];
        } else if (configValue) {
          groupUpdate[key2] = signalOrValueRef(configValue);
        }
        if (configValue) {
          mark.encode.update[key2] = { value: 0 };
        }
      }
      const groupby = [];
      if (((_a2 = model.stack.groupbyChannels) == null ? void 0 : _a2.length) > 0) {
        for (const groupbyChannel of model.stack.groupbyChannels) {
          const groupByField = model.fieldDef(groupbyChannel);
          const field2 = vgField(groupByField);
          if (field2) {
            groupby.push(field2);
          }
          if ((groupByField == null ? void 0 : groupByField.bin) || (groupByField == null ? void 0 : groupByField.timeUnit)) {
            groupby.push(vgField(groupByField, { binSuffix: "end" }));
          }
        }
      }
      const strokeProperties = [
        "stroke",
        "strokeWidth",
        "strokeJoin",
        "strokeCap",
        "strokeDash",
        "strokeDashOffset",
        "strokeMiterLimit",
        "strokeOpacity"
      ];
      groupUpdate = strokeProperties.reduce((encode2, prop) => {
        if (mark.encode.update[prop]) {
          return { ...encode2, [prop]: mark.encode.update[prop] };
        } else {
          const configValue = getMarkConfig(prop, model.markDef, model.config);
          if (configValue !== void 0) {
            return { ...encode2, [prop]: signalOrValueRef(configValue) };
          } else {
            return encode2;
          }
        }
      }, groupUpdate);
      if (groupUpdate.stroke) {
        groupUpdate.strokeForeground = { value: true };
        groupUpdate.strokeOffset = { value: 0 };
      }
      return [
        {
          type: "group",
          from: {
            facet: {
              data: model.requestDataName(DataSourceType.Main),
              name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),
              groupby,
              aggregate: {
                fields: [
                  stackField({ suffix: "start" }),
                  stackField({ suffix: "start" }),
                  stackField({ suffix: "end" }),
                  stackField({ suffix: "end" })
                ],
                ops: ["min", "max", "min", "max"]
              }
            }
          },
          encode: {
            update: groupUpdate
          },
          marks: [
            {
              type: "group",
              encode: { update: innerGroupUpdate },
              marks: [mark]
            }
          ]
        }
      ];
    }
    function getSort(model) {
      var _a2;
      const { encoding, stack: stack2, mark, markDef, config } = model;
      const order = encoding.order;
      if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
        return void 0;
      } else if ((isArray(order) || isFieldDef(order)) && !stack2) {
        return sortParams(order, { expr: "datum" });
      } else if (isPathMark(mark)) {
        const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
        const dimensionChannelDef = encoding[dimensionChannel];
        if (isFieldDef(dimensionChannelDef)) {
          const s = dimensionChannelDef.sort;
          if (isArray(s)) {
            return {
              field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: "sort_index", expr: "datum" })
            };
          } else if (isSortField(s)) {
            return {
              field: vgField({
                // FIXME: this op might not already exist?
                // FIXME: what if dimensionChannel (x or y) contains custom domain?
                aggregate: isAggregate$1(model.encoding) ? s.op : void 0,
                field: s.field
              }, { expr: "datum" })
            };
          } else if (isSortByEncoding(s)) {
            const fieldDefToSort = model.fieldDef(s.encoding);
            return {
              field: vgField(fieldDefToSort, { expr: "datum" }),
              order: s.order
            };
          } else if (s === null) {
            return void 0;
          } else {
            return {
              field: vgField(dimensionChannelDef, {
                // For stack with imputation, we only have bin_mid
                binSuffix: ((_a2 = model.stack) == null ? void 0 : _a2.impute) ? "mid" : void 0,
                expr: "datum"
              })
            };
          }
        }
        return void 0;
      }
      return void 0;
    }
    function getMarkGroup(model, opt = { fromPrefix: "" }) {
      const { mark, markDef, encoding, config } = model;
      const clip2 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
      const style2 = getStyles(markDef);
      const key2 = encoding.key;
      const sort2 = getSort(model);
      const interactive2 = interactiveFlag(model);
      const aria2 = getMarkPropOrConfig("aria", markDef, config);
      const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;
      return [
        {
          name: model.getName("marks"),
          type: markCompiler[mark].vgMark,
          ...clip2 ? { clip: true } : {},
          ...style2 ? { style: style2 } : {},
          ...key2 ? { key: key2.field } : {},
          ...sort2 ? { sort: sort2 } : {},
          ...interactive2 ? interactive2 : {},
          ...aria2 === false ? { aria: aria2 } : {},
          from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) },
          encode: {
            update: markCompiler[mark].encodeEntry(model)
          },
          ...postEncodingTransform ? {
            transform: postEncodingTransform
          } : {}
        }
      ];
    }
    function scaleClip(model) {
      const xScale = model.getScaleComponent("x");
      const yScale = model.getScaleComponent("y");
      return (xScale == null ? void 0 : xScale.get("selectionExtent")) || (yScale == null ? void 0 : yScale.get("selectionExtent")) ? true : void 0;
    }
    function projectionClip(model) {
      const projection2 = model.component.projection;
      return projection2 && !projection2.isFit ? true : void 0;
    }
    function interactiveFlag(model) {
      if (!model.component.selection)
        return null;
      const unitCount = keys(model.component.selection).length;
      let parentCount = unitCount;
      let parent = model.parent;
      while (parent && parentCount === 0) {
        parentCount = keys(parent.component.selection).length;
        parent = parent.parent;
      }
      return parentCount ? {
        interactive: unitCount > 0 || model.mark === "geoshape" || !!model.encoding.tooltip
      } : null;
    }
    class UnitModel extends ModelWithField {
      constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
        super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
        this.specifiedScales = {};
        this.specifiedAxes = {};
        this.specifiedLegends = {};
        this.specifiedProjection = {};
        this.selection = [];
        this.children = [];
        const markDef = isMarkDef(spec.mark) ? { ...spec.mark } : { type: spec.mark };
        const mark = markDef.type;
        if (markDef.filled === void 0) {
          markDef.filled = defaultFilled(markDef, config, {
            graticule: spec.data && isGraticuleGenerator(spec.data)
          });
        }
        const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);
        this.markDef = initMarkdef(markDef, encoding, config);
        this.size = initLayoutSize({
          encoding,
          size: isFrameMixins(spec) ? {
            ...parentGivenSize,
            ...spec.width ? { width: spec.width } : {},
            ...spec.height ? { height: spec.height } : {}
          } : parentGivenSize
        });
        this.stack = stack(this.markDef, encoding);
        this.specifiedScales = this.initScales(mark, encoding);
        this.specifiedAxes = this.initAxes(encoding);
        this.specifiedLegends = this.initLegends(encoding);
        this.specifiedProjection = spec.projection;
        this.selection = (spec.params ?? []).filter((p) => isSelectionParameter(p));
      }
      get hasProjection() {
        const { encoding } = this;
        const isGeoShapeMark = this.mark === GEOSHAPE;
        const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
        return isGeoShapeMark || hasGeoPosition;
      }
      /**
       * Return specified Vega-Lite scale domain for a particular channel
       * @param channel
       */
      scaleDomain(channel) {
        const scale2 = this.specifiedScales[channel];
        return scale2 ? scale2.domain : void 0;
      }
      axis(channel) {
        return this.specifiedAxes[channel];
      }
      legend(channel) {
        return this.specifiedLegends[channel];
      }
      initScales(mark, encoding) {
        return SCALE_CHANNELS.reduce((scales2, channel) => {
          const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          if (fieldOrDatumDef) {
            scales2[channel] = this.initScale(fieldOrDatumDef.scale ?? {});
          }
          return scales2;
        }, {});
      }
      initScale(scale2) {
        const { domain: domain2, range: range2 } = scale2;
        const scaleInternal = replaceExprRef(scale2);
        if (isArray(domain2)) {
          scaleInternal.domain = domain2.map(signalRefOrValue);
        }
        if (isArray(range2)) {
          scaleInternal.range = range2.map(signalRefOrValue);
        }
        return scaleInternal;
      }
      initAxes(encoding) {
        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
          const channelDef = encoding[channel];
          if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {
            const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
            _axis[channel] = axisSpec ? this.initAxis({ ...axisSpec }) : axisSpec;
          }
          return _axis;
        }, {});
      }
      initAxis(axis2) {
        const props = keys(axis2);
        const axisInternal = {};
        for (const prop of props) {
          const val = axis2[prop];
          axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
        }
        return axisInternal;
      }
      initLegends(encoding) {
        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
          const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          if (fieldOrDatumDef && supportLegend(channel)) {
            const legend = fieldOrDatumDef.legend;
            _legend[channel] = legend ? replaceExprRef(legend) : legend;
          }
          return _legend;
        }, {});
      }
      parseData() {
        this.component.data = parseData(this);
      }
      parseLayoutSize() {
        parseUnitLayoutSize(this);
      }
      parseSelections() {
        this.component.selection = parseUnitSelection(this, this.selection);
      }
      parseMarkGroup() {
        this.component.mark = parseMarkGroups(this);
      }
      parseAxesAndHeaders() {
        this.component.axes = parseUnitAxes(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return assembleTopLevelSignals(this, signals);
      }
      assembleSignals() {
        return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
      }
      assembleSelectionData(data2) {
        return assembleUnitSelectionData(this, data2);
      }
      assembleLayout() {
        return null;
      }
      assembleLayoutSignals() {
        return assembleLayoutSignals(this);
      }
      assembleMarks() {
        let marks = this.component.mark ?? [];
        if (!this.parent || !isLayerModel(this.parent)) {
          marks = assembleUnitSelectionMarks(this, marks);
        }
        return marks.map(this.correctDataNames);
      }
      assembleGroupStyle() {
        const { style: style2 } = this.view || {};
        if (style2 !== void 0) {
          return style2;
        }
        if (this.encoding.x || this.encoding.y) {
          return "cell";
        } else {
          return "view";
        }
      }
      getMapping() {
        return this.encoding;
      }
      get mark() {
        return this.markDef.type;
      }
      channelHasField(channel) {
        return channelHasField(this.encoding, channel);
      }
      fieldDef(channel) {
        const channelDef = this.encoding[channel];
        return getFieldDef(channelDef);
      }
      typedFieldDef(channel) {
        const fieldDef = this.fieldDef(channel);
        if (isTypedFieldDef(fieldDef)) {
          return fieldDef;
        }
        return null;
      }
    }
    class LayerModel extends Model {
      constructor(spec, parent, parentGivenName, parentGivenSize, config) {
        super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
        const layoutSize = {
          ...parentGivenSize,
          ...spec.width ? { width: spec.width } : {},
          ...spec.height ? { height: spec.height } : {}
        };
        this.children = spec.layer.map((layer, i) => {
          if (isLayerSpec(layer)) {
            return new LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
          } else if (isUnitSpec(layer)) {
            return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
          }
          throw new Error(invalidSpec(layer));
        });
      }
      parseData() {
        this.component.data = parseData(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseLayoutSize() {
        parseLayerLayoutSize(this);
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key2 of keys(child.component.selection)) {
            this.component.selection[key2] = child.component.selection[key2];
          }
        }
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        parseLayerAxes(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      // TODO: Support same named selections across children.
      assembleSignals() {
        return this.children.reduce((signals, child) => {
          return signals.concat(child.assembleSignals());
        }, assembleAxisSignals(this));
      }
      assembleLayoutSignals() {
        return this.children.reduce((signals, child) => {
          return signals.concat(child.assembleLayoutSignals());
        }, assembleLayoutSignals(this));
      }
      assembleSelectionData(data2) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data2);
      }
      assembleGroupStyle() {
        const uniqueStyles = /* @__PURE__ */ new Set();
        for (const child of this.children) {
          for (const style2 of array$2(child.assembleGroupStyle())) {
            uniqueStyles.add(style2);
          }
        }
        const styles = Array.from(uniqueStyles);
        return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : void 0;
      }
      assembleTitle() {
        let title2 = super.assembleTitle();
        if (title2) {
          return title2;
        }
        for (const child of this.children) {
          title2 = child.assembleTitle();
          if (title2) {
            return title2;
          }
        }
        return void 0;
      }
      assembleLayout() {
        return null;
      }
      assembleMarks() {
        return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
          return child.assembleMarks();
        }));
      }
      assembleLegends() {
        return this.children.reduce((legends, child) => {
          return legends.concat(child.assembleLegends());
        }, assembleLegends(this));
      }
    }
    function buildModel(spec, parent, parentGivenName, unitSize, config) {
      if (isFacetSpec(spec)) {
        return new FacetModel(spec, parent, parentGivenName, config);
      } else if (isLayerSpec(spec)) {
        return new LayerModel(spec, parent, parentGivenName, unitSize, config);
      } else if (isUnitSpec(spec)) {
        return new UnitModel(spec, parent, parentGivenName, unitSize, config);
      } else if (isAnyConcatSpec(spec)) {
        return new ConcatModel(spec, parent, parentGivenName, config);
      }
      throw new Error(invalidSpec(spec));
    }
    function compile(inputSpec, opt = {}) {
      if (opt.logger) {
        set(opt.logger);
      }
      if (opt.fieldTitle) {
        setTitleFormatter(opt.fieldTitle);
      }
      try {
        const config = initConfig(mergeConfig(opt.config, inputSpec.config));
        const spec = normalize(inputSpec, config);
        const model = buildModel(spec, null, "", void 0, config);
        model.parse();
        optimizeDataflow(model.component.data, model);
        const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
        return {
          spec: vgSpec,
          normalized: spec
        };
      } finally {
        if (opt.logger) {
          reset();
        }
        if (opt.fieldTitle) {
          resetTitleFormatter();
        }
      }
    }
    function getTopLevelProperties(inputSpec, autosize, config, model) {
      const width2 = model.component.layoutSize.get("width");
      const height2 = model.component.layoutSize.get("height");
      if (autosize === void 0) {
        autosize = { type: "pad" };
        if (model.hasAxisOrientSignalRef()) {
          autosize.resize = true;
        }
      } else if (isString(autosize)) {
        autosize = { type: autosize };
      }
      if (width2 && height2 && isFitType(autosize.type)) {
        if (width2 === "step" && height2 === "step") {
          warn(droppingFit());
          autosize.type = "pad";
        } else if (width2 === "step" || height2 === "step") {
          const sizeType = width2 === "step" ? "width" : "height";
          warn(droppingFit(getPositionScaleChannel(sizeType)));
          const inverseSizeType = sizeType === "width" ? "height" : "width";
          autosize.type = getFitType(inverseSizeType);
        }
      }
      return {
        ...keys(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize },
        ...extractTopLevelProperties(config, false),
        ...extractTopLevelProperties(inputSpec, true)
      };
    }
    function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
      const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
      const data2 = [].concat(
        model.assembleSelectionData([]),
        // only assemble data in the root
        assembleRootData(model.component.data, datasets)
      );
      const projections2 = model.assembleProjections();
      const title2 = model.assembleTitle();
      const style2 = model.assembleGroupStyle();
      const encodeEntry2 = model.assembleGroupEncodeEntry(true);
      let layoutSignals = model.assembleLayoutSignals();
      layoutSignals = layoutSignals.filter((signal) => {
        if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
          topLevelProperties[signal.name] = +signal.value;
          return false;
        }
        return true;
      });
      const { params: params2, ...otherTopLevelProps } = topLevelProperties;
      return {
        $schema: "https://vega.github.io/schema/vega/v5.json",
        ...model.description ? { description: model.description } : {},
        ...otherTopLevelProps,
        ...title2 ? { title: title2 } : {},
        ...style2 ? { style: style2 } : {},
        ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
        data: data2,
        ...projections2.length > 0 ? { projections: projections2 } : {},
        ...model.assembleGroup([
          ...layoutSignals,
          ...model.assembleSelectionTopLevelSignals([]),
          ...assembleParameterSignals(params2)
        ]),
        ...vgConfig ? { config: vgConfig } : {},
        ...usermeta ? { usermeta } : {}
      };
    }
    const version$2 = pkg$1.version;
    const vegaLiteImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      accessPathDepth,
      accessPathWithDatum,
      compile,
      contains,
      deepEqual,
      deleteNestedProperty,
      duplicate,
      entries: entries$1,
      every,
      fieldIntersection,
      flatAccessWithDatum,
      getFirstDefined,
      hasIntersection,
      hash,
      internalField,
      isBoolean,
      isEmpty,
      isEqual,
      isInternalField,
      isNullOrFalse,
      isNumeric,
      keys,
      logicalExpr,
      mergeDeep: mergeDeep$1,
      never,
      normalize,
      normalizeAngle,
      omit,
      pick,
      prefixGenerator,
      removePathFromField,
      replaceAll,
      replacePathInField,
      resetIdCounter,
      setEqual,
      some,
      stringify: stringify$1,
      titleCase,
      unique,
      uniqueId,
      vals,
      varName,
      version: version$2
    }, Symbol.toStringTag, { value: "Module" }));
    function e(e3) {
      const [n, r] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e3).slice(1, 3);
      return { library: n, version: r };
    }
    var name = "vega-themes";
    var version$1 = "2.14.0";
    var description = "Themes for stylized Vega and Vega-Lite visualizations.";
    var keywords = ["vega", "vega-lite", "themes", "style"];
    var license = "BSD-3-Clause";
    var author = {
      name: "UW Interactive Data Lab",
      url: "https://idl.cs.washington.edu"
    };
    var contributors = [{
      name: "Emily Gu",
      url: "https://github.com/emilygu"
    }, {
      name: "Arvind Satyanarayan",
      url: "http://arvindsatya.com"
    }, {
      name: "Jeffrey Heer",
      url: "https://idl.cs.washington.edu"
    }, {
      name: "Dominik Moritz",
      url: "https://www.domoritz.de"
    }];
    var main = "build/vega-themes.js";
    var module = "build/vega-themes.module.js";
    var unpkg = "build/vega-themes.min.js";
    var jsdelivr = "build/vega-themes.min.js";
    var types = "build/vega-themes.module.d.ts";
    var repository = {
      type: "git",
      url: "https://github.com/vega/vega-themes.git"
    };
    var files = ["src", "build"];
    var scripts = {
      prebuild: "yarn clean",
      build: "rollup -c",
      clean: "rimraf build && rimraf examples/build",
      "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
      "copy:build": "rsync -r build/* examples/build",
      "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
      preversion: "yarn lint",
      serve: "browser-sync start -s -f build examples --serveStatic examples",
      start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
      format: "eslint . --fix",
      lint: "eslint .",
      release: "release-it"
    };
    var devDependencies = {
      "@babel/core": "^7.22.9",
      "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
      "@babel/plugin-proposal-json-strings": "^7.18.6",
      "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
      "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
      "@babel/plugin-transform-runtime": "^7.22.9",
      "@babel/preset-env": "^7.22.9",
      "@babel/preset-typescript": "^7.22.5",
      "@release-it/conventional-changelog": "^7.0.0",
      "@rollup/plugin-json": "^6.0.0",
      "@rollup/plugin-node-resolve": "^15.1.0",
      "@rollup/plugin-terser": "^0.4.3",
      "@typescript-eslint/eslint-plugin": "^6.0.0",
      "@typescript-eslint/parser": "^6.0.0",
      "browser-sync": "^2.29.3",
      concurrently: "^8.2.0",
      eslint: "^8.45.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-prettier": "^5.0.0",
      "gh-pages": "^5.0.0",
      prettier: "^3.0.0",
      "release-it": "^16.1.0",
      rollup: "^3.26.2",
      "rollup-plugin-bundle-size": "^1.0.3",
      "rollup-plugin-ts": "^3.2.0",
      typescript: "^5.1.6",
      vega: "^5.25.0",
      "vega-lite": "^5.9.3"
    };
    var peerDependencies = {
      vega: "*",
      "vega-lite": "*"
    };
    var dependencies = {};
    var pkg = {
      name,
      version: version$1,
      description,
      keywords,
      license,
      author,
      contributors,
      main,
      module,
      unpkg,
      jsdelivr,
      types,
      repository,
      files,
      scripts,
      devDependencies,
      peerDependencies,
      dependencies
    };
    const lightColor = "#fff";
    const medColor = "#888";
    const darkTheme = {
      background: "#333",
      view: {
        stroke: medColor
      },
      title: {
        color: lightColor,
        subtitleColor: lightColor
      },
      style: {
        "guide-label": {
          fill: lightColor
        },
        "guide-title": {
          fill: lightColor
        }
      },
      axis: {
        domainColor: lightColor,
        gridColor: medColor,
        tickColor: lightColor
      }
    };
    const markColor$7 = "#4572a7";
    const excelTheme = {
      background: "#fff",
      arc: {
        fill: markColor$7
      },
      area: {
        fill: markColor$7
      },
      line: {
        stroke: markColor$7,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$7
      },
      rect: {
        fill: markColor$7
      },
      shape: {
        stroke: markColor$7
      },
      symbol: {
        fill: markColor$7,
        strokeWidth: 1.5,
        size: 50
      },
      axis: {
        bandPosition: 0.5,
        grid: true,
        gridColor: "#000000",
        gridOpacity: 1,
        gridWidth: 0.5,
        labelPadding: 10,
        tickSize: 5,
        tickWidth: 0.5
      },
      axisBand: {
        grid: false,
        tickExtra: true
      },
      legend: {
        labelBaseline: "middle",
        labelFontSize: 11,
        symbolSize: 50,
        symbolType: "square"
      },
      range: {
        category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
      }
    };
    const markColor$6 = "#30a2da";
    const axisColor$2 = "#cbcbcb";
    const guideLabelColor = "#999";
    const guideTitleColor = "#333";
    const backgroundColor$2 = "#f0f0f0";
    const blackTitle = "#333";
    const fiveThirtyEightTheme = {
      arc: {
        fill: markColor$6
      },
      area: {
        fill: markColor$6
      },
      axis: {
        domainColor: axisColor$2,
        grid: true,
        gridColor: axisColor$2,
        gridWidth: 1,
        labelColor: guideLabelColor,
        labelFontSize: 10,
        titleColor: guideTitleColor,
        tickColor: axisColor$2,
        tickSize: 10,
        titleFontSize: 14,
        titlePadding: 10,
        labelPadding: 4
      },
      axisBand: {
        grid: false
      },
      background: backgroundColor$2,
      group: {
        fill: backgroundColor$2
      },
      legend: {
        labelColor: blackTitle,
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: "square",
        titleColor: blackTitle,
        titleFontSize: 14,
        titlePadding: 10
      },
      line: {
        stroke: markColor$6,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$6,
        strokeWidth: 0.5
      },
      rect: {
        fill: markColor$6
      },
      range: {
        category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
        diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
        heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
      },
      point: {
        filled: true,
        shape: "circle"
      },
      shape: {
        stroke: markColor$6
      },
      bar: {
        binSpacing: 2,
        fill: markColor$6,
        stroke: null
      },
      title: {
        anchor: "start",
        fontSize: 24,
        fontWeight: 600,
        offset: 20
      }
    };
    const markColor$5 = "#000";
    const ggplot2Theme = {
      group: {
        fill: "#e5e5e5"
      },
      arc: {
        fill: markColor$5
      },
      area: {
        fill: markColor$5
      },
      line: {
        stroke: markColor$5
      },
      path: {
        stroke: markColor$5
      },
      rect: {
        fill: markColor$5
      },
      shape: {
        stroke: markColor$5
      },
      symbol: {
        fill: markColor$5,
        size: 40
      },
      axis: {
        domain: false,
        grid: true,
        gridColor: "#FFFFFF",
        gridOpacity: 1,
        labelColor: "#7F7F7F",
        labelPadding: 4,
        tickColor: "#7F7F7F",
        tickSize: 5.67,
        titleFontSize: 16,
        titleFontWeight: "normal"
      },
      legend: {
        labelBaseline: "middle",
        labelFontSize: 11,
        symbolSize: 40
      },
      range: {
        category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
      }
    };
    const headlineFontSize = 22;
    const headlineFontWeight = "normal";
    const labelFont$1 = "Benton Gothic, sans-serif";
    const labelFontSize = 11.5;
    const labelFontWeight = "normal";
    const markColor$4 = "#82c6df";
    const titleFont = "Benton Gothic Bold, sans-serif";
    const titleFontWeight = "normal";
    const titleFontSize$1 = 13;
    const colorSchemes$1 = {
      "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
      "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
      "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
      "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
    };
    const latimesTheme = {
      background: "#ffffff",
      title: {
        anchor: "start",
        color: "#000000",
        font: titleFont,
        fontSize: headlineFontSize,
        fontWeight: headlineFontWeight
      },
      arc: {
        fill: markColor$4
      },
      area: {
        fill: markColor$4
      },
      line: {
        stroke: markColor$4,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$4
      },
      rect: {
        fill: markColor$4
      },
      shape: {
        stroke: markColor$4
      },
      symbol: {
        fill: markColor$4,
        size: 30
      },
      axis: {
        labelFont: labelFont$1,
        labelFontSize,
        labelFontWeight,
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight
      },
      axisX: {
        labelAngle: 0,
        labelPadding: 4,
        tickSize: 3
      },
      axisY: {
        labelBaseline: "middle",
        maxExtent: 45,
        minExtent: 45,
        tickSize: 2,
        titleAlign: "left",
        titleAngle: 0,
        titleX: -45,
        titleY: -11
      },
      legend: {
        labelFont: labelFont$1,
        labelFontSize,
        symbolType: "square",
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight
      },
      range: {
        category: colorSchemes$1["category-6"],
        diverging: colorSchemes$1["fireandice-6"],
        heatmap: colorSchemes$1["fire-7"],
        ordinal: colorSchemes$1["fire-7"],
        ramp: colorSchemes$1["fire-7"]
      }
    };
    const markColor$3 = "#ab5787";
    const axisColor$1 = "#979797";
    const quartzTheme = {
      background: "#f9f9f9",
      arc: {
        fill: markColor$3
      },
      area: {
        fill: markColor$3
      },
      line: {
        stroke: markColor$3
      },
      path: {
        stroke: markColor$3
      },
      rect: {
        fill: markColor$3
      },
      shape: {
        stroke: markColor$3
      },
      symbol: {
        fill: markColor$3,
        size: 30
      },
      axis: {
        domainColor: axisColor$1,
        domainWidth: 0.5,
        gridWidth: 0.2,
        labelColor: axisColor$1,
        tickColor: axisColor$1,
        tickWidth: 0.2,
        titleColor: axisColor$1
      },
      axisBand: {
        grid: false
      },
      axisX: {
        grid: true,
        tickSize: 10
      },
      axisY: {
        domain: false,
        grid: true,
        tickSize: 0
      },
      legend: {
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: "square"
      },
      range: {
        category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
      }
    };
    const markColor$2 = "#3e5c69";
    const voxTheme = {
      background: "#fff",
      arc: {
        fill: markColor$2
      },
      area: {
        fill: markColor$2
      },
      line: {
        stroke: markColor$2
      },
      path: {
        stroke: markColor$2
      },
      rect: {
        fill: markColor$2
      },
      shape: {
        stroke: markColor$2
      },
      symbol: {
        fill: markColor$2
      },
      axis: {
        domainWidth: 0.5,
        grid: true,
        labelPadding: 2,
        tickSize: 5,
        tickWidth: 0.5,
        titleFontWeight: "normal"
      },
      axisBand: {
        grid: false
      },
      axisX: {
        gridWidth: 0.2
      },
      axisY: {
        gridDash: [3],
        gridWidth: 0.4
      },
      legend: {
        labelFontSize: 11,
        padding: 1,
        symbolType: "square"
      },
      range: {
        category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
      }
    };
    const markColor$1 = "#1696d2";
    const axisColor = "#000000";
    const backgroundColor$1 = "#FFFFFF";
    const font = "Lato";
    const labelFont = "Lato";
    const sourceFont = "Lato";
    const gridColor$1 = "#DEDDDD";
    const titleFontSize = 18;
    const colorSchemes = {
      "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
      "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
      "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
      "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
      "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
      "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
      "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
      "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
      "one-group": ["#1696d2", "#000000"],
      "two-groups-cat-1": ["#1696d2", "#000000"],
      "two-groups-cat-2": ["#1696d2", "#fdbf11"],
      "two-groups-cat-3": ["#1696d2", "#db2b27"],
      "two-groups-seq": ["#a2d4ec", "#1696d2"],
      "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
      "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
      "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
      "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
      "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
      "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
      "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
      "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
      "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
      "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
      "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
      "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
    };
    const urbanInstituteTheme = {
      background: backgroundColor$1,
      title: {
        anchor: "start",
        fontSize: titleFontSize,
        font
      },
      axisX: {
        domain: true,
        domainColor: axisColor,
        domainWidth: 1,
        grid: false,
        labelFontSize: 12,
        labelFont,
        labelAngle: 0,
        tickColor: axisColor,
        tickSize: 5,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font
      },
      axisY: {
        domain: false,
        domainWidth: 1,
        grid: true,
        gridColor: gridColor$1,
        gridWidth: 1,
        labelFontSize: 12,
        labelFont,
        labelPadding: 8,
        ticks: false,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        titleAngle: 0,
        titleY: -10,
        titleX: 18
      },
      legend: {
        labelFontSize: 12,
        labelFont,
        symbolSize: 100,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        orient: "right",
        offset: 10
      },
      view: {
        stroke: "transparent"
      },
      range: {
        category: colorSchemes["six-groups-cat-1"],
        diverging: colorSchemes["diverging-colors"],
        heatmap: colorSchemes["diverging-colors"],
        ordinal: colorSchemes["six-groups-seq"],
        ramp: colorSchemes["shades-blue"]
      },
      area: {
        fill: markColor$1
      },
      rect: {
        fill: markColor$1
      },
      line: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 5
      },
      trail: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 0,
        size: 1
      },
      path: {
        stroke: markColor$1,
        strokeWidth: 0.5
      },
      point: {
        filled: true
      },
      text: {
        font: sourceFont,
        color: markColor$1,
        fontSize: 11,
        align: "center",
        fontWeight: 400,
        size: 11
      },
      style: {
        bar: {
          fill: markColor$1,
          stroke: null
        }
      },
      arc: {
        fill: markColor$1
      },
      shape: {
        stroke: markColor$1
      },
      symbol: {
        fill: markColor$1,
        size: 30
      }
    };
    const markColor = "#3366CC";
    const gridColor = "#ccc";
    const defaultFont$1 = "Arial, sans-serif";
    const googlechartsTheme = {
      arc: {
        fill: markColor
      },
      area: {
        fill: markColor
      },
      path: {
        stroke: markColor
      },
      rect: {
        fill: markColor
      },
      shape: {
        stroke: markColor
      },
      symbol: {
        stroke: markColor
      },
      circle: {
        fill: markColor
      },
      background: "#fff",
      padding: {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
      },
      style: {
        "guide-label": {
          font: defaultFont$1,
          fontSize: 12
        },
        "guide-title": {
          font: defaultFont$1,
          fontSize: 12
        },
        "group-title": {
          font: defaultFont$1,
          fontSize: 12
        }
      },
      title: {
        font: defaultFont$1,
        fontSize: 14,
        fontWeight: "bold",
        dy: -3,
        anchor: "start"
      },
      axis: {
        gridColor,
        tickColor: gridColor,
        domain: false,
        grid: true
      },
      range: {
        category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
        heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
      }
    };
    const ptToPx = (value2) => value2 * (1 / 3 + 1);
    const fontSmallPx = ptToPx(9);
    const legendFontPx = ptToPx(10);
    const fontLargePx = ptToPx(12);
    const fontStandard = "Segoe UI";
    const fontTitle = "wf_standard-font, helvetica, arial, sans-serif";
    const firstLevelElementColor = "#252423";
    const secondLevelElementColor = "#605E5C";
    const backgroundColor = "transparent";
    const backgroundSecondaryColor = "#C8C6C4";
    const paletteColor1 = "#118DFF";
    const paletteColor2 = "#12239E";
    const paletteColor3 = "#E66C37";
    const paletteColor4 = "#6B007B";
    const paletteColor5 = "#E044A7";
    const paletteColor6 = "#744EC2";
    const paletteColor7 = "#D9B300";
    const paletteColor8 = "#D64550";
    const divergentColorMax = paletteColor1;
    const divergentColorMin = "#DEEFFF";
    const divergentPalette = [divergentColorMin, divergentColorMax];
    const ordinalPalette = [divergentColorMin, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", divergentColorMax];
    const powerbiTheme = {
      view: {
        stroke: backgroundColor
      },
      background: backgroundColor,
      font: fontStandard,
      header: {
        titleFont: fontTitle,
        titleFontSize: fontLargePx,
        titleColor: firstLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor
      },
      axis: {
        ticks: false,
        grid: false,
        domain: false,
        labelColor: secondLevelElementColor,
        labelFontSize: fontSmallPx,
        titleFont: fontTitle,
        titleColor: firstLevelElementColor,
        titleFontSize: fontLargePx,
        titleFontWeight: "normal"
      },
      axisQuantitative: {
        tickCount: 3,
        grid: true,
        gridColor: backgroundSecondaryColor,
        gridDash: [1, 5],
        labelFlush: false
      },
      axisBand: {
        tickExtra: true
      },
      axisX: {
        labelPadding: 5
      },
      axisY: {
        labelPadding: 10
      },
      bar: {
        fill: paletteColor1
      },
      line: {
        stroke: paletteColor1,
        strokeWidth: 3,
        strokeCap: "round",
        strokeJoin: "round"
      },
      text: {
        font: fontStandard,
        fontSize: fontSmallPx,
        fill: secondLevelElementColor
      },
      arc: {
        fill: paletteColor1
      },
      area: {
        fill: paletteColor1,
        line: true,
        opacity: 0.6
      },
      path: {
        stroke: paletteColor1
      },
      rect: {
        fill: paletteColor1
      },
      point: {
        fill: paletteColor1,
        filled: true,
        size: 75
      },
      shape: {
        stroke: paletteColor1
      },
      symbol: {
        fill: paletteColor1,
        strokeWidth: 1.5,
        size: 50
      },
      legend: {
        titleFont: fontStandard,
        titleFontWeight: "bold",
        titleColor: secondLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor,
        symbolType: "circle",
        symbolSize: 75
      },
      range: {
        category: [paletteColor1, paletteColor2, paletteColor3, paletteColor4, paletteColor5, paletteColor6, paletteColor7, paletteColor8],
        diverging: divergentPalette,
        heatmap: divergentPalette,
        ordinal: ordinalPalette
      }
    };
    const defaultFont = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif';
    const fontWeight = 400;
    const darkCategories = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"];
    const lightCategories = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
    function genCarbonConfig({
      type: type2,
      background: background2
    }) {
      const viewbg = type2 === "dark" ? "#161616" : "#ffffff";
      const textColor = type2 === "dark" ? "#f4f4f4" : "#161616";
      const category2 = type2 === "dark" ? darkCategories : lightCategories;
      const markColor2 = type2 === "dark" ? "#d4bbff" : "#6929c4";
      return {
        background: background2,
        arc: {
          fill: markColor2
        },
        area: {
          fill: markColor2
        },
        path: {
          stroke: markColor2
        },
        rect: {
          fill: markColor2
        },
        shape: {
          stroke: markColor2
        },
        symbol: {
          stroke: markColor2
        },
        circle: {
          fill: markColor2
        },
        view: {
          fill: viewbg,
          stroke: viewbg
        },
        group: {
          fill: viewbg
        },
        title: {
          color: textColor,
          anchor: "start",
          dy: -15,
          fontSize: 16,
          font: defaultFont,
          fontWeight: 600
        },
        axis: {
          labelColor: textColor,
          labelFontSize: 12,
          grid: true,
          gridColor: "#525252",
          titleColor: textColor,
          labelAngle: 0
        },
        style: {
          "guide-label": {
            font: defaultFont,
            fill: textColor,
            fontWeight
          },
          "guide-title": {
            font: defaultFont,
            fill: textColor,
            fontWeight
          }
        },
        range: {
          category: category2,
          diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
          heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
        }
      };
    }
    const carbonwhite = genCarbonConfig({
      type: "light",
      background: "#ffffff"
    });
    const carbong10 = genCarbonConfig({
      type: "light",
      background: "#f4f4f4"
    });
    const carbong90 = genCarbonConfig({
      type: "dark",
      background: "#262626"
    });
    const carbong100 = genCarbonConfig({
      type: "dark",
      background: "#161616"
    });
    const version = pkg.version;
    const themes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      carbong10,
      carbong100,
      carbong90,
      carbonwhite,
      dark: darkTheme,
      excel: excelTheme,
      fivethirtyeight: fiveThirtyEightTheme,
      ggplot2: ggplot2Theme,
      googlecharts: googlechartsTheme,
      latimes: latimesTheme,
      powerbi: powerbiTheme,
      quartz: quartzTheme,
      urbaninstitute: urbanInstituteTheme,
      version,
      vox: voxTheme
    }, Symbol.toStringTag, { value: "Module" }));
    function formatValue(value2, valueToHtml, maxDepth2, baseURL) {
      if (isArray(value2)) {
        return `[${value2.map((v) => valueToHtml(isString(v) ? v : stringify(v, maxDepth2))).join(", ")}]`;
      }
      if (isObject(value2)) {
        let content2 = "";
        const {
          title: title2,
          image: image2,
          ...rest
        } = value2;
        if (title2) {
          content2 += `<h2>${valueToHtml(title2)}</h2>`;
        }
        if (image2) {
          content2 += `<img src="${new URL(valueToHtml(image2), baseURL || location.href).href}">`;
        }
        const keys2 = Object.keys(rest);
        if (keys2.length > 0) {
          content2 += "<table>";
          for (const key2 of keys2) {
            let val = rest[key2];
            if (val === void 0) {
              continue;
            }
            if (isObject(val)) {
              val = stringify(val, maxDepth2);
            }
            content2 += `<tr><td class="key">${valueToHtml(key2)}</td><td class="value">${valueToHtml(val)}</td></tr>`;
          }
          content2 += `</table>`;
        }
        return content2 || "{}";
      }
      return valueToHtml(value2);
    }
    function replacer(maxDepth2) {
      const stack2 = [];
      return function(key2, value2) {
        if (typeof value2 !== "object" || value2 === null) {
          return value2;
        }
        const pos = stack2.indexOf(this) + 1;
        stack2.length = pos;
        if (stack2.length > maxDepth2) {
          return "[Object]";
        }
        if (stack2.indexOf(value2) >= 0) {
          return "[Circular]";
        }
        stack2.push(value2);
        return value2;
      };
    }
    function stringify(obj, maxDepth2) {
      return JSON.stringify(obj, replacer(maxDepth2));
    }
    var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
    const EL_ID = "vg-tooltip-element";
    const DEFAULT_OPTIONS = {
      /**
       * X offset.
       */
      offsetX: 10,
      /**
       * Y offset.
       */
      offsetY: 10,
      /**
       * ID of the tooltip element.
       */
      id: EL_ID,
      /**
       * ID of the tooltip CSS style.
       */
      styleId: "vega-tooltip-style",
      /**
       * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
       *
       * There are two predefined themes: "light" (default) and "dark".
       */
      theme: "light",
      /**
       * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
       */
      disableDefaultStyle: false,
      /**
       * HTML sanitizer function that removes dangerous HTML to prevent XSS.
       *
       * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
       */
      sanitize: escapeHTML,
      /**
       * The maximum recursion depth when printing objects in the tooltip.
       */
      maxDepth: 2,
      /**
       * A function to customize the rendered HTML of the tooltip.
       * @param value A value string, or object of value strings keyed by field
       * @param sanitize The `sanitize` function from `options.sanitize`
       * @param baseURL The `baseURL` from `options.baseURL`
       * @returns {string} The returned string will become the `innerHTML` of the tooltip element
       */
      formatTooltip: formatValue,
      /**
       * The baseurl to use in image paths.
       */
      baseURL: ""
    };
    function escapeHTML(value2) {
      return String(value2).replace(/&/g, "&amp;").replace(/</g, "&lt;");
    }
    function createDefaultStyle(id2) {
      if (!/^[A-Za-z]+[-:.\w]*$/.test(id2)) {
        throw new Error("Invalid HTML ID");
      }
      return defaultStyle.toString().replace(EL_ID, id2);
    }
    function calculatePosition(event2, tooltipBox, offsetX, offsetY) {
      let x2 = event2.clientX + offsetX;
      if (x2 + tooltipBox.width > window.innerWidth) {
        x2 = +event2.clientX - offsetX - tooltipBox.width;
      }
      let y2 = event2.clientY + offsetY;
      if (y2 + tooltipBox.height > window.innerHeight) {
        y2 = +event2.clientY - offsetY - tooltipBox.height;
      }
      return {
        x: x2,
        y: y2
      };
    }
    class Handler {
      /**
       * The handler function. We bind this to this function in the constructor.
       */
      /**
       * Complete tooltip options.
       */
      /**
       * The tooltip html element.
       */
      /**
       * Create the tooltip handler and initialize the element and style.
       *
       * @param options Tooltip Options
       */
      constructor(options) {
        this.options = {
          ...DEFAULT_OPTIONS,
          ...options
        };
        const elementId = this.options.id;
        this.el = null;
        this.call = this.tooltipHandler.bind(this);
        if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
          const style2 = document.createElement("style");
          style2.setAttribute("id", this.options.styleId);
          style2.innerHTML = createDefaultStyle(elementId);
          const head = document.head;
          if (head.childNodes.length > 0) {
            head.insertBefore(style2, head.childNodes[0]);
          } else {
            head.appendChild(style2);
          }
        }
      }
      /**
       * The tooltip handler function.
       */
      tooltipHandler(handler, event2, item, value2) {
        this.el = document.getElementById(this.options.id);
        if (!this.el) {
          this.el = document.createElement("div");
          this.el.setAttribute("id", this.options.id);
          this.el.classList.add("vg-tooltip");
          const tooltipContainer = document.fullscreenElement ?? document.body;
          tooltipContainer.appendChild(this.el);
        }
        if (value2 == null || value2 === "") {
          this.el.classList.remove("visible", `${this.options.theme}-theme`);
          return;
        }
        this.el.innerHTML = this.options.formatTooltip(value2, this.options.sanitize, this.options.maxDepth, this.options.baseURL);
        this.el.classList.add("visible", `${this.options.theme}-theme`);
        const {
          x: x2,
          y: y2
        } = calculatePosition(event2, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
        this.el.style.top = `${y2}px`;
        this.el.style.left = `${x2}px`;
      }
    }
    var define_process_env_default = {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var iterator;
    var hasRequiredIterator;
    function requireIterator() {
      if (hasRequiredIterator)
        return iterator;
      hasRequiredIterator = 1;
      iterator = function(Yallist2) {
        Yallist2.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
      return iterator;
    }
    var yallist = Yallist$1;
    Yallist$1.Node = Node$1;
    Yallist$1.create = Yallist$1;
    function Yallist$1(list2) {
      var self = this;
      if (!(self instanceof Yallist$1)) {
        self = new Yallist$1();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist$1.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next2 = node.next;
      var prev2 = node.prev;
      if (next2) {
        next2.prev = prev2;
      }
      if (prev2) {
        prev2.next = next2;
      }
      if (node === this.head) {
        this.head = next2;
      }
      if (node === this.tail) {
        this.tail = prev2;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next2;
    };
    Yallist$1.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist$1.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist$1.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist$1.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist$1.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist$1.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist$1.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist$1.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist$1.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist$1.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist$1.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist$1();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist$1.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist$1();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist$1.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist$1.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist$1.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist$1.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist$1.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist$1();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist$1.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist$1();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist$1.prototype.splice = function(start2, deleteCount, ...nodes) {
      if (start2 > this.length) {
        start2 = this.length - 1;
      }
      if (start2 < 0) {
        start2 = this.length + start2;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start2; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist$1.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value2) {
      var inserted = node === self.head ? new Node$1(value2, null, node, self) : new Node$1(value2, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node$1(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node$1(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node$1(value2, prev2, next2, list2) {
      if (!(this instanceof Node$1)) {
        return new Node$1(value2, prev2, next2, list2);
      }
      this.list = list2;
      this.value = value2;
      if (prev2) {
        prev2.next = this;
        this.prev = prev2;
      } else {
        this.prev = null;
      }
      if (next2) {
        next2.prev = this;
        this.next = next2;
      } else {
        this.next = null;
      }
    }
    try {
      requireIterator()(Yallist$1);
    } catch (er) {
    }
    const Yallist = yallist;
    const MAX = Symbol("max");
    const LENGTH = Symbol("length");
    const LENGTH_CALCULATOR = Symbol("lengthCalculator");
    const ALLOW_STALE = Symbol("allowStale");
    const MAX_AGE = Symbol("maxAge");
    const DISPOSE = Symbol("dispose");
    const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    const LRU_LIST = Symbol("lruList");
    const CACHE = Symbol("cache");
    const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    const naiveLength = () => 1;
    class LRUCache {
      constructor(options) {
        if (typeof options === "number")
          options = {
            max: options
          };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit2) => {
            hit2.length = this[LENGTH_CALCULATOR](hit2.value, hit2.key);
            this[LENGTH] += hit2.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev2 = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev2;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next2 = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next2;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit2) => this[DISPOSE](hit2.key, hit2.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit2) => isStale(this, hit2) ? false : {
          k: hit2.key,
          v: hit2.value,
          e: hit2.now + (hit2.maxAge || 0)
        }).toArray().filter((h2) => h2);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key2, value2, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now2 = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value2, key2);
        if (this[CACHE].has(key2)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key2));
            return false;
          }
          const node = this[CACHE].get(key2);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key2, item.value);
          }
          item.now = now2;
          item.maxAge = maxAge;
          item.value = value2;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key2);
          trim(this);
          return true;
        }
        const hit2 = new Entry(key2, value2, len, now2, maxAge);
        if (hit2.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key2, value2);
          return false;
        }
        this[LENGTH] += hit2.length;
        this[LRU_LIST].unshift(hit2);
        this[CACHE].set(key2, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key2) {
        if (!this[CACHE].has(key2))
          return false;
        const hit2 = this[CACHE].get(key2).value;
        return !isStale(this, hit2);
      }
      get(key2) {
        return get(this, key2, true);
      }
      peek(key2) {
        return get(this, key2, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key2) {
        del(this, this[CACHE].get(key2));
      }
      load(arr) {
        this.reset();
        const now2 = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit2 = arr[l];
          const expiresAt = hit2.e || 0;
          if (expiresAt === 0)
            this.set(hit2.k, hit2.v);
          else {
            const maxAge = expiresAt - now2;
            if (maxAge > 0) {
              this.set(hit2.k, hit2.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key2) => get(this, key2, false));
      }
    }
    const get = (self, key2, doUse) => {
      const node = self[CACHE].get(key2);
      if (node) {
        const hit2 = node.value;
        if (isStale(self, hit2)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit2.value;
      }
    };
    const isStale = (self, hit2) => {
      if (!hit2 || !hit2.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit2.now;
      return hit2.maxAge ? diff > hit2.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    const trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev2 = walker.prev;
          del(self, walker);
          walker = prev2;
        }
      }
    };
    const del = (self, node) => {
      if (node) {
        const hit2 = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit2.key, hit2.value);
        self[LENGTH] -= hit2.length;
        self[CACHE].delete(hit2.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    class Entry {
      constructor(key2, value2, length2, now2, maxAge) {
        this.key = key2;
        this.value = value2;
        this.length = length2;
        this.now = now2;
        this.maxAge = maxAge || 0;
      }
    }
    const forEachStep = (self, fn, node, thisp) => {
      let hit2 = node.value;
      if (isStale(self, hit2)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit2 = void 0;
      }
      if (hit2)
        fn.call(thisp, hit2.value, hit2.key, self);
    };
    var lruCache = LRUCache;
    const looseOption = Object.freeze({
      loose: true
    });
    const emptyOpts = Object.freeze({});
    const parseOptions$1 = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    var parseOptions_1 = parseOptions$1;
    var re$1 = { exports: {} };
    const SEMVER_SPEC_VERSION = "2.0.0";
    const MAX_LENGTH$1 = 256;
    const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    const MAX_SAFE_COMPONENT_LENGTH = 16;
    const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
    const RELEASE_TYPES = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
    var constants = {
      MAX_LENGTH: MAX_LENGTH$1,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
    const debug$1 = typeof process === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    var debug_1 = debug$1;
    (function(module2, exports2) {
      const {
        MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
        MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
        MAX_LENGTH: MAX_LENGTH2
      } = constants;
      const debug2 = debug_1;
      exports2 = module2.exports = {};
      const re2 = exports2.re = [];
      const safeRe = exports2.safeRe = [];
      const src = exports2.src = [];
      const t22 = exports2.t = {};
      let R = 0;
      const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      const safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH2], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]];
      const makeSafeRegex = (value2) => {
        for (const [token, max2] of safeRegexReplacements) {
          value2 = value2.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
        }
        return value2;
      };
      const createToken = (name2, value2, isGlobal) => {
        const safe = makeSafeRegex(value2);
        const index2 = R++;
        debug2(name2, index2, value2);
        t22[name2] = index2;
        src[index2] = value2;
        re2[index2] = new RegExp(value2, isGlobal ? "g" : void 0);
        safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken("MAINVERSION", `(${src[t22.NUMERICIDENTIFIER]})\\.(${src[t22.NUMERICIDENTIFIER]})\\.(${src[t22.NUMERICIDENTIFIER]})`);
      createToken("MAINVERSIONLOOSE", `(${src[t22.NUMERICIDENTIFIERLOOSE]})\\.(${src[t22.NUMERICIDENTIFIERLOOSE]})\\.(${src[t22.NUMERICIDENTIFIERLOOSE]})`);
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t22.NUMERICIDENTIFIER]}|${src[t22.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t22.NUMERICIDENTIFIERLOOSE]}|${src[t22.NONNUMERICIDENTIFIER]})`);
      createToken("PRERELEASE", `(?:-(${src[t22.PRERELEASEIDENTIFIER]}(?:\\.${src[t22.PRERELEASEIDENTIFIER]})*))`);
      createToken("PRERELEASELOOSE", `(?:-?(${src[t22.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t22.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken("BUILD", `(?:\\+(${src[t22.BUILDIDENTIFIER]}(?:\\.${src[t22.BUILDIDENTIFIER]})*))`);
      createToken("FULLPLAIN", `v?${src[t22.MAINVERSION]}${src[t22.PRERELEASE]}?${src[t22.BUILD]}?`);
      createToken("FULL", `^${src[t22.FULLPLAIN]}$`);
      createToken("LOOSEPLAIN", `[v=\\s]*${src[t22.MAINVERSIONLOOSE]}${src[t22.PRERELEASELOOSE]}?${src[t22.BUILD]}?`);
      createToken("LOOSE", `^${src[t22.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t22.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken("XRANGEIDENTIFIER", `${src[t22.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken("XRANGEPLAIN", `[v=\\s]*(${src[t22.XRANGEIDENTIFIER]})(?:\\.(${src[t22.XRANGEIDENTIFIER]})(?:\\.(${src[t22.XRANGEIDENTIFIER]})(?:${src[t22.PRERELEASE]})?${src[t22.BUILD]}?)?)?`);
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t22.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t22.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t22.XRANGEIDENTIFIERLOOSE]})(?:${src[t22.PRERELEASELOOSE]})?${src[t22.BUILD]}?)?)?`);
      createToken("XRANGE", `^${src[t22.GTLT]}\\s*${src[t22.XRANGEPLAIN]}$`);
      createToken("XRANGELOOSE", `^${src[t22.GTLT]}\\s*${src[t22.XRANGEPLAINLOOSE]}$`);
      createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
      createToken("COERCERTL", src[t22.COERCE], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t22.LONETILDE]}\\s+`, true);
      exports2.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t22.LONETILDE]}${src[t22.XRANGEPLAIN]}$`);
      createToken("TILDELOOSE", `^${src[t22.LONETILDE]}${src[t22.XRANGEPLAINLOOSE]}$`);
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t22.LONECARET]}\\s+`, true);
      exports2.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t22.LONECARET]}${src[t22.XRANGEPLAIN]}$`);
      createToken("CARETLOOSE", `^${src[t22.LONECARET]}${src[t22.XRANGEPLAINLOOSE]}$`);
      createToken("COMPARATORLOOSE", `^${src[t22.GTLT]}\\s*(${src[t22.LOOSEPLAIN]})$|^$`);
      createToken("COMPARATOR", `^${src[t22.GTLT]}\\s*(${src[t22.FULLPLAIN]})$|^$`);
      createToken("COMPARATORTRIM", `(\\s*)${src[t22.GTLT]}\\s*(${src[t22.LOOSEPLAIN]}|${src[t22.XRANGEPLAIN]})`, true);
      exports2.comparatorTrimReplace = "$1$2$3";
      createToken("HYPHENRANGE", `^\\s*(${src[t22.XRANGEPLAIN]})\\s+-\\s+(${src[t22.XRANGEPLAIN]})\\s*$`);
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t22.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t22.XRANGEPLAINLOOSE]})\\s*$`);
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    })(re$1, re$1.exports);
    var reExports = re$1.exports;
    const numeric = /^[0-9]+$/;
    const compareIdentifiers$1 = (a2, b2) => {
      const anum = numeric.test(a2);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a2 = +a2;
        b2 = +b2;
      }
      return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
    };
    const rcompareIdentifiers = (a2, b2) => compareIdentifiers$1(b2, a2);
    var identifiers = {
      compareIdentifiers: compareIdentifiers$1,
      rcompareIdentifiers
    };
    const debug = debug_1;
    const {
      MAX_LENGTH,
      MAX_SAFE_INTEGER
    } = constants;
    const {
      safeRe: re,
      t
    } = reExports;
    const parseOptions = parseOptions_1;
    const {
      compareIdentifiers
    } = identifiers;
    let SemVer$1 = class SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a2 = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug("prerelease compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a2 = this.build[i];
          const b2 = other.build[i];
          debug("prerelease compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base2 = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base2];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base2);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base2];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    var semver = SemVer$1;
    const SemVer2 = semver;
    const compare$6 = (a2, b2, loose) => new SemVer2(a2, loose).compare(new SemVer2(b2, loose));
    var compare_1 = compare$6;
    const compare$5 = compare_1;
    const eq$1 = (a2, b2, loose) => compare$5(a2, b2, loose) === 0;
    var eq_1 = eq$1;
    const compare$4 = compare_1;
    const neq$1 = (a2, b2, loose) => compare$4(a2, b2, loose) !== 0;
    var neq_1 = neq$1;
    const compare$3 = compare_1;
    const gt$1 = (a2, b2, loose) => compare$3(a2, b2, loose) > 0;
    var gt_1 = gt$1;
    const compare$2 = compare_1;
    const gte$1 = (a2, b2, loose) => compare$2(a2, b2, loose) >= 0;
    var gte_1 = gte$1;
    const compare$1 = compare_1;
    const lt$1 = (a2, b2, loose) => compare$1(a2, b2, loose) < 0;
    var lt_1 = lt$1;
    const compare = compare_1;
    const lte$1 = (a2, b2, loose) => compare(a2, b2, loose) <= 0;
    var lte_1 = lte$1;
    const eq = eq_1;
    const neq = neq_1;
    const gt = gt_1;
    const gte = gte_1;
    const lt = lt_1;
    const lte = lte_1;
    const cmp = (a2, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 === b2;
        case "!==":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 !== b2;
        case "":
        case "=":
        case "==":
          return eq(a2, b2, loose);
        case "!=":
          return neq(a2, b2, loose);
        case ">":
          return gt(a2, b2, loose);
        case ">=":
          return gte(a2, b2, loose);
        case "<":
          return lt(a2, b2, loose);
        case "<=":
          return lte(a2, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    var cmp_1 = cmp;
    var comparator;
    var hasRequiredComparator;
    function requireComparator() {
      if (hasRequiredComparator)
        return comparator;
      hasRequiredComparator = 1;
      const ANY = Symbol("SemVer ANY");
      class Comparator {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions2(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re2[t22.COMPARATORLOOSE] : re2[t22.COMPARATOR];
          const m2 = comp.match(r);
          if (!m2) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m2[1] !== void 0 ? m2[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m2[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer3(m2[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version2) {
          debug2("Comparator.test", version2, this.options.loose);
          if (this.semver === ANY || version2 === ANY) {
            return true;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer3(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp2(version2, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range2(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range2(this.value, options).test(comp.semver);
          }
          options = parseOptions2(options);
          if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
            return false;
          }
          if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
            return false;
          }
          if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
            return true;
          }
          if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
            return true;
          }
          if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
            return true;
          }
          if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
            return true;
          }
          if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
            return true;
          }
          return false;
        }
      }
      comparator = Comparator;
      const parseOptions2 = parseOptions_1;
      const {
        safeRe: re2,
        t: t22
      } = reExports;
      const cmp2 = cmp_1;
      const debug2 = debug_1;
      const SemVer3 = semver;
      const Range2 = requireRange();
      return comparator;
    }
    var range;
    var hasRequiredRange;
    function requireRange() {
      if (hasRequiredRange)
        return range;
      hasRequiredRange = 1;
      class Range2 {
        constructor(range2, options) {
          options = parseOptions2(options);
          if (range2 instanceof Range2) {
            if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
              return range2;
            } else {
              return new Range2(range2.raw, options);
            }
          }
          if (range2 instanceof Comparator) {
            this.raw = range2.value;
            this.set = [[range2]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range2.trim().split(/\s+/).join(" ");
          this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c2) => c2.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c2) => !isNullSet(c2[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c2 of this.set) {
                if (c2.length === 1 && isAny(c2[0])) {
                  this.set = [c2];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range2) {
          const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
          const memoKey = memoOpts + ":" + range2;
          const cached = cache2.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re2[t22.HYPHENRANGELOOSE] : re2[t22.HYPHENRANGE];
          range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug2("hyphen replace", range2);
          range2 = range2.replace(re2[t22.COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range2);
          range2 = range2.replace(re2[t22.TILDETRIM], tildeTrimReplace);
          debug2("tilde trim", range2);
          range2 = range2.replace(re2[t22.CARETTRIM], caretTrimReplace);
          debug2("caret trim", range2);
          let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter((comp) => {
              debug2("loose invalid filter", comp, this.options);
              return !!comp.match(re2[t22.COMPARATORLOOSE]);
            });
          }
          debug2("range list", rangeList);
          const rangeMap = /* @__PURE__ */ new Map();
          const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
          }
          const result = [...rangeMap.values()];
          cache2.set(memoKey, result);
          return result;
        }
        intersects(range2, options) {
          if (!(range2 instanceof Range2)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(version2) {
          if (!version2) {
            return false;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer3(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version2, this.options)) {
              return true;
            }
          }
          return false;
        }
      }
      range = Range2;
      const LRU = lruCache;
      const cache2 = new LRU({
        max: 1e3
      });
      const parseOptions2 = parseOptions_1;
      const Comparator = requireComparator();
      const debug2 = debug_1;
      const SemVer3 = semver;
      const {
        safeRe: re2,
        t: t22,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = reExports;
      const {
        FLAG_INCLUDE_PRERELEASE,
        FLAG_LOOSE
      } = constants;
      const isNullSet = (c2) => c2.value === "<0.0.0-0";
      const isAny = (c2) => c2.value === "";
      const isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      const parseComparator = (comp, options) => {
        debug2("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug2("caret", comp);
        comp = replaceTildes(comp, options);
        debug2("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug2("xrange", comp);
        comp = replaceStars(comp, options);
        debug2("stars", comp);
        return comp;
      };
      const isX2 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
      const replaceTildes = (comp, options) => {
        return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
      };
      const replaceTilde = (comp, options) => {
        const r = options.loose ? re2[t22.TILDELOOSE] : re2[t22.TILDE];
        return comp.replace(r, (_, M2, m2, p, pr) => {
          debug2("tilde", comp, _, M2, m2, p, pr);
          let ret;
          if (isX2(M2)) {
            ret = "";
          } else if (isX2(m2)) {
            ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
          } else if (isX2(p)) {
            ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
          } else if (pr) {
            debug2("replaceTilde pr", pr);
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m2}.${p} <${M2}.${+m2 + 1}.0-0`;
          }
          debug2("tilde return", ret);
          return ret;
        });
      };
      const replaceCarets = (comp, options) => {
        return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
      };
      const replaceCaret = (comp, options) => {
        debug2("caret", comp, options);
        const r = options.loose ? re2[t22.CARETLOOSE] : re2[t22.CARET];
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M2, m2, p, pr) => {
          debug2("caret", comp, _, M2, m2, p, pr);
          let ret;
          if (isX2(M2)) {
            ret = "";
          } else if (isX2(m2)) {
            ret = `>=${M2}.0.0${z} <${+M2 + 1}.0.0-0`;
          } else if (isX2(p)) {
            if (M2 === "0") {
              ret = `>=${M2}.${m2}.0${z} <${M2}.${+m2 + 1}.0-0`;
            } else {
              ret = `>=${M2}.${m2}.0${z} <${+M2 + 1}.0.0-0`;
            }
          } else if (pr) {
            debug2("replaceCaret pr", pr);
            if (M2 === "0") {
              if (m2 === "0") {
                ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${m2}.${+p + 1}-0`;
              } else {
                ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
              }
            } else {
              ret = `>=${M2}.${m2}.${p}-${pr} <${+M2 + 1}.0.0-0`;
            }
          } else {
            debug2("no pr");
            if (M2 === "0") {
              if (m2 === "0") {
                ret = `>=${M2}.${m2}.${p}${z} <${M2}.${m2}.${+p + 1}-0`;
              } else {
                ret = `>=${M2}.${m2}.${p}${z} <${M2}.${+m2 + 1}.0-0`;
              }
            } else {
              ret = `>=${M2}.${m2}.${p} <${+M2 + 1}.0.0-0`;
            }
          }
          debug2("caret return", ret);
          return ret;
        });
      };
      const replaceXRanges = (comp, options) => {
        debug2("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
      };
      const replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re2[t22.XRANGELOOSE] : re2[t22.XRANGE];
        return comp.replace(r, (ret, gtlt, M2, m2, p, pr) => {
          debug2("xRange", comp, ret, gtlt, M2, m2, p, pr);
          const xM = isX2(M2);
          const xm = xM || isX2(m2);
          const xp = xm || isX2(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret = "<0.0.0-0";
            } else {
              ret = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m2 = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M2 = +M2 + 1;
                m2 = 0;
                p = 0;
              } else {
                m2 = +m2 + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M2 = +M2 + 1;
              } else {
                m2 = +m2 + 1;
              }
            }
            if (gtlt === "<") {
              pr = "-0";
            }
            ret = `${gtlt + M2}.${m2}.${p}${pr}`;
          } else if (xm) {
            ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
          } else if (xp) {
            ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
          }
          debug2("xRange return", ret);
          return ret;
        });
      };
      const replaceStars = (comp, options) => {
        debug2("replaceStars", comp, options);
        return comp.trim().replace(re2[t22.STAR], "");
      };
      const replaceGTE0 = (comp, options) => {
        debug2("replaceGTE0", comp, options);
        return comp.trim().replace(re2[options.includePrerelease ? t22.GTE0PRE : t22.GTE0], "");
      };
      const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX2(fM)) {
          from = "";
        } else if (isX2(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX2(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX2(tM)) {
          to = "";
        } else if (isX2(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX2(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      const testSet = (set2, version2, options) => {
        for (let i = 0; i < set2.length; i++) {
          if (!set2[i].test(version2)) {
            return false;
          }
        }
        if (version2.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set2.length; i++) {
            debug2(set2[i].semver);
            if (set2[i].semver === Comparator.ANY) {
              continue;
            }
            if (set2[i].semver.prerelease.length > 0) {
              const allowed = set2[i].semver;
              if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
      return range;
    }
    const Range = requireRange();
    const satisfies = (version2, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    var satisfies_1 = satisfies;
    var satisfies$1 = /* @__PURE__ */ getDefaultExportFromCjs(satisfies_1);
    function post(window2, url, data2) {
      const editor = window2.open(url);
      const wait = 1e4;
      const step = 250;
      const {
        origin
      } = new URL(url);
      let count2 = ~~(wait / step);
      function listen2(evt) {
        if (evt.source === editor) {
          count2 = 0;
          window2.removeEventListener("message", listen2, false);
        }
      }
      window2.addEventListener("message", listen2, false);
      function send2() {
        if (count2 <= 0) {
          return;
        }
        editor.postMessage(data2, origin);
        setTimeout(send2, step);
        count2 -= 1;
      }
      setTimeout(send2, step);
    }
    var embedStyle = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
    function mergeDeep(dest, ...src) {
      for (const s of src) {
        deepMerge_(dest, s);
      }
      return dest;
    }
    function deepMerge_(dest, src) {
      for (const property2 of Object.keys(src)) {
        writeConfig(dest, property2, src[property2], true);
      }
    }
    const vega = vegaImport;
    let vegaLite = vegaLiteImport;
    const w = typeof window !== "undefined" ? window : void 0;
    if (vegaLite === void 0 && ((_a = w == null ? void 0 : w.vl) == null ? void 0 : _a.compile)) {
      vegaLite = w.vl;
    }
    const DEFAULT_ACTIONS = {
      export: {
        svg: true,
        png: true
      },
      source: true,
      compiled: true,
      editor: true
    };
    const I18N = {
      CLICK_TO_VIEW_ACTIONS: "Click to view actions",
      COMPILED_ACTION: "View Compiled Vega",
      EDITOR_ACTION: "Open in Vega Editor",
      PNG_ACTION: "Save as PNG",
      SOURCE_ACTION: "View Source",
      SVG_ACTION: "Save as SVG"
    };
    const NAMES = {
      vega: "Vega",
      "vega-lite": "Vega-Lite"
    };
    const VERSION = {
      vega: vega.version,
      "vega-lite": vegaLite ? vegaLite.version : "not available"
    };
    const PREPROCESSOR = {
      vega: (vgSpec) => vgSpec,
      "vega-lite": (vlSpec, config) => vegaLite.compile(vlSpec, {
        config
      }).spec
    };
    const SVG_CIRCLES = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`;
    const CHART_WRAPPER_CLASS = "chart-wrapper";
    function isTooltipHandler(h2) {
      return typeof h2 === "function";
    }
    function viewSource(source2, sourceHeader, sourceFooter, mode) {
      const header = `<html><head>${sourceHeader}</head><body><pre><code class="json">`;
      const footer = `</code></pre>${sourceFooter}</body></html>`;
      const win = window.open("");
      win.document.write(header + source2 + footer);
      win.document.title = `${NAMES[mode]} JSON Source`;
    }
    function guessMode(spec, providedMode) {
      if (spec.$schema) {
        const parsed = e(spec.$schema);
        if (providedMode && providedMode !== parsed.library) {
          console.warn(`The given visualization spec is written in ${NAMES[parsed.library]}, but mode argument sets ${NAMES[providedMode] ?? providedMode}.`);
        }
        const mode = parsed.library;
        if (!satisfies$1(VERSION[mode], `^${parsed.version.slice(1)}`)) {
          console.warn(`The input spec uses ${NAMES[mode]} ${parsed.version}, but the current version of ${NAMES[mode]} is v${VERSION[mode]}.`);
        }
        return mode;
      }
      if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
        return "vega-lite";
      }
      if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
        return "vega";
      }
      return providedMode ?? "vega";
    }
    function isLoader(o) {
      return !!(o && "load" in o);
    }
    function createLoader(opts) {
      return isLoader(opts) ? opts : vega.loader(opts);
    }
    function embedOptionsFromUsermeta(parsedSpec) {
      var _a2;
      const opts = ((_a2 = parsedSpec.usermeta) == null ? void 0 : _a2.embedOptions) ?? {};
      if (isString(opts.defaultStyle)) {
        opts.defaultStyle = false;
      }
      return opts;
    }
    async function embed(el, spec, opts = {}) {
      let parsedSpec;
      let loader2;
      if (isString(spec)) {
        loader2 = createLoader(opts.loader);
        parsedSpec = JSON.parse(await loader2.load(spec));
      } else {
        parsedSpec = spec;
      }
      const loadedEmbedOptions = embedOptionsFromUsermeta(parsedSpec);
      const usermetaLoader = loadedEmbedOptions.loader;
      if (!loader2 || usermetaLoader) {
        loader2 = createLoader(opts.loader ?? usermetaLoader);
      }
      const usermetaOpts = await loadOpts(loadedEmbedOptions, loader2);
      const parsedOpts = await loadOpts(opts, loader2);
      const mergedOpts = {
        ...mergeDeep(parsedOpts, usermetaOpts),
        config: mergeConfig(parsedOpts.config ?? {}, usermetaOpts.config ?? {})
      };
      return await _embed(el, parsedSpec, mergedOpts, loader2);
    }
    async function loadOpts(opt, loader2) {
      const config = isString(opt.config) ? JSON.parse(await loader2.load(opt.config)) : opt.config ?? {};
      const patch2 = isString(opt.patch) ? JSON.parse(await loader2.load(opt.patch)) : opt.patch;
      return {
        ...opt,
        ...patch2 ? {
          patch: patch2
        } : {},
        ...config ? {
          config
        } : {}
      };
    }
    function getRoot(el) {
      const possibleRoot = el.getRootNode ? el.getRootNode() : document;
      return possibleRoot instanceof ShadowRoot ? {
        root: possibleRoot,
        rootContainer: possibleRoot
      } : {
        root: document,
        rootContainer: document.head ?? document.body
      };
    }
    async function _embed(el, spec, opts = {}, loader2) {
      const config = opts.theme ? mergeConfig(themes[opts.theme], opts.config ?? {}) : opts.config;
      const actions = isBoolean$2(opts.actions) ? opts.actions : mergeDeep({}, DEFAULT_ACTIONS, opts.actions ?? {});
      const i18n = {
        ...I18N,
        ...opts.i18n
      };
      const renderer = opts.renderer ?? "canvas";
      const logLevel = opts.logLevel ?? vega.Warn;
      const downloadFileName = opts.downloadFileName ?? "visualization";
      const element2 = typeof el === "string" ? document.querySelector(el) : el;
      if (!element2) {
        throw new Error(`${el} does not exist`);
      }
      if (opts.defaultStyle !== false) {
        const ID = "vega-embed-style";
        const {
          root: root2,
          rootContainer
        } = getRoot(element2);
        if (!root2.getElementById(ID)) {
          const style2 = document.createElement("style");
          style2.id = ID;
          style2.innerHTML = opts.defaultStyle === void 0 || opts.defaultStyle === true ? embedStyle.toString() : opts.defaultStyle;
          rootContainer.appendChild(style2);
        }
      }
      const mode = guessMode(spec, opts.mode);
      let vgSpec = PREPROCESSOR[mode](spec, config);
      if (mode === "vega-lite") {
        if (vgSpec.$schema) {
          const parsed = e(vgSpec.$schema);
          if (!satisfies$1(VERSION.vega, `^${parsed.version.slice(1)}`)) {
            console.warn(`The compiled spec uses Vega ${parsed.version}, but current version is v${VERSION.vega}.`);
          }
        }
      }
      element2.classList.add("vega-embed");
      if (actions) {
        element2.classList.add("has-actions");
      }
      element2.innerHTML = "";
      let container = element2;
      if (actions) {
        const chartWrapper = document.createElement("div");
        chartWrapper.classList.add(CHART_WRAPPER_CLASS);
        element2.appendChild(chartWrapper);
        container = chartWrapper;
      }
      const patch2 = opts.patch;
      if (patch2) {
        vgSpec = patch2 instanceof Function ? patch2(vgSpec) : applyPatch(vgSpec, patch2, true, false).newDocument;
      }
      if (opts.formatLocale) {
        vega.formatLocale(opts.formatLocale);
      }
      if (opts.timeFormatLocale) {
        vega.timeFormatLocale(opts.timeFormatLocale);
      }
      if (opts.expressionFunctions) {
        for (const name2 in opts.expressionFunctions) {
          const expressionFunction2 = opts.expressionFunctions[name2];
          if ("fn" in expressionFunction2) {
            vega.expressionFunction(name2, expressionFunction2.fn, expressionFunction2["visitor"]);
          } else if (expressionFunction2 instanceof Function) {
            vega.expressionFunction(name2, expressionFunction2);
          }
        }
      }
      const {
        ast
      } = opts;
      const runtime2 = vega.parse(vgSpec, mode === "vega-lite" ? {} : config, {
        ast
      });
      const view = new (opts.viewClass || vega.View)(runtime2, {
        loader: loader2,
        logLevel,
        renderer,
        ...ast ? {
          expr: vega.expressionInterpreter ?? opts.expr ?? expression$1
        } : {}
      });
      view.addSignalListener("autosize", (_, autosize) => {
        const {
          type: type2
        } = autosize;
        if (type2 == "fit-x") {
          container.classList.add("fit-x");
          container.classList.remove("fit-y");
        } else if (type2 == "fit-y") {
          container.classList.remove("fit-x");
          container.classList.add("fit-y");
        } else if (type2 == "fit") {
          container.classList.add("fit-x", "fit-y");
        } else {
          container.classList.remove("fit-x", "fit-y");
        }
      });
      if (opts.tooltip !== false) {
        const {
          loader: loader_,
          tooltip: tooltip2
        } = opts;
        const baseURL = loader_ && !isLoader(loader_) ? loader_ == null ? void 0 : loader_.baseURL : void 0;
        const handler = isTooltipHandler(tooltip2) ? tooltip2 : (
          // user provided boolean true or tooltip options
          new Handler({
            baseURL,
            ...tooltip2 === true ? {} : tooltip2
          }).call
        );
        view.tooltip(handler);
      }
      let {
        hover: hover2
      } = opts;
      if (hover2 === void 0) {
        hover2 = mode === "vega";
      }
      if (hover2) {
        const {
          hoverSet,
          updateSet
        } = typeof hover2 === "boolean" ? {} : hover2;
        view.hover(hoverSet, updateSet);
      }
      if (opts) {
        if (opts.width != null) {
          view.width(opts.width);
        }
        if (opts.height != null) {
          view.height(opts.height);
        }
        if (opts.padding != null) {
          view.padding(opts.padding);
        }
      }
      await view.initialize(container, opts.bind).runAsync();
      let documentClickHandler;
      if (actions !== false) {
        let wrapper = element2;
        if (opts.defaultStyle !== false || opts.forceActionsMenu) {
          const details2 = document.createElement("details");
          details2.title = i18n.CLICK_TO_VIEW_ACTIONS;
          element2.append(details2);
          wrapper = details2;
          const summary = document.createElement("summary");
          summary.innerHTML = SVG_CIRCLES;
          details2.append(summary);
          documentClickHandler = (ev) => {
            if (!details2.contains(ev.target)) {
              details2.removeAttribute("open");
            }
          };
          document.addEventListener("click", documentClickHandler);
        }
        const ctrl = document.createElement("div");
        wrapper.append(ctrl);
        ctrl.classList.add("vega-actions");
        if (actions === true || actions.export !== false) {
          for (const ext of ["svg", "png"]) {
            if (actions === true || actions.export === true || actions.export[ext]) {
              const i18nExportAction = i18n[`${ext.toUpperCase()}_ACTION`];
              const exportLink = document.createElement("a");
              const scaleFactor = isObject(opts.scaleFactor) ? opts.scaleFactor[ext] : opts.scaleFactor;
              exportLink.text = i18nExportAction;
              exportLink.href = "#";
              exportLink.target = "_blank";
              exportLink.download = `${downloadFileName}.${ext}`;
              exportLink.addEventListener("mousedown", async function(e3) {
                e3.preventDefault();
                const url = await view.toImageURL(ext, scaleFactor);
                this.href = url;
              });
              ctrl.append(exportLink);
            }
          }
        }
        if (actions === true || actions.source !== false) {
          const viewSourceLink = document.createElement("a");
          viewSourceLink.text = i18n.SOURCE_ACTION;
          viewSourceLink.href = "#";
          viewSourceLink.addEventListener("click", function(e3) {
            viewSource(stringify$2(spec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", mode);
            e3.preventDefault();
          });
          ctrl.append(viewSourceLink);
        }
        if (mode === "vega-lite" && (actions === true || actions.compiled !== false)) {
          const compileLink = document.createElement("a");
          compileLink.text = i18n.COMPILED_ACTION;
          compileLink.href = "#";
          compileLink.addEventListener("click", function(e3) {
            viewSource(stringify$2(vgSpec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", "vega");
            e3.preventDefault();
          });
          ctrl.append(compileLink);
        }
        if (actions === true || actions.editor !== false) {
          const editorUrl = opts.editorUrl ?? "https://vega.github.io/editor/";
          const editorLink = document.createElement("a");
          editorLink.text = i18n.EDITOR_ACTION;
          editorLink.href = "#";
          editorLink.addEventListener("click", function(e3) {
            post(window, editorUrl, {
              config,
              mode,
              renderer,
              spec: stringify$2(spec)
            });
            e3.preventDefault();
          });
          ctrl.append(editorLink);
        }
      }
      function finalize2() {
        if (documentClickHandler) {
          document.removeEventListener("click", documentClickHandler);
        }
        view.finalize();
      }
      return {
        view,
        spec,
        vgSpec,
        finalize: finalize2,
        embedOptions: opts
      };
    }
    function create_else_block(ctx) {
      let p;
      return {
        c() {
          p = element$2("p");
          p.textContent = "No observations found";
          attr$6(p, "class", "text-gray-500 w-full text-right");
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
        },
        p: noop$6,
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }
    function create_if_block_1$1(ctx) {
      let checkbox2;
      let updating_checked;
      let current2;
      function checkbox_checked_binding(value2) {
        ctx[25](value2);
      }
      let checkbox_props = {
        label: `Show ${/*observationsForSelectedReportSteps*/
        ctx[10].length} observations?`
      };
      if (
        /*showObservations*/
        ctx[2] !== void 0
      ) {
        checkbox_props.checked = /*showObservations*/
        ctx[2];
      }
      checkbox2 = new Checkbox({ props: checkbox_props });
      binding_callbacks.push(() => bind$2(checkbox2, "checked", checkbox_checked_binding));
      return {
        c() {
          create_component(checkbox2.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(checkbox2, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const checkbox_changes = {};
          if (dirty[0] & /*observationsForSelectedReportSteps*/
          1024)
            checkbox_changes.label = `Show ${/*observationsForSelectedReportSteps*/
            ctx2[10].length} observations?`;
          if (!updating_checked && dirty[0] & /*showObservations*/
          4) {
            updating_checked = true;
            checkbox_changes.checked = /*showObservations*/
            ctx2[2];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox2.$set(checkbox_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(checkbox2.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(checkbox2.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(checkbox2, detaching);
        }
      };
    }
    function create_if_block$1(ctx) {
      let slider;
      let updating_value;
      let t4;
      let checkbox2;
      let updating_checked;
      let current2;
      function slider_value_binding(value2) {
        ctx[29](value2);
      }
      let slider_props = {
        min: 0.5,
        max: 20,
        step: 0.5,
        valueDisplay: func_3
      };
      if (
        /*observationWeight*/
        ctx[4] !== void 0
      ) {
        slider_props.value = /*observationWeight*/
        ctx[4];
      }
      slider = new Slider({ props: slider_props });
      binding_callbacks.push(() => bind$2(slider, "value", slider_value_binding));
      function checkbox_checked_binding_1(value2) {
        ctx[30](value2);
      }
      let checkbox_props = { label: `Show ticks?` };
      if (
        /*observationShowTicks*/
        ctx[5] !== void 0
      ) {
        checkbox_props.checked = /*observationShowTicks*/
        ctx[5];
      }
      checkbox2 = new Checkbox({ props: checkbox_props });
      binding_callbacks.push(() => bind$2(checkbox2, "checked", checkbox_checked_binding_1));
      return {
        c() {
          create_component(slider.$$.fragment);
          t4 = space();
          create_component(checkbox2.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(slider, target2, anchor2);
          insert$2(target2, t4, anchor2);
          mount_component(checkbox2, target2, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          const slider_changes = {};
          if (!updating_value && dirty[0] & /*observationWeight*/
          16) {
            updating_value = true;
            slider_changes.value = /*observationWeight*/
            ctx2[4];
            add_flush_callback(() => updating_value = false);
          }
          slider.$set(slider_changes);
          const checkbox_changes = {};
          if (!updating_checked && dirty[0] & /*observationShowTicks*/
          32) {
            updating_checked = true;
            checkbox_changes.checked = /*observationShowTicks*/
            ctx2[5];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox2.$set(checkbox_changes);
        },
        i(local) {
          if (current2)
            return;
          transition_in(slider.$$.fragment, local);
          transition_in(checkbox2.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(slider.$$.fragment, local);
          transition_out(checkbox2.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
          destroy_component(slider, detaching);
          destroy_component(checkbox2, detaching);
        }
      };
    }
    function create_fragment$4(ctx) {
      let div0;
      let combobox;
      let updating_value;
      let t02;
      let br2;
      let t12;
      let current_block_type_index;
      let if_block0;
      let t22;
      let slider0;
      let updating_value_1;
      let t32;
      let slider1;
      let updating_value_2;
      let t4;
      let slider2;
      let updating_value_3;
      let t5;
      let portal_action;
      let t6;
      let div1;
      let current2;
      let mounted;
      let dispose;
      function combobox_value_binding(value2) {
        ctx[23](value2);
      }
      let combobox_props = {
        label: "Report steps",
        placeholder: "Select report steps",
        options: (
          /*availableReportSteps*/
          ctx[11]()
        ),
        multiselect: true,
        maxChipContainerWidth: "300px"
      };
      if (
        /*activeReportSteps*/
        ctx[3] !== void 0
      ) {
        combobox_props.value = /*activeReportSteps*/
        ctx[3];
      }
      combobox = new Combobox({ props: combobox_props });
      binding_callbacks.push(() => bind$2(combobox, "value", combobox_value_binding));
      combobox.$on(
        "change",
        /*change_handler*/
        ctx[24]
      );
      const if_block_creators = [create_if_block_1$1, create_else_block];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (!!/*observationsData*/
        ctx2[1] && /*observationsData*/
        ctx2[1].length > 0)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      function slider0_value_binding(value2) {
        ctx[26](value2);
      }
      let slider0_props = {
        min: 0.5,
        max: 30,
        step: 0.5,
        valueDisplay: func$1
      };
      if (
        /*weight*/
        ctx[7] !== void 0
      ) {
        slider0_props.value = /*weight*/
        ctx[7];
      }
      slider0 = new Slider({ props: slider0_props });
      binding_callbacks.push(() => bind$2(slider0, "value", slider0_value_binding));
      function slider1_value_binding(value2) {
        ctx[27](value2);
      }
      let slider1_props = {
        min: 1,
        max: 100,
        step: 1,
        valueDisplay: func_1
      };
      if (
        /*opacity*/
        ctx[9] !== void 0
      ) {
        slider1_props.value = /*opacity*/
        ctx[9];
      }
      slider1 = new Slider({ props: slider1_props });
      binding_callbacks.push(() => bind$2(slider1, "value", slider1_value_binding));
      function slider2_value_binding(value2) {
        ctx[28](value2);
      }
      let slider2_props = {
        min: 0,
        max: 10,
        step: 1,
        valueDisplay: func_2$1
      };
      if (
        /*dasharray*/
        ctx[8] !== void 0
      ) {
        slider2_props.value = /*dasharray*/
        ctx[8];
      }
      slider2 = new Slider({ props: slider2_props });
      binding_callbacks.push(() => bind$2(slider2, "value", slider2_value_binding));
      let if_block1 = (
        /*showObservations*/
        ctx[2] && create_if_block$1(ctx)
      );
      return {
        c() {
          div0 = element$2("div");
          create_component(combobox.$$.fragment);
          t02 = space();
          br2 = element$2("br");
          t12 = space();
          if_block0.c();
          t22 = space();
          create_component(slider0.$$.fragment);
          t32 = space();
          create_component(slider1.$$.fragment);
          t4 = space();
          create_component(slider2.$$.fragment);
          t5 = space();
          if (if_block1)
            if_block1.c();
          t6 = space();
          div1 = element$2("div");
          attr$6(div1, "class", "absolute top-0 left-0 h-full w-full overflow-visible");
        },
        m(target2, anchor2) {
          insert$2(target2, div0, anchor2);
          mount_component(combobox, div0, null);
          append$2(div0, t02);
          append$2(div0, br2);
          append$2(div0, t12);
          if_blocks[current_block_type_index].m(div0, null);
          append$2(div0, t22);
          mount_component(slider0, div0, null);
          append$2(div0, t32);
          mount_component(slider1, div0, null);
          append$2(div0, t4);
          mount_component(slider2, div0, null);
          append$2(div0, t5);
          if (if_block1)
            if_block1.m(div0, null);
          insert$2(target2, t6, anchor2);
          insert$2(target2, div1, anchor2);
          ctx[31](div1);
          current2 = true;
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div0,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, dirty) {
          const combobox_changes = {};
          if (!updating_value && dirty[0] & /*activeReportSteps*/
          8) {
            updating_value = true;
            combobox_changes.value = /*activeReportSteps*/
            ctx2[3];
            add_flush_callback(() => updating_value = false);
          }
          combobox.$set(combobox_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];
            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block0.c();
            } else {
              if_block0.p(ctx2, dirty);
            }
            transition_in(if_block0, 1);
            if_block0.m(div0, t22);
          }
          const slider0_changes = {};
          if (!updating_value_1 && dirty[0] & /*weight*/
          128) {
            updating_value_1 = true;
            slider0_changes.value = /*weight*/
            ctx2[7];
            add_flush_callback(() => updating_value_1 = false);
          }
          slider0.$set(slider0_changes);
          const slider1_changes = {};
          if (!updating_value_2 && dirty[0] & /*opacity*/
          512) {
            updating_value_2 = true;
            slider1_changes.value = /*opacity*/
            ctx2[9];
            add_flush_callback(() => updating_value_2 = false);
          }
          slider1.$set(slider1_changes);
          const slider2_changes = {};
          if (!updating_value_3 && dirty[0] & /*dasharray*/
          256) {
            updating_value_3 = true;
            slider2_changes.value = /*dasharray*/
            ctx2[8];
            add_flush_callback(() => updating_value_3 = false);
          }
          slider2.$set(slider2_changes);
          if (
            /*showObservations*/
            ctx2[2]
          ) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & /*showObservations*/
              4) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$1(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div0, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if (portal_action && is_function(portal_action.update) && dirty[0] & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
        },
        i(local) {
          if (current2)
            return;
          transition_in(combobox.$$.fragment, local);
          transition_in(if_block0);
          transition_in(slider0.$$.fragment, local);
          transition_in(slider1.$$.fragment, local);
          transition_in(slider2.$$.fragment, local);
          transition_in(if_block1);
          current2 = true;
        },
        o(local) {
          transition_out(combobox.$$.fragment, local);
          transition_out(if_block0);
          transition_out(slider0.$$.fragment, local);
          transition_out(slider1.$$.fragment, local);
          transition_out(slider2.$$.fragment, local);
          transition_out(if_block1);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div0);
            detach(t6);
            detach(div1);
          }
          destroy_component(combobox);
          if_blocks[current_block_type_index].d();
          destroy_component(slider0);
          destroy_component(slider1);
          destroy_component(slider2);
          if (if_block1)
            if_block1.d();
          ctx[31](null);
          mounted = false;
          dispose();
        }
      };
    }
    const func$1 = (v) => `Line weight: ${v}px`;
    const func_1 = (v) => `Global line opacity: ${v}%`;
    const func_2$1 = (v) => `Series stipled by ${v}px`;
    const func_3 = (v) => `Observations weight: ${v}px`;
    function instance$3($$self, $$props, $$invalidate) {
      let errorBarSpec;
      let dataForSelectedReportSteps;
      let observationsForSelectedReportSteps;
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { observationsData } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { keyword } = $$props;
      let showObservations = false;
      let activeReportSteps = [data2[0].report_step.toString()];
      let observationWeight = 4;
      let observationShowTicks = false;
      let container;
      let weight = 0.5;
      let dasharray = 0;
      let opacity2 = 100;
      function availableReportSteps() {
        const { experiment } = data2[0];
        const exp2 = getLoadedExperiments()[experiment];
        const entry2 = exp2.responses.gen_data.find((gd) => gd.name === keyword);
        const { report_steps } = entry2;
        return report_steps.map((rs) => ({
          label: `${Math.trunc(rs)}`,
          value: Math.trunc(rs).toString()
        }));
      }
      function combobox_value_binding(value2) {
        activeReportSteps = value2;
        $$invalidate(3, activeReportSteps);
      }
      const change_handler = (e3) => {
        activeReportSteps.sort((a2, b2) => +a2 - +b2);
      };
      function checkbox_checked_binding(value2) {
        showObservations = value2;
        $$invalidate(2, showObservations);
      }
      function slider0_value_binding(value2) {
        weight = value2;
        $$invalidate(7, weight);
      }
      function slider1_value_binding(value2) {
        opacity2 = value2;
        $$invalidate(9, opacity2);
      }
      function slider2_value_binding(value2) {
        dasharray = value2;
        $$invalidate(8, dasharray);
      }
      function slider_value_binding(value2) {
        observationWeight = value2;
        $$invalidate(4, observationWeight);
      }
      function checkbox_checked_binding_1(value2) {
        observationShowTicks = value2;
        $$invalidate(5, observationShowTicks);
      }
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          container = $$value;
          $$invalidate(6, container);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(12, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(13, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(14, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(15, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(16, data2 = $$props2.data);
        if ("observationsData" in $$props2)
          $$invalidate(1, observationsData = $$props2.observationsData);
        if ("style" in $$props2)
          $$invalidate(17, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(18, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(19, height2 = $$props2.height);
        if ("keyword" in $$props2)
          $$invalidate(20, keyword = $$props2.keyword);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*data, activeReportSteps*/
        65544) {
          $$invalidate(21, dataForSelectedReportSteps = data2.filter((d) => activeReportSteps.includes(d.report_step.toString())));
        }
        if ($$self.$$.dirty[0] & /*observationsData, activeReportSteps*/
        10) {
          $$invalidate(10, observationsForSelectedReportSteps = observationsData.filter((d) => activeReportSteps.includes(d.report_step.toString())));
        }
        if ($$self.$$.dirty[0] & /*showObservations, observationShowTicks, observationWeight*/
        52) {
          $$invalidate(22, errorBarSpec = (data22) => {
            return showObservations ? [
              {
                "mark": {
                  "type": "errorbar",
                  "ticks": observationShowTicks,
                  "extent": "stderr",
                  "thickness": observationWeight
                },
                "encoding": {
                  "x": {
                    "field": "index",
                    "type": "ordinal",
                    title: ""
                  },
                  "y": {
                    "field": "vmin",
                    "type": "quantitative",
                    title: ""
                  },
                  "y2": {
                    "field": "vmax",
                    "type": "quantitative",
                    title: ""
                  },
                  "detail": {
                    "field": "realization",
                    "type": "nominal"
                  },
                  "color": { "value": "red" }
                },
                "data": { "values": data22 }
              }
            ] : [];
          });
        }
        if ($$self.$$.dirty[0] & /*container, dataForSelectedReportSteps, observationsForSelectedReportSteps, width, height, opacity, dasharray, weight, errorBarSpec*/
        7079872) {
          {
            if (container) {
              const experiments = getLoadedExperiments();
              const transformedData = dataForSelectedReportSteps.map((d, i) => ({
                lineIndex: i,
                value: d.values.map((v, ii) => ({ v, i: ii })),
                report_step: d.report_step,
                iteration: experiments[d.experiment].ensembles[d.ensemble_id].iteration,
                realization: d.realization
              }));
              const errorBarData = observationsForSelectedReportSteps.map((d) => ({
                report_step: d.report_step,
                index: d.index,
                vmin: d.observations - d.std,
                vmax: d.observations + d.std
              }));
              const numReportSteps = new Set(dataForSelectedReportSteps.map((d) => d.report_step)).size;
              const numIterations = new Set(dataForSelectedReportSteps.map((d) => d.ensemble_id)).size;
              const useWidth = (width2 - 250) / numReportSteps;
              const useHeight = (height2 - 100) / numIterations;
              const view = embed(container, {
                $schema: "https://vega.github.io/schema/vega-lite/v5.json",
                transform: [{ flatten: ["value"] }],
                data: { values: transformedData },
                facet: {
                  "column": {
                    "field": "report_step",
                    "type": "ordinal",
                    "title": "Report steps"
                  },
                  "row": {
                    "field": "iteration",
                    "type": "ordinal",
                    "title": "Iterations"
                  }
                },
                // Added column facet
                spec: {
                  width: useWidth,
                  height: useHeight,
                  layer: [
                    {
                      "mark": { "type": "line", "point": false },
                      "encoding": {
                        "y": {
                          "field": "value.v",
                          "type": "quantitative"
                        },
                        "x": {
                          "field": "value.i",
                          "type": "ordinal",
                          "title": "index"
                        },
                        "detail": {
                          "field": "realization",
                          "type": "nominal"
                        },
                        "opacity": { "value": opacity2 / 100 },
                        "strokeDash": { "value": [dasharray] },
                        "strokeWidth": { "value": weight },
                        "tooltip": [
                          {
                            "field": "iteration",
                            "title": "Iteration"
                          },
                          {
                            "field": "report_step",
                            "title": "Report Step"
                          },
                          { "field": "realization", "title": "" }
                        ]
                      }
                    },
                    // @ts-ignore
                    ...errorBarSpec(errorBarData)
                  ]
                }
              });
              view.then((result) => {
                result.view.width(width2).height(height2);
                result.view.resize();
              });
            }
          }
        }
        if ($$self.$$.dirty[0] & /*data*/
        65536)
          ;
        if ($$self.$$.dirty[0] & /*data*/
        65536)
          ;
      };
      return [
        localControlsDivSelector,
        observationsData,
        showObservations,
        activeReportSteps,
        observationWeight,
        observationShowTicks,
        container,
        weight,
        dasharray,
        opacity2,
        observationsForSelectedReportSteps,
        availableReportSteps,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        data2,
        style2,
        width2,
        height2,
        keyword,
        dataForSelectedReportSteps,
        errorBarSpec,
        combobox_value_binding,
        change_handler,
        checkbox_checked_binding,
        slider0_value_binding,
        slider1_value_binding,
        slider2_value_binding,
        slider_value_binding,
        checkbox_checked_binding_1,
        div1_binding
      ];
    }
    class GenDataLineMatrixVegaLite extends SvelteComponent {
      constructor(options) {
        super();
        init$2(
          this,
          options,
          instance$3,
          create_fragment$4,
          safe_not_equal,
          {
            localControlsDivSelector: 0,
            axisMarginLeft: 12,
            axisMarginBottom: 13,
            showAxisX: 14,
            showAxisY: 15,
            data: 16,
            observationsData: 1,
            style: 17,
            width: 18,
            height: 19,
            keyword: 20
          },
          null,
          [-1, -1]
        );
      }
    }
    function create_fragment$3(ctx) {
      let div0;
      let portal_action;
      let t4;
      let div1;
      let mounted;
      let dispose;
      return {
        c() {
          div0 = element$2("div");
          div0.innerHTML = ``;
          t4 = space();
          div1 = element$2("div");
          div1.innerHTML = ``;
        },
        m(target2, anchor2) {
          insert$2(target2, div0, anchor2);
          insert$2(target2, t4, anchor2);
          insert$2(target2, div1, anchor2);
          if (!mounted) {
            dispose = action_destroyer(portal_action = portal.call(
              null,
              div0,
              /*localControlsDivSelector*/
              ctx[0]
            ));
            mounted = true;
          }
        },
        p(ctx2, [dirty]) {
          if (portal_action && is_function(portal_action.update) && dirty & /*localControlsDivSelector*/
          1)
            portal_action.update.call(
              null,
              /*localControlsDivSelector*/
              ctx2[0]
            );
        },
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(div0);
            detach(t4);
            detach(div1);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function instance$2($$self, $$props, $$invalidate) {
      let { localControlsDivSelector } = $$props;
      let { axisMarginLeft = 35 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      let { data: data2 } = $$props;
      let { observationsData } = $$props;
      let { style: style2 } = $$props;
      let { width: width2 } = $$props;
      let { height: height2 } = $$props;
      let { keyword } = $$props;
      $$self.$$set = ($$props2) => {
        if ("localControlsDivSelector" in $$props2)
          $$invalidate(0, localControlsDivSelector = $$props2.localControlsDivSelector);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(1, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(2, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(3, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(4, showAxisY = $$props2.showAxisY);
        if ("data" in $$props2)
          $$invalidate(5, data2 = $$props2.data);
        if ("observationsData" in $$props2)
          $$invalidate(6, observationsData = $$props2.observationsData);
        if ("style" in $$props2)
          $$invalidate(7, style2 = $$props2.style);
        if ("width" in $$props2)
          $$invalidate(8, width2 = $$props2.width);
        if ("height" in $$props2)
          $$invalidate(9, height2 = $$props2.height);
        if ("keyword" in $$props2)
          $$invalidate(10, keyword = $$props2.keyword);
      };
      return [
        localControlsDivSelector,
        axisMarginLeft,
        axisMarginBottom,
        showAxisX,
        showAxisY,
        data2,
        observationsData,
        style2,
        width2,
        height2,
        keyword
      ];
    }
    class SurfaceViewPlotly extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$2, create_fragment$3, safe_not_equal, {
          localControlsDivSelector: 0,
          axisMarginLeft: 1,
          axisMarginBottom: 2,
          showAxisX: 3,
          showAxisY: 4,
          data: 5,
          observationsData: 6,
          style: 7,
          width: 8,
          height: 9,
          keyword: 10
        });
      }
    }
    const DataToComponentType = [
      {
        kind: "surface",
        chart: "contour3d",
        component: SurfaceViewPlotly
      },
      {
        kind: "gendata",
        chart: "line matrix",
        component: GenDataLineMatrixVegaLite
      },
      {
        kind: "gendata",
        chart: "lines",
        component: GenDataLines
      },
      {
        kind: "parameter",
        chart: "ridgelines",
        component: ParameterKDERidgelines
      },
      {
        kind: "parameter",
        chart: "area",
        component: ParameterKDEArea
      },
      {
        kind: "summary",
        chart: "lines",
        component: SummaryLines
      },
      {
        kind: "summary",
        chart: "linePlotly",
        component: SummaryLinesPlotly
      },
      {
        kind: "summary",
        chart: "stackedLines",
        component: SummaryLinesStacked
      }
    ];
    function create_item_slot_2(ctx) {
      let div;
      let t_value = (
        /*option*/
        ctx[30].label + ""
      );
      let t4;
      return {
        c() {
          div = element$2("div");
          t4 = text$3(t_value);
          attr$6(div, "slot", "item");
          attr$6(div, "class", "w-full p-3 flex flex-row");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          append$2(div, t4);
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*option*/
          1073741824 && t_value !== (t_value = /*option*/
          ctx2[30].label + ""))
            set_data(t4, t_value);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }
    function create_if_block_1(ctx) {
      let div;
      let t4;
      let current2;
      let if_block0 = (
        /*option*/
        ctx[30].data.hasHistory && create_if_block_3()
      );
      let if_block1 = (
        /*option*/
        ctx[30].data.hasObservations && create_if_block_2()
      );
      return {
        c() {
          div = element$2("div");
          if (if_block0)
            if_block0.c();
          t4 = space();
          if (if_block1)
            if_block1.c();
          attr$6(div, "class", "flex min-w-8 flex-row w-full justify-evenly");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          if (if_block0)
            if_block0.m(div, null);
          append$2(div, t4);
          if (if_block1)
            if_block1.m(div, null);
          current2 = true;
        },
        p(ctx2, dirty) {
          if (
            /*option*/
            ctx2[30].data.hasHistory
          ) {
            if (if_block0) {
              if (dirty[0] & /*option*/
              1073741824) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_3();
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t4);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (
            /*option*/
            ctx2[30].data.hasObservations
          ) {
            if (if_block1) {
              if (dirty[0] & /*option*/
              1073741824) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2();
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          current2 = true;
        },
        o(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
        }
      };
    }
    function create_if_block_3(ctx) {
      let p;
      let icon;
      let t4;
      let current2;
      icon = new Icon({
        props: {
          width: "22",
          height: "22",
          name: "timeline"
        }
      });
      return {
        c() {
          p = element$2("p");
          create_component(icon.$$.fragment);
          t4 = text$3(" History");
          attr$6(p, "class", "flex flex-1 justify-end");
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
          mount_component(icon, p, null);
          append$2(p, t4);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(p);
          }
          destroy_component(icon);
        }
      };
    }
    function create_if_block_2(ctx) {
      let p;
      let icon;
      let t4;
      let current2;
      icon = new Icon({
        props: {
          width: "22",
          height: "22",
          name: "table_chart"
        }
      });
      return {
        c() {
          p = element$2("p");
          create_component(icon.$$.fragment);
          t4 = text$3(" Observations");
          attr$6(p, "class", "flex flex-1 justify-end");
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
          mount_component(icon, p, null);
          append$2(p, t4);
          current2 = true;
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(p);
          }
          destroy_component(icon);
        }
      };
    }
    function create_item_slot_1(ctx) {
      let div1;
      let div0;
      let p02;
      let icon;
      let t02;
      let t1_value = (
        /*option*/
        ctx[30].label + ""
      );
      let t12;
      let t22;
      let p1;
      let t3_value = (
        /*option*/
        ctx[30].data.kind + ""
      );
      let t32;
      let t4;
      let current2;
      icon = new Icon({
        props: {
          width: "22",
          height: "22",
          name: (
            /*option*/
            ctx[30].data.kind === "summary" ? "time" : "bar_chart"
          )
        }
      });
      let if_block = (
        /*option*/
        (ctx[30].data.hasHistory || /*option*/
        ctx[30].data.hasObservations) && create_if_block_1(ctx)
      );
      return {
        c() {
          div1 = element$2("div");
          div0 = element$2("div");
          p02 = element$2("p");
          create_component(icon.$$.fragment);
          t02 = text$3("");
          t12 = text$3(t1_value);
          t22 = space();
          p1 = element$2("p");
          t32 = text$3(t3_value);
          t4 = space();
          if (if_block)
            if_block.c();
          attr$6(p02, "class", "flex flex-1");
          attr$6(p1, "class", "font-light ml-2 italic");
          attr$6(div0, "class", "flex flex-col w-full");
          attr$6(div1, "slot", "item");
          attr$6(div1, "class", "w-full p-3 flex flex-row");
        },
        m(target2, anchor2) {
          insert$2(target2, div1, anchor2);
          append$2(div1, div0);
          append$2(div0, p02);
          mount_component(icon, p02, null);
          append$2(p02, t02);
          append$2(p02, t12);
          append$2(div0, t22);
          append$2(div0, p1);
          append$2(p1, t32);
          append$2(div1, t4);
          if (if_block)
            if_block.m(div1, null);
          current2 = true;
        },
        p(ctx2, dirty) {
          const icon_changes = {};
          if (dirty[0] & /*option*/
          1073741824)
            icon_changes.name = /*option*/
            ctx2[30].data.kind === "summary" ? "time" : "bar_chart";
          icon.$set(icon_changes);
          if ((!current2 || dirty[0] & /*option*/
          1073741824) && t1_value !== (t1_value = /*option*/
          ctx2[30].label + ""))
            set_data(t12, t1_value);
          if ((!current2 || dirty[0] & /*option*/
          1073741824) && t3_value !== (t3_value = /*option*/
          ctx2[30].data.kind + ""))
            set_data(t32, t3_value);
          if (
            /*option*/
            ctx2[30].data.hasHistory || /*option*/
            ctx2[30].data.hasObservations
          ) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & /*option*/
              1073741824) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          transition_in(if_block);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          transition_out(if_block);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          destroy_component(icon);
          if (if_block)
            if_block.d();
        }
      };
    }
    function create_item_slot(ctx) {
      let div;
      let t_value = (
        /*option*/
        ctx[30].label + ""
      );
      let t4;
      return {
        c() {
          div = element$2("div");
          t4 = text$3(t_value);
          attr$6(div, "slot", "item");
          attr$6(div, "class", "w-full p-3 flex flex-row");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          append$2(div, t4);
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*option*/
          1073741824 && t_value !== (t_value = /*option*/
          ctx2[30].label + ""))
            set_data(t4, t_value);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }
    function create_controls_slot(ctx) {
      let div1;
      let combobox0;
      let t02;
      let combobox1;
      let t12;
      let br0;
      let t22;
      let combobox2;
      let t32;
      let br1;
      let t4;
      let combobox3;
      let t5;
      let div0;
      let div0_id_value;
      let current2;
      combobox0 = new Combobox({
        props: {
          label: "Experiment",
          placeholder: "Select experiment",
          options: Object.values(getLoadedExperiments()).map(func),
          value: (
            /*spec*/
            ctx[2].query.experiment
          ),
          customValueLabel: (
            /*func_1*/
            ctx[22]
          ),
          noMinItemHeight: true,
          $$slots: {
            item: [
              create_item_slot_2,
              ({ option }) => ({ 30: option }),
              ({ option }) => [option ? 1073741824 : 0]
            ]
          },
          $$scope: { ctx }
        }
      });
      combobox0.$on(
        "change",
        /*change_handler*/
        ctx[23]
      );
      combobox1 = new Combobox({
        props: {
          label: "Ensembles",
          placeholder: "Select ensembles",
          options: (
            /*experiment*/
            ctx[8]().sortedEnsembles().map(func_2)
          ),
          customValueLabel: (
            /*ensembleLabelFunction*/
            ctx[17]
          ),
          value: (
            /*spec*/
            ctx[2].query.ensembles.map(
              /*func_3*/
              ctx[24]
            )
          ),
          multiselect: true
        }
      });
      combobox1.$on(
        "change",
        /*change_handler_1*/
        ctx[25]
      );
      combobox2 = new Combobox({
        props: {
          label: "Keyword",
          placeholder: "Select keyword",
          options: (
            /*experiment*/
            ctx[8]().availableKeywords().map(func_4)
          ),
          value: (
            /*spec*/
            ctx[2].query.keyword
          ),
          noMinItemHeight: true,
          $$slots: {
            item: [
              create_item_slot_1,
              ({ option }) => ({ 30: option }),
              ({ option }) => [option ? 1073741824 : 0]
            ]
          },
          $$scope: { ctx }
        }
      });
      combobox2.$on(
        "change",
        /*change_handler_2*/
        ctx[26]
      );
      combobox3 = new Combobox({
        props: {
          label: "Chart",
          placeholder: "Select chart type",
          options: (
            /*availableChartTypes*/
            ctx[7].map(func_5)
          ),
          value: (
            /*spec*/
            ctx[2].chart
          ),
          noMinItemHeight: true,
          $$slots: {
            item: [
              create_item_slot,
              ({ option }) => ({ 30: option }),
              ({ option }) => [option ? 1073741824 : 0]
            ]
          },
          $$scope: { ctx }
        }
      });
      combobox3.$on(
        "change",
        /*change_handler_3*/
        ctx[27]
      );
      return {
        c() {
          div1 = element$2("div");
          create_component(combobox0.$$.fragment);
          t02 = space();
          create_component(combobox1.$$.fragment);
          t12 = space();
          br0 = element$2("br");
          t22 = space();
          create_component(combobox2.$$.fragment);
          t32 = space();
          br1 = element$2("br");
          t4 = space();
          create_component(combobox3.$$.fragment);
          t5 = space();
          div0 = element$2("div");
          attr$6(div0, "class", "p-3");
          attr$6(div0, "id", div0_id_value = /*localControlsDivId*/
          ctx[9]());
          attr$6(div1, "slot", "controls");
          attr$6(div1, "class", "p-2");
        },
        m(target2, anchor2) {
          insert$2(target2, div1, anchor2);
          mount_component(combobox0, div1, null);
          append$2(div1, t02);
          mount_component(combobox1, div1, null);
          append$2(div1, t12);
          append$2(div1, br0);
          append$2(div1, t22);
          mount_component(combobox2, div1, null);
          append$2(div1, t32);
          append$2(div1, br1);
          append$2(div1, t4);
          mount_component(combobox3, div1, null);
          append$2(div1, t5);
          append$2(div1, div0);
          current2 = true;
        },
        p(ctx2, dirty) {
          const combobox0_changes = {};
          if (dirty[0] & /*spec*/
          4)
            combobox0_changes.value = /*spec*/
            ctx2[2].query.experiment;
          if (dirty[0] & /*option*/
          1073741824 | dirty[1] & /*$$scope*/
          1) {
            combobox0_changes.$$scope = { dirty, ctx: ctx2 };
          }
          combobox0.$set(combobox0_changes);
          const combobox1_changes = {};
          if (dirty[0] & /*experiment*/
          256)
            combobox1_changes.options = /*experiment*/
            ctx2[8]().sortedEnsembles().map(func_2);
          if (dirty[0] & /*spec, experiment*/
          260)
            combobox1_changes.value = /*spec*/
            ctx2[2].query.ensembles.map(
              /*func_3*/
              ctx2[24]
            );
          combobox1.$set(combobox1_changes);
          const combobox2_changes = {};
          if (dirty[0] & /*experiment*/
          256)
            combobox2_changes.options = /*experiment*/
            ctx2[8]().availableKeywords().map(func_4);
          if (dirty[0] & /*spec*/
          4)
            combobox2_changes.value = /*spec*/
            ctx2[2].query.keyword;
          if (dirty[0] & /*option*/
          1073741824 | dirty[1] & /*$$scope*/
          1) {
            combobox2_changes.$$scope = { dirty, ctx: ctx2 };
          }
          combobox2.$set(combobox2_changes);
          const combobox3_changes = {};
          if (dirty[0] & /*availableChartTypes*/
          128)
            combobox3_changes.options = /*availableChartTypes*/
            ctx2[7].map(func_5);
          if (dirty[0] & /*spec*/
          4)
            combobox3_changes.value = /*spec*/
            ctx2[2].chart;
          if (dirty[0] & /*option*/
          1073741824 | dirty[1] & /*$$scope*/
          1) {
            combobox3_changes.$$scope = { dirty, ctx: ctx2 };
          }
          combobox3.$set(combobox3_changes);
          if (!current2 || dirty[0] & /*localControlsDivId*/
          512 && div0_id_value !== (div0_id_value = /*localControlsDivId*/
          ctx2[9]())) {
            attr$6(div0, "id", div0_id_value);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(combobox0.$$.fragment, local);
          transition_in(combobox1.$$.fragment, local);
          transition_in(combobox2.$$.fragment, local);
          transition_in(combobox3.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(combobox0.$$.fragment, local);
          transition_out(combobox1.$$.fragment, local);
          transition_out(combobox2.$$.fragment, local);
          transition_out(combobox3.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          destroy_component(combobox0);
          destroy_component(combobox1);
          destroy_component(combobox2);
          destroy_component(combobox3);
        }
      };
    }
    function create_catch_block_1(ctx) {
      return { c: noop$6, m: noop$6, p: noop$6, d: noop$6 };
    }
    function create_then_block_1(ctx) {
      let t_value = (
        /*performanceInfo*/
        ctx[10]() + ""
      );
      let t4;
      return {
        c() {
          t4 = text$3(t_value);
        },
        m(target2, anchor2) {
          insert$2(target2, t4, anchor2);
        },
        p(ctx2, dirty) {
          if (dirty[0] & /*performanceInfo*/
          1024 && t_value !== (t_value = /*performanceInfo*/
          ctx2[10]() + ""))
            set_data(t4, t_value);
        },
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
        }
      };
    }
    function create_pending_block_1(ctx) {
      let t4;
      return {
        c() {
          t4 = text$3("Fetching data...");
        },
        m(target2, anchor2) {
          insert$2(target2, t4, anchor2);
        },
        p: noop$6,
        d(detaching) {
          if (detaching) {
            detach(t4);
          }
        }
      };
    }
    function create_catch_block$1(ctx) {
      return {
        c: noop$6,
        m: noop$6,
        p: noop$6,
        i: noop$6,
        o: noop$6,
        d: noop$6
      };
    }
    function create_then_block$1(ctx) {
      let if_block_anchor;
      let current2;
      let if_block = (
        /*containerWidth*/
        ctx[3] > 0 && /*containerHeight*/
        ctx[4] > 0 && create_if_block(ctx)
      );
      return {
        c() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty$1();
        },
        m(target2, anchor2) {
          if (if_block)
            if_block.m(target2, anchor2);
          insert$2(target2, if_block_anchor, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          if (
            /*containerWidth*/
            ctx2[3] > 0 && /*containerHeight*/
            ctx2[4] > 0
          ) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & /*containerWidth, containerHeight*/
              24) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(if_block);
          current2 = true;
        },
        o(local) {
          transition_out(if_block);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(if_block_anchor);
          }
          if (if_block)
            if_block.d(detaching);
        }
      };
    }
    function create_if_block(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current2;
      var switch_value = (
        /*findComponentAndDataInfo*/
        ctx[14]().component
      );
      function switch_props(ctx2, dirty) {
        return {
          props: {
            data: (
              /*findComponentAndDataInfo*/
              ctx2[14]().data
            ),
            historyData: (
              /*findComponentAndDataInfo*/
              ctx2[14]().historyData
            ),
            observationsData: (
              /*observations*/
              ctx2[6]()
            ),
            style: (
              /*computeEnsembleStyleMap*/
              ctx2[11]()
            ),
            width: (
              /*containerWidth*/
              ctx2[3] - 20
            ),
            height: (
              /*containerHeight*/
              ctx2[4] - 20
            ),
            keyword: (
              /*spec*/
              ctx2[2].query.keyword
            ),
            axisMarginLeft: (
              /*axisMarginLeft*/
              ctx2[0]
            ),
            axisMarginBottom: (
              /*axisMarginBottom*/
              ctx2[1]
            ),
            localControlsDivSelector: "#" + /*localControlsDivId*/
            ctx2[9]()
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      return {
        c() {
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty$1();
        },
        m(target2, anchor2) {
          if (switch_instance)
            mount_component(switch_instance, target2, anchor2);
          insert$2(target2, switch_instance_anchor, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          if (switch_value !== (switch_value = /*findComponentAndDataInfo*/
          ctx2[14]().component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[0] & /*observations*/
            64)
              switch_instance_changes.observationsData = /*observations*/
              ctx2[6]();
            if (dirty[0] & /*computeEnsembleStyleMap*/
            2048)
              switch_instance_changes.style = /*computeEnsembleStyleMap*/
              ctx2[11]();
            if (dirty[0] & /*containerWidth*/
            8)
              switch_instance_changes.width = /*containerWidth*/
              ctx2[3] - 20;
            if (dirty[0] & /*containerHeight*/
            16)
              switch_instance_changes.height = /*containerHeight*/
              ctx2[4] - 20;
            if (dirty[0] & /*spec*/
            4)
              switch_instance_changes.keyword = /*spec*/
              ctx2[2].query.keyword;
            if (dirty[0] & /*axisMarginLeft*/
            1)
              switch_instance_changes.axisMarginLeft = /*axisMarginLeft*/
              ctx2[0];
            if (dirty[0] & /*axisMarginBottom*/
            2)
              switch_instance_changes.axisMarginBottom = /*axisMarginBottom*/
              ctx2[1];
            if (dirty[0] & /*localControlsDivId*/
            512)
              switch_instance_changes.localControlsDivSelector = "#" + /*localControlsDivId*/
              ctx2[9]();
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current2)
            return;
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(switch_instance_anchor);
          }
          if (switch_instance)
            destroy_component(switch_instance, detaching);
        }
      };
    }
    function create_pending_block$1(ctx) {
      let div;
      let p;
      let t12;
      let icon;
      let current2;
      icon = new Icon({ props: { name: "loop", spin: true } });
      return {
        c() {
          div = element$2("div");
          p = element$2("p");
          p.textContent = "Loading data & rendering chart";
          t12 = space();
          create_component(icon.$$.fragment);
          attr$6(p, "class", "");
          attr$6(div, "class", "w-full h-full flex items-center justify-center");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          append$2(div, p);
          append$2(div, t12);
          mount_component(icon, div, null);
          current2 = true;
        },
        p: noop$6,
        i(local) {
          if (current2)
            return;
          transition_in(icon.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(icon.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_component(icon);
        }
      };
    }
    function create_fragment$2(ctx) {
      let div4;
      let span2;
      let sidebar;
      let updating_open;
      let updating_experiment;
      let t02;
      let div2;
      let div0;
      let t1_value = (
        /*spec*/
        ctx[2].chart + ""
      );
      let t12;
      let t22;
      let t3_value = (
        /*spec*/
        ctx[2].kind + ""
      );
      let t32;
      let t4;
      let t5_value = (
        /*spec*/
        ctx[2].query.keyword + ""
      );
      let t5;
      let t6;
      let div1;
      let promise;
      let t7;
      let div3;
      let promise_1;
      let current2;
      let mounted;
      let dispose;
      function sidebar_open_binding(value2) {
        ctx[28](value2);
      }
      function sidebar_experiment_binding(value2) {
        ctx[29](value2);
      }
      let sidebar_props = {
        waitFor: Promise.all([
          /*ensureComponentDataIsLoaded*/
          ctx[12](),
          /*ensureExperimentIsSelected*/
          ctx[13]()
        ]),
        $$slots: { controls: [create_controls_slot] },
        $$scope: { ctx }
      };
      if (
        /*isSidebarOpen*/
        ctx[5] !== void 0
      ) {
        sidebar_props.open = /*isSidebarOpen*/
        ctx[5];
      }
      if (
        /*spec*/
        ctx[2].query.experiment !== void 0
      ) {
        sidebar_props.experiment = /*spec*/
        ctx[2].query.experiment;
      }
      sidebar = new Sidebar({ props: sidebar_props });
      binding_callbacks.push(() => bind$2(sidebar, "open", sidebar_open_binding));
      binding_callbacks.push(() => bind$2(sidebar, "experiment", sidebar_experiment_binding));
      let info2 = {
        ctx,
        current: null,
        token: null,
        hasCatch: false,
        pending: create_pending_block_1,
        then: create_then_block_1,
        catch: create_catch_block_1
      };
      handle_promise(
        promise = Promise.all([
          /*ensureComponentDataIsLoaded*/
          ctx[12](),
          /*ensureExperimentIsSelected*/
          ctx[13]()
        ]),
        info2
      );
      let info_1 = {
        ctx,
        current: null,
        token: null,
        hasCatch: false,
        pending: create_pending_block$1,
        then: create_then_block$1,
        catch: create_catch_block$1,
        blocks: [, , ,]
      };
      handle_promise(
        promise_1 = Promise.all([
          /*ensureComponentDataIsLoaded*/
          ctx[12](),
          /*ensureExperimentIsSelected*/
          ctx[13]()
        ]),
        info_1
      );
      return {
        c() {
          div4 = element$2("div");
          span2 = element$2("span");
          create_component(sidebar.$$.fragment);
          t02 = space();
          div2 = element$2("div");
          div0 = element$2("div");
          t12 = text$3(t1_value);
          t22 = text$3(" of ");
          t32 = text$3(t3_value);
          t4 = text$3(" keyword ");
          t5 = text$3(t5_value);
          t6 = space();
          div1 = element$2("div");
          info2.block.c();
          t7 = space();
          div3 = element$2("div");
          info_1.block.c();
          attr$6(div0, "class", "flex flex-1 justify-end text-lg");
          attr$6(div1, "class", "flex flex-1 justify-end italic font-thin");
          attr$6(div2, "class", "flex-1 justify-end pr-8");
          attr$6(span2, "class", "inline-flex p-3 w-full");
          attr$6(div3, "class", "h-96 relative");
          attr$6(div4, "class", "relative w-full h-full shadow-lg rounded m-5");
        },
        m(target2, anchor2) {
          insert$2(target2, div4, anchor2);
          append$2(div4, span2);
          mount_component(sidebar, span2, null);
          append$2(span2, t02);
          append$2(span2, div2);
          append$2(div2, div0);
          append$2(div0, t12);
          append$2(div0, t22);
          append$2(div0, t32);
          append$2(div0, t4);
          append$2(div0, t5);
          append$2(div2, t6);
          append$2(div2, div1);
          info2.block.m(div1, info2.anchor = null);
          info2.mount = () => div1;
          info2.anchor = null;
          append$2(div4, t7);
          append$2(div4, div3);
          info_1.block.m(div3, info_1.anchor = null);
          info_1.mount = () => div3;
          info_1.anchor = null;
          current2 = true;
          if (!mounted) {
            dispose = [
              action_destroyer(watchResize.call(null, div3)),
              listen(
                div3,
                "resized",
                /*onResize*/
                ctx[15]
              )
            ];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          const sidebar_changes = {};
          if (dirty[0] & /*ensureComponentDataIsLoaded*/
          4096)
            sidebar_changes.waitFor = Promise.all([
              /*ensureComponentDataIsLoaded*/
              ctx[12](),
              /*ensureExperimentIsSelected*/
              ctx[13]()
            ]);
          if (dirty[0] & /*localControlsDivId, availableChartTypes, spec, experiment*/
          900 | dirty[1] & /*$$scope*/
          1) {
            sidebar_changes.$$scope = { dirty, ctx };
          }
          if (!updating_open && dirty[0] & /*isSidebarOpen*/
          32) {
            updating_open = true;
            sidebar_changes.open = /*isSidebarOpen*/
            ctx[5];
            add_flush_callback(() => updating_open = false);
          }
          if (!updating_experiment && dirty[0] & /*spec*/
          4) {
            updating_experiment = true;
            sidebar_changes.experiment = /*spec*/
            ctx[2].query.experiment;
            add_flush_callback(() => updating_experiment = false);
          }
          sidebar.$set(sidebar_changes);
          if ((!current2 || dirty[0] & /*spec*/
          4) && t1_value !== (t1_value = /*spec*/
          ctx[2].chart + ""))
            set_data(t12, t1_value);
          if ((!current2 || dirty[0] & /*spec*/
          4) && t3_value !== (t3_value = /*spec*/
          ctx[2].kind + ""))
            set_data(t32, t3_value);
          if ((!current2 || dirty[0] & /*spec*/
          4) && t5_value !== (t5_value = /*spec*/
          ctx[2].query.keyword + ""))
            set_data(t5, t5_value);
          info2.ctx = ctx;
          if (dirty[0] & /*ensureComponentDataIsLoaded*/
          4096 && promise !== (promise = Promise.all([
            /*ensureComponentDataIsLoaded*/
            ctx[12](),
            /*ensureExperimentIsSelected*/
            ctx[13]()
          ])) && handle_promise(promise, info2))
            ;
          else {
            update_await_block_branch(info2, ctx, dirty);
          }
          info_1.ctx = ctx;
          if (dirty[0] & /*ensureComponentDataIsLoaded*/
          4096 && promise_1 !== (promise_1 = Promise.all([
            /*ensureComponentDataIsLoaded*/
            ctx[12](),
            /*ensureExperimentIsSelected*/
            ctx[13]()
          ])) && handle_promise(promise_1, info_1))
            ;
          else {
            update_await_block_branch(info_1, ctx, dirty);
          }
        },
        i(local) {
          if (current2)
            return;
          transition_in(sidebar.$$.fragment, local);
          transition_in(info_1.block);
          current2 = true;
        },
        o(local) {
          transition_out(sidebar.$$.fragment, local);
          for (let i = 0; i < 3; i += 1) {
            const block2 = info_1.blocks[i];
            transition_out(block2);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div4);
          }
          destroy_component(sidebar);
          info2.block.d();
          info2.token = null;
          info2 = null;
          info_1.block.d();
          info_1.token = null;
          info_1 = null;
          mounted = false;
          run_all(dispose);
        }
      };
    }
    const func = (t4) => ({ value: t4.id, label: t4.name });
    const func_2 = (ens) => ({
      value: ens.id,
      label: `Iteration ${ens.iteration}`
    });
    const func_4 = (info2) => ({
      value: info2.key,
      label: info2.key,
      data: info2
    });
    const func_5 = (t4) => ({ value: t4, label: t4 });
    function instance$1($$self, $$props, $$invalidate) {
      let spec;
      let ensureComponentDataIsLoaded;
      let computeEnsembleStyleMap;
      let performanceInfo;
      let experiment;
      let localControlsDivId;
      let availableChartTypes;
      let observations;
      let $plotterStore;
      component_subscribe($$self, plotterStore, ($$value) => $$invalidate(21, $plotterStore = $$value));
      let { viewIndex } = $$props;
      let { axisMarginLeft = 65 } = $$props;
      let { axisMarginBottom = 35 } = $$props;
      let { showAxisX = true } = $$props;
      let { showAxisY = true } = $$props;
      const ensureExperimentIsSelected = async () => {
        await fetchExperiments();
        const metadata2 = getLoadedExperiments();
        if (spec.query.experiment === "auto")
          $$invalidate(2, spec.query.experiment = Object.keys(metadata2)[0], spec);
      };
      const findComponentAndDataInfo = () => {
        const { kind, chart } = spec;
        const component = DataToComponentType.find((v) => v.kind === kind && v.chart === chart).component;
        if (kind === "gendata") {
          const genData = getLoadedGenData(spec.query);
          return { component, ...genData };
        }
        if (kind === "parameter") {
          const param2 = getLoadedParameter(spec.query);
          return { component, ...param2 };
        }
        if (kind === "summary") {
          const summary = getLoadedSummary(spec.query);
          return { component, ...summary };
        }
        throw new TypeError(`Expected valid dataset kind, got ${kind}, expected one of [${["summary", "parameter"].join(", ")}]`);
      };
      let containerWidth = 0;
      let containerHeight = 0;
      const onResize = (event2) => {
        const { entries: entries2 } = event2.detail;
        const entry2 = entries2[0];
        const { width: width2, height: height2 } = entry2.contentRect;
        $$invalidate(3, containerWidth = width2);
        $$invalidate(4, containerHeight = height2);
      };
      let isSidebarOpen = false;
      const updateChartQuery = async (keyword) => {
        const info2 = experiment().getKeywordInfo(keyword);
        const { kind } = info2;
        if (kind !== spec.kind) {
          const chart = DataToComponentType.find((info22) => info22.kind === kind).chart;
          Object.assign(spec, { chart, kind });
          $$invalidate(2, spec.query.keyword = keyword, spec);
        } else {
          $$invalidate(2, spec.query.keyword = keyword, spec);
        }
      };
      const ensembleLabelFunction = (value2, options) => {
        const singleLabels = value2.map((v) => options.find((o) => o.value === v).label);
        const niceLabel = `Iterations ${singleLabels.map((sl) => sl.replace("Iteration ", "")).sort().join(", ")}`;
        return niceLabel;
      };
      const func_12 = (v) => getLoadedExperiments()[v].name;
      const change_handler = (e3) => $$invalidate(2, spec.query.experiment = e3.detail.value, spec);
      const func_32 = (e3) => experiment().ensembleAliasToId(e3);
      const change_handler_1 = (e3) => $$invalidate(2, spec.query.ensembles = e3.detail.value, spec);
      const change_handler_2 = (e3) => updateChartQuery(e3.detail.value);
      const change_handler_3 = (e3) => $$invalidate(2, spec.chart = e3.detail.value, spec);
      function sidebar_open_binding(value2) {
        isSidebarOpen = value2;
        $$invalidate(5, isSidebarOpen);
      }
      function sidebar_experiment_binding(value2) {
        if ($$self.$$.not_equal(spec.query.experiment, value2)) {
          spec.query.experiment = value2;
          $$invalidate(2, spec), $$invalidate(21, $plotterStore), $$invalidate(18, viewIndex);
        }
      }
      $$self.$$set = ($$props2) => {
        if ("viewIndex" in $$props2)
          $$invalidate(18, viewIndex = $$props2.viewIndex);
        if ("axisMarginLeft" in $$props2)
          $$invalidate(0, axisMarginLeft = $$props2.axisMarginLeft);
        if ("axisMarginBottom" in $$props2)
          $$invalidate(1, axisMarginBottom = $$props2.axisMarginBottom);
        if ("showAxisX" in $$props2)
          $$invalidate(19, showAxisX = $$props2.showAxisX);
        if ("showAxisY" in $$props2)
          $$invalidate(20, showAxisY = $$props2.showAxisY);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*$plotterStore, viewIndex*/
        2359296) {
          $$invalidate(2, spec = $plotterStore.charts[viewIndex]);
        }
        if ($$self.$$.dirty[0] & /*spec*/
        4) {
          $$invalidate(12, ensureComponentDataIsLoaded = async () => {
            const { kind, query } = spec;
            if (query.ensembles.length === 0)
              return true;
            switch (kind) {
              case "summary":
                await fetchSummary(query);
                await fetchObservations(query);
                break;
              case "parameter":
                await fetchParameter(query);
                break;
              case "gendata":
                await fetchGenData(query);
                await fetchObservations(query);
                break;
            }
          });
        }
        if ($$self.$$.dirty[0] & /*spec, $plotterStore*/
        2097156) {
          $$invalidate(11, computeEnsembleStyleMap = () => {
            const style2 = spec.style || {};
            const stylePerEnsemble = {};
            const experiment2 = getLoadedExperiments()[spec.query.experiment];
            experiment2.eachEnsemble((ensembleId, ensembleAlias, index2) => {
              stylePerEnsemble[ensembleAlias] = stylePerEnsemble[ensembleId] = {
                stroke: SortedEDSColors[index2],
                fill: SortedEDSColors[index2]
              };
              const globalStyle = $plotterStore.style;
              Object.keys(globalStyle).filter((k) => k.startsWith("ensemble:") || k === "*").filter((k) => k === ensembleAlias || k === "*").forEach((k) => Object.assign(stylePerEnsemble[ensembleAlias], globalStyle[k]));
              Object.keys(style2 || {}).filter((k) => k.startsWith("ensemble:") || k === "*").filter((k) => k === ensembleAlias || k === "*").forEach((k) => Object.assign(stylePerEnsemble[ensembleAlias], style2[k]));
            });
            return {
              ...stylePerEnsemble,
              annotationColors: SortedEDSWarningColors
            };
          });
        }
        if ($$self.$$.dirty[0] & /*spec*/
        4) {
          $$invalidate(10, performanceInfo = () => {
            const { kind } = spec;
            const { timeSpentSeconds, MBProcessed, data: data2 } = findComponentAndDataInfo();
            try {
              if (kind === "gendata") {
                const { experiment: experiment2 } = data2[0];
                const exp2 = getLoadedExperiments()[experiment2];
                const entry2 = exp2.responses.gen_data.find((gd) => gd.name === spec.query.keyword);
                const { report_steps } = entry2;
                return `Loaded ${data2.length / report_steps.length} realizations x ${report_steps.length} report steps in ${timeSpentSeconds.toFixed(4)}s, ${MBProcessed}MB processed`;
              }
              return `Loaded ${data2.length} realizations in ${timeSpentSeconds.toFixed(4)}s, ${MBProcessed}MB processed`;
            } catch (e3) {
              return `Loading data...`;
            }
          });
        }
        if ($$self.$$.dirty[0] & /*spec*/
        4) {
          $$invalidate(8, experiment = () => getLoadedExperiments()[spec.query.experiment]);
        }
        if ($$self.$$.dirty[0] & /*viewIndex*/
        262144) {
          $$invalidate(9, localControlsDivId = () => `chart-view-${viewIndex}-local-controls`);
        }
        if ($$self.$$.dirty[0] & /*spec*/
        4) {
          $$invalidate(7, availableChartTypes = DataToComponentType.filter((info2) => info2.kind === spec.kind).map((info2) => info2.chart));
        }
        if ($$self.$$.dirty[0] & /*spec*/
        4) {
          $$invalidate(6, observations = () => {
            const allObservations = getLoadedObservations(spec.query);
            switch (spec.kind) {
              case "summary":
                return (allObservations.summary || []).filter((obs) => obs.name === spec.query.keyword);
              case "gendata":
                return (allObservations.gen_data || []).filter((obs) => obs.name === spec.query.keyword);
              case "parameter":
                return [];
            }
          });
        }
      };
      return [
        axisMarginLeft,
        axisMarginBottom,
        spec,
        containerWidth,
        containerHeight,
        isSidebarOpen,
        observations,
        availableChartTypes,
        experiment,
        localControlsDivId,
        performanceInfo,
        computeEnsembleStyleMap,
        ensureComponentDataIsLoaded,
        ensureExperimentIsSelected,
        findComponentAndDataInfo,
        onResize,
        updateChartQuery,
        ensembleLabelFunction,
        viewIndex,
        showAxisX,
        showAxisY,
        $plotterStore,
        func_12,
        change_handler,
        func_32,
        change_handler_1,
        change_handler_2,
        change_handler_3,
        sidebar_open_binding,
        sidebar_experiment_binding
      ];
    }
    class GeneralChartView extends SvelteComponent {
      constructor(options) {
        super();
        init$2(
          this,
          options,
          instance$1,
          create_fragment$2,
          safe_not_equal,
          {
            viewIndex: 18,
            axisMarginLeft: 0,
            axisMarginBottom: 1,
            showAxisX: 19,
            showAxisY: 20
          },
          null,
          [-1, -1]
        );
      }
    }
    function get_each_context(ctx, list2, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list2[i];
      child_ctx[3] = i;
      return child_ctx;
    }
    function create_catch_block(ctx) {
      return {
        c: noop$6,
        m: noop$6,
        p: noop$6,
        i: noop$6,
        o: noop$6,
        d: noop$6
      };
    }
    function create_then_block(ctx) {
      let each_1_anchor;
      let current2;
      let each_value = ensure_array_like({
        length: (
          /*$plotterStore*/
          ctx[0].charts.length
        )
      });
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty$1();
        },
        m(target2, anchor2) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(target2, anchor2);
            }
          }
          insert$2(target2, each_1_anchor, anchor2);
          current2 = true;
        },
        p(ctx2, dirty) {
          if (dirty & /*$plotterStore*/
          1) {
            each_value = ensure_array_like({
              length: (
                /*$plotterStore*/
                ctx2[0].charts.length
              )
            });
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
          }
        },
        i(local) {
          if (current2)
            return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current2 = true;
        },
        o(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function create_each_block(ctx) {
      let generalchartview;
      let current2;
      generalchartview = new GeneralChartView({ props: { viewIndex: (
        /*index*/
        ctx[3]
      ) } });
      return {
        c() {
          create_component(generalchartview.$$.fragment);
        },
        m(target2, anchor2) {
          mount_component(generalchartview, target2, anchor2);
          current2 = true;
        },
        p: noop$6,
        i(local) {
          if (current2)
            return;
          transition_in(generalchartview.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(generalchartview.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          destroy_component(generalchartview, detaching);
        }
      };
    }
    function create_pending_block(ctx) {
      let p;
      return {
        c() {
          p = element$2("p");
          p.textContent = "Fetching experiments...";
        },
        m(target2, anchor2) {
          insert$2(target2, p, anchor2);
        },
        p: noop$6,
        i: noop$6,
        o: noop$6,
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }
    function create_fragment$1(ctx) {
      let div;
      let current2;
      let info2 = {
        ctx,
        current: null,
        token: null,
        hasCatch: false,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        blocks: [, , ,]
      };
      handle_promise(ensureStoreIsSyncedWithExperiments(), info2);
      return {
        c() {
          div = element$2("div");
          info2.block.c();
          attr$6(div, "class", "flex-wrap flex m-2");
        },
        m(target2, anchor2) {
          insert$2(target2, div, anchor2);
          info2.block.m(div, info2.anchor = null);
          info2.mount = () => div;
          info2.anchor = null;
          current2 = true;
        },
        p(new_ctx, [dirty]) {
          ctx = new_ctx;
          update_await_block_branch(info2, ctx, dirty);
        },
        i(local) {
          if (current2)
            return;
          transition_in(info2.block);
          current2 = true;
        },
        o(local) {
          for (let i = 0; i < 3; i += 1) {
            const block2 = info2.blocks[i];
            transition_out(block2);
          }
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          info2.block.d();
          info2.token = null;
          info2 = null;
        }
      };
    }
    function instance($$self, $$props, $$invalidate) {
      let $plotterStore;
      component_subscribe($$self, plotterStore, ($$value) => $$invalidate(0, $plotterStore = $$value));
      return [$plotterStore];
    }
    class MainView extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance, create_fragment$1, safe_not_equal, {});
      }
    }
    function create_fragment(ctx) {
      let main2;
      let mainview;
      let current2;
      mainview = new MainView({});
      return {
        c() {
          main2 = element$2("main");
          create_component(mainview.$$.fragment);
        },
        m(target2, anchor2) {
          insert$2(target2, main2, anchor2);
          mount_component(mainview, main2, null);
          current2 = true;
        },
        p: noop$6,
        i(local) {
          if (current2)
            return;
          transition_in(mainview.$$.fragment, local);
          current2 = true;
        },
        o(local) {
          transition_out(mainview.$$.fragment, local);
          current2 = false;
        },
        d(detaching) {
          if (detaching) {
            detach(main2);
          }
          destroy_component(mainview);
        }
      };
    }
    class App extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, null, create_fragment, safe_not_equal, {});
      }
    }
    new App({
      target: document.getElementById("app")
    });
  }
});
export default require_index_001();
//# sourceMappingURL=index-r6Svla0D.js.map
